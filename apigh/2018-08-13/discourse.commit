{
  "sha": "7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c",
  "node_id": "MDY6Q29tbWl0NzU2OTU3ODo3ZjRlZjNkYjllMWEyNzk0MDgzYmY5OWY1ZjFmOGUxN2IyNGRlNTRj",
  "commit": {
    "author": {
      "name": "Gerhard Schlager",
      "email": "mail@gerhard-schlager.at",
      "date": "2018-08-13T13:27:51Z"
    },
    "committer": {
      "name": "Gerhard Schlager",
      "email": "mail@gerhard-schlager.at",
      "date": "2018-08-13T13:28:11Z"
    },
    "message": "Improve Telligent importer\n\n* Try multiple filenames and do lots of guessing when searching for attachments\n* Unescape HTML in filenames and replace invalid characters in filenames\n* Existing permalinks prevented resuming of import\n* Prevent duplicate attachments in same post",
    "tree": {
      "sha": "bbf3495cd5410592933c77651b9685cc1db58fc3",
      "url": "https://api.github.com/repos/discourse/discourse/git/trees/bbf3495cd5410592933c77651b9685cc1db58fc3"
    },
    "url": "https://api.github.com/repos/discourse/discourse/git/commits/7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/discourse/discourse/commits/7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c",
  "html_url": "https://github.com/discourse/discourse/commit/7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c",
  "comments_url": "https://api.github.com/repos/discourse/discourse/commits/7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c/comments",
  "author": {
    "login": "gschlager",
    "id": 473736,
    "node_id": "MDQ6VXNlcjQ3MzczNg==",
    "avatar_url": "https://avatars3.githubusercontent.com/u/473736?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gschlager",
    "html_url": "https://github.com/gschlager",
    "followers_url": "https://api.github.com/users/gschlager/followers",
    "following_url": "https://api.github.com/users/gschlager/following{/other_user}",
    "gists_url": "https://api.github.com/users/gschlager/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gschlager/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gschlager/subscriptions",
    "organizations_url": "https://api.github.com/users/gschlager/orgs",
    "repos_url": "https://api.github.com/users/gschlager/repos",
    "events_url": "https://api.github.com/users/gschlager/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gschlager/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "gschlager",
    "id": 473736,
    "node_id": "MDQ6VXNlcjQ3MzczNg==",
    "avatar_url": "https://avatars3.githubusercontent.com/u/473736?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/gschlager",
    "html_url": "https://github.com/gschlager",
    "followers_url": "https://api.github.com/users/gschlager/followers",
    "following_url": "https://api.github.com/users/gschlager/following{/other_user}",
    "gists_url": "https://api.github.com/users/gschlager/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/gschlager/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/gschlager/subscriptions",
    "organizations_url": "https://api.github.com/users/gschlager/orgs",
    "repos_url": "https://api.github.com/users/gschlager/repos",
    "events_url": "https://api.github.com/users/gschlager/events{/privacy}",
    "received_events_url": "https://api.github.com/users/gschlager/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dadbf2edb441a14e6cefd75e82eb4c2ee1e5cdab",
      "url": "https://api.github.com/repos/discourse/discourse/commits/dadbf2edb441a14e6cefd75e82eb4c2ee1e5cdab",
      "html_url": "https://github.com/discourse/discourse/commit/dadbf2edb441a14e6cefd75e82eb4c2ee1e5cdab"
    }
  ],
  "stats": {
    "total": 76,
    "additions": 60,
    "deletions": 16
  },
  "files": [
    {
      "sha": "7594affcec8f1dd93b745fb1ae3814d39cdeae26",
      "filename": "script/import_scripts/telligent.rb",
      "status": "modified",
      "additions": 60,
      "deletions": 16,
      "changes": 76,
      "blob_url": "https://github.com/discourse/discourse/blob/7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c/script/import_scripts/telligent.rb",
      "raw_url": "https://github.com/discourse/discourse/raw/7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c/script/import_scripts/telligent.rb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/script/import_scripts/telligent.rb?ref=7f4ef3db9e1a2794083bf99f5f1f8e17b24de54c",
      "patch": "@@ -1,11 +1,18 @@\n require_relative 'base'\n require 'tiny_tds'\n \n+# Import script for Telligent communities\n+#\n+# Users are currently imported from a temp table. This will need some\n+# work the next time this import script is used, because that table\n+# won't exist. Also, it's really hard to find all attachments, but\n+# the script tries to do it anyway.\n+\n class ImportScripts::Telligent < ImportScripts::Base\n   BATCH_SIZE ||= 1000\n   LOCAL_AVATAR_REGEX ||= /\\A~\\/.*(?<directory>communityserver-components-(?:selectable)?avatars)\\/(?<path>[^\\/]+)\\/(?<filename>.+)/i\n   REMOTE_AVATAR_REGEX ||= /\\Ahttps?:\\/\\//i\n-  EMBEDDED_ATTACHMENT_REGEX ||= /<a href=\"\\/cfs-file(?:\\.ashx)?\\/__key\\/(?<directory>[^\\/]+)\\/(?<path>[^\\/]+)\\/(?<filename>.+)\">.*?<\\/a>/i\n+  EMBEDDED_ATTACHMENT_REGEX ||= /<a href=\"\\/cfs-file(?:\\.ashx)?\\/__key\\/(?<directory>[^\\/]+)\\/(?<path>[^\\/]+)\\/(?<filename1>.+)\">(?<filename2>.*?)<\\/a>/i\n \n   CATEGORY_LINK_NORMALIZATION = '/.*?(f\\/\\d+)$/\\1'\n   TOPIC_LINK_NORMALIZATION = '/.*?(f\\/\\d+\\/t\\/\\d+)$/\\1'\n@@ -174,7 +181,8 @@ def import_categories\n \n       if category_id = replace_with_category_id(row, child_categories, parent_category_id)\n         add_category(row['ForumId'], Category.find_by_id(category_id))\n-        Permalink.create(url: \"f/#{row['ForumId']}\", category_id: category_id)\n+        url = \"f/#{row['ForumId']}\"\n+        Permalink.create(url: url, category_id: category_id) unless Permalink.exists?(url: url)\n         nil\n       else\n         {\n@@ -268,7 +276,8 @@ def import_topics\n           post_create_action: proc do |post|\n             topic = post.topic\n             Jobs.enqueue_at(topic.pinned_until, :unpin_topic, topic_id: topic.id) if topic.pinned_until\n-            Permalink.create(url: \"f/#{row['ForumId']}/t/#{row['ThreadId']}\", topic_id: topic.id)\n+            url = \"f/#{row['ForumId']}/t/#{row['ThreadId']}\"\n+            Permalink.create(url: url, topic_id: topic.id) unless Permalink.exists?(url: url)\n           end\n         }\n \n@@ -345,7 +354,7 @@ def import_posts\n   end\n \n   def raw_with_attachment(row, user_id)\n-    raw, embedded_paths = replace_embedded_attachments(row[\"Body\"], user_id)\n+    raw, embedded_paths, upload_ids = replace_embedded_attachments(row[\"Body\"], user_id)\n     raw = html_to_markdown(raw) || \"\"\n \n     filename = row[\"FileName\"]\n@@ -358,13 +367,16 @@ def raw_with_attachment(row, user_id)\n       \"%02d\" % row[\"ApplicationId\"],\n       \"%02d\" % row[\"ApplicationContentTypeId\"],\n       (\"%010d\" % row[\"ContentId\"]).scan(/.{2}/),\n-      filename\n+      clean_filename(filename)\n     )\n \n     unless embedded_paths.include?(path)\n       if File.exists?(path)\n         upload = @uploader.create_upload(user_id, path, filename)\n-        raw << \"\\n\" << @uploader.html_for_upload(upload, filename) if upload.present? && upload.persisted?\n+\n+        if upload.present? && upload.persisted? && !upload_ids.include?(upload.id)\n+          raw << \"\\n\" << @uploader.html_for_upload(upload, filename)\n+        end\n       else\n         STDERR.puts \"Could not find file: #{path}\"\n       end\n@@ -375,31 +387,63 @@ def raw_with_attachment(row, user_id)\n \n   def replace_embedded_attachments(raw, user_id)\n     paths = []\n+    upload_ids = []\n \n     raw = raw.gsub(EMBEDDED_ATTACHMENT_REGEX) do\n-      match_data = Regexp.last_match\n-      filename = match_data[:filename]\n-\n-      path = File.join(\n-        ENV[\"FILE_BASE_DIR\"],\n-        match_data[:directory].gsub(\"-\", \".\"),\n-        match_data[:path].split(\"-\"),\n-        filename\n-      )\n+      filename, path = attachment_path(Regexp.last_match)\n \n       if File.exists?(path)\n         upload = @uploader.create_upload(user_id, path, filename)\n \n         if upload.present? && upload.persisted?\n           paths << path\n+          upload_ids << upload.id\n           @uploader.html_for_upload(upload, filename)\n         end\n       else\n         STDERR.puts \"Could not find file: #{path}\"\n       end\n     end\n \n-    [raw, paths]\n+    [raw, paths, upload_ids]\n+  end\n+\n+  def clean_filename(filename)\n+    CGI.unescapeHTML(filename)\n+      .gsub(/[\\x00\\/\\\\:\\*\\?\\\"<>\\|]/, '_')\n+      .gsub(/_(?:2B00|2E00|2D00|5B00|5D00|5F00)/, '')\n+  end\n+\n+  def attachment_path(match_data)\n+    filename, path = join_attachment_path(match_data, filename_index: 2)\n+    filename, path = join_attachment_path(match_data, filename_index: 1) unless File.exists?(path)\n+    [filename, path]\n+  end\n+\n+  # filenames are a total mess - try to guess the correct filename\n+  # works for 70% of all files\n+  def join_attachment_path(match_data, filename_index:)\n+    filename = clean_filename(match_data[:\"filename#{filename_index}\"])\n+    base_path = File.join(\n+      ENV[\"FILE_BASE_DIR\"],\n+      match_data[:directory].gsub(\"-\", \".\"),\n+      match_data[:path].split(\"-\")\n+    )\n+\n+    path = File.join(base_path, filename)\n+    return [filename, path] if File.exists?(path)\n+\n+    original_filename = filename.dup\n+\n+    filename = filename.gsub(\"-\", \" \")\n+    path = File.join(base_path, filename)\n+    return [filename, path] if File.exists?(path)\n+\n+    filename = filename.gsub(\"_\", \"-\")\n+    path = File.join(base_path, filename)\n+    return [filename, path] if File.exists?(path)\n+\n+    [original_filename, File.join(base_path, original_filename)]\n   end\n \n   def mark_topics_as_solved"
    }
  ]
}
