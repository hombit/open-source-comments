{
  "sha": "15f657309a9b457ff315482da2fe8fbbed9caa02",
  "node_id": "MDY6Q29tbWl0NzU2OTU3ODoxNWY2NTczMDlhOWI0NTdmZjMxNTQ4MmRhMmZlOGZiYmVkOWNhYTAy",
  "commit": {
    "author": {
      "name": "Neil Lalonde",
      "email": "neillalonde@gmail.com",
      "date": "2018-08-28T14:21:39Z"
    },
    "committer": {
      "name": "Neil Lalonde",
      "email": "neillalonde@gmail.com",
      "date": "2018-08-28T14:21:39Z"
    },
    "message": "FEATURE: Zendesk importer that uses its API to get data",
    "tree": {
      "sha": "85de791aa38e6809a3936ebea6eb9d07c81f666e",
      "url": "https://api.github.com/repos/discourse/discourse/git/trees/85de791aa38e6809a3936ebea6eb9d07c81f666e"
    },
    "url": "https://api.github.com/repos/discourse/discourse/git/commits/15f657309a9b457ff315482da2fe8fbbed9caa02",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/discourse/discourse/commits/15f657309a9b457ff315482da2fe8fbbed9caa02",
  "html_url": "https://github.com/discourse/discourse/commit/15f657309a9b457ff315482da2fe8fbbed9caa02",
  "comments_url": "https://api.github.com/repos/discourse/discourse/commits/15f657309a9b457ff315482da2fe8fbbed9caa02/comments",
  "author": {
    "login": "nlalonde",
    "id": 151885,
    "node_id": "MDQ6VXNlcjE1MTg4NQ==",
    "avatar_url": "https://avatars2.githubusercontent.com/u/151885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nlalonde",
    "html_url": "https://github.com/nlalonde",
    "followers_url": "https://api.github.com/users/nlalonde/followers",
    "following_url": "https://api.github.com/users/nlalonde/following{/other_user}",
    "gists_url": "https://api.github.com/users/nlalonde/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nlalonde/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nlalonde/subscriptions",
    "organizations_url": "https://api.github.com/users/nlalonde/orgs",
    "repos_url": "https://api.github.com/users/nlalonde/repos",
    "events_url": "https://api.github.com/users/nlalonde/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nlalonde/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nlalonde",
    "id": 151885,
    "node_id": "MDQ6VXNlcjE1MTg4NQ==",
    "avatar_url": "https://avatars2.githubusercontent.com/u/151885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nlalonde",
    "html_url": "https://github.com/nlalonde",
    "followers_url": "https://api.github.com/users/nlalonde/followers",
    "following_url": "https://api.github.com/users/nlalonde/following{/other_user}",
    "gists_url": "https://api.github.com/users/nlalonde/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nlalonde/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nlalonde/subscriptions",
    "organizations_url": "https://api.github.com/users/nlalonde/orgs",
    "repos_url": "https://api.github.com/users/nlalonde/repos",
    "events_url": "https://api.github.com/users/nlalonde/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nlalonde/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "83bf641292d45e786b8820a1c3fa07e050f8a575",
      "url": "https://api.github.com/repos/discourse/discourse/commits/83bf641292d45e786b8820a1c3fa07e050f8a575",
      "html_url": "https://github.com/discourse/discourse/commit/83bf641292d45e786b8820a1c3fa07e050f8a575"
    }
  ],
  "stats": {
    "total": 312,
    "additions": 311,
    "deletions": 1
  },
  "files": [
    {
      "sha": "880150c11f51786b251def5eaf8f8cdc9a433d70",
      "filename": "script/import_scripts/base.rb",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/discourse/discourse/blob/15f657309a9b457ff315482da2fe8fbbed9caa02/script/import_scripts/base.rb",
      "raw_url": "https://github.com/discourse/discourse/raw/15f657309a9b457ff315482da2fe8fbbed9caa02/script/import_scripts/base.rb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/script/import_scripts/base.rb?ref=15f657309a9b457ff315482da2fe8fbbed9caa02",
      "patch": "@@ -873,7 +873,7 @@ def get_start_time(key)\n     @start_times.fetch(key) { |k| @start_times[k] = Time.now }\n   end\n \n-  def batches(batch_size)\n+  def batches(batch_size = 1000)\n     offset = 0\n     loop do\n       yield offset"
    },
    {
      "sha": "39284a4d34583bc42aa64ec890014a8edb42c464",
      "filename": "script/import_scripts/base/generic_database.rb",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/discourse/discourse/blob/15f657309a9b457ff315482da2fe8fbbed9caa02/script/import_scripts/base/generic_database.rb",
      "raw_url": "https://github.com/discourse/discourse/raw/15f657309a9b457ff315482da2fe8fbbed9caa02/script/import_scripts/base/generic_database.rb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/script/import_scripts/base/generic_database.rb?ref=15f657309a9b457ff315482da2fe8fbbed9caa02",
      "patch": "@@ -125,6 +125,10 @@ def execute_sql(sql)\n       @db.execute(sql)\n     end\n \n+    def get_first_value(sql)\n+      @db.get_first_value(sql)\n+    end\n+\n     private\n \n     def configure_database"
    },
    {
      "sha": "ddea6f1cb5f383dd85ec991500ff7598dcfce369",
      "filename": "script/import_scripts/zendesk_api.rb",
      "status": "added",
      "additions": 306,
      "deletions": 0,
      "changes": 306,
      "blob_url": "https://github.com/discourse/discourse/blob/15f657309a9b457ff315482da2fe8fbbed9caa02/script/import_scripts/zendesk_api.rb",
      "raw_url": "https://github.com/discourse/discourse/raw/15f657309a9b457ff315482da2fe8fbbed9caa02/script/import_scripts/zendesk_api.rb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/script/import_scripts/zendesk_api.rb?ref=15f657309a9b457ff315482da2fe8fbbed9caa02",
      "patch": "@@ -0,0 +1,306 @@\n+# Zendesk importer\n+#\n+# This one uses their API.\n+\n+require 'reverse_markdown'\n+require_relative 'base'\n+require_relative 'base/generic_database'\n+\n+# Call it like this:\n+#   RAILS_ENV=production bundle exec ruby script/import_scripts/zendesk_api.rb SOURCE_URL DIRNAME AUTH_EMAIL AUTH_TOKEN\n+class ImportScripts::Zendesk < ImportScripts::Base\n+  BATCH_SIZE = 1000\n+\n+  def initialize(source_url, path, auth_email, auth_token)\n+    super()\n+\n+    @source_url = source_url\n+    @path = path\n+    @auth_email = auth_email\n+    @auth_token = auth_token\n+    @db = ImportScripts::GenericDatabase.new(@path, batch_size: BATCH_SIZE, recreate: true)\n+  end\n+\n+  def execute\n+    fetch_from_api\n+\n+    import_categories\n+    import_users\n+    import_topics\n+    import_posts\n+  end\n+\n+  def fetch_from_api\n+    puts '', 'fetching categories...'\n+\n+    get_from_api('/api/v2/community/topics.json', 'topics') do |row|\n+      @db.insert_category(\n+        id: row['id'],\n+        name: row['name'],\n+        description: row['description'],\n+        position: row['position'],\n+        url: row['html_url']\n+      )\n+    end\n+\n+    puts '', 'fetching topics...'\n+\n+    get_from_api('/api/v2/community/posts.json', 'posts') do |row|\n+      @db.insert_topic(\n+        id: row['id'],\n+        title: row['title'],\n+        raw: row['details'],\n+        category_id: row['topic_id'],\n+        closed: row['closed'],\n+        user_id: row['author_id'],\n+        created_at: row['created_at'],\n+        url: row['html_url']\n+      )\n+    end\n+\n+    puts '', 'fetching posts...'\n+    total_count = @db.count_topics\n+    start_time = Time.now\n+    last_id = ''\n+\n+    batches do |offset|\n+      rows, last_id = @db.fetch_topics(last_id)\n+      break if rows.empty?\n+\n+      print_status(offset, total_count, start_time)\n+\n+      rows.each do |topic_row|\n+        get_from_api(\"/api/v2/community/posts/#{topic_row['id']}/comments.json\", 'comments', show_status: false) do |row|\n+          @db.insert_post(\n+            id: row['id'],\n+            raw: row['body'],\n+            topic_id: topic_row['id'],\n+            user_id: row['author_id'],\n+            created_at: row['created_at'],\n+            url: row['html_url']\n+          )\n+        end\n+      end\n+    end\n+\n+    puts '', 'fetching users...'\n+\n+    results = @db.execute_sql(\"SELECT user_id FROM topic\")\n+    user_ids = results.map { |h| h['user_id']&.to_i }\n+    results = @db.execute_sql(\"SELECT user_id FROM post\")\n+    user_ids += results.map { |h| h['user_id']&.to_i }\n+    user_ids.uniq!\n+    user_ids.sort!\n+\n+    total_users = user_ids.size\n+    start_time = Time.now\n+\n+    while !user_ids.empty?\n+      print_status(total_users - user_ids.size, total_users, start_time)\n+      get_from_api(\"/api/v2/users/show_many.json?ids=#{user_ids.shift(50).join(',')}\", 'users', show_status: false) do |row|\n+        @db.insert_user(\n+          id: row['id'],\n+          email: row['email'],\n+          name: row['name'],\n+          created_at: row['created_at'],\n+          last_seen_at: row['last_login_at'],\n+          active: row['active']\n+        )\n+      end\n+    end\n+\n+    @db.sort_posts_by_created_at\n+  end\n+\n+  def import_categories\n+    puts \"\", \"creating categories\"\n+    rows = @db.fetch_categories\n+\n+    create_categories(rows) do |row|\n+      {\n+        id: row['id'],\n+        name: row['name'],\n+        description: row['description'],\n+        position: row['position'],\n+        post_create_action: proc do |category|\n+          url = remove_domain(row['url'])\n+          Permalink.create(url: url, category_id: category.id) unless permalink_exists?(url)\n+        end\n+      }\n+    end\n+  end\n+\n+  def import_users\n+    puts \"\", \"creating users\"\n+    total_count = @db.count_users\n+    last_id = ''\n+\n+    batches do |offset|\n+      rows, last_id = @db.fetch_users(last_id)\n+      break if rows.empty?\n+\n+      next if all_records_exist?(:users, rows.map { |row| row['id'] })\n+\n+      create_users(rows, total: total_count, offset: offset) do |row|\n+        {\n+          id: row['id'],\n+          email: row['email'],\n+          name: row['name'],\n+          created_at: row['created_at'],\n+          last_seen_at: row['last_seen_at'],\n+          active: row['active'] == 1\n+        }\n+      end\n+    end\n+  end\n+\n+  def import_topics\n+    puts \"\", \"creating topics\"\n+    total_count = @db.count_topics\n+    last_id = ''\n+\n+    batches do |offset|\n+      rows, last_id = @db.fetch_topics(last_id)\n+      break if rows.empty?\n+\n+      next if all_records_exist?(:posts, rows.map { |row| import_topic_id(row['id']) })\n+\n+      create_posts(rows, total: total_count, offset: offset) do |row|\n+        {\n+          id: import_topic_id(row['id']),\n+          title: row['title'].present? ? row['title'].strip[0...255] : \"Topic title missing\",\n+          raw: normalize_raw(row['raw']),\n+          category: category_id_from_imported_category_id(row['category_id']),\n+          user_id: user_id_from_imported_user_id(row['user_id']) || Discourse.system_user.id,\n+          created_at: row['created_at'],\n+          closed: row['closed'] == 1,\n+          post_create_action: proc do |post|\n+            url = remove_domain(row['url'])\n+            Permalink.create(url: url, topic_id: post.topic.id) unless permalink_exists?(url)\n+          end\n+        }\n+      end\n+    end\n+  end\n+\n+  def import_topic_id(topic_id)\n+    \"T#{topic_id}\"\n+  end\n+\n+  def import_posts\n+    puts \"\", \"creating posts\"\n+    total_count = @db.count_posts\n+    last_row_id = 0\n+\n+    batches do |offset|\n+      rows, last_row_id = @db.fetch_posts(last_row_id)\n+      break if rows.empty?\n+\n+      create_posts(rows, total: total_count, offset: offset) do |row|\n+        topic = topic_lookup_from_imported_post_id(import_topic_id(row['topic_id']))\n+\n+        if topic.nil?\n+          p \"MISSING TOPIC #{row['topic_id']}\"\n+          p row\n+          next\n+        end\n+\n+        {\n+          id: row['id'],\n+          raw: normalize_raw(row['raw']),\n+          user_id: user_id_from_imported_user_id(row['user_id']) || Discourse.system_user.id,\n+          topic_id: topic[:topic_id],\n+          created_at: row['created_at'],\n+          post_create_action: proc do |post|\n+            url = remove_domain(row['url'])\n+            Permalink.create(url: url, post_id: post.id) unless permalink_exists?(url)\n+          end\n+        }\n+      end\n+    end\n+  end\n+\n+  def normalize_raw(raw)\n+    raw = raw.gsub('\\n', '')\n+    raw = ReverseMarkdown.convert(raw)\n+    raw\n+  end\n+\n+  def remove_domain(url)\n+    url.sub(@source_url, \"\")\n+  end\n+\n+  def permalink_exists?(url)\n+    Permalink.find_by(url: url)\n+  end\n+\n+  def connection\n+    @_connection ||= begin\n+      connect_uri = URI.parse(@source_url)\n+\n+      http = Net::HTTP.new(connect_uri.host, connect_uri.port)\n+      http.open_timeout = 30\n+      http.read_timeout = 30\n+      http.use_ssl = connect_uri.scheme == \"https\"\n+\n+      http\n+    end\n+  end\n+\n+  def authorization\n+    @_authorization ||= begin\n+      auth_str = \"#{@auth_email}/token:#{@auth_token}\"\n+      \"Basic #{Base64.strict_encode64(auth_str)}\"\n+    end\n+  end\n+\n+  def get_from_api(path, array_name, show_status: true)\n+    url = \"#{@source_url}#{path}\"\n+    start_time = Time.now\n+\n+    while url\n+      get = Net::HTTP::Get.new(url)\n+      get['User-Agent'] = 'Discourse Zendesk Importer'\n+      get['Authorization'] = authorization\n+\n+      retry_count = 0\n+\n+      begin\n+        while retry_count < 5\n+          begin\n+            response = connection.request(get)\n+            puts(\"Retry successful!\") if retry_count > 0\n+            break\n+          rescue => e\n+            puts \"Request failed #{url}. Waiting and will retry. #{e.class.name} #{e.message}\"\n+            sleep(20)\n+            retry_count += 1\n+          end\n+        end\n+      end\n+\n+      json = JSON.parse(response.body)\n+\n+      json[array_name].each do |row|\n+        yield row\n+      end\n+\n+      url = json['next_page']\n+\n+      if show_status\n+        if json['page'] && json['page_count']\n+          print_status(json['page'], json['page_count'], start_time)\n+        else\n+          print '.'\n+        end\n+      end\n+    end\n+  end\n+end\n+\n+unless ARGV.length == 4 && Dir.exist?(ARGV[1])\n+  puts \"\", \"Usage:\", \"\", \"bundle exec ruby script/import_scripts/zendesk_api.rb SOURCE_URL DIRNAME AUTH_EMAIL AUTH_TOKEN\", \"\"\n+  exit 1\n+end\n+\n+ImportScripts::Zendesk.new(ARGV[0], ARGV[1], ARGV[2], ARGV[3]).perform"
    }
  ]
}
