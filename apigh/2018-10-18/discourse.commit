{
  "sha": "3973823a33f2215577e84e5b757f3c4f40b4cece",
  "node_id": "MDY6Q29tbWl0NzU2OTU3ODozOTczODIzYTMzZjIyMTU1NzdlODRlNWI3NTdmM2M0ZjQwYjRjZWNl",
  "commit": {
    "author": {
      "name": "Régis Hanol",
      "email": "regis@hanol.fr",
      "date": "2018-10-18T09:02:54Z"
    },
    "committer": {
      "name": "Régis Hanol",
      "email": "regis@hanol.fr",
      "date": "2018-10-18T09:02:54Z"
    },
    "message": "FIX: always update 'last_gravatar_download_attempt' when updating gravatar",
    "tree": {
      "sha": "658df748538f31592a559a84e2c263506c4a4049",
      "url": "https://api.github.com/repos/discourse/discourse/git/trees/658df748538f31592a559a84e2c263506c4a4049"
    },
    "url": "https://api.github.com/repos/discourse/discourse/git/commits/3973823a33f2215577e84e5b757f3c4f40b4cece",
    "comment_count": 1,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/discourse/discourse/commits/3973823a33f2215577e84e5b757f3c4f40b4cece",
  "html_url": "https://github.com/discourse/discourse/commit/3973823a33f2215577e84e5b757f3c4f40b4cece",
  "comments_url": "https://api.github.com/repos/discourse/discourse/commits/3973823a33f2215577e84e5b757f3c4f40b4cece/comments",
  "author": {
    "login": "ZogStriP",
    "id": 362783,
    "node_id": "MDQ6VXNlcjM2Mjc4Mw==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/362783?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZogStriP",
    "html_url": "https://github.com/ZogStriP",
    "followers_url": "https://api.github.com/users/ZogStriP/followers",
    "following_url": "https://api.github.com/users/ZogStriP/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZogStriP/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZogStriP/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZogStriP/subscriptions",
    "organizations_url": "https://api.github.com/users/ZogStriP/orgs",
    "repos_url": "https://api.github.com/users/ZogStriP/repos",
    "events_url": "https://api.github.com/users/ZogStriP/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZogStriP/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZogStriP",
    "id": 362783,
    "node_id": "MDQ6VXNlcjM2Mjc4Mw==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/362783?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZogStriP",
    "html_url": "https://github.com/ZogStriP",
    "followers_url": "https://api.github.com/users/ZogStriP/followers",
    "following_url": "https://api.github.com/users/ZogStriP/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZogStriP/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZogStriP/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZogStriP/subscriptions",
    "organizations_url": "https://api.github.com/users/ZogStriP/orgs",
    "repos_url": "https://api.github.com/users/ZogStriP/repos",
    "events_url": "https://api.github.com/users/ZogStriP/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZogStriP/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "53aa0344bff63d1807267003c0f4db2bc4786378",
      "url": "https://api.github.com/repos/discourse/discourse/commits/53aa0344bff63d1807267003c0f4db2bc4786378",
      "html_url": "https://github.com/discourse/discourse/commit/53aa0344bff63d1807267003c0f4db2bc4786378"
    }
  ],
  "stats": {
    "total": 107,
    "additions": 60,
    "deletions": 47
  },
  "files": [
    {
      "sha": "fd3fb8e4bb2a6d4258e3a5382ac02b8ac04ec696",
      "filename": "app/models/user_avatar.rb",
      "status": "modified",
      "additions": 4,
      "deletions": 8,
      "changes": 12,
      "blob_url": "https://github.com/discourse/discourse/blob/3973823a33f2215577e84e5b757f3c4f40b4cece/app/models/user_avatar.rb",
      "raw_url": "https://github.com/discourse/discourse/raw/3973823a33f2215577e84e5b757f3c4f40b4cece/app/models/user_avatar.rb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/app/models/user_avatar.rb?ref=3973823a33f2215577e84e5b757f3c4f40b4cece",
      "patch": "@@ -13,12 +13,10 @@ def contains_upload?(id)\n   def update_gravatar!\n     DistributedMutex.synchronize(\"update_gravatar_#{user_id}\") do\n       begin\n-        # special logic for our system user\n-        email_hash = user_id == Discourse::SYSTEM_USER_ID ? User.email_hash(\"info@discourse.org\") : user.email_hash\n-\n-        self.last_gravatar_download_attempt = Time.new\n+        self.update_columns(last_gravatar_download_attempt: Time.now)\n \n         max = Discourse.avatar_sizes.max\n+        email_hash = user_id == Discourse::SYSTEM_USER_ID ? User.email_hash(\"info@discourse.org\") : user.email_hash\n         gravatar_url = \"https://www.gravatar.com/avatar/#{email_hash}.png?s=#{max}&d=404\"\n \n         # follow redirects in case gravatar change rules on us\n@@ -42,12 +40,10 @@ def update_gravatar!\n             type: \"avatar\"\n           ).create_for(user_id)\n \n-          upload_id = upload.id\n-\n-          if gravatar_upload_id != upload_id\n+          if gravatar_upload_id != upload.id\n             User.transaction do\n               if gravatar_upload_id && user.uploaded_avatar_id == gravatar_upload_id\n-                user.update!(uploaded_avatar_id: upload_id)\n+                user.update!(uploaded_avatar_id: upload.id)\n               end\n \n               gravatar_upload&.destroy!"
    },
    {
      "sha": "b52303d7b774d7363061f6047541c816291c440b",
      "filename": "spec/models/user_avatar_spec.rb",
      "status": "modified",
      "additions": 56,
      "deletions": 39,
      "changes": 95,
      "blob_url": "https://github.com/discourse/discourse/blob/3973823a33f2215577e84e5b757f3c4f40b4cece/spec/models/user_avatar_spec.rb",
      "raw_url": "https://github.com/discourse/discourse/raw/3973823a33f2215577e84e5b757f3c4f40b4cece/spec/models/user_avatar_spec.rb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/spec/models/user_avatar_spec.rb?ref=3973823a33f2215577e84e5b757f3c4f40b4cece",
      "patch": "@@ -8,62 +8,79 @@\n     let(:temp) { Tempfile.new('test') }\n     let(:upload) { Fabricate(:upload, user: user) }\n \n-    before do\n-      temp.binmode\n-      # tiny valid png\n-      temp.write(Base64.decode64(\"R0lGODlhAQABALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//wBiZCH5BAEAAA8ALAAAAAABAAEAAAQC8EUAOw==\"))\n-      temp.rewind\n-      FileHelper.expects(:download).returns(temp)\n-    end\n+    describe \"when working\" do\n+\n+      before do\n+        temp.binmode\n+        # tiny valid png\n+        temp.write(Base64.decode64(\"R0lGODlhAQABALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//wBiZCH5BAEAAA8ALAAAAAABAAEAAAQC8EUAOw==\"))\n+        temp.rewind\n+        FileHelper.expects(:download).returns(temp)\n+      end\n \n-    after do\n-      temp.unlink\n-    end\n+      after do\n+        temp.unlink\n+      end\n \n-    it 'can update gravatars' do\n-      expect do\n-        avatar.update_gravatar!\n-      end.to change { Upload.count }.by(1)\n+      it 'can update gravatars' do\n+        freeze_time Time.now\n \n-      upload = Upload.last\n+        expect { avatar.update_gravatar! }.to change { Upload.count }.by(1)\n \n-      expect(avatar.gravatar_upload).to eq(upload)\n-      expect(user.reload.uploaded_avatar).to eq(nil)\n-    end\n+        expect(avatar.gravatar_upload).to eq(Upload.last)\n+        expect(avatar.last_gravatar_download_attempt).to eq(Time.now)\n+        expect(user.reload.uploaded_avatar).to eq(nil)\n+      end\n \n-    describe 'when user has an existing custom upload' do\n-      it \"should not change the user's uploaded avatar\" do\n-        user.update!(uploaded_avatar: upload)\n+      describe 'when user has an existing custom upload' do\n+        it \"should not change the user's uploaded avatar\" do\n+          user.update!(uploaded_avatar: upload)\n \n-        avatar.update!(\n-          custom_upload: upload,\n-          gravatar_upload: Fabricate(:upload, user: user)\n-        )\n+          avatar.update!(\n+            custom_upload: upload,\n+            gravatar_upload: Fabricate(:upload, user: user)\n+          )\n \n-        avatar.update_gravatar!\n+          avatar.update_gravatar!\n \n-        expect(upload.reload).to eq(upload)\n-        expect(user.reload.uploaded_avatar).to eq(upload)\n-        expect(avatar.reload.custom_upload).to eq(upload)\n-        expect(avatar.gravatar_upload).to eq(Upload.last)\n+          expect(upload.reload).to eq(upload)\n+          expect(user.reload.uploaded_avatar).to eq(upload)\n+          expect(avatar.reload.custom_upload).to eq(upload)\n+          expect(avatar.gravatar_upload).to eq(Upload.last)\n+        end\n+      end\n+\n+      describe 'when user has an existing gravatar' do\n+        it \"should update the user's uploaded avatar correctly\" do\n+          user.update!(uploaded_avatar: upload)\n+          avatar.update!(gravatar_upload: upload)\n+\n+          avatar.update_gravatar!\n+\n+          expect(Upload.find_by(id: upload.id)).to eq(nil)\n+\n+          new_upload = Upload.last\n+\n+          expect(user.reload.uploaded_avatar).to eq(new_upload)\n+          expect(avatar.reload.gravatar_upload).to eq(new_upload)\n+        end\n       end\n     end\n \n-    describe 'when user has an existing gravatar' do\n-      it \"should update the user's uploaded avatar correctly\" do\n-        user.update!(uploaded_avatar: upload)\n-        avatar.update!(gravatar_upload: upload)\n+    describe \"when failing\" do\n \n-        avatar.update_gravatar!\n+      it \"always update 'last_gravatar_download_attempt'\" do\n+        freeze_time Time.now\n \n-        expect(Upload.find_by(id: upload.id)).to eq(nil)\n+        FileHelper.expects(:download).raises(SocketError)\n \n-        new_upload = Upload.last\n+        expect { avatar.update_gravatar! }.to_not change { Upload.count }\n \n-        expect(user.reload.uploaded_avatar).to eq(new_upload)\n-        expect(avatar.reload.gravatar_upload).to eq(new_upload)\n+        expect(avatar.last_gravatar_download_attempt).to eq(Time.now)\n       end\n+\n     end\n+\n   end\n \n   context '.import_url_for_user' do"
    }
  ]
}
