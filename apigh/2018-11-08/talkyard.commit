{
  "sha": "bbd678f37f5a4b2704f5fe75a332920637ee630a",
  "node_id": "MDY6Q29tbWl0MTA1NjMzMjI6YmJkNjc4ZjM3ZjVhNGIyNzA0ZjVmZTc1YTMzMjkyMDYzN2VlNjMwYQ==",
  "commit": {
    "author": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2018-11-08T04:36:04Z"
    },
    "committer": {
      "name": "Kaj Magnus Lindberg",
      "email": "kajmagnus3@gmail.com",
      "date": "2018-11-08T04:36:04Z"
    },
    "message": "Add e2e test that repros tricky-override-group-notf-prefs issue\n\nAnd rename lots of 'transaction' to 'tx'.",
    "tree": {
      "sha": "17c95db8026c51c29481dc753240b148175ebc8b",
      "url": "https://api.github.com/repos/debiki/talkyard/git/trees/17c95db8026c51c29481dc753240b148175ebc8b"
    },
    "url": "https://api.github.com/repos/debiki/talkyard/git/commits/bbd678f37f5a4b2704f5fe75a332920637ee630a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/debiki/talkyard/commits/bbd678f37f5a4b2704f5fe75a332920637ee630a",
  "html_url": "https://github.com/debiki/talkyard/commit/bbd678f37f5a4b2704f5fe75a332920637ee630a",
  "comments_url": "https://api.github.com/repos/debiki/talkyard/commits/bbd678f37f5a4b2704f5fe75a332920637ee630a/comments",
  "author": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "kajmagnus",
    "id": 7477359,
    "node_id": "MDQ6VXNlcjc0NzczNTk=",
    "avatar_url": "https://avatars1.githubusercontent.com/u/7477359?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/kajmagnus",
    "html_url": "https://github.com/kajmagnus",
    "followers_url": "https://api.github.com/users/kajmagnus/followers",
    "following_url": "https://api.github.com/users/kajmagnus/following{/other_user}",
    "gists_url": "https://api.github.com/users/kajmagnus/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/kajmagnus/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/kajmagnus/subscriptions",
    "organizations_url": "https://api.github.com/users/kajmagnus/orgs",
    "repos_url": "https://api.github.com/users/kajmagnus/repos",
    "events_url": "https://api.github.com/users/kajmagnus/events{/privacy}",
    "received_events_url": "https://api.github.com/users/kajmagnus/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5b0c28c918f70fafea236441cfc6f28e63ec4d0b",
      "url": "https://api.github.com/repos/debiki/talkyard/commits/5b0c28c918f70fafea236441cfc6f28e63ec4d0b",
      "html_url": "https://github.com/debiki/talkyard/commit/5b0c28c918f70fafea236441cfc6f28e63ec4d0b"
    }
  ],
  "stats": {
    "total": 540,
    "additions": 394,
    "deletions": 146
  },
  "files": [
    {
      "sha": "6f930356af1558afd39a79723cddccea058f2fcb",
      "filename": "app/debiki/dao/UserDao.scala",
      "status": "modified",
      "additions": 149,
      "deletions": 146,
      "changes": 295,
      "blob_url": "https://github.com/debiki/talkyard/blob/bbd678f37f5a4b2704f5fe75a332920637ee630a/app/debiki/dao/UserDao.scala",
      "raw_url": "https://github.com/debiki/talkyard/raw/bbd678f37f5a4b2704f5fe75a332920637ee630a/app/debiki/dao/UserDao.scala",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/app/debiki/dao/UserDao.scala?ref=bbd678f37f5a4b2704f5fe75a332920637ee630a",
      "patch": "@@ -46,24 +46,24 @@ trait UserDao {\n \n   import self.context.security\n \n-  def addUserStats(moreStats: UserStats)(transaction: SiteTransaction) {\n+  def addUserStats(moreStats: UserStats)(tx: SiteTransaction) {\n     // Exclude superadmins. Maybe should incl system? [EXCLSYS]\n     if (NoUserId < moreStats.userId && moreStats.userId < User.LowestNormalMemberId)\n       return\n \n-    val anyStats = transaction.loadUserStats(moreStats.userId)\n+    val anyStats = tx.loadUserStats(moreStats.userId)\n     val stats = anyStats.getOrDie(\"EdE2WKZ8A4\", s\"No stats for user $siteId:${moreStats.userId}\")\n     val newStats = stats.addMoreStats(moreStats)\n     SHOULD // if moreStats replies to chat message or discourse topic, then update\n     // num-chat/discourse-topics-replied-in.\n     SHOULD // update num-topics-entered too\n-    transaction.upsertUserStats(newStats)\n+    tx.upsertUserStats(newStats)\n   }\n \n \n   def insertInvite(invite: Invite) {\n-    readWriteTransaction { transaction =>\n-      transaction.insertInvite(invite)\n+    readWriteTransaction { tx =>\n+      tx.insertInvite(invite)\n     }\n   }\n \n@@ -256,28 +256,28 @@ trait UserDao {\n \n \n   def lockMemberTrustLevel(memberId: UserId, newTrustLevel: Option[TrustLevel]) {\n-    readWriteTransaction { transaction =>\n-      val member = transaction.loadTheMemberInclDetails(memberId)\n+    readWriteTransaction { tx =>\n+      val member = tx.loadTheMemberInclDetails(memberId)\n       val memberAfter = member.copy(lockedTrustLevel = newTrustLevel)\n-      transaction.updateMemberInclDetails(memberAfter)\n+      tx.updateMemberInclDetails(memberAfter)\n     }\n     removeUserFromMemCache(memberId)\n   }\n \n \n   def lockMemberThreatLevel(memberId: UserId, newThreatLevel: Option[ThreatLevel]) {\n-    readWriteTransaction { transaction =>\n-      val member: MemberInclDetails = transaction.loadTheMemberInclDetails(memberId)\n+    readWriteTransaction { tx =>\n+      val member: MemberInclDetails = tx.loadTheMemberInclDetails(memberId)\n       val memberAfter = member.copy(lockedThreatLevel = newThreatLevel)\n-      transaction.updateMemberInclDetails(memberAfter)\n+      tx.updateMemberInclDetails(memberAfter)\n     }\n     removeUserFromMemCache(memberId)\n   }\n \n \n   def lockGuestThreatLevel(guestId: UserId, newThreatLevel: Option[ThreatLevel]) {\n-    readWriteTransaction { transaction =>\n-      val guest = transaction.loadTheGuest(guestId)\n+    readWriteTransaction { tx =>\n+      val guest = tx.loadTheGuest(guestId)\n       ??? // lock both ips and guest cookie\n     }\n     removeUserFromMemCache(guestId)\n@@ -292,8 +292,8 @@ trait UserDao {\n     val cappedDays = math.min(numDays, 365 * 110)\n     val now = globals.now()\n \n-    readWriteTransaction { transaction =>\n-      var user = transaction.loadTheMemberInclDetails(userId)\n+    readWriteTransaction { tx =>\n+      var user = tx.loadTheMemberInclDetails(userId)\n       if (user.isAdmin)\n         throwForbidden(\"DwE4KEF24\", \"Cannot suspend admins\")\n \n@@ -303,37 +303,37 @@ trait UserDao {\n         suspendedTill = Some(suspendedTill),\n         suspendedById = Some(suspendedById),\n         suspendedReason = Some(reason.trim))\n-      transaction.updateMemberInclDetails(user)\n+      tx.updateMemberInclDetails(user)\n     }\n     removeUserFromMemCache(userId)\n   }\n \n \n   def unsuspendUser(userId: UserId) {\n-    readWriteTransaction { transaction =>\n-      var user = transaction.loadTheMemberInclDetails(userId)\n+    readWriteTransaction { tx =>\n+      var user = tx.loadTheMemberInclDetails(userId)\n       user = user.copy(suspendedAt = None, suspendedTill = None, suspendedById = None,\n         suspendedReason = None)\n-      transaction.updateMemberInclDetails(user)\n+      tx.updateMemberInclDetails(user)\n     }\n     removeUserFromMemCache(userId)\n   }\n \n \n   def blockGuest(postId: PostId, numDays: Int, threatLevel: ThreatLevel, blockerId: UserId) {\n-    readWriteTransaction { transaction =>\n-      val auditLogEntry: AuditLogEntry = transaction.loadCreatePostAuditLogEntry(postId) getOrElse {\n+    readWriteTransaction { tx =>\n+      val auditLogEntry: AuditLogEntry = tx.loadCreatePostAuditLogEntry(postId) getOrElse {\n         throwForbidden(\"DwE2WKF5\", \"Cannot block user: No audit log entry, so no ip and id cookie\")\n       }\n \n       blockGuestImpl(auditLogEntry.browserIdData, auditLogEntry.doerId,\n-          numDays, threatLevel, blockerId)(transaction)\n+          numDays, threatLevel, blockerId)(tx)\n     }\n   }\n \n \n   def blockGuestImpl(browserIdData: BrowserIdData, guestId: UserId, numDays: Int,\n-        threatLevel: ThreatLevel, blockerId: UserId)(transaction: SiteTransaction) {\n+        threatLevel: ThreatLevel, blockerId: UserId)(tx: SiteTransaction) {\n \n       if (!User.isGuestId(guestId))\n         throwForbidden(\"DwE4WKQ2\", \"Cannot block authenticated users. Suspend them instead\")\n@@ -342,17 +342,17 @@ trait UserDao {\n       // to think about. Block the ip for a little bit shorter time, because might affect\n       // \"innocent\" people.\n       val ipBlockedTill =\n-        Some(new ju.Date(transaction.now.millis + OneWeekInMillis * 2))\n+        Some(new ju.Date(tx.now.millis + OneWeekInMillis * 2))\n \n       val cookieBlockedTill =\n-        Some(new ju.Date(transaction.now.millis + OneWeekInMillis * 6))\n+        Some(new ju.Date(tx.now.millis + OneWeekInMillis * 6))\n \n       val ipBlock = Block(\n         threatLevel = threatLevel,\n         ip = Some(browserIdData.inetAddress),  // include ip\n         browserIdCookie = None,                // skip cookie\n         blockedById = blockerId,\n-        blockedAt = transaction.now.toJavaDate,\n+        blockedAt = tx.now.toJavaDate,\n         blockedTill = ipBlockedTill)\n \n       val browserIdCookieBlock = browserIdData.idCookie map { idCookie =>\n@@ -361,68 +361,68 @@ trait UserDao {\n           ip = None,                        // skip ip\n           browserIdCookie = Some(idCookie), // include cookie\n           blockedById = blockerId,\n-          blockedAt = transaction.now.toJavaDate,\n+          blockedAt = tx.now.toJavaDate,\n           blockedTill = cookieBlockedTill)\n       }\n \n       // COULD catch dupl key error when inserting IP block, and update it instead, if new\n       // threat level is *worse* [6YF42]. Aand continue anyway with inserting browser id\n       // cookie block.\n-      transaction.insertBlock(ipBlock)\n-      browserIdCookieBlock foreach transaction.insertBlock\n+      tx.insertBlock(ipBlock)\n+      browserIdCookieBlock foreach tx.insertBlock\n \n       // Also set the user's threat level, if the new level is worse.\n-      transaction.loadGuest(guestId) foreach { guest =>\n+      tx.loadGuest(guestId) foreach { guest =>\n         if (!guest.lockedThreatLevel.exists(_.toInt > threatLevel.toInt)) {\n-          transaction.updateGuest(\n+          tx.updateGuest(\n             guest.copy(lockedThreatLevel = Some(threatLevel)))\n         }\n       }\n   }\n \n \n   def unblockGuest(postNr: PostNr, unblockerId: UserId) {\n-    readWriteTransaction { transaction =>\n-      val auditLogEntry: AuditLogEntry = transaction.loadCreatePostAuditLogEntry(postNr) getOrElse {\n+    readWriteTransaction { tx =>\n+      val auditLogEntry: AuditLogEntry = tx.loadCreatePostAuditLogEntry(postNr) getOrElse {\n         throwForbidden(\"DwE5FK83\", \"Cannot unblock guest: No audit log entry, IP unknown\")\n       }\n-      transaction.unblockIp(auditLogEntry.browserIdData.inetAddress)\n-      auditLogEntry.browserIdData.idCookie foreach transaction.unblockBrowser\n-      transaction.loadGuest(auditLogEntry.doerId) foreach { guest =>\n+      tx.unblockIp(auditLogEntry.browserIdData.inetAddress)\n+      auditLogEntry.browserIdData.idCookie foreach tx.unblockBrowser\n+      tx.loadGuest(auditLogEntry.doerId) foreach { guest =>\n         if (guest.lockedThreatLevel.isDefined) {\n-          transaction.updateGuest(guest.copy(lockedThreatLevel = None))\n+          tx.updateGuest(guest.copy(lockedThreatLevel = None))\n         }\n       }\n     }\n   }\n \n \n   def loadAuthorBlocks(postId: PostId): immutable.Seq[Block] = {\n-    readOnlyTransaction { transaction =>\n-      val auditLogEntry = transaction.loadCreatePostAuditLogEntry(postId) getOrElse {\n+    readOnlyTransaction { tx =>\n+      val auditLogEntry = tx.loadCreatePostAuditLogEntry(postId) getOrElse {\n         return Nil\n       }\n       val browserIdData = auditLogEntry.browserIdData\n-      transaction.loadBlocks(ip = browserIdData.ip, browserIdCookie = browserIdData.idCookie)\n+      tx.loadBlocks(ip = browserIdData.ip, browserIdCookie = browserIdData.idCookie)\n     }\n   }\n \n \n   def loadBlocks(ip: String, browserIdCookie: Option[String]): immutable.Seq[Block] = {\n-    readOnlyTransactionNotSerializable { transaction =>\n-      transaction.loadBlocks(ip = ip, browserIdCookie = browserIdCookie)\n+    readOnlyTransactionNotSerializable { tx =>\n+      tx.loadBlocks(ip = ip, browserIdCookie = browserIdCookie)\n     }\n   }\n \n \n-  def loadUserAndLevels(who: Who, transaction: SiteTransaction): UserAndLevels = {\n-    val user = transaction.loadTheUser(who.id)\n+  def loadUserAndLevels(who: Who, tx: SiteTransaction): UserAndLevels = {\n+    val user = tx.loadTheUser(who.id)\n     val trustLevel = user.effectiveTrustLevel\n     val threatLevel = user match {\n       case member: Member => member.effectiveThreatLevel\n       case guest: Guest =>\n         // Somewhat dupl code [2WKPU08], see a bit below.\n-        val blocks = transaction.loadBlocks(ip = who.ip, browserIdCookie = who.idCookie)\n+        val blocks = tx.loadBlocks(ip = who.ip, browserIdCookie = who.idCookie)\n         val baseThreatLevel = guest.lockedThreatLevel getOrElse ThreatLevel.HopefullySafe\n         val levelInt = blocks.foldLeft(baseThreatLevel.toInt) { (maxSoFar, block) =>\n           math.max(maxSoFar, block.threatLevel.toInt)\n@@ -435,10 +435,10 @@ trait UserDao {\n   }\n \n \n-  def loadThreatLevelNoUser(browserIdData: BrowserIdData, transaction: SiteTransaction)\n+  def loadThreatLevelNoUser(browserIdData: BrowserIdData, tx: SiteTransaction)\n         : ThreatLevel = {\n     // Somewhat dupl code [2WKPU08], see just above.\n-    val blocks = transaction.loadBlocks(\n+    val blocks = tx.loadBlocks(\n       ip = browserIdData.ip, browserIdCookie = browserIdData.idCookie)\n     val levelInt = blocks.foldLeft(ThreatLevel.HopefullySafe.toInt) { (maxSoFar, block) =>\n       math.max(maxSoFar, block.threatLevel.toInt)\n@@ -490,11 +490,11 @@ trait UserDao {\n     require(user.email.nonEmpty, \"DwE3KEF7\")\n     require(user.emailVerifiedAt.nonEmpty, \"DwE5KGE2\")\n     require(user.isAuthenticated, \"DwE4KEF8\")\n-    readWriteTransaction { transaction =>\n-      val identityId = transaction.nextIdentityId\n+    readWriteTransaction { tx =>\n+      val identityId = tx.nextIdentityId\n       val identity = OpenAuthIdentity(id = identityId, userId = user.id, oauthDetails)\n-      transaction.insertIdentity(identity)\n-      addUserStats(UserStats(user.id, lastSeenAt = transaction.now))(transaction)\n+      tx.insertIdentity(identity)\n+      addUserStats(UserStats(user.id, lastSeenAt = tx.now))(tx)\n       MemberLoginGrant(Some(identity), user, isNewIdentity = true, isNewMember = false)\n     }\n   }\n@@ -568,26 +568,26 @@ trait UserDao {\n \n   def changePasswordCheckStrongEnough(userId: UserId, newPassword: String): Boolean = {\n     val newPasswordSaltHash = DbDao.saltAndHashPassword(newPassword)\n-    readWriteTransaction { transaction =>\n-      var user = transaction.loadTheMemberInclDetails(userId)\n+    readWriteTransaction { tx =>\n+      var user = tx.loadTheMemberInclDetails(userId)\n       security.throwErrorIfPasswordBad(\n         password = newPassword, username = user.username,\n         fullName = user.fullName, email = user.primaryEmailAddress,\n         minPasswordLength = globals.minPasswordLengthAllSites, isForOwner = user.isOwner)\n       user = user.copy(passwordHash = Some(newPasswordSaltHash))\n-      transaction.updateMemberInclDetails(user)\n+      tx.updateMemberInclDetails(user)\n     }\n   }\n \n \n   def loginAsGuest(loginAttempt: GuestLoginAttempt): Guest = {\n-    val user = readWriteTransaction { transaction =>\n-      val guest = transaction.loginAsGuest(loginAttempt).guest\n+    val user = readWriteTransaction { tx =>\n+      val guest = tx.loginAsGuest(loginAttempt).guest\n       // We don't know if this guest user is being created now, or if it already exists\n       // — so upsert (rather than insert? or update?) stats about this guest user.\n       // (Currently this upsert keeps the earliest/oldest first/latest dates, see [7FKTU02].)\n-      transaction.upsertUserStats(UserStats(\n-        guest.id, firstSeenAtOr0 = transaction.now, lastSeenAt = transaction.now))\n+      tx.upsertUserStats(UserStats(\n+        guest.id, firstSeenAtOr0 = tx.now, lastSeenAt = tx.now))\n       guest\n     }\n     memCache.put(\n@@ -642,23 +642,23 @@ trait UserDao {\n \n \n   def logout(userId: UserId) {\n-    readWriteTransaction { transaction =>\n-      addUserStats(UserStats(userId, lastSeenAt = transaction.now))(transaction)\n+    readWriteTransaction { tx =>\n+      addUserStats(UserStats(userId, lastSeenAt = tx.now))(tx)\n     }\n     memCache.remove(key(userId))\n   }\n \n \n   def loadUsers(): immutable.Seq[User] = {\n-    readOnlyTransaction { transaction =>\n-      transaction.loadUsers()\n+    readOnlyTransaction { tx =>\n+      tx.loadUsers()\n     }\n   }\n \n \n   def loadSiteOwner(): Option[MemberInclDetails] = {\n-    readOnlyTransaction { transaction =>\n-      transaction.loadOwner()\n+    readOnlyTransaction { tx =>\n+      tx.loadOwner()\n     }\n   }\n \n@@ -682,8 +682,8 @@ trait UserDao {\n \n \n   def loadMemberInclDetailsById(userId: UserId): Option[MemberInclDetails] = {\n-    readOnlyTransaction { transaction =>\n-      transaction.loadMemberInclDetails(userId)\n+    readOnlyTransaction { tx =>\n+      tx.loadMemberInclDetails(userId)\n     }\n   }\n \n@@ -731,8 +731,8 @@ trait UserDao {\n     memCache.lookup[User](\n       key(userId),\n       orCacheAndReturn = {\n-        readOnlyTransaction { transaction =>\n-          transaction.loadUser(userId)\n+        readOnlyTransaction { tx =>\n+          tx.loadUser(userId)\n         }\n       },\n       ignoreSiteCacheVersion = true)\n@@ -776,9 +776,9 @@ trait UserDao {\n   }\n \n   def loadMemberByEmailOrUsername(emailOrUsername: String): Option[Member] = {  // RENAME to ... PrimaryEmailAddress... ?\n-    readOnlyTransaction { transaction =>\n+    readOnlyTransaction { tx =>\n       // Don't need to cache this? Only called when logging in.\n-      transaction.loadMemberByPrimaryEmailOrUsername(emailOrUsername)\n+      tx.loadMemberByPrimaryEmailOrUsername(emailOrUsername)\n     }\n   }\n \n@@ -804,8 +804,8 @@ trait UserDao {\n     user match {\n       case _: Guest | UnknownUser => Vector(Group.EveryoneId)\n       case _: Member | _: Group =>\n-        readOnlyTransaction { transaction =>\n-          transaction.loadGroupIds(user)\n+        readOnlyTransaction { tx =>\n+          tx.loadGroupIds(user)\n         }\n     }\n   }\n@@ -899,28 +899,28 @@ trait UserDao {\n \n \n   private def joinLeavePageImpl(userIds: Set[UserId], pageId: PageId, add: Boolean,\n-    byWho: Who, couldntAdd: mutable.Set[UserId], transaction: SiteTransaction): PageMeta = {\n-    val pageMeta = transaction.loadPageMeta(pageId) getOrElse\n+    byWho: Who, couldntAdd: mutable.Set[UserId], tx: SiteTransaction): PageMeta = {\n+    val pageMeta = tx.loadPageMeta(pageId) getOrElse\n       security.throwIndistinguishableNotFound(\"42PKD0\")\n \n     // Right now, to join a forum page = sub community, one just adds it to one's watchbar.\n     // But we don't add/remove the user from the page members list, so nothing to do here.\n     if (pageMeta.pageRole == PageRole.Forum)\n       return pageMeta\n \n-    val usersById = transaction.loadMembersAsMap(userIds + byWho.id)\n+    val usersById = tx.loadMembersAsMap(userIds + byWho.id)\n     val me = usersById.getOrElse(byWho.id, throwForbidden(\n       \"EsE6KFE0X\", s\"Your user cannot be found, id: ${byWho.id}\"))\n \n-    lazy val numMembersAlready = transaction.loadMessageMembers(pageId).size\n+    lazy val numMembersAlready = tx.loadMessageMembers(pageId).size\n     if (add && numMembersAlready + userIds.size > 400) {\n       // I guess something, not sure what?, would break if too many people join\n       // the same page.\n       throwForbidden(\"EsE4FK0Y2\", o\"\"\"Sorry but currently more than 400 page members\n             isn't allowed. There are $numMembersAlready page members already\"\"\")\n     }\n \n-    throwIfMayNotSeePage(pageMeta, Some(me))(transaction)\n+    throwIfMayNotSeePage(pageMeta, Some(me))(tx)\n \n     val addingRemovingMyselfOnly = userIds.size == 1 && userIds.head == me.id\n \n@@ -938,7 +938,7 @@ trait UserDao {\n \n       userIds foreach { id =>\n         COULD_OPTIMIZE // batch insert all users at once (would slightly speed up imports)\n-        val wasAdded = transaction.insertMessageMember(pageId, userId = id, addedById = me.id)\n+        val wasAdded = tx.insertMessageMember(pageId, userId = id, addedById = me.id)\n         if (!wasAdded) {\n           // Someone else has added that user already. Could happen e.g. if someone adds you\n           // to a chat channel, and you attempt to join it yourself at the same time.\n@@ -948,7 +948,7 @@ trait UserDao {\n     }\n     else {\n       userIds foreach { id =>\n-        transaction.removePageMember(pageId, userId = id, removedById = byWho.id)\n+        tx.removePageMember(pageId, userId = id, removedById = byWho.id)\n       }\n     }\n \n@@ -958,7 +958,7 @@ trait UserDao {\n     // for chat topics, in the forum topic list? (because # comments in a chat channel is\n     // rather pointless, instead, # new comments per time unit matters more, but then it's\n     // simpler to instead show # users?)\n-    transaction.updatePageMeta(pageMeta, oldMeta = pageMeta, markSectionPageStale = false)\n+    tx.updatePageMeta(pageMeta, oldMeta = pageMeta, markSectionPageStale = false)\n     pageMeta\n   }\n \n@@ -1089,43 +1089,43 @@ trait UserDao {\n   }\n \n \n-  def promoteUser(userId: UserId, newTrustLevel: TrustLevel, transaction: SiteTransaction) {\n+  def promoteUser(userId: UserId, newTrustLevel: TrustLevel, tx: SiteTransaction) {\n     // If trust level locked, we'll promote the member anyway — but member.effectiveTrustLevel\n     // won't change, because it considers the locked trust level first.\n-    val member = transaction.loadTheMemberInclDetails(userId)\n+    val member = tx.loadTheMemberInclDetails(userId)\n     val promoted = member.copy(trustLevel = newTrustLevel)\n-    transaction.updateMemberInclDetails(promoted)\n+    tx.updateMemberInclDetails(promoted)\n     TESTS_MISSING // Perhaps now new chat channels are available to the member.\n-    joinGloballyPinnedChats(member.briefUser, transaction)\n+    joinGloballyPinnedChats(member.briefUser, tx)\n   }\n \n \n   def loadNotifications(userId: UserId, upToWhen: Option[When], me: Who,\n         unseenFirst: Boolean = false, limit: Int = 100)\n         : NotfsAndCounts = {\n-    readOnlyTransaction { transaction =>\n+    readOnlyTransaction { tx =>\n       if (me.id != userId) {\n-        if (!transaction.loadUser(me.id).exists(_.isStaff))\n+        if (!tx.loadUser(me.id).exists(_.isStaff))\n           throwForbidden(\"EsE5Y5IKF0\", \"May not list other users' notifications\")\n       }\n       SECURITY; SHOULD // filter out priv msg notf, unless isMe or isAdmin.\n-      debiki.JsonMaker.loadNotifications(userId, transaction, unseenFirst = unseenFirst, limit = limit,\n+      debiki.JsonMaker.loadNotifications(userId, tx, unseenFirst = unseenFirst, limit = limit,\n         upToWhen = None) // later: Some(upToWhenDate), and change to limit = 50 above?\n     }\n   }\n \n \n   REFACTOR; CLEAN_UP // Delete, break out fn instead. [4KDPREU2]\n   def verifyPrimaryEmailAddress(userId: UserId, verifiedAt: ju.Date) {\n-    readWriteTransaction { transaction =>\n-      var user = transaction.loadTheMemberInclDetails(userId)\n+    readWriteTransaction { tx =>\n+      var user = tx.loadTheMemberInclDetails(userId)\n       user = user.copy(emailVerifiedAt = Some(verifiedAt))\n       val userEmailAddress = user.primaryEmailInfo getOrDie \"EdE4JKA2S\"\n       dieUnless(userEmailAddress.isVerified, \"EdE7UNHR4\")\n-      transaction.updateMemberInclDetails(user)\n-      transaction.updateUserEmailAddress(userEmailAddress)\n+      tx.updateMemberInclDetails(user)\n+      tx.updateUserEmailAddress(userEmailAddress)\n       // Now, when email verified, perhaps time to start sending summary emails.\n-      transaction.reconsiderSendingSummaryEmailsTo(user.id)\n+      tx.reconsiderSendingSummaryEmailsTo(user.id)\n     }\n     removeUserFromMemCache(userId)\n   }\n@@ -1136,18 +1136,18 @@ trait UserDao {\n         mediumAvatar: Option[UploadRef], browserIdData: BrowserIdData) {\n     require(smallAvatar.isDefined == tinyAvatar.isDefined, \"EsE9PYM2\")\n     require(smallAvatar.isDefined == mediumAvatar.isDefined, \"EsE8YFM2\")\n-    readWriteTransaction { transaction =>\n+    readWriteTransaction { tx =>\n       setUserAvatarImpl(userId, tinyAvatar = tinyAvatar,\n-        smallAvatar = smallAvatar, mediumAvatar = mediumAvatar, browserIdData, transaction)\n+        smallAvatar = smallAvatar, mediumAvatar = mediumAvatar, browserIdData, tx)\n     }\n   }\n \n \n   private def setUserAvatarImpl(userId: UserId, tinyAvatar: Option[UploadRef],\n         smallAvatar: Option[UploadRef], mediumAvatar: Option[UploadRef],\n-        browserIdData: BrowserIdData, transaction: SiteTransaction) {\n+        browserIdData: BrowserIdData, tx: SiteTransaction) {\n \n-      val userBefore = transaction.loadTheMemberInclDetails(userId)\n+      val userBefore = tx.loadTheMemberInclDetails(userId)\n       val userAfter = userBefore.copy(\n         tinyAvatar = tinyAvatar,\n         smallAvatar = smallAvatar,\n@@ -1164,56 +1164,56 @@ trait UserDao {\n           userBefore.tinyAvatar.toSet ++ userBefore.smallAvatar.toSet ++\n             userBefore.mediumAvatar.toSet ++ userAfter.tinyAvatar.toSet ++\n             userAfter.smallAvatar.toSet ++ userAfter.mediumAvatar.toSet\n-      val refsInUseBefore = transaction.filterUploadRefsInUse(relevantRefs)\n+      val refsInUseBefore = tx.filterUploadRefsInUse(relevantRefs)\n \n-      transaction.updateMemberInclDetails(userAfter)\n+      tx.updateMemberInclDetails(userAfter)\n \n       if (hasNewAvatar) {\n-        val refsInUseAfter = transaction.filterUploadRefsInUse(relevantRefs)\n+        val refsInUseAfter = tx.filterUploadRefsInUse(relevantRefs)\n         val refsAdded = refsInUseAfter -- refsInUseBefore\n         val refsRemoved = refsInUseBefore -- refsInUseAfter\n-        refsAdded.foreach(transaction.updateUploadQuotaUse(_, wasAdded = true))\n-        refsRemoved.foreach(transaction.updateUploadQuotaUse(_, wasAdded = false))\n-\n-        userBefore.tinyAvatar.foreach(transaction.updateUploadedFileReferenceCount)\n-        userBefore.smallAvatar.foreach(transaction.updateUploadedFileReferenceCount)\n-        userBefore.mediumAvatar.foreach(transaction.updateUploadedFileReferenceCount)\n-        userAfter.tinyAvatar.foreach(transaction.updateUploadedFileReferenceCount)\n-        userAfter.smallAvatar.foreach(transaction.updateUploadedFileReferenceCount)\n-        userAfter.mediumAvatar.foreach(transaction.updateUploadedFileReferenceCount)\n-        transaction.markPagesWithUserAvatarAsStale(userId)\n+        refsAdded.foreach(tx.updateUploadQuotaUse(_, wasAdded = true))\n+        refsRemoved.foreach(tx.updateUploadQuotaUse(_, wasAdded = false))\n+\n+        userBefore.tinyAvatar.foreach(tx.updateUploadedFileReferenceCount)\n+        userBefore.smallAvatar.foreach(tx.updateUploadedFileReferenceCount)\n+        userBefore.mediumAvatar.foreach(tx.updateUploadedFileReferenceCount)\n+        userAfter.tinyAvatar.foreach(tx.updateUploadedFileReferenceCount)\n+        userAfter.smallAvatar.foreach(tx.updateUploadedFileReferenceCount)\n+        userAfter.mediumAvatar.foreach(tx.updateUploadedFileReferenceCount)\n+        tx.markPagesWithUserAvatarAsStale(userId)\n       }\n       removeUserFromMemCache(userId)\n \n       // Clear the PageStuff cache (by clearing the whole in-mem cache), because\n       // PageStuff includes avatar urls.\n       // COULD have above markPagesWithUserAvatarAsStale() return a page id list and\n       // uncache only those pages.\n-      emptyCacheImpl(transaction)\n+      emptyCacheImpl(tx)\n   }\n \n \n   def configRole(userId: RoleId,\n         emailNotfPrefs: Option[EmailNotfPrefs] = None,\n         activitySummaryEmailsIntervalMins: Option[Int] = None) {\n     // Don't specify emailVerifiedAt — use verifyPrimaryEmailAddress() instead; it refreshes the cache.\n-    readWriteTransaction { transaction =>\n-      var user = transaction.loadTheMemberInclDetails(userId)\n+    readWriteTransaction { tx =>\n+      var user = tx.loadTheMemberInclDetails(userId)\n       emailNotfPrefs foreach { prefs =>\n         user = user.copy(emailNotfPrefs = prefs)\n       }\n       activitySummaryEmailsIntervalMins foreach { mins =>\n         user = user.copy(summaryEmailIntervalMins = Some(mins))\n       }\n-      transaction.updateMemberInclDetails(user)\n+      tx.updateMemberInclDetails(user)\n     }\n     removeUserFromMemCache(userId)\n   }\n \n \n   def configIdtySimple(ctime: ju.Date, emailAddr: String, emailNotfPrefs: EmailNotfPrefs) {\n-    readWriteTransaction { transaction =>\n-      transaction.configIdtySimple(ctime = ctime,\n+    readWriteTransaction { tx =>\n+      tx.configIdtySimple(ctime = ctime,\n         emailAddr = emailAddr, emailNotfPrefs = emailNotfPrefs)\n       // COULD refresh guest in cache: new email prefs --> perhaps show \"??\" not \"?\" after name.\n     }\n@@ -1252,9 +1252,9 @@ trait UserDao {\n     SECURITY // should create audit log entry. Should allow staff to change usernames.\n     BUG // the lost update bug (if staff + user henself changes the user's prefs at the same time)\n \n-    readWriteTransaction { transaction =>\n-      val user = transaction.loadTheMemberInclDetails(preferences.userId)\n-      val me = transaction.loadTheMember(byWho.id)\n+    readWriteTransaction { tx =>\n+      val user = tx.loadTheMemberInclDetails(preferences.userId)\n+      val me = tx.loadTheMember(byWho.id)\n \n       require(me.isStaff || me.id == user.id, \"TyE2WK7G4\")\n \n@@ -1276,10 +1276,10 @@ trait UserDao {\n       if (user.username != preferences.username) {\n         throwForbiddenIfBadUsername(preferences.username)\n \n-        val usersOldUsernames: Seq[UsernameUsage] = transaction.loadUsersOldUsernames(user.id)\n+        val usersOldUsernames: Seq[UsernameUsage] = tx.loadUsersOldUsernames(user.id)\n \n         // [CANONUN] load both exact & canonical username, any match —> not allowed (unless one's own).\n-        val previousUsages = transaction.loadUsernameUsages(preferences.username)\n+        val previousUsages = tx.loadUsernameUsages(preferences.username)\n \n         // For now: (later, could allow, if never mentioned, after a grace period. Docs [8KFUT20])\n         val usagesByOthers = previousUsages.filter(_.userId != user.id)\n@@ -1291,7 +1291,7 @@ trait UserDao {\n         val maxPerYearDistinct = me.isStaff ? 8 | 3\n \n         val recentUsernames = usersOldUsernames.filter(\n-            _.inUseFrom.daysBetween(transaction.now) < 365)\n+            _.inUseFrom.daysBetween(tx.now) < 365)\n         if (recentUsernames.length >= maxPerYearTotal)\n           throwForbidden(\"DwE5FKW02\",\n             \"You have changed your username too many times the past year\")\n@@ -1304,13 +1304,13 @@ trait UserDao {\n \n         val anyUsernamesToStopUsingNow = usersOldUsernames.filter(_.inUseTo.isEmpty)\n         anyUsernamesToStopUsingNow foreach { usage: UsernameUsage =>\n-          val usageStopped = usage.copy(inUseTo = Some(transaction.now))\n-          transaction.updateUsernameUsage(usageStopped)\n+          val usageStopped = usage.copy(inUseTo = Some(tx.now))\n+          tx.updateUsernameUsage(usageStopped)\n         }\n \n-        transaction.insertUsernameUsage(UsernameUsage(\n+        tx.insertUsernameUsage(UsernameUsage(\n           usernameLowercase = preferences.username.toLowerCase, // [CANONUN]\n-          inUseFrom = transaction.now,\n+          inUseFrom = tx.now,\n           inUseTo = None,\n           userId = user.id,\n           firstMentionAt = None))\n@@ -1321,24 +1321,26 @@ trait UserDao {\n         throwForbidden(\"DwE44ELK9\", \"Shouldn't modify one's email here\")\n \n       REFACTOR // notf prefs should be a separate tab in the UI, and a separate api endpoint [REFACTORNOTFS]\n-      val oldSiteNotfLevel = transaction.loadPageNotfLevels(\n-        preferences.userId, NoPageId, categoryId = None).forWholeSite getOrElse NotfLevel.Normal\n+      // BUG need to first change to sth else, before set-Normal has any effect. [7KASDSRF20]\n+      val oldNotfLevels = tx.loadPageNotfLevels(\n+         preferences.userId, NoPageId, categoryId = None)\n+      val oldSiteNotfLevel = oldNotfLevels.forWholeSite getOrElse NotfLevel.Normal\n       if (preferences.siteNotfLevel != oldSiteNotfLevel) {\n-        transaction.upsertPageNotfPref(\n+        tx.upsertPageNotfPref(\n             PageNotfPref(user.id, preferences.siteNotfLevel, wholeSite = true))\n       }\n       // -- / REFACTOR -------------------------------------------------------------------------------\n \n       val userAfter = user.copyWithNewAboutPrefs(preferences)\n-      try transaction.updateMemberInclDetails(userAfter)\n+      try tx.updateMemberInclDetails(userAfter)\n       catch {\n         case _: DuplicateUsernameException =>\n           throwForbidden(\"EdE2WK8Y4_\", \"Username already in use\")\n       }\n \n       if (userAfter.summaryEmailIntervalMins != user.summaryEmailIntervalMins ||\n           userAfter.summaryEmailIfActive != user.summaryEmailIfActive) {\n-        transaction.reconsiderSendingSummaryEmailsTo(user.id)  // related: [5KRDUQ0]\n+        tx.reconsiderSendingSummaryEmailsTo(user.id)  // related: [5KRDUQ0]\n       }\n \n       removeUserFromMemCache(preferences.userId)\n@@ -1348,7 +1350,7 @@ trait UserDao {\n       if (preferences.changesStuffIncludedEverywhere(user)) {\n         // COULD_OPTIMIZE bump only page versions for the pages on which the user has posted something.\n         // Use markPagesWithUserAvatarAsStale ?\n-        emptyCacheImpl(transaction)\n+        emptyCacheImpl(tx)\n       }\n     }\n   }\n@@ -1359,9 +1361,9 @@ trait UserDao {\n     SECURITY // should create audit log entry. Should allow staff to change usernames.\n     BUG // the lost update bug (if staff + user henself changes the user's prefs at the same time)\n \n-    readWriteTransaction { transaction =>\n-      val group = transaction.loadTheGroupInclDetails(preferences.groupId)\n-      val me = transaction.loadTheMember(byWho.id)\n+    readWriteTransaction { tx =>\n+      val group = tx.loadTheGroupInclDetails(preferences.groupId)\n+      val me = tx.loadTheMember(byWho.id)\n       require(me.isStaff, \"EdE5LKWV0\")\n \n       val groupAfter = group.copyWithNewAboutPrefs(preferences)\n@@ -1373,12 +1375,12 @@ trait UserDao {\n       if (groupAfter.theUsername != group.theUsername) {\n         throwForbiddenIfBadUsername(preferences.username)\n         unimplemented(\"Changing a group's username\", \"TyE2KBFU50\")\n-        // Need to: transaction.updateUsernameUsage(usageStopped) — stop using current\n-        // And: transaction.insertUsernameUsage(UsernameUsage(   [CANONUN]\n+        // Need to: tx.updateUsernameUsage(usageStopped) — stop using current\n+        // And: tx.insertUsernameUsage(UsernameUsage(   [CANONUN]\n         // See saveAboutMemberPrefs.\n       }\n \n-      try transaction.updateGroup(groupAfter)\n+      try tx.updateGroup(groupAfter)\n       catch {\n         case _: DuplicateUsernameException =>\n           throwForbidden(\"EdE2WK8Y4_\", \"Username already in use\")\n@@ -1388,14 +1390,15 @@ trait UserDao {\n       // So let the summary-emails module reconsider all members at this site.\n       if (groupAfter.summaryEmailIntervalMins != group.summaryEmailIntervalMins ||\n           groupAfter.summaryEmailIfActive != group.summaryEmailIfActive) {\n-        transaction.reconsiderSendingSummaryEmailsToEveryone()  // related: [5KRDUQ0] [8YQKSD10]\n+        tx.reconsiderSendingSummaryEmailsToEveryone()  // related: [5KRDUQ0] [8YQKSD10]\n       }\n \n       REFACTOR // notf prefs should be a separate tab in the UI, and a separate api endpoint [REFACTORNOTFS]\n-      val oldSiteNotfLevel = transaction.loadPageNotfLevels(\n+      // BUG need to first change to sth else, before set-Normal has any effect. [7KASDSRF20]\n+      val oldSiteNotfLevel = tx.loadPageNotfLevels(\n         preferences.groupId, NoPageId, categoryId = None).forWholeSite getOrElse NotfLevel.Normal\n       if (preferences.siteNotfLevel != oldSiteNotfLevel) {\n-        transaction.upsertPageNotfPref(\n+        tx.upsertPageNotfPref(\n           PageNotfPref(group.id, preferences.siteNotfLevel, wholeSite = true))\n       }\n       // ---/ REFACTOR -------------------------------------------------------------------------------\n@@ -1428,10 +1431,10 @@ trait UserDao {\n \n   def saveGuest(guestId: UserId, name: String) {\n     // BUG: the lost update bug.\n-    readWriteTransaction { transaction =>\n-      var guest = transaction.loadTheGuest(guestId)\n+    readWriteTransaction { tx =>\n+      var guest = tx.loadTheGuest(guestId)\n       guest = guest.copy(guestName = name)\n-      transaction.updateGuest(guest)\n+      tx.updateGuest(guest)\n     }\n     removeUserFromMemCache(guestId)\n   }\n@@ -1484,7 +1487,7 @@ trait UserDao {\n \n       // Use this fn so uploads ref counts get decremented.\n       setUserAvatarImpl(userId: UserId, tinyAvatar = None, smallAvatar = None, mediumAvatar = None,\n-        browserIdData = byWho.browserIdData, transaction = tx)\n+        browserIdData = byWho.browserIdData, tx = tx)\n \n       // Load member after having forgotten avatar images (above).\n       val memberBefore = tx.loadTheMemberInclDetails(userId)\n@@ -1580,8 +1583,8 @@ trait UserDao {\n         // If a superadmin is visiting the site (e.g. to help fixing a config error), don't  [EXCLSYS]\n         // show hen in the online list — hen isn't a real member.\n         val userIds = userIdsInclSystem.filterNot(id => id == SystemUserId || id == User.SuperAdminId)\n-        val users = readOnlyTransaction { transaction =>\n-          transaction.loadUsers(userIds)\n+        val users = readOnlyTransaction { tx =>\n+          tx.loadUsers(userIds)\n         }\n         UsersOnlineStuff(\n           users,"
    },
    {
      "sha": "a610220923af80e45ce2c10babe05782482a0457",
      "filename": "s/run-e2e-tests.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/debiki/talkyard/blob/bbd678f37f5a4b2704f5fe75a332920637ee630a/s/run-e2e-tests.sh",
      "raw_url": "https://github.com/debiki/talkyard/raw/bbd678f37f5a4b2704f5fe75a332920637ee630a/s/run-e2e-tests.sh",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/s/run-e2e-tests.sh?ref=bbd678f37f5a4b2704f5fe75a332920637ee630a",
      "patch": "@@ -241,6 +241,7 @@ function runAllE2eTests {\n   runE2eTest s/wdio target/e2e/wdio.2chrome.conf.js    --only unsubscribe.2browsers $args\n   runE2eTest s/wdio target/e2e/wdio.2chrome.conf.js    --only notf-emails-discussion.2browsers $args\n   runE2eTest s/wdio target/e2e/wdio.2chrome.conf.js    --only notfs-mark-all-as-read.2browsers $args\n+  runE2eTest s/wdio target/e2e/wdio.2chrome.conf.js    --only notf-override-group-prefs.2browsers $args\n   # See: specs/notf-page-cats-site.2browsers.test.ts:\n   #runE2eTest s/wdio target/e2e/wdio.2chrome.conf.js   --only notfs-for-whole-site.2browsers $args\n   #runE2eTest s/wdio target/e2e/wdio.2chrome.conf.js   --only notfs-for-publ-cat.2browsers $args"
    },
    {
      "sha": "a2d300c0242c397a32863f2dea56e89ba70524ce",
      "filename": "tests/e2e/specs/notf-override-group-prefs.2browsers.test.ts",
      "status": "added",
      "additions": 244,
      "deletions": 0,
      "changes": 244,
      "blob_url": "https://github.com/debiki/talkyard/blob/bbd678f37f5a4b2704f5fe75a332920637ee630a/tests/e2e/specs/notf-override-group-prefs.2browsers.test.ts",
      "raw_url": "https://github.com/debiki/talkyard/raw/bbd678f37f5a4b2704f5fe75a332920637ee630a/tests/e2e/specs/notf-override-group-prefs.2browsers.test.ts",
      "contents_url": "https://api.github.com/repos/debiki/talkyard/contents/tests/e2e/specs/notf-override-group-prefs.2browsers.test.ts?ref=bbd678f37f5a4b2704f5fe75a332920637ee630a",
      "patch": "@@ -0,0 +1,244 @@\n+/// <reference path=\"../test-types.ts\"/>\n+\n+import * as _ from 'lodash';\n+import assert = require('assert');\n+import server = require('../utils/server');\n+import utils = require('../utils/utils');\n+import pagesFor = require('../utils/pages-for');\n+import settings = require('../utils/settings');\n+import make = require('../utils/make');\n+import logAndDie = require('../utils/log-and-die');\n+import c = require('../test-constants');\n+\n+declare const browser: any;\n+declare var browserA: any;\n+declare var browserB: any;\n+\n+let richBrowserA;\n+let richBrowserB;\n+\n+let owen;\n+let owensBrowser;\n+let trillian;\n+let trilliansBrowser;\n+let modya;\n+let modyasBrowser;\n+let mons;\n+let monsBrowser;\n+let maja;\n+let majasBrowser;\n+let maria;\n+let mariasBrowser;\n+let michael;\n+let michaelsBrowser;\n+\n+let idAddress: IdAddress;\n+let siteId: any;\n+\n+const forumTitle = \"Email Notfs in Discussions Forum\";\n+\n+const owensTopicTitleOne = 'owensTopicTitleOne';\n+const owensTopicBodyOne = 'owensTopicBodyOne';\n+const owensReplyOne = 'owensReplyOne';\n+const owensReplyTwo = 'owensReplyTwo';\n+const owensReplyThree = 'owensReplyThree';\n+\n+const owensTopicTitleTwo = 'owensTopicTitleTwo';\n+const owensTopicBodyTwo = 'owensTopicBodyTwo';\n+\n+\n+describe(\"notfs overr grp prfs TyT6BKWDGY24\", () => {\n+\n+  it(\"initialize people\", () => {\n+    richBrowserA = _.assign(browserA, pagesFor(browserA));\n+    richBrowserB = _.assign(browserB, pagesFor(browserB));\n+    owensBrowser = richBrowserA;\n+    modyasBrowser = richBrowserB;\n+    monsBrowser = richBrowserB;\n+    majasBrowser = richBrowserB;\n+    mariasBrowser = richBrowserB;\n+    michaelsBrowser = richBrowserB;\n+    trilliansBrowser = richBrowserB;\n+\n+    owen = make.memberOwenOwner();\n+    modya = make.memberModeratorModya();\n+    mons = make.memberModeratorMons();\n+    maja = make.memberMaja();\n+    maria = make.memberMaria();\n+    michael = make.memberMichael();\n+    trillian = make.memberTrillian();\n+  });\n+\n+  it(\"import a site\", () => {\n+    const site: SiteData = make.forumOwnedByOwen('eml-ntf-disc', { title: forumTitle });\n+    //site.members.push(modya);\n+    //site.members.push(mons);\n+    site.members.push(maja);\n+    site.members.push(maria);\n+    site.members.push(michael);\n+    idAddress = server.importSiteData(site);\n+    siteId = idAddress.id;\n+  });\n+\n+\n+  // ----- Individual's notf-Normal and Every Post overrides All Member's notf about New Topics\n+\n+\n+  it(\"Owen goes to All Members' prefs page\", () => {\n+    owensBrowser.go(idAddress.origin);\n+    owensBrowser.complex.loginWithPasswordViaTopbar(owen);\n+    owensBrowser.go('/-/users/new_members/preferences');\n+  });\n+\n+  it(\"... and configures All Members to get notified about new topics\", () => {\n+    owensBrowser.userProfilePage.preferences.setNotfsForEachNewTopic();\n+    owensBrowser.userProfilePage.preferences.save();\n+  });\n+\n+  it(\"Maria goes to her notfs prefs page\", () => {\n+    mariasBrowser.go(idAddress.origin);\n+    mariasBrowser.complex.loginWithPasswordViaTopbar(maria);\n+    mariasBrowser.userProfilePage.openPreferencesFor(maria.username);\n+  });\n+\n+  it(\"... and overrides the All Members group prefs: She wants to be notfd about every post \", () => {\n+    // BUG need to first change to sth else, before set-Normal has any effect. [7KASDSRF20]\n+    mariasBrowser.userProfilePage.preferences.setNotfsForEachNewTopic();\n+    mariasBrowser.userProfilePage.preferences.save();\n+    mariasBrowser.userProfilePage.preferences.setNotfsNormal();\n+    mariasBrowser.userProfilePage.preferences.save();\n+  });\n+\n+  it(\"Maja goes to her notfs prefs page\", () => {\n+    mariasBrowser.topbar.clickLogout();\n+    majasBrowser.complex.loginWithPasswordViaTopbar(maja);\n+    majasBrowser.userProfilePage.openPreferencesFor(maja.username);\n+  });\n+\n+  it(\"... and overrides the All Members group prefs, to get notified about every post\", () => {\n+    majasBrowser.userProfilePage.preferences.setNotfsForEachNewPost();\n+    majasBrowser.userProfilePage.preferences.save();\n+  });\n+\n+  it(\"Owen posts a topic\", () => {\n+    owensBrowser.go('/');\n+    owensBrowser.complex.createAndSaveTopic({ title: owensTopicTitleOne, body: owensTopicBodyOne });\n+  });\n+\n+  it(\"Maja and Michael get notified\", () => {\n+    const titleBody = [owensTopicTitleOne, owensTopicBodyOne];\n+    server.waitUntilLastEmailMatches(siteId, maja.emailAddress, titleBody, browser);\n+    server.waitUntilLastEmailMatches(siteId, michael.emailAddress, titleBody, browser);\n+  });\n+\n+  it(\"... once, exactly\", () => {\n+    assert.equal(server.countLastEmailsSentTo(siteId, maja.emailAddress), 1);\n+    assert.equal(server.countLastEmailsSentTo(siteId, michael.emailAddress), 1);\n+  });\n+\n+  it(\"... but not Maria (because she configd normal site notfs prefs, *not* for every topic)\", () => {\n+   assert.equal(server.countLastEmailsSentTo(siteId, maria.emailAddress), 0);\n+  });\n+\n+  it(\"Owen posts a reply\", () => {\n+    owensBrowser.complex.replyToOrigPost(owensReplyOne);\n+  });\n+\n+  it(\"Maja gets notified: has overrided All Members' prefs, to get notfs about every new post\", () => {\n+    server.waitUntilLastEmailMatches(siteId, maja.emailAddress, [owensReplyOne], browser);\n+  });\n+\n+  it(\"... she gets exactly one email\", () => {\n+    assert.equal(server.countLastEmailsSentTo(siteId, maja.emailAddress), 2);\n+  });\n+\n+  it(\"No one else gets notified\", () => {\n+    assert.equal(server.countLastEmailsSentTo(siteId, michael.emailAddress), 1);  // old email\n+    assert.equal(server.countLastEmailsSentTo(siteId, maria.emailAddress), 0);\n+  });\n+\n+\n+  // ----- Individual's Normal overrides All Member's notf about Every Post\n+\n+\n+  let owensTopicUrl;\n+\n+  it(\"Owen goes to All Members' prefs page again\", () => {\n+    owensTopicUrl = owensBrowser.url().value;\n+    owensBrowser.go('/-/users/new_members/preferences');\n+  });\n+\n+  it(\"... configs prefs for every post, for everyone\", () => {\n+    owensBrowser.userProfilePage.preferences.setNotfsForEachNewPost();\n+    owensBrowser.userProfilePage.preferences.save();\n+  });\n+\n+  it(\"Owen returns to his topic\", () => {\n+    owensBrowser.go(owensTopicUrl);\n+  });\n+\n+  it(\"... posts a 2nd reply\", () => {\n+    owensBrowser.complex.replyToOrigPost(owensReplyTwo);\n+  });\n+\n+  it(\"Now also Michael get notified\", () => {\n+    server.waitUntilLastEmailMatches(siteId, michael.emailAddress, [owensReplyTwo], browser);\n+  });\n+\n+  it(\"... and Maja\", () => {\n+    server.waitUntilLastEmailMatches(siteId, maja.emailAddress, [owensReplyTwo], browser);\n+  });\n+\n+  it(\"... num emails sent is correct\", () => {\n+    assert.equal(server.countLastEmailsSentTo(siteId, maja.emailAddress), 3);\n+    assert.equal(server.countLastEmailsSentTo(siteId, michael.emailAddress), 2);\n+    assert.equal(server.countLastEmailsSentTo(siteId, maria.emailAddress), 0);\n+  });\n+\n+\n+  // ----- Individual's New-Topics only overrides All Member's Every Post\n+\n+\n+  it(\"Maja changes her prefs, to new topics only\", () => {\n+    majasBrowser.userProfilePage.preferences.setNotfsForEachNewTopic();\n+    majasBrowser.userProfilePage.preferences.save();\n+  });\n+\n+\n+  it(\"Owen posts a 2nd topic\", () => {\n+    owensBrowser.go('/');\n+    owensBrowser.complex.createAndSaveTopic({ title: owensTopicTitleTwo, body: owensTopicBodyTwo });\n+  });\n+\n+  it(\"Again, Maja and Michael get notified\", () => {\n+    const titleBody = [owensTopicTitleTwo, owensTopicBodyTwo];\n+    server.waitUntilLastEmailMatches(siteId, maja.emailAddress, titleBody, browser);\n+    server.waitUntilLastEmailMatches(siteId, michael.emailAddress, titleBody, browser);\n+  });\n+\n+  it(\"... num emails sent is correct\", () => {\n+    assert.equal(server.countLastEmailsSentTo(siteId, maja.emailAddress), 4);\n+    assert.equal(server.countLastEmailsSentTo(siteId, michael.emailAddress), 3);\n+    assert.equal(server.countLastEmailsSentTo(siteId, maria.emailAddress), 0);\n+  });\n+\n+\n+  it(\"Owen posts a reply, in the 2nd topic\", () => {\n+    owensBrowser.complex.replyToOrigPost(owensReplyThree);\n+  });\n+\n+  it(\"Michael gets notified (because the All Members group gets notfd about every post)\", () => {\n+    server.waitUntilLastEmailMatches(siteId, michael.emailAddress, [owensReplyThree], browser);\n+  });\n+\n+  it(\"... once, exactly\", () => {\n+    assert.equal(server.countLastEmailsSentTo(siteId, michael.emailAddress), 4);\n+  });\n+\n+  it(\"... but not Maria or Maja (they've overridden the group prefs)\", () => {\n+    assert.equal(server.countLastEmailsSentTo(siteId, maja.emailAddress), 4);\n+    assert.equal(server.countLastEmailsSentTo(siteId, maria.emailAddress), 0);\n+  });\n+\n+});\n+"
    }
  ]
}
