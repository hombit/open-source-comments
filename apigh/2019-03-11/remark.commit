{
  "sha": "034101fb648ea7d731fe37f3fce452e5c202fa2c",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOjAzNDEwMWZiNjQ4ZWE3ZDczMWZlMzdmM2ZjZTQ1MmU1YzIwMmZhMmM=",
  "commit": {
    "author": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-03-10T20:42:52Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2019-03-10T20:42:52Z"
    },
    "message": "Merge pull request #286 from umputun/mod\n\nswitch to go mod",
    "tree": {
      "sha": "3725b66235ed088bfc8a4f4979b8e71c45bac3f0",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/3725b66235ed088bfc8a4f4979b8e71c45bac3f0"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/034101fb648ea7d731fe37f3fce452e5c202fa2c",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJchXbMCRBK7hj4Ov3rIwAAdHIIAE0TV6sOPrP7c1BAcsmfTqBM\n0kPFKfckzd5PIrod70YqBS8dFmyebXMgAFkyM4CIKEthSCsHQRyuLN0XqZ1Si6WS\nSf6nVkcf9CtO81HjQ1LyjI7Eq4RXp2DIn/072Nu9eefEmnS82/i2eE/J8bFUmWJh\nQ6Y5eDytFwbIo25GscHVtDI4AjaS6sa7GHjoZyOj0OyiRFCrbVTFGCz4JkLaZx6U\n76ID75qjM6agPaxiFW/RWhBdpv60wlkGO+JW5xUWoo2NXAc1o2eM5KeHCvyLcYEJ\n3C8Q8/uAlQcBY7FCl544jwdoD+z5duVEvxTY3w+kZ5eNyTx5Mpww0+qbuPGCOhU=\n=nfSo\n-----END PGP SIGNATURE-----\n",
      "payload": "tree 3725b66235ed088bfc8a4f4979b8e71c45bac3f0\nparent d37ce1a91218f86b05d9641dd17e6ec29bc67930\nparent 1561dc2fdadf4d0b479ec5c693c9f004efb6dabb\nauthor Umputun <umputun@gmail.com> 1552250572 -0500\ncommitter GitHub <noreply@github.com> 1552250572 -0500\n\nMerge pull request #286 from umputun/mod\n\nswitch to go mod"
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/034101fb648ea7d731fe37f3fce452e5c202fa2c",
  "html_url": "https://github.com/umputun/remark/commit/034101fb648ea7d731fe37f3fce452e5c202fa2c",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/034101fb648ea7d731fe37f3fce452e5c202fa2c/comments",
  "author": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "url": "https://api.github.com/repos/umputun/remark/commits/d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "html_url": "https://github.com/umputun/remark/commit/d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "1561dc2fdadf4d0b479ec5c693c9f004efb6dabb",
      "url": "https://api.github.com/repos/umputun/remark/commits/1561dc2fdadf4d0b479ec5c693c9f004efb6dabb",
      "html_url": "https://github.com/umputun/remark/commit/1561dc2fdadf4d0b479ec5c693c9f004efb6dabb"
    }
  ],
  "stats": {
    "total": 113680,
    "additions": 92179,
    "deletions": 21501
  },
  "files": [
    {
      "sha": "9e8729e39a97e6fb981ae1dc2db70534acd7da08",
      "filename": "Dockerfile",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/Dockerfile",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/Dockerfile",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/Dockerfile?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -21,28 +21,28 @@ ARG DRONE_PULL_REQUEST\n ARG SKIP_BACKEND_TEST\n ARG MONGO_TEST\n \n-WORKDIR /go/src/github.com/umputun/remark/backend\n-ADD backend /go/src/github.com/umputun/remark/backend\n-ADD .git /go/src/github.com/umputun/remark/.git\n+ADD backend /build/backend\n+ADD .git /build/.git\n+WORKDIR /build/backend\n \n # run tests\n RUN \\\n     if [ -f .mongo ] ; then export MONGO_TEST=$(cat .mongo) ; fi && \\\n     cd app && \\\n-    if [ -z \"$SKIP_BACKEND_TEST\" ] ; then go test -covermode=count -coverprofile=/profile.cov ./... ; \\\n+    if [ -z \"$SKIP_BACKEND_TEST\" ] ; then go test -mod=vendor -covermode=count -coverprofile=/profile.cov ./... ; \\\n     else echo \"skip backend test\" ; fi\n \n RUN echo \"mongo=${MONGO_TEST}\" >> /etc/hosts\n \n # linters\n RUN if [ -z \"$SKIP_BACKEND_TEST\" ] ; then \\\n     if [ -f .mongo ] ; then export MONGO_TEST=$(cat .mongo) ; fi && \\\n-    gometalinter --disable-all --deadline=300s --vendor --enable=vet --enable=vetshadow --enable=golint \\\n-    --enable=staticcheck --enable=ineffassign --enable=errcheck --enable=unconvert \\\n-    --enable=deadcode  --enable=gosimple --exclude=test --exclude=mock --exclude=vendor ./... ; \\\n+    golangci-lint run --out-format=tab --disable-all --tests=false --enable=unconvert \\\n+    --enable=megacheck --enable=structcheck --enable=gas --enable=gocyclo --enable=dupl --enable=misspell \\\n+    --enable=unparam --enable=varcheck --enable=deadcode --enable=typecheck \\\n+    --enable=ineffassign --enable=varcheck ./... ; \\\n     else echo \"skip backend linters\" ; fi\n \n-\n # submit coverage to coverals if COVERALLS_TOKEN in env\n RUN if [ -z \"$COVERALLS_TOKEN\" ] ; then \\\n     echo \"coverall not enabled\" ; \\\n@@ -90,7 +90,7 @@ ADD backend/scripts/restore.sh /usr/local/bin/restore\n ADD backend/scripts/import.sh /usr/local/bin/import\n RUN chmod +x /entrypoint.sh /usr/local/bin/backup /usr/local/bin/restore /usr/local/bin/import\n \n-COPY --from=build-backend /go/src/github.com/umputun/remark/backend/remark42 /srv/remark42\n+COPY --from=build-backend /build/backend/remark42 /srv/remark42\n COPY --from=build-frontend /srv/web/public/ /srv/web\n RUN chown -R app:app /srv\n RUN ln -s /srv/remark42 /usr/bin/remark42"
    },
    {
      "sha": "c6ba2956b1467f19f66d8473261204fc842ef15b",
      "filename": "backend/Gopkg.lock",
      "status": "removed",
      "additions": 0,
      "deletions": 447,
      "changes": 447,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/Gopkg.lock",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/Gopkg.lock",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/Gopkg.lock?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "patch": "@@ -1,447 +0,0 @@\n-# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n-\n-\n-[[projects]]\n-  digest = \"1:180876db3ec295bb9f0babec5ca926fe9f2036b747b7c5bfcd13b333023e7cfd\"\n-  name = \"cloud.google.com/go\"\n-  packages = [\"compute/metadata\"]\n-  pruneopts = \"UT\"\n-  revision = \"767c40d6a2e058483c25fa193e963a22da17236d\"\n-  version = \"v0.18.0\"\n-\n-[[projects]]\n-  digest = \"1:bff7b2530f02b143623e260c11df5cbf34e0faeaca6aa001a8be31f333518ca9\"\n-  name = \"github.com/PuerkitoBio/goquery\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"a86ea073017a6beddef78c8659e7224e8ca634b0\"\n-  version = \"v1.4.0\"\n-\n-[[projects]]\n-  digest = \"1:66b3310cf22cdc96c35ef84ede4f7b9b370971c4025f394c89a2638729653b11\"\n-  name = \"github.com/andybalholm/cascadia\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"901648c87902174f774fac311d7f176f8647bdaa\"\n-  version = \"v1.0.0\"\n-\n-[[projects]]\n-  digest = \"1:c28625428387b63dd7154eb857f51e700465cfbf7c06f619e71f2da33cefe47e\"\n-  name = \"github.com/coreos/bbolt\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"583e8937c61f1af6513608ccc75c97b6abdf4ff9\"\n-  version = \"v1.3.0\"\n-\n-[[projects]]\n-  digest = \"1:a2c1d0e43bd3baaa071d1b9ed72c27d78169b2b269f71c105ac4ba34b1be4a39\"\n-  name = \"github.com/davecgh/go-spew\"\n-  packages = [\"spew\"]\n-  pruneopts = \"UT\"\n-  revision = \"346938d642f2ec3594ed81d874461961cd0faa76\"\n-  version = \"v1.1.0\"\n-\n-[[projects]]\n-  digest = \"1:76dc72490af7174349349838f2fe118996381b31ea83243812a97e5a0fd5ed55\"\n-  name = \"github.com/dgrijalva/jwt-go\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"06ea1031745cb8b3dab3f6a236daf2b0aa468b7e\"\n-  version = \"v3.2.0\"\n-\n-[[projects]]\n-  digest = \"1:82c6357bc57f8417f993d490f6c07a9f0b5682ac68b1a64b93a189dece7c5bf5\"\n-  name = \"github.com/didip/tollbooth\"\n-  packages = [\n-    \".\",\n-    \"errors\",\n-    \"libstring\",\n-    \"limiter\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"c95eaa3ddc98f635a91e218b48727fb2e06613ea\"\n-  version = \"v4.0.0\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:60fb125752a234a0a43bfc281bfdd9726fd1071a13f66bb35ec4b8e7ed1ef642\"\n-  name = \"github.com/didip/tollbooth_chi\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"6ab5f3083f3d925e1944d58cdaebf43bbbff9238\"\n-\n-[[projects]]\n-  digest = \"1:4b08116de0de75c041bb341686f0b139930f26cb84dfdf7641d435548114181d\"\n-  name = \"github.com/globalsign/mgo\"\n-  packages = [\n-    \".\",\n-    \"bson\",\n-    \"internal/json\",\n-    \"internal/sasl\",\n-    \"internal/scram\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"113d3961e7311526535a1ef7042196563d442761\"\n-  version = \"r2018.06.15\"\n-\n-[[projects]]\n-  digest = \"1:4eda9f7bf70f5145b3b9ed3f18ac93e9b1a0e38906eb69e526380c34861e2b07\"\n-  name = \"github.com/go-chi/chi\"\n-  packages = [\n-    \".\",\n-    \"middleware\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"e83ac2304db3c50cf03d96a2fcd39009d458bc35\"\n-  version = \"v3.3.2\"\n-\n-[[projects]]\n-  digest = \"1:dfa416a1bb8139f30832543340f972f65c0db9932034cb6a1b42c5ac615a3fb8\"\n-  name = \"github.com/go-chi/cors\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"dba6525398619dead495962a916728e7ee2ca322\"\n-  version = \"v1.0.0\"\n-\n-[[projects]]\n-  digest = \"1:75f324f9a6b76bca2fdd087ba169de30bc28a95a7139a6cefd5a9ac7582f6dab\"\n-  name = \"github.com/go-chi/render\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"9f855fadd4b8cde7773f9ef51f6b2705af239519\"\n-  version = \"v1.0.0\"\n-\n-[[projects]]\n-  digest = \"1:5531b51e68782803aa0bb987611e6c5eff939b5dc32fe671864f52e44766bf08\"\n-  name = \"github.com/go-pkgz/auth\"\n-  packages = [\n-    \".\",\n-    \"avatar\",\n-    \"logger\",\n-    \"middleware\",\n-    \"provider\",\n-    \"token\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"09b02500e01e25ac05182a6dc1b80ce1b0a7fd53\"\n-  version = \"v0.4.2\"\n-\n-[[projects]]\n-  digest = \"1:c4cb8b521f8e55dd02e1ed0952953adb35dbcc8eca8aeac9d707abc7ed625843\"\n-  name = \"github.com/go-pkgz/lcw\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"4f4492679c5c96714bc4b25d195036534bb01f72\"\n-  version = \"v0.2.0\"\n-\n-[[projects]]\n-  digest = \"1:6734b6a2ee0f6ccf35d8f3f72ce8c1e4f11e7060b284443502668c0805ff6aa2\"\n-  name = \"github.com/go-pkgz/lgr\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"6e5c31cef8b3f015033c6857e3368a08f97fa679\"\n-  version = \"v0.4.0\"\n-\n-[[projects]]\n-  digest = \"1:62aeed92576ea10c25389334254f957594b4b5ae8ff71a53d3aa9df5dc6961eb\"\n-  name = \"github.com/go-pkgz/mongo\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"b39a3946e96d28d96eb54d7a8400d80134302f69\"\n-  version = \"v1.1.2\"\n-\n-[[projects]]\n-  digest = \"1:35cb9b5c59734ea9bc47166aabc7d7136139ed8fe39f084fbc29afbbe3ae9213\"\n-  name = \"github.com/go-pkgz/repeater\"\n-  packages = [\n-    \".\",\n-    \"strategy\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"661f2868dc41260f912f400aed01c14476659ff2\"\n-  version = \"v1.1.1\"\n-\n-[[projects]]\n-  digest = \"1:74e7f0d5cf9c383695eabb20764c189c4ac898d89883ab31732d838874ac0998\"\n-  name = \"github.com/go-pkgz/rest\"\n-  packages = [\n-    \".\",\n-    \"cache\",\n-    \"logger\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"f726ac4d98016b5009883c2d3c20a9c8ce873ee1\"\n-  version = \"v1.4.0\"\n-\n-[[projects]]\n-  digest = \"1:92b44856ee15e8a98b91d751a60b512017e0ba227d1ed9d2c02ad13d67062ff8\"\n-  name = \"github.com/go-pkgz/syncs\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"72b3cd427a3495479f72a3a06c8949e39485dfc0\"\n-  version = \"v1.1.0\"\n-\n-[[projects]]\n-  digest = \"1:ffc060c551980d37ee9e428ef528ee2813137249ccebb0bfc412ef83071cac91\"\n-  name = \"github.com/golang/protobuf\"\n-  packages = [\"proto\"]\n-  pruneopts = \"UT\"\n-  revision = \"925541529c1fa6821df4e44ce2723319eb2be768\"\n-  version = \"v1.0.0\"\n-\n-[[projects]]\n-  digest = \"1:8f8811f9be822914c3a25c6a071e93beb4c805d7b026cbf298bc577bc1cc945b\"\n-  name = \"github.com/google/uuid\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"064e2069ce9c359c118179501254f67d7d37ba24\"\n-  version = \"0.2\"\n-\n-[[projects]]\n-  digest = \"1:2b418e5e28a68ccab236a22f344140cebab2d90c3a4a3f5593ecbb82cfe0e5ce\"\n-  name = \"github.com/gorilla/feeds\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"6edcbcd2d57fd0bbd7f39947a593ed0c06648388\"\n-  version = \"v1.1.0\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:07671f8997086ed115824d1974507d2b147d1e0463675ea5dbf3be89b1c2c563\"\n-  name = \"github.com/hashicorp/errwrap\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"7554cd9344cec97297fa6649b055a8c98c2a1e55\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:e5048c5da80697be2fcdecc944e29d2999e01fd7f48b643168443209779f3463\"\n-  name = \"github.com/hashicorp/go-multierror\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"b7773ae218740a7be65057fc60b366a49b538a44\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:cf296baa185baae04a9a7004efee8511d08e2f5f51d4cbe5375da89722d681db\"\n-  name = \"github.com/hashicorp/golang-lru\"\n-  packages = [\n-    \".\",\n-    \"simplelru\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"0fb14efe8c47ae851c0034ed7a448854d3d34cf3\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:3217800110ab50cd0e0784307be46b5344c0c103dbd15a16d0994ae4abdc96ab\"\n-  name = \"github.com/jessevdk/go-flags\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"1c38ed7ad0cc3d9e66649ac398c30e45f395c4eb\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:e83a8cf54ecc5c4efdbc88aa914578773d4d6897470b698ae315b5734081e8ed\"\n-  name = \"github.com/microcosm-cc/bluemonday\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"542fd4642604d0d0c26112396ce5b1a9d01eee0b\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:ea014b8bb16b0decc3393baeafc3b19815bcaf92329fe643eef5c0aa89bd3291\"\n-  name = \"github.com/nullrocks/identicon\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"7875f45b0022edded6377e40639d8aa620193a62\"\n-\n-[[projects]]\n-  digest = \"1:808cdddf087fb64baeae67b8dfaee2069034d9704923a3cb8bd96a995421a625\"\n-  name = \"github.com/patrickmn/go-cache\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"a3647f8e31d79543b2d0f0ae2fe5c379d72cedc0\"\n-  version = \"v2.1.0\"\n-\n-[[projects]]\n-  digest = \"1:40e195917a951a8bf867cd05de2a46aaf1806c50cf92eebf4c16f78cd196f747\"\n-  name = \"github.com/pkg/errors\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"645ef00459ed84a119197bfb8d8205042c6df63d\"\n-  version = \"v0.8.0\"\n-\n-[[projects]]\n-  digest = \"1:0028cb19b2e4c3112225cd871870f2d9cf49b9b4276531f03438a88e94be86fe\"\n-  name = \"github.com/pmezard/go-difflib\"\n-  packages = [\"difflib\"]\n-  pruneopts = \"UT\"\n-  revision = \"792786c7400a136282c1664665ae0a8db921c6c2\"\n-  version = \"v1.0.0\"\n-\n-[[projects]]\n-  digest = \"1:bc91590d3e20673d5e33267fc140e7dadddde0b84f2e9030547ba86859d2d13e\"\n-  name = \"github.com/rakyll/statik\"\n-  packages = [\"fs\"]\n-  pruneopts = \"UT\"\n-  revision = \"19b88da8fc15428620782ba18f68423130e7ac7d\"\n-  version = \"v0.1.3\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:def689e73e9252f6f7fe66834a76751a41b767e03daab299e607e7226c58a855\"\n-  name = \"github.com/shurcooL/sanitized_anchor_name\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"86672fcb3f950f35f2e675df2240550f2a50762f\"\n-\n-[[projects]]\n-  digest = \"1:7e8d267900c7fa7f35129a2a37596e38ed0f11ca746d6d9ba727980ee138f9f6\"\n-  name = \"github.com/stretchr/testify\"\n-  packages = [\n-    \"assert\",\n-    \"require\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"12b6f73e6084dad08a7c6e575284b177ecafbc71\"\n-  version = \"v1.2.1\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:674a2405f77863f4f362e3e45078fd9caa647dc1c0e8b022e3b9dc1ae89fbc8f\"\n-  name = \"golang.org/x/crypto\"\n-  packages = [\n-    \"acme\",\n-    \"acme/autocert\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"4d3f4d9ffa16a13f451c3b2999e9c49e9750bf06\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:b34062e39d8f3172fdd0c5c22ca1a3badeb2ddde295a997b0b63441e96d916f7\"\n-  name = \"golang.org/x/image\"\n-  packages = [\n-    \"draw\",\n-    \"math/f64\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"af66defab954cb421ca110193eed9477c8541e2a\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:ac7eaa5f1179480f517d32831225215cc20940152d66be29f3d5204ea15d425f\"\n-  name = \"golang.org/x/net\"\n-  packages = [\n-    \"context\",\n-    \"context/ctxhttp\",\n-    \"html\",\n-    \"html/atom\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"f5dfe339be1d06f81b22525fe34671ee7d2c8904\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:ccb0526e2eb5d454a25a536634fade769664eaa93ad2e4cd4107967bbc01b4e8\"\n-  name = \"golang.org/x/oauth2\"\n-  packages = [\n-    \".\",\n-    \"facebook\",\n-    \"github\",\n-    \"google\",\n-    \"internal\",\n-    \"jws\",\n-    \"jwt\",\n-    \"yandex\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"543e37812f10c46c622c9575afd7ad22f22a12ba\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:ba7d5e85e8b4f084fae02a1a9d7462980e889d1eb689c747507b30a30b8bfa67\"\n-  name = \"golang.org/x/sys\"\n-  packages = [\"unix\"]\n-  pruneopts = \"UT\"\n-  revision = \"37707fdb30a5b38865cfb95e5aab41707daec7fd\"\n-\n-[[projects]]\n-  branch = \"master\"\n-  digest = \"1:51a479a09b7ed06b7be5a854e27fcc328718ae0e5ad159f9ddeef12d0326c2e7\"\n-  name = \"golang.org/x/time\"\n-  packages = [\"rate\"]\n-  pruneopts = \"UT\"\n-  revision = \"6dc17368e09b0e8634d71cac8168d853e869a0c7\"\n-\n-[[projects]]\n-  digest = \"1:a48f97fb737d5d61cf13e81cfef040942d217d086766b823757d39d4f6a4c547\"\n-  name = \"google.golang.org/appengine\"\n-  packages = [\n-    \".\",\n-    \"internal\",\n-    \"internal/app_identity\",\n-    \"internal/base\",\n-    \"internal/datastore\",\n-    \"internal/log\",\n-    \"internal/modules\",\n-    \"internal/remote_api\",\n-    \"internal/urlfetch\",\n-    \"urlfetch\",\n-  ]\n-  pruneopts = \"UT\"\n-  revision = \"150dc57a1b433e64154302bdc40b6bb8aefa313a\"\n-  version = \"v1.0.0\"\n-\n-[[projects]]\n-  digest = \"1:39c2113f3a89585666e6f973650cff186b2d06deb4aa202c88addb87b0a201db\"\n-  name = \"gopkg.in/russross/blackfriday.v2\"\n-  packages = [\".\"]\n-  pruneopts = \"UT\"\n-  revision = \"cadec560ec52d93835bf2f15bd794700d3a2473b\"\n-  version = \"v2.0.0\"\n-\n-[solve-meta]\n-  analyzer-name = \"dep\"\n-  analyzer-version = 1\n-  input-imports = [\n-    \"github.com/PuerkitoBio/goquery\",\n-    \"github.com/coreos/bbolt\",\n-    \"github.com/dgrijalva/jwt-go\",\n-    \"github.com/didip/tollbooth\",\n-    \"github.com/didip/tollbooth_chi\",\n-    \"github.com/globalsign/mgo\",\n-    \"github.com/globalsign/mgo/bson\",\n-    \"github.com/go-chi/chi\",\n-    \"github.com/go-chi/chi/middleware\",\n-    \"github.com/go-chi/cors\",\n-    \"github.com/go-chi/render\",\n-    \"github.com/go-pkgz/auth\",\n-    \"github.com/go-pkgz/auth/avatar\",\n-    \"github.com/go-pkgz/auth/provider\",\n-    \"github.com/go-pkgz/auth/token\",\n-    \"github.com/go-pkgz/lcw\",\n-    \"github.com/go-pkgz/lgr\",\n-    \"github.com/go-pkgz/mongo\",\n-    \"github.com/go-pkgz/repeater\",\n-    \"github.com/go-pkgz/rest\",\n-    \"github.com/go-pkgz/rest/cache\",\n-    \"github.com/go-pkgz/rest/logger\",\n-    \"github.com/go-pkgz/syncs\",\n-    \"github.com/google/uuid\",\n-    \"github.com/gorilla/feeds\",\n-    \"github.com/hashicorp/go-multierror\",\n-    \"github.com/jessevdk/go-flags\",\n-    \"github.com/microcosm-cc/bluemonday\",\n-    \"github.com/patrickmn/go-cache\",\n-    \"github.com/pkg/errors\",\n-    \"github.com/rakyll/statik/fs\",\n-    \"github.com/stretchr/testify/assert\",\n-    \"github.com/stretchr/testify/require\",\n-    \"golang.org/x/crypto/acme/autocert\",\n-    \"golang.org/x/net/html\",\n-    \"gopkg.in/russross/blackfriday.v2\",\n-  ]\n-  solver-name = \"gps-cdcl\"\n-  solver-version = 1"
    },
    {
      "sha": "d6e93dbd308e18074ca23a25165465c9c46d20bf",
      "filename": "backend/Gopkg.toml",
      "status": "removed",
      "additions": 0,
      "deletions": 44,
      "changes": 44,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/Gopkg.toml",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/Gopkg.toml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/Gopkg.toml?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "patch": "@@ -1,44 +0,0 @@\n-required = [\"github.com/patrickmn/go-cache\"]\n-\n-[[constraint]]\n-  name = \"github.com/go-chi/chi\"\n-  version = \"3.0.0\"\n-\n-[[constraint]]\n-  name = \"github.com/go-chi/render\"\n-  version = \"1.0.0\"\n-\n-[[constraint]]\n-  name = \"github.com/google/uuid\"\n-  version = \"0.2.0\"\n-\n-[[constraint]]\n-  branch = \"master\"\n-  name = \"github.com/microcosm-cc/bluemonday\"\n-\n-[[constraint]]\n-  name = \"gopkg.in/russross/blackfriday.v2\"\n-  version = \"2.0.0\"\n-\n-[[constraint]]\n-  name = \"github.com/patrickmn/go-cache\"\n-  version = \"2.1.0\"\n-\n-[[constraint]]\n-  branch = \"master\"\n-  name = \"github.com/jessevdk/go-flags\"\n-\n-[[constraint]]\n-  name = \"github.com/globalsign/mgo\"\n-  version = \"r2018.06.15\"\n-\n-[prune]\n-  go-tests = true\n-  unused-packages = true\n-\n-\n-\n-\n-[[constraint]]\n-  branch = \"master\"\n-  name = \"golang.org/x/crypto\""
    },
    {
      "sha": "c7b3e3e52488d946afa42aa890b4121e0c1c0fee",
      "filename": "backend/app/cmd/cleanup.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/app/cmd/cleanup.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/app/cmd/cleanup.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/cmd/cleanup.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -131,7 +131,7 @@ func (cc *CleanupCommand) postsInRange(fromS, toS string) ([]store.PostInfo, err\n // get all posts via GET /list?site=siteID&limit=50&skip=10\n func (cc *CleanupCommand) listPosts() ([]store.PostInfo, error) {\n \tlistURL := fmt.Sprintf(\"%s/api/v1/list?site=%s&limit=10000\", cc.RemarkURL, cc.Site)\n-\tr, err := http.Get(listURL)\n+\tr, err := http.Get(listURL) //nolint\n \tif err != nil {\n \t\treturn nil, errors.Wrapf(err, \"get request failed for list of posts, site %s\", cc.Site)\n \t}\n@@ -158,7 +158,7 @@ func (cc *CleanupCommand) listComments(postURL string) ([]store.Comment, error)\n \n \t// handle 429 error from limiter\n \tfor {\n-\t\tr, err = http.Get(commentsURL)\n+\t\tr, err = http.Get(commentsURL) //nolint\n \t\tif err != nil {\n \t\t\treturn nil, errors.Wrapf(err, \"get request failed for comments, %s\", postURL)\n \t\t}"
    },
    {
      "sha": "40c8e99e36cfb80d3117563141f8de3987b02f88",
      "filename": "backend/app/rest/api/rest_public.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/app/rest/api/rest_public.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/app/rest/api/rest_public.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest_public.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,7 +1,7 @@\n package api\n \n import (\n-\t\"crypto/sha1\"\n+\t\"crypto/sha1\" //nolint\n \t\"encoding/base64\"\n \t\"net/http\"\n \t\"strconv\"\n@@ -274,7 +274,7 @@ func (s *Rest) countMultiCtrl(w http.ResponseWriter, r *http.Request) {\n \n \t// key could be long for multiple posts, make it sha1\n \tk := URLKey(r) + strings.Join(posts, \",\")\n-\thasher := sha1.New()\n+\thasher := sha1.New() //nolint\n \tif _, err := hasher.Write([]byte(k)); err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusInternalServerError, err, \"can't make sha1 for list of urls\", rest.ErrInternal)\n \t\treturn"
    },
    {
      "sha": "462cd28aba8f5c83795f3a29f2d83b8a6e39a69e",
      "filename": "backend/app/store/user.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/app/store/user.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/app/store/user.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/user.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -2,7 +2,7 @@ package store\n \n import (\n \t\"crypto/hmac\"\n-\t\"crypto/sha1\"\n+\t\"crypto/sha1\" //nolint\n \t\"encoding/hex\"\n \t\"fmt\"\n \t\"hash\"\n@@ -41,7 +41,7 @@ func HashValue(val string, secret string) string {\n // EncodeID hashes id to sha1. The function intentionally left outside of User struct because in some cases\n // we need hashing for parts of id, in some others hashing for non-User values.\n func EncodeID(id string) string {\n-\treturn hashWithFallback(sha1.New(), id)\n+\treturn hashWithFallback(sha1.New(), id) //nolint\n }\n \n // hashWithFallback tries to has val with hash.Hash and fallback to crc if needed"
    },
    {
      "sha": "afe3534fa02481ab840e16eb83197f16cfc6a2b4",
      "filename": "backend/go.mod",
      "status": "added",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.mod?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -0,0 +1,39 @@\n+module github.com/umputun/remark/backend\n+\n+go 1.12\n+\n+require (\n+\tgithub.com/PuerkitoBio/goquery v1.4.0\n+\tgithub.com/andybalholm/cascadia v1.0.0 // indirect\n+\tgithub.com/coreos/bbolt v1.3.0\n+\tgithub.com/dgrijalva/jwt-go v3.2.0+incompatible\n+\tgithub.com/didip/tollbooth v4.0.0+incompatible\n+\tgithub.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d\n+\tgithub.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8\n+\tgithub.com/go-chi/chi v3.3.2+incompatible\n+\tgithub.com/go-chi/cors v1.0.0\n+\tgithub.com/go-chi/render v1.0.0\n+\tgithub.com/go-pkgz/auth v0.4.2\n+\tgithub.com/go-pkgz/lcw v0.2.0\n+\tgithub.com/go-pkgz/lgr v0.4.0\n+\tgithub.com/go-pkgz/mongo v1.1.2\n+\tgithub.com/go-pkgz/repeater v1.1.1\n+\tgithub.com/go-pkgz/rest v1.4.0\n+\tgithub.com/go-pkgz/syncs v1.1.0\n+\tgithub.com/google/uuid v0.0.0-20161128191214-064e2069ce9c\n+\tgithub.com/gorilla/feeds v1.1.0\n+\tgithub.com/hashicorp/errwrap v0.0.0-20141028054710-7554cd9344ce // indirect\n+\tgithub.com/hashicorp/go-multierror v0.0.0-20171204182908-b7773ae21874\n+\tgithub.com/hashicorp/golang-lru v0.5.1 // indirect\n+\tgithub.com/jessevdk/go-flags v0.0.0-20180331124232-1c38ed7ad0cc\n+\tgithub.com/microcosm-cc/bluemonday v0.0.0-20171222152607-542fd4642604\n+\tgithub.com/patrickmn/go-cache v2.1.0+incompatible\n+\tgithub.com/pkg/errors v0.8.1\n+\tgithub.com/rakyll/statik v0.1.3\n+\tgithub.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95 // indirect\n+\tgithub.com/stretchr/testify v1.3.0\n+\tgolang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16\n+\tgolang.org/x/net v0.0.0-20190107210223-45ffb0cd1ba0\n+\tgolang.org/x/time v0.0.0-20170927054726-6dc17368e09b // indirect\n+\tgopkg.in/russross/blackfriday.v2 v2.0.0\n+)"
    },
    {
      "sha": "8bf05b8204f48b02b6e24e5ab76e217e8da00bfc",
      "filename": "backend/go.sum",
      "status": "added",
      "additions": 109,
      "deletions": 0,
      "changes": 109,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.sum?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -0,0 +1,109 @@\n+cloud.google.com/go v0.34.0 h1:eOI3/cP2VTU6uZLDYAoic+eyzzB9YyGmJ7eIjl8rOPg=\n+cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\n+github.com/PuerkitoBio/goquery v1.4.0 h1:13fV4AYmaSopdNp8KWDUlLyU5INklBkYk0tsTfxRO2U=\n+github.com/PuerkitoBio/goquery v1.4.0/go.mod h1:T9ezsOHcCrDCgA8aF1Cqr3sSYbO/xgdy8/R/XiIMAhA=\n+github.com/andybalholm/cascadia v1.0.0 h1:hOCXnnZ5A+3eVDX8pvgl4kofXv2ELss0bKcqRySc45o=\n+github.com/andybalholm/cascadia v1.0.0/go.mod h1:GsXiBklL0woXo1j/WYWtSYYC4ouU9PqHO0sqidkEA4Y=\n+github.com/boltdb/bolt v1.3.1 h1:JQmyP4ZBrce+ZQu0dY660FMfatumYDLun9hBCUVIkF4=\n+github.com/boltdb/bolt v1.3.1/go.mod h1:clJnj/oiGkjum5o1McbSZDSLxVThjynRyGBgiAx27Ps=\n+github.com/coreos/bbolt v1.3.0 h1:HIgH5xUWXT914HCI671AxuTTqjj64UOFr7pHn48LUTI=\n+github.com/coreos/bbolt v1.3.0/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\n+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\n+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=\n+github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\n+github.com/didip/tollbooth v4.0.0+incompatible h1:ayQZYuF5QOxx3NdYRNuRVFLv9/2b64JtSUlewb+0TMo=\n+github.com/didip/tollbooth v4.0.0+incompatible/go.mod h1:A9b0665CE6l1KmzpDws2++elm/CsuWBMa5Jv4WY0PEY=\n+github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d h1:vs5Nf6IE0N/PwGJ8//zRed4gpCdcr99K2HzX7RuLOQ8=\n+github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d/go.mod h1:YWyIfq3y4ArRfWZ9XksmuusP+7Mad+T0iFZ0kv0XG/M=\n+github.com/globalsign/mgo v0.0.0-20180615134936-113d3961e731/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\n+github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8 h1:DujepqpGd1hyOd7aW59XpK7Qymp8iy83xq74fLr21is=\n+github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\n+github.com/go-chi/chi v3.3.2+incompatible h1:uQNcQN3NsV1j4ANsPh42P4ew4t6rnRbJb8frvpp31qQ=\n+github.com/go-chi/chi v3.3.2+incompatible/go.mod h1:eB3wogJHnLi3x/kFX2A+IbTBlXxmMeXJVKy9tTv1XzQ=\n+github.com/go-chi/cors v1.0.0 h1:e6x8k7uWbUwYs+aXDoiUzeQFT6l0cygBYyNhD7/1Tg0=\n+github.com/go-chi/cors v1.0.0/go.mod h1:K2Yje0VW/SJzxiyMYu6iPQYa7hMjQX2i/F491VChg1I=\n+github.com/go-chi/render v1.0.0 h1:cLJlkaTB4xfx5rWhtoB0BSXsXVJKWFqv08Y3cR1bZKA=\n+github.com/go-chi/render v1.0.0/go.mod h1:pq4Rr7HbnsdaeHagklXub+p6Wd16Af5l9koip1OvJns=\n+github.com/go-pkgz/auth v0.4.2 h1:WY3XzjUieUGxJSjXDU0rLrKt8RcPEaGdtLVRS7M56wU=\n+github.com/go-pkgz/auth v0.4.2/go.mod h1:CWtB8dHmOv+TfF3MUzKwk/YwTLepC2TaDL05A+pFVBM=\n+github.com/go-pkgz/lcw v0.2.0 h1:aFoKUG8q0YybId+ThVRQpDMjjuSG4hkLL1EA2xUtruc=\n+github.com/go-pkgz/lcw v0.2.0/go.mod h1:k+PY1CkCMTLXILtFoJOyK65Qqi9rkoTYunFH1vE/C0I=\n+github.com/go-pkgz/lgr v0.2.2/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n+github.com/go-pkgz/lgr v0.4.0 h1:s4490VXkaepbkMZBNZgr3rgfUg0G4nOLVa/Yp0hlwyc=\n+github.com/go-pkgz/lgr v0.4.0/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n+github.com/go-pkgz/mongo v1.0.0/go.mod h1:R9si/F2aJsjz4MUxhzuppIHY8yLV3YCeuCpgcI50cu4=\n+github.com/go-pkgz/mongo v1.1.2 h1:2Vqn3CWQJkkx4gxxDiQUitAW2FN/CH26lKHkipmpKcc=\n+github.com/go-pkgz/mongo v1.1.2/go.mod h1:0NkWnzpiUxoL5fYZuttCtJrpC67oNDidfYxcdPqHTf0=\n+github.com/go-pkgz/repeater v1.1.1 h1:9HVgXFJGjUQznPmaeuVDTPhgflzVlUyjCx2gmBYXeGI=\n+github.com/go-pkgz/repeater v1.1.1/go.mod h1:QfNR/a+xqjs+f9wSxWqOQlw9aQhmKlUaSwXCiZ+Ko2w=\n+github.com/go-pkgz/rest v1.2.0/go.mod h1:COazNj35u3RXAgQNBr6neR599tYP3URiOpsu9p0rOtk=\n+github.com/go-pkgz/rest v1.4.0 h1:xNkdMjEL2rNZSHouWjFTH22ncaZ77fopm34RN+eXAwk=\n+github.com/go-pkgz/rest v1.4.0/go.mod h1:COazNj35u3RXAgQNBr6neR599tYP3URiOpsu9p0rOtk=\n+github.com/go-pkgz/syncs v1.1.0 h1:k+dTyUZs1JHsYzo2tuUNrnW0OCwuGuS6ozfXHVspjSY=\n+github.com/go-pkgz/syncs v1.1.0/go.mod h1:bt9lxWRRJ9vOCMGc8Big8ttjYHLKP88ofj1y38UlaHE=\n+github.com/golang/protobuf v1.2.0 h1:P3YflyNX/ehuJFLhxviNdFxQPkGK5cDcApsge1SqnvM=\n+github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\n+github.com/google/uuid v0.0.0-20161128191214-064e2069ce9c h1:jWtZjFEUE/Bz0IeIhqCnyZ3HG6KRXSntXe4SjtuTH7c=\n+github.com/google/uuid v0.0.0-20161128191214-064e2069ce9c/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\n+github.com/gorilla/feeds v1.1.0 h1:pcgLJhbdYgaUESnj3AmXPcB7cS3vy63+jC/TI14AGXk=\n+github.com/gorilla/feeds v1.1.0/go.mod h1:Nk0jZrvPFZX1OBe5NPiddPw7CfwF6Q9eqzaBbaightA=\n+github.com/hashicorp/errwrap v0.0.0-20141028054710-7554cd9344ce h1:prjrVgOk2Yg6w+PflHoszQNLTUh4kaByUcEWM/9uin4=\n+github.com/hashicorp/errwrap v0.0.0-20141028054710-7554cd9344ce/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\n+github.com/hashicorp/go-multierror v0.0.0-20171204182908-b7773ae21874 h1:em+tTnzgU7N22woTBMcSJAOW7tRHAkK597W+MD/CpK8=\n+github.com/hashicorp/go-multierror v0.0.0-20171204182908-b7773ae21874/go.mod h1:JMRHfdO9jKNzS/+BTlxCjKNQHg/jZAft8U7LloJvN7I=\n+github.com/hashicorp/golang-lru v0.5.0 h1:CL2msUPvZTLb5O648aiLNJw3hnBxN2+1Jq8rCOH9wdo=\n+github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n+github.com/hashicorp/golang-lru v0.5.1 h1:0hERBMJE1eitiLkihrMvRVBYAkpHzc/J3QdDN+dAcgU=\n+github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n+github.com/jessevdk/go-flags v0.0.0-20180331124232-1c38ed7ad0cc h1:0L2sGkaj6MWuV1BfXsrLJ/+XA8RzKKVsYlLVXNkK1Lw=\n+github.com/jessevdk/go-flags v0.0.0-20180331124232-1c38ed7ad0cc/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\n+github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\n+github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\n+github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\n+github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\n+github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\n+github.com/microcosm-cc/bluemonday v0.0.0-20171222152607-542fd4642604 h1:BbG6VMVavjbhIsD7Hoscfz+wExp1hY+pmk+7Agc4J74=\n+github.com/microcosm-cc/bluemonday v0.0.0-20171222152607-542fd4642604/go.mod h1:hsXNsILzKxV+sX77C5b8FSuKF00vh2OMYv+xgHpAMF4=\n+github.com/nullrocks/identicon v0.0.0-20180626043057-7875f45b0022 h1:Ys0rDzh8s4UMlGaDa1UTA0sfKgvF0hQZzTYX8ktjiDc=\n+github.com/nullrocks/identicon v0.0.0-20180626043057-7875f45b0022/go.mod h1:x4NsS+uc7ecH/Cbm9xKQ6XzmJM57rWTkjywjfB2yQ18=\n+github.com/patrickmn/go-cache v2.1.0+incompatible h1:HRMgzkcYKYpi3C8ajMPV8OFXaaRUnok+kx1WdO15EQc=\n+github.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=\n+github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\n+github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n+github.com/rakyll/statik v0.1.3 h1:H/5HK3yNM7sDzOiMQtC2Q1N69hl+KxzomBBWus662LU=\n+github.com/rakyll/statik v0.1.3/go.mod h1:OEi9wJV/fMUAGx1eNjq75DKDsJVuEv1U0oYdX6GX8Zs=\n+github.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95 h1:/vdW8Cb7EXrkqWGufVMES1OH2sU9gKVb2n9/1y5NMBY=\n+github.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\n+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\n+github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\n+github.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\n+github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\n+golang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16 h1:y6ce7gCWtnH+m3dCjzQ1PCuwl28DDIc3VNnvY29DlIA=\n+golang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\n+golang.org/x/image v0.0.0-20181116024801-cd38e8056d9b h1:VHyIDlv3XkfCa5/a81uzaoDkHH4rr81Z62g+xlnO8uM=\n+golang.org/x/image v0.0.0-20181116024801-cd38e8056d9b/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=\n+golang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20190107210223-45ffb0cd1ba0 h1:1DW40AJQ7AP4nY6ORUGUdkpXyEC9W2GAXcOPaMZK0K8=\n+golang.org/x/net v0.0.0-20190107210223-45ffb0cd1ba0/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/oauth2 v0.0.0-20181203162652-d668ce993890 h1:uESlIz09WIHT2I+pasSXcpLYqYK8wHcdCetU3VuMBJE=\n+golang.org/x/oauth2 v0.0.0-20181203162652-d668ce993890/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\n+golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4 h1:YUO/7uOKsKeq9UokNS62b8FYywz3ker1l1vDZRCRefw=\n+golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sys v0.0.0-20190109145017-48ac38b7c8cb h1:1w588/yEchbPNpa9sEvOcMZYbWHedwJjg4VOAdDHWHk=\n+golang.org/x/sys v0.0.0-20190109145017-48ac38b7c8cb/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n+golang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\n+golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n+golang.org/x/time v0.0.0-20170927054726-6dc17368e09b h1:3X+R0qq1+64izd8es+EttB6qcY+JDlVmAhpRXl7gpzU=\n+golang.org/x/time v0.0.0-20170927054726-6dc17368e09b/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n+google.golang.org/appengine v1.4.0 h1:/wp5JvzpHIxhs/dumFmF7BXTf3Z+dd4uXta4kVyO508=\n+google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\n+gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\n+gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\n+gopkg.in/russross/blackfriday.v2 v2.0.0 h1:+FlnIV8DSQnT7NZ43hcVKcdJdzZoeCmJj4Ql8gq5keA=\n+gopkg.in/russross/blackfriday.v2 v2.0.0/go.mod h1:6sSBNz/GtOm/pJTuh5UmBK2ZHfmnxGbl2NZg1UliSOI="
    },
    {
      "sha": "3b3cbed98e9a9e0ab3052b98359d43a82a9c1c8c",
      "filename": "backend/vendor/cloud.google.com/go/CONTRIBUTORS",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/cloud.google.com/go/CONTRIBUTORS",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/cloud.google.com/go/CONTRIBUTORS",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/cloud.google.com/go/CONTRIBUTORS?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -22,6 +22,7 @@ David Symonds <dsymonds@golang.org>\n Filippo Valsorda <hi@filippo.io>\n Glenn Lewis <gmlewis@google.com>\n Ingo Oeser <nightlyone@googlemail.com>\n+James Hall <james.hall@shopify.com>\n Johan Euphrosine <proppy@google.com>\n Jonathan Amsterdam <jba@google.com>\n Kunpei Sakai <namusyaka@gmail.com>"
    },
    {
      "sha": "0d929a6192111b46a33242a1eada37a38caf2f25",
      "filename": "backend/vendor/cloud.google.com/go/compute/metadata/metadata.go",
      "status": "modified",
      "additions": 213,
      "deletions": 149,
      "changes": 362,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/cloud.google.com/go/compute/metadata/metadata.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/cloud.google.com/go/compute/metadata/metadata.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/cloud.google.com/go/compute/metadata/metadata.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 Google Inc. All Rights Reserved.\n+// Copyright 2014 Google LLC\n //\n // Licensed under the Apache License, Version 2.0 (the \"License\");\n // you may not use this file except in compliance with the License.\n@@ -20,6 +20,7 @@\n package metadata // import \"cloud.google.com/go/compute/metadata\"\n \n import (\n+\t\"context\"\n \t\"encoding/json\"\n \t\"fmt\"\n \t\"io/ioutil\"\n@@ -31,9 +32,6 @@ import (\n \t\"strings\"\n \t\"sync\"\n \t\"time\"\n-\n-\t\"golang.org/x/net/context\"\n-\t\"golang.org/x/net/context/ctxhttp\"\n )\n \n const (\n@@ -64,23 +62,23 @@ var (\n )\n \n var (\n-\tmetaClient = &http.Client{\n+\tdefaultClient = &Client{hc: &http.Client{\n \t\tTransport: &http.Transport{\n \t\t\tDial: (&net.Dialer{\n \t\t\t\tTimeout:   2 * time.Second,\n \t\t\t\tKeepAlive: 30 * time.Second,\n \t\t\t}).Dial,\n \t\t\tResponseHeaderTimeout: 2 * time.Second,\n \t\t},\n-\t}\n-\tsubscribeClient = &http.Client{\n+\t}}\n+\tsubscribeClient = &Client{hc: &http.Client{\n \t\tTransport: &http.Transport{\n \t\t\tDial: (&net.Dialer{\n \t\t\t\tTimeout:   2 * time.Second,\n \t\t\t\tKeepAlive: 30 * time.Second,\n \t\t\t}).Dial,\n \t\t},\n-\t}\n+\t}}\n )\n \n // NotDefinedError is returned when requested metadata is not defined.\n@@ -95,74 +93,16 @@ func (suffix NotDefinedError) Error() string {\n \treturn fmt.Sprintf(\"metadata: GCE metadata %q not defined\", string(suffix))\n }\n \n-// Get returns a value from the metadata service.\n-// The suffix is appended to \"http://${GCE_METADATA_HOST}/computeMetadata/v1/\".\n-//\n-// If the GCE_METADATA_HOST environment variable is not defined, a default of\n-// 169.254.169.254 will be used instead.\n-//\n-// If the requested metadata is not defined, the returned error will\n-// be of type NotDefinedError.\n-func Get(suffix string) (string, error) {\n-\tval, _, err := getETag(metaClient, suffix)\n-\treturn val, err\n-}\n-\n-// getETag returns a value from the metadata service as well as the associated\n-// ETag using the provided client. This func is otherwise equivalent to Get.\n-func getETag(client *http.Client, suffix string) (value, etag string, err error) {\n-\t// Using a fixed IP makes it very difficult to spoof the metadata service in\n-\t// a container, which is an important use-case for local testing of cloud\n-\t// deployments. To enable spoofing of the metadata service, the environment\n-\t// variable GCE_METADATA_HOST is first inspected to decide where metadata\n-\t// requests shall go.\n-\thost := os.Getenv(metadataHostEnv)\n-\tif host == \"\" {\n-\t\t// Using 169.254.169.254 instead of \"metadata\" here because Go\n-\t\t// binaries built with the \"netgo\" tag and without cgo won't\n-\t\t// know the search suffix for \"metadata\" is\n-\t\t// \".google.internal\", and this IP address is documented as\n-\t\t// being stable anyway.\n-\t\thost = metadataIP\n-\t}\n-\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n-\treq, _ := http.NewRequest(\"GET\", url, nil)\n-\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n-\treq.Header.Set(\"User-Agent\", userAgent)\n-\tres, err := client.Do(req)\n-\tif err != nil {\n-\t\treturn \"\", \"\", err\n-\t}\n-\tdefer res.Body.Close()\n-\tif res.StatusCode == http.StatusNotFound {\n-\t\treturn \"\", \"\", NotDefinedError(suffix)\n-\t}\n-\tif res.StatusCode != 200 {\n-\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n-\t}\n-\tall, err := ioutil.ReadAll(res.Body)\n-\tif err != nil {\n-\t\treturn \"\", \"\", err\n-\t}\n-\treturn string(all), res.Header.Get(\"Etag\"), nil\n-}\n-\n-func getTrimmed(suffix string) (s string, err error) {\n-\ts, err = Get(suffix)\n-\ts = strings.TrimSpace(s)\n-\treturn\n-}\n-\n-func (c *cachedValue) get() (v string, err error) {\n+func (c *cachedValue) get(cl *Client) (v string, err error) {\n \tdefer c.mu.Unlock()\n \tc.mu.Lock()\n \tif c.v != \"\" {\n \t\treturn c.v, nil\n \t}\n \tif c.trim {\n-\t\tv, err = getTrimmed(c.k)\n+\t\tv, err = cl.getTrimmed(c.k)\n \t} else {\n-\t\tv, err = Get(c.k)\n+\t\tv, err = cl.Get(c.k)\n \t}\n \tif err == nil {\n \t\tc.v = v\n@@ -201,7 +141,7 @@ func testOnGCE() bool {\n \tgo func() {\n \t\treq, _ := http.NewRequest(\"GET\", \"http://\"+metadataIP, nil)\n \t\treq.Header.Set(\"User-Agent\", userAgent)\n-\t\tres, err := ctxhttp.Do(ctx, metaClient, req)\n+\t\tres, err := defaultClient.hc.Do(req.WithContext(ctx))\n \t\tif err != nil {\n \t\t\tresc <- false\n \t\t\treturn\n@@ -266,78 +206,183 @@ func systemInfoSuggestsGCE() bool {\n \treturn name == \"Google\" || name == \"Google Compute Engine\"\n }\n \n-// Subscribe subscribes to a value from the metadata service.\n-// The suffix is appended to \"http://${GCE_METADATA_HOST}/computeMetadata/v1/\".\n-// The suffix may contain query parameters.\n-//\n-// Subscribe calls fn with the latest metadata value indicated by the provided\n-// suffix. If the metadata value is deleted, fn is called with the empty string\n-// and ok false. Subscribe blocks until fn returns a non-nil error or the value\n-// is deleted. Subscribe returns the error value returned from the last call to\n-// fn, which may be nil when ok == false.\n+// Subscribe calls Client.Subscribe on a client designed for subscribing (one with no\n+// ResponseHeaderTimeout).\n func Subscribe(suffix string, fn func(v string, ok bool) error) error {\n-\tconst failedSubscribeSleep = time.Second * 5\n+\treturn subscribeClient.Subscribe(suffix, fn)\n+}\n \n-\t// First check to see if the metadata value exists at all.\n-\tval, lastETag, err := getETag(subscribeClient, suffix)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n+// Get calls Client.Get on the default client.\n+func Get(suffix string) (string, error) { return defaultClient.Get(suffix) }\n \n-\tif err := fn(val, true); err != nil {\n-\t\treturn err\n+// ProjectID returns the current instance's project ID string.\n+func ProjectID() (string, error) { return defaultClient.ProjectID() }\n+\n+// NumericProjectID returns the current instance's numeric project ID.\n+func NumericProjectID() (string, error) { return defaultClient.NumericProjectID() }\n+\n+// InternalIP returns the instance's primary internal IP address.\n+func InternalIP() (string, error) { return defaultClient.InternalIP() }\n+\n+// ExternalIP returns the instance's primary external (public) IP address.\n+func ExternalIP() (string, error) { return defaultClient.ExternalIP() }\n+\n+// Hostname returns the instance's hostname. This will be of the form\n+// \"<instanceID>.c.<projID>.internal\".\n+func Hostname() (string, error) { return defaultClient.Hostname() }\n+\n+// InstanceTags returns the list of user-defined instance tags,\n+// assigned when initially creating a GCE instance.\n+func InstanceTags() ([]string, error) { return defaultClient.InstanceTags() }\n+\n+// InstanceID returns the current VM's numeric instance ID.\n+func InstanceID() (string, error) { return defaultClient.InstanceID() }\n+\n+// InstanceName returns the current VM's instance ID string.\n+func InstanceName() (string, error) { return defaultClient.InstanceName() }\n+\n+// Zone returns the current VM's zone, such as \"us-central1-b\".\n+func Zone() (string, error) { return defaultClient.Zone() }\n+\n+// InstanceAttributes calls Client.InstanceAttributes on the default client.\n+func InstanceAttributes() ([]string, error) { return defaultClient.InstanceAttributes() }\n+\n+// ProjectAttributes calls Client.ProjectAttributes on the default client.\n+func ProjectAttributes() ([]string, error) { return defaultClient.ProjectAttributes() }\n+\n+// InstanceAttributeValue calls Client.InstanceAttributeValue on the default client.\n+func InstanceAttributeValue(attr string) (string, error) {\n+\treturn defaultClient.InstanceAttributeValue(attr)\n+}\n+\n+// ProjectAttributeValue calls Client.ProjectAttributeValue on the default client.\n+func ProjectAttributeValue(attr string) (string, error) {\n+\treturn defaultClient.ProjectAttributeValue(attr)\n+}\n+\n+// Scopes calls Client.Scopes on the default client.\n+func Scopes(serviceAccount string) ([]string, error) { return defaultClient.Scopes(serviceAccount) }\n+\n+func strsContains(ss []string, s string) bool {\n+\tfor _, v := range ss {\n+\t\tif v == s {\n+\t\t\treturn true\n+\t\t}\n \t}\n+\treturn false\n+}\n \n-\tok := true\n-\tif strings.ContainsRune(suffix, '?') {\n-\t\tsuffix += \"&wait_for_change=true&last_etag=\"\n-\t} else {\n-\t\tsuffix += \"?wait_for_change=true&last_etag=\"\n+// A Client provides metadata.\n+type Client struct {\n+\thc *http.Client\n+}\n+\n+// NewClient returns a Client that can be used to fetch metadata. All HTTP requests\n+// will use the given http.Client instead of the default client.\n+func NewClient(c *http.Client) *Client {\n+\treturn &Client{hc: c}\n+}\n+\n+// getETag returns a value from the metadata service as well as the associated ETag.\n+// This func is otherwise equivalent to Get.\n+func (c *Client) getETag(suffix string) (value, etag string, err error) {\n+\t// Using a fixed IP makes it very difficult to spoof the metadata service in\n+\t// a container, which is an important use-case for local testing of cloud\n+\t// deployments. To enable spoofing of the metadata service, the environment\n+\t// variable GCE_METADATA_HOST is first inspected to decide where metadata\n+\t// requests shall go.\n+\thost := os.Getenv(metadataHostEnv)\n+\tif host == \"\" {\n+\t\t// Using 169.254.169.254 instead of \"metadata\" here because Go\n+\t\t// binaries built with the \"netgo\" tag and without cgo won't\n+\t\t// know the search suffix for \"metadata\" is\n+\t\t// \".google.internal\", and this IP address is documented as\n+\t\t// being stable anyway.\n+\t\thost = metadataIP\n \t}\n-\tfor {\n-\t\tval, etag, err := getETag(subscribeClient, suffix+url.QueryEscape(lastETag))\n-\t\tif err != nil {\n-\t\t\tif _, deleted := err.(NotDefinedError); !deleted {\n-\t\t\t\ttime.Sleep(failedSubscribeSleep)\n-\t\t\t\tcontinue // Retry on other errors.\n-\t\t\t}\n-\t\t\tok = false\n-\t\t}\n-\t\tlastETag = etag\n+\turl := \"http://\" + host + \"/computeMetadata/v1/\" + suffix\n+\treq, _ := http.NewRequest(\"GET\", url, nil)\n+\treq.Header.Set(\"Metadata-Flavor\", \"Google\")\n+\treq.Header.Set(\"User-Agent\", userAgent)\n+\tres, err := c.hc.Do(req)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n+\tdefer res.Body.Close()\n+\tif res.StatusCode == http.StatusNotFound {\n+\t\treturn \"\", \"\", NotDefinedError(suffix)\n+\t}\n+\tif res.StatusCode != 200 {\n+\t\treturn \"\", \"\", fmt.Errorf(\"status code %d trying to fetch %s\", res.StatusCode, url)\n+\t}\n+\tall, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n+\treturn string(all), res.Header.Get(\"Etag\"), nil\n+}\n \n-\t\tif err := fn(val, ok); err != nil || !ok {\n-\t\t\treturn err\n-\t\t}\n+// Get returns a value from the metadata service.\n+// The suffix is appended to \"http://${GCE_METADATA_HOST}/computeMetadata/v1/\".\n+//\n+// If the GCE_METADATA_HOST environment variable is not defined, a default of\n+// 169.254.169.254 will be used instead.\n+//\n+// If the requested metadata is not defined, the returned error will\n+// be of type NotDefinedError.\n+func (c *Client) Get(suffix string) (string, error) {\n+\tval, _, err := c.getETag(suffix)\n+\treturn val, err\n+}\n+\n+func (c *Client) getTrimmed(suffix string) (s string, err error) {\n+\ts, err = c.Get(suffix)\n+\ts = strings.TrimSpace(s)\n+\treturn\n+}\n+\n+func (c *Client) lines(suffix string) ([]string, error) {\n+\tj, err := c.Get(suffix)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n+\ts := strings.Split(strings.TrimSpace(j), \"\\n\")\n+\tfor i := range s {\n+\t\ts[i] = strings.TrimSpace(s[i])\n+\t}\n+\treturn s, nil\n }\n \n // ProjectID returns the current instance's project ID string.\n-func ProjectID() (string, error) { return projID.get() }\n+func (c *Client) ProjectID() (string, error) { return projID.get(c) }\n \n // NumericProjectID returns the current instance's numeric project ID.\n-func NumericProjectID() (string, error) { return projNum.get() }\n+func (c *Client) NumericProjectID() (string, error) { return projNum.get(c) }\n+\n+// InstanceID returns the current VM's numeric instance ID.\n+func (c *Client) InstanceID() (string, error) { return instID.get(c) }\n \n // InternalIP returns the instance's primary internal IP address.\n-func InternalIP() (string, error) {\n-\treturn getTrimmed(\"instance/network-interfaces/0/ip\")\n+func (c *Client) InternalIP() (string, error) {\n+\treturn c.getTrimmed(\"instance/network-interfaces/0/ip\")\n }\n \n // ExternalIP returns the instance's primary external (public) IP address.\n-func ExternalIP() (string, error) {\n-\treturn getTrimmed(\"instance/network-interfaces/0/access-configs/0/external-ip\")\n+func (c *Client) ExternalIP() (string, error) {\n+\treturn c.getTrimmed(\"instance/network-interfaces/0/access-configs/0/external-ip\")\n }\n \n // Hostname returns the instance's hostname. This will be of the form\n // \"<instanceID>.c.<projID>.internal\".\n-func Hostname() (string, error) {\n-\treturn getTrimmed(\"instance/hostname\")\n+func (c *Client) Hostname() (string, error) {\n+\treturn c.getTrimmed(\"instance/hostname\")\n }\n \n // InstanceTags returns the list of user-defined instance tags,\n // assigned when initially creating a GCE instance.\n-func InstanceTags() ([]string, error) {\n+func (c *Client) InstanceTags() ([]string, error) {\n \tvar s []string\n-\tj, err := Get(\"instance/tags\")\n+\tj, err := c.Get(\"instance/tags\")\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -347,23 +392,18 @@ func InstanceTags() ([]string, error) {\n \treturn s, nil\n }\n \n-// InstanceID returns the current VM's numeric instance ID.\n-func InstanceID() (string, error) {\n-\treturn instID.get()\n-}\n-\n // InstanceName returns the current VM's instance ID string.\n-func InstanceName() (string, error) {\n-\thost, err := Hostname()\n+func (c *Client) InstanceName() (string, error) {\n+\thost, err := c.Hostname()\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n \treturn strings.Split(host, \".\")[0], nil\n }\n \n // Zone returns the current VM's zone, such as \"us-central1-b\".\n-func Zone() (string, error) {\n-\tzone, err := getTrimmed(\"instance/zone\")\n+func (c *Client) Zone() (string, error) {\n+\tzone, err := c.getTrimmed(\"instance/zone\")\n \t// zone is of the form \"projects/<projNum>/zones/<zoneName>\".\n \tif err != nil {\n \t\treturn \"\", err\n@@ -374,24 +414,12 @@ func Zone() (string, error) {\n // InstanceAttributes returns the list of user-defined attributes,\n // assigned when initially creating a GCE VM instance. The value of an\n // attribute can be obtained with InstanceAttributeValue.\n-func InstanceAttributes() ([]string, error) { return lines(\"instance/attributes/\") }\n+func (c *Client) InstanceAttributes() ([]string, error) { return c.lines(\"instance/attributes/\") }\n \n // ProjectAttributes returns the list of user-defined attributes\n // applying to the project as a whole, not just this VM.  The value of\n // an attribute can be obtained with ProjectAttributeValue.\n-func ProjectAttributes() ([]string, error) { return lines(\"project/attributes/\") }\n-\n-func lines(suffix string) ([]string, error) {\n-\tj, err := Get(suffix)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\ts := strings.Split(strings.TrimSpace(j), \"\\n\")\n-\tfor i := range s {\n-\t\ts[i] = strings.TrimSpace(s[i])\n-\t}\n-\treturn s, nil\n-}\n+func (c *Client) ProjectAttributes() ([]string, error) { return c.lines(\"project/attributes/\") }\n \n // InstanceAttributeValue returns the value of the provided VM\n // instance attribute.\n@@ -401,8 +429,8 @@ func lines(suffix string) ([]string, error) {\n //\n // InstanceAttributeValue may return (\"\", nil) if the attribute was\n // defined to be the empty string.\n-func InstanceAttributeValue(attr string) (string, error) {\n-\treturn Get(\"instance/attributes/\" + attr)\n+func (c *Client) InstanceAttributeValue(attr string) (string, error) {\n+\treturn c.Get(\"instance/attributes/\" + attr)\n }\n \n // ProjectAttributeValue returns the value of the provided\n@@ -413,25 +441,61 @@ func InstanceAttributeValue(attr string) (string, error) {\n //\n // ProjectAttributeValue may return (\"\", nil) if the attribute was\n // defined to be the empty string.\n-func ProjectAttributeValue(attr string) (string, error) {\n-\treturn Get(\"project/attributes/\" + attr)\n+func (c *Client) ProjectAttributeValue(attr string) (string, error) {\n+\treturn c.Get(\"project/attributes/\" + attr)\n }\n \n // Scopes returns the service account scopes for the given account.\n // The account may be empty or the string \"default\" to use the instance's\n // main account.\n-func Scopes(serviceAccount string) ([]string, error) {\n+func (c *Client) Scopes(serviceAccount string) ([]string, error) {\n \tif serviceAccount == \"\" {\n \t\tserviceAccount = \"default\"\n \t}\n-\treturn lines(\"instance/service-accounts/\" + serviceAccount + \"/scopes\")\n+\treturn c.lines(\"instance/service-accounts/\" + serviceAccount + \"/scopes\")\n }\n \n-func strsContains(ss []string, s string) bool {\n-\tfor _, v := range ss {\n-\t\tif v == s {\n-\t\t\treturn true\n+// Subscribe subscribes to a value from the metadata service.\n+// The suffix is appended to \"http://${GCE_METADATA_HOST}/computeMetadata/v1/\".\n+// The suffix may contain query parameters.\n+//\n+// Subscribe calls fn with the latest metadata value indicated by the provided\n+// suffix. If the metadata value is deleted, fn is called with the empty string\n+// and ok false. Subscribe blocks until fn returns a non-nil error or the value\n+// is deleted. Subscribe returns the error value returned from the last call to\n+// fn, which may be nil when ok == false.\n+func (c *Client) Subscribe(suffix string, fn func(v string, ok bool) error) error {\n+\tconst failedSubscribeSleep = time.Second * 5\n+\n+\t// First check to see if the metadata value exists at all.\n+\tval, lastETag, err := c.getETag(suffix)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif err := fn(val, true); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tok := true\n+\tif strings.ContainsRune(suffix, '?') {\n+\t\tsuffix += \"&wait_for_change=true&last_etag=\"\n+\t} else {\n+\t\tsuffix += \"?wait_for_change=true&last_etag=\"\n+\t}\n+\tfor {\n+\t\tval, etag, err := c.getETag(suffix + url.QueryEscape(lastETag))\n+\t\tif err != nil {\n+\t\t\tif _, deleted := err.(NotDefinedError); !deleted {\n+\t\t\t\ttime.Sleep(failedSubscribeSleep)\n+\t\t\t\tcontinue // Retry on other errors.\n+\t\t\t}\n+\t\t\tok = false\n+\t\t}\n+\t\tlastETag = etag\n+\n+\t\tif err := fn(val, ok); err != nil || !ok {\n+\t\t\treturn err\n \t\t}\n \t}\n-\treturn false\n }"
    },
    {
      "sha": null,
      "filename": "backend/vendor/github.com/andybalholm/cascadia/LICENSE",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/andybalholm/cascadia/LICENSE",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/andybalholm/cascadia/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/andybalholm/cascadia/LICENSE?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "bc52e96f2b0ea97cc450e2fefbbb4cc430d1ac5a",
      "filename": "backend/vendor/github.com/davecgh/go-spew/LICENSE",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/LICENSE",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/davecgh/go-spew/LICENSE?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -2,7 +2,7 @@ ISC License\n \n Copyright (c) 2012-2016 Dave Collins <dave@davec.name>\n \n-Permission to use, copy, modify, and distribute this software for any\n+Permission to use, copy, modify, and/or distribute this software for any\n purpose with or without fee is hereby granted, provided that the above\n copyright notice and this permission notice appear in all copies.\n "
    },
    {
      "sha": "792994785e36ca74c5545a0d93a2cdecda006678",
      "filename": "backend/vendor/github.com/davecgh/go-spew/spew/bypass.go",
      "status": "modified",
      "additions": 90,
      "deletions": 97,
      "changes": 187,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/bypass.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/bypass.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/davecgh/go-spew/spew/bypass.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -16,7 +16,9 @@\n // when the code is not running on Google App Engine, compiled by GopherJS, and\n // \"-tags safe\" is not added to the go build command line.  The \"disableunsafe\"\n // tag is deprecated and thus should not be used.\n-// +build !js,!appengine,!safe,!disableunsafe\n+// Go versions prior to 1.4 are disabled because they use a different layout\n+// for interfaces which make the implementation of unsafeReflectValue more complex.\n+// +build !js,!appengine,!safe,!disableunsafe,go1.4\n \n package spew\n \n@@ -34,80 +36,49 @@ const (\n \tptrSize = unsafe.Sizeof((*byte)(nil))\n )\n \n+type flag uintptr\n+\n var (\n-\t// offsetPtr, offsetScalar, and offsetFlag are the offsets for the\n-\t// internal reflect.Value fields.  These values are valid before golang\n-\t// commit ecccf07e7f9d which changed the format.  The are also valid\n-\t// after commit 82f48826c6c7 which changed the format again to mirror\n-\t// the original format.  Code in the init function updates these offsets\n-\t// as necessary.\n-\toffsetPtr    = uintptr(ptrSize)\n-\toffsetScalar = uintptr(0)\n-\toffsetFlag   = uintptr(ptrSize * 2)\n-\n-\t// flagKindWidth and flagKindShift indicate various bits that the\n-\t// reflect package uses internally to track kind information.\n-\t//\n-\t// flagRO indicates whether or not the value field of a reflect.Value is\n-\t// read-only.\n-\t//\n-\t// flagIndir indicates whether the value field of a reflect.Value is\n-\t// the actual data or a pointer to the data.\n-\t//\n-\t// These values are valid before golang commit 90a7c3c86944 which\n-\t// changed their positions.  Code in the init function updates these\n-\t// flags as necessary.\n-\tflagKindWidth = uintptr(5)\n-\tflagKindShift = uintptr(flagKindWidth - 1)\n-\tflagRO        = uintptr(1 << 0)\n-\tflagIndir     = uintptr(1 << 1)\n+\t// flagRO indicates whether the value field of a reflect.Value\n+\t// is read-only.\n+\tflagRO flag\n+\n+\t// flagAddr indicates whether the address of the reflect.Value's\n+\t// value may be taken.\n+\tflagAddr flag\n )\n \n-func init() {\n-\t// Older versions of reflect.Value stored small integers directly in the\n-\t// ptr field (which is named val in the older versions).  Versions\n-\t// between commits ecccf07e7f9d and 82f48826c6c7 added a new field named\n-\t// scalar for this purpose which unfortunately came before the flag\n-\t// field, so the offset of the flag field is different for those\n-\t// versions.\n-\t//\n-\t// This code constructs a new reflect.Value from a known small integer\n-\t// and checks if the size of the reflect.Value struct indicates it has\n-\t// the scalar field. When it does, the offsets are updated accordingly.\n-\tvv := reflect.ValueOf(0xf00)\n-\tif unsafe.Sizeof(vv) == (ptrSize * 4) {\n-\t\toffsetScalar = ptrSize * 2\n-\t\toffsetFlag = ptrSize * 3\n-\t}\n+// flagKindMask holds the bits that make up the kind\n+// part of the flags field. In all the supported versions,\n+// it is in the lower 5 bits.\n+const flagKindMask = flag(0x1f)\n \n-\t// Commit 90a7c3c86944 changed the flag positions such that the low\n-\t// order bits are the kind.  This code extracts the kind from the flags\n-\t// field and ensures it's the correct type.  When it's not, the flag\n-\t// order has been changed to the newer format, so the flags are updated\n-\t// accordingly.\n-\tupf := unsafe.Pointer(uintptr(unsafe.Pointer(&vv)) + offsetFlag)\n-\tupfv := *(*uintptr)(upf)\n-\tflagKindMask := uintptr((1<<flagKindWidth - 1) << flagKindShift)\n-\tif (upfv&flagKindMask)>>flagKindShift != uintptr(reflect.Int) {\n-\t\tflagKindShift = 0\n-\t\tflagRO = 1 << 5\n-\t\tflagIndir = 1 << 6\n-\n-\t\t// Commit adf9b30e5594 modified the flags to separate the\n-\t\t// flagRO flag into two bits which specifies whether or not the\n-\t\t// field is embedded.  This causes flagIndir to move over a bit\n-\t\t// and means that flagRO is the combination of either of the\n-\t\t// original flagRO bit and the new bit.\n-\t\t//\n-\t\t// This code detects the change by extracting what used to be\n-\t\t// the indirect bit to ensure it's set.  When it's not, the flag\n-\t\t// order has been changed to the newer format, so the flags are\n-\t\t// updated accordingly.\n-\t\tif upfv&flagIndir == 0 {\n-\t\t\tflagRO = 3 << 5\n-\t\t\tflagIndir = 1 << 7\n-\t\t}\n+// Different versions of Go have used different\n+// bit layouts for the flags type. This table\n+// records the known combinations.\n+var okFlags = []struct {\n+\tro, addr flag\n+}{{\n+\t// From Go 1.4 to 1.5\n+\tro:   1 << 5,\n+\taddr: 1 << 7,\n+}, {\n+\t// Up to Go tip.\n+\tro:   1<<5 | 1<<6,\n+\taddr: 1 << 8,\n+}}\n+\n+var flagValOffset = func() uintptr {\n+\tfield, ok := reflect.TypeOf(reflect.Value{}).FieldByName(\"flag\")\n+\tif !ok {\n+\t\tpanic(\"reflect.Value has no flag field\")\n \t}\n+\treturn field.Offset\n+}()\n+\n+// flagField returns a pointer to the flag field of a reflect.Value.\n+func flagField(v *reflect.Value) *flag {\n+\treturn (*flag)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + flagValOffset))\n }\n \n // unsafeReflectValue converts the passed reflect.Value into a one that bypasses\n@@ -119,34 +90,56 @@ func init() {\n // This allows us to check for implementations of the Stringer and error\n // interfaces to be used for pretty printing ordinarily unaddressable and\n // inaccessible values such as unexported struct fields.\n-func unsafeReflectValue(v reflect.Value) (rv reflect.Value) {\n-\tindirects := 1\n-\tvt := v.Type()\n-\tupv := unsafe.Pointer(uintptr(unsafe.Pointer(&v)) + offsetPtr)\n-\trvf := *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&v)) + offsetFlag))\n-\tif rvf&flagIndir != 0 {\n-\t\tvt = reflect.PtrTo(v.Type())\n-\t\tindirects++\n-\t} else if offsetScalar != 0 {\n-\t\t// The value is in the scalar field when it's not one of the\n-\t\t// reference types.\n-\t\tswitch vt.Kind() {\n-\t\tcase reflect.Uintptr:\n-\t\tcase reflect.Chan:\n-\t\tcase reflect.Func:\n-\t\tcase reflect.Map:\n-\t\tcase reflect.Ptr:\n-\t\tcase reflect.UnsafePointer:\n-\t\tdefault:\n-\t\t\tupv = unsafe.Pointer(uintptr(unsafe.Pointer(&v)) +\n-\t\t\t\toffsetScalar)\n-\t\t}\n+func unsafeReflectValue(v reflect.Value) reflect.Value {\n+\tif !v.IsValid() || (v.CanInterface() && v.CanAddr()) {\n+\t\treturn v\n \t}\n+\tflagFieldPtr := flagField(&v)\n+\t*flagFieldPtr &^= flagRO\n+\t*flagFieldPtr |= flagAddr\n+\treturn v\n+}\n \n-\tpv := reflect.NewAt(vt, upv)\n-\trv = pv\n-\tfor i := 0; i < indirects; i++ {\n-\t\trv = rv.Elem()\n+// Sanity checks against future reflect package changes\n+// to the type or semantics of the Value.flag field.\n+func init() {\n+\tfield, ok := reflect.TypeOf(reflect.Value{}).FieldByName(\"flag\")\n+\tif !ok {\n+\t\tpanic(\"reflect.Value has no flag field\")\n+\t}\n+\tif field.Type.Kind() != reflect.TypeOf(flag(0)).Kind() {\n+\t\tpanic(\"reflect.Value flag field has changed kind\")\n+\t}\n+\ttype t0 int\n+\tvar t struct {\n+\t\tA t0\n+\t\t// t0 will have flagEmbedRO set.\n+\t\tt0\n+\t\t// a will have flagStickyRO set\n+\t\ta t0\n+\t}\n+\tvA := reflect.ValueOf(t).FieldByName(\"A\")\n+\tva := reflect.ValueOf(t).FieldByName(\"a\")\n+\tvt0 := reflect.ValueOf(t).FieldByName(\"t0\")\n+\n+\t// Infer flagRO from the difference between the flags\n+\t// for the (otherwise identical) fields in t.\n+\tflagPublic := *flagField(&vA)\n+\tflagWithRO := *flagField(&va) | *flagField(&vt0)\n+\tflagRO = flagPublic ^ flagWithRO\n+\n+\t// Infer flagAddr from the difference between a value\n+\t// taken from a pointer and not.\n+\tvPtrA := reflect.ValueOf(&t).Elem().FieldByName(\"A\")\n+\tflagNoPtr := *flagField(&vA)\n+\tflagPtr := *flagField(&vPtrA)\n+\tflagAddr = flagNoPtr ^ flagPtr\n+\n+\t// Check that the inferred flags tally with one of the known versions.\n+\tfor _, f := range okFlags {\n+\t\tif flagRO == f.ro && flagAddr == f.addr {\n+\t\t\treturn\n+\t\t}\n \t}\n-\treturn rv\n+\tpanic(\"reflect.Value read-only flag has changed semantics\")\n }"
    },
    {
      "sha": "205c28d68c474e4497e6aa1ce8b9fdeb260f4586",
      "filename": "backend/vendor/github.com/davecgh/go-spew/spew/bypasssafe.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/bypasssafe.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/bypasssafe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/davecgh/go-spew/spew/bypasssafe.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -16,7 +16,7 @@\n // when the code is running on Google App Engine, compiled by GopherJS, or\n // \"-tags safe\" is added to the go build command line.  The \"disableunsafe\"\n // tag is deprecated and thus should not be used.\n-// +build js appengine safe disableunsafe\n+// +build js appengine safe disableunsafe !go1.4\n \n package spew\n "
    },
    {
      "sha": "1be8ce9457612e02a64c01b2321d087ebd6415f2",
      "filename": "backend/vendor/github.com/davecgh/go-spew/spew/common.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/common.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/common.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/davecgh/go-spew/spew/common.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -180,7 +180,7 @@ func printComplex(w io.Writer, c complex128, floatPrecision int) {\n \tw.Write(closeParenBytes)\n }\n \n-// printHexPtr outputs a uintptr formatted as hexidecimal with a leading '0x'\n+// printHexPtr outputs a uintptr formatted as hexadecimal with a leading '0x'\n // prefix to Writer w.\n func printHexPtr(w io.Writer, p uintptr) {\n \t// Null pointer."
    },
    {
      "sha": "f78d89fc1f6c454df58cd1e346817db6e30c4299",
      "filename": "backend/vendor/github.com/davecgh/go-spew/spew/dump.go",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/dump.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/dump.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/davecgh/go-spew/spew/dump.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -35,16 +35,16 @@ var (\n \n \t// cCharRE is a regular expression that matches a cgo char.\n \t// It is used to detect character arrays to hexdump them.\n-\tcCharRE = regexp.MustCompile(\"^.*\\\\._Ctype_char$\")\n+\tcCharRE = regexp.MustCompile(`^.*\\._Ctype_char$`)\n \n \t// cUnsignedCharRE is a regular expression that matches a cgo unsigned\n \t// char.  It is used to detect unsigned character arrays to hexdump\n \t// them.\n-\tcUnsignedCharRE = regexp.MustCompile(\"^.*\\\\._Ctype_unsignedchar$\")\n+\tcUnsignedCharRE = regexp.MustCompile(`^.*\\._Ctype_unsignedchar$`)\n \n \t// cUint8tCharRE is a regular expression that matches a cgo uint8_t.\n \t// It is used to detect uint8_t arrays to hexdump them.\n-\tcUint8tCharRE = regexp.MustCompile(\"^.*\\\\._Ctype_uint8_t$\")\n+\tcUint8tCharRE = regexp.MustCompile(`^.*\\._Ctype_uint8_t$`)\n )\n \n // dumpState contains information about the state of a dump operation.\n@@ -143,10 +143,10 @@ func (d *dumpState) dumpPtr(v reflect.Value) {\n \t// Display dereferenced value.\n \td.w.Write(openParenBytes)\n \tswitch {\n-\tcase nilFound == true:\n+\tcase nilFound:\n \t\td.w.Write(nilAngleBytes)\n \n-\tcase cycleFound == true:\n+\tcase cycleFound:\n \t\td.w.Write(circularBytes)\n \n \tdefault:"
    },
    {
      "sha": "b04edb7d7ac278ae0b873a1335f37822a00bfd7c",
      "filename": "backend/vendor/github.com/davecgh/go-spew/spew/format.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/format.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/davecgh/go-spew/spew/format.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/davecgh/go-spew/spew/format.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -182,10 +182,10 @@ func (f *formatState) formatPtr(v reflect.Value) {\n \n \t// Display dereferenced value.\n \tswitch {\n-\tcase nilFound == true:\n+\tcase nilFound:\n \t\tf.fs.Write(nilAngleBytes)\n \n-\tcase cycleFound == true:\n+\tcase cycleFound:\n \t\tf.fs.Write(circularShortBytes)\n \n \tdefault:"
    },
    {
      "sha": "f1f89e966b6937e544b5bd9b7326673ec99bb418",
      "filename": "backend/vendor/github.com/globalsign/mgo/.travis.yml",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/globalsign/mgo/.travis.yml",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/globalsign/mgo/.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/globalsign/mgo/.travis.yml?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -29,7 +29,7 @@ install:\n     - go get gopkg.in/check.v1\n     - go get gopkg.in/yaml.v2\n     - go get gopkg.in/tomb.v2\n-    - go get github.com/golang/lint\n+    - go get golang.org/x/lint/golint\n \n before_script:\n     - golint  ./... | grep -v 'ID' | cat"
    },
    {
      "sha": "76fd05542dfc7c17be6870dc92222d2c19353225",
      "filename": "backend/vendor/github.com/globalsign/mgo/README.md",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/globalsign/mgo/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/globalsign/mgo/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/globalsign/mgo/README.md?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -13,6 +13,12 @@ Detailed documentation of the API is available at\n \n A [sub-package](https://godoc.org/github.com/globalsign/mgo/bson) that implements the [BSON](http://bsonspec.org) specification is also included, and may be used independently of the driver.\n \n+## Supported Versions\n+\n+`mgo` is known to work well on (and has integration tests against) MongoDB v3.0, 3.2, 3.4 and 3.6. \n+\n+MongoDB 4.0 is currently experimental - we would happily accept PRs to help improve support!\n+\n ## Changes\n * Fixes attempting to authenticate before every query ([details](https://github.com/go-mgo/mgo/issues/254))\n * Removes bulk update / delete batch size limitations ([details](https://github.com/go-mgo/mgo/issues/288))"
    },
    {
      "sha": "0f646931a4627fbe7c4259f3fb0337d04d798d8e",
      "filename": "backend/vendor/github.com/golang/protobuf/LICENSE",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/LICENSE",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/LICENSE?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,7 +1,4 @@\n-Go support for Protocol Buffers - Google's data interchange format\n-\n Copyright 2010 The Go Authors.  All rights reserved.\n-https://github.com/golang/protobuf\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are"
    },
    {
      "sha": "e2e0651a934d3ab8fe6393dfd2556bbc4bd0792e",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/Makefile",
      "status": "removed",
      "additions": 0,
      "deletions": 43,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/github.com/golang/protobuf/proto/Makefile",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/github.com/golang/protobuf/proto/Makefile",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/Makefile?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "patch": "@@ -1,43 +0,0 @@\n-# Go support for Protocol Buffers - Google's data interchange format\n-#\n-# Copyright 2010 The Go Authors.  All rights reserved.\n-# https://github.com/golang/protobuf\n-#\n-# Redistribution and use in source and binary forms, with or without\n-# modification, are permitted provided that the following conditions are\n-# met:\n-#\n-#     * Redistributions of source code must retain the above copyright\n-# notice, this list of conditions and the following disclaimer.\n-#     * Redistributions in binary form must reproduce the above\n-# copyright notice, this list of conditions and the following disclaimer\n-# in the documentation and/or other materials provided with the\n-# distribution.\n-#     * Neither the name of Google Inc. nor the names of its\n-# contributors may be used to endorse or promote products derived from\n-# this software without specific prior written permission.\n-#\n-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n-# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n-# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-install:\n-\tgo install\n-\n-test: install generate-test-pbs\n-\tgo test\n-\n-\n-generate-test-pbs:\n-\tmake install\n-\tmake -C testdata\n-\tprotoc --go_out=Mtestdata/test.proto=github.com/golang/protobuf/proto/testdata,Mgoogle/protobuf/any.proto=github.com/golang/protobuf/ptypes/any:. proto3_proto/proto3.proto\n-\tmake"
    },
    {
      "sha": "3cd3249f706241d57b2b79f36de043bfac488449",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/clone.go",
      "status": "modified",
      "additions": 35,
      "deletions": 11,
      "changes": 46,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/clone.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/clone.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/clone.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -35,40 +35,64 @@\n package proto\n \n import (\n+\t\"fmt\"\n \t\"log\"\n \t\"reflect\"\n \t\"strings\"\n )\n \n // Clone returns a deep copy of a protocol buffer.\n-func Clone(pb Message) Message {\n-\tin := reflect.ValueOf(pb)\n+func Clone(src Message) Message {\n+\tin := reflect.ValueOf(src)\n \tif in.IsNil() {\n-\t\treturn pb\n+\t\treturn src\n \t}\n-\n \tout := reflect.New(in.Type().Elem())\n-\t// out is empty so a merge is a deep copy.\n-\tmergeStruct(out.Elem(), in.Elem())\n-\treturn out.Interface().(Message)\n+\tdst := out.Interface().(Message)\n+\tMerge(dst, src)\n+\treturn dst\n+}\n+\n+// Merger is the interface representing objects that can merge messages of the same type.\n+type Merger interface {\n+\t// Merge merges src into this message.\n+\t// Required and optional fields that are set in src will be set to that value in dst.\n+\t// Elements of repeated fields will be appended.\n+\t//\n+\t// Merge may panic if called with a different argument type than the receiver.\n+\tMerge(src Message)\n+}\n+\n+// generatedMerger is the custom merge method that generated protos will have.\n+// We must add this method since a generate Merge method will conflict with\n+// many existing protos that have a Merge data field already defined.\n+type generatedMerger interface {\n+\tXXX_Merge(src Message)\n }\n \n // Merge merges src into dst.\n // Required and optional fields that are set in src will be set to that value in dst.\n // Elements of repeated fields will be appended.\n // Merge panics if src and dst are not the same type, or if dst is nil.\n func Merge(dst, src Message) {\n+\tif m, ok := dst.(Merger); ok {\n+\t\tm.Merge(src)\n+\t\treturn\n+\t}\n+\n \tin := reflect.ValueOf(src)\n \tout := reflect.ValueOf(dst)\n \tif out.IsNil() {\n \t\tpanic(\"proto: nil destination\")\n \t}\n \tif in.Type() != out.Type() {\n-\t\t// Explicit test prior to mergeStruct so that mistyped nils will fail\n-\t\tpanic(\"proto: type mismatch\")\n+\t\tpanic(fmt.Sprintf(\"proto.Merge(%T, %T) type mismatch\", dst, src))\n \t}\n \tif in.IsNil() {\n-\t\t// Merging nil into non-nil is a quiet no-op\n+\t\treturn // Merge from nil src is a noop\n+\t}\n+\tif m, ok := dst.(generatedMerger); ok {\n+\t\tm.XXX_Merge(src)\n \t\treturn\n \t}\n \tmergeStruct(out.Elem(), in.Elem())\n@@ -84,7 +108,7 @@ func mergeStruct(out, in reflect.Value) {\n \t\tmergeAny(out.Field(i), in.Field(i), false, sprop.Prop[i])\n \t}\n \n-\tif emIn, ok := extendable(in.Addr().Interface()); ok {\n+\tif emIn, err := extendable(in.Addr().Interface()); err == nil {\n \t\temOut, _ := extendable(out.Addr().Interface())\n \t\tmIn, muIn := emIn.extensionsRead()\n \t\tif mIn != nil {"
    },
    {
      "sha": "d9aa3c42d666ec2503c322d567c035a0a884ee24",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/decode.go",
      "status": "modified",
      "additions": 63,
      "deletions": 605,
      "changes": 668,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/decode.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/decode.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/decode.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -39,8 +39,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n-\t\"reflect\"\n )\n \n // errOverflow is returned when an integer is too large to be represented.\n@@ -50,10 +48,6 @@ var errOverflow = errors.New(\"proto: integer overflow\")\n // wire type is encountered. It does not get returned to user code.\n var ErrInternalBadWireType = errors.New(\"proto: internal error: bad wiretype for oneof\")\n \n-// The fundamental decoders that interpret bytes on the wire.\n-// Those that take integer types all return uint64 and are\n-// therefore of type valueDecoder.\n-\n // DecodeVarint reads a varint-encoded integer from the slice.\n // It returns the integer and the number of bytes consumed, or\n // zero if there is not enough.\n@@ -267,9 +261,6 @@ func (p *Buffer) DecodeZigzag32() (x uint64, err error) {\n \treturn\n }\n \n-// These are not ValueDecoders: they produce an array of bytes or a string.\n-// bytes, embedded messages\n-\n // DecodeRawBytes reads a count-delimited byte buffer from the Buffer.\n // This is the format used for the bytes protocol buffer\n // type and for embedded messages.\n@@ -311,81 +302,29 @@ func (p *Buffer) DecodeStringBytes() (s string, err error) {\n \treturn string(buf), nil\n }\n \n-// Skip the next item in the buffer. Its wire type is decoded and presented as an argument.\n-// If the protocol buffer has extensions, and the field matches, add it as an extension.\n-// Otherwise, if the XXX_unrecognized field exists, append the skipped data there.\n-func (o *Buffer) skipAndSave(t reflect.Type, tag, wire int, base structPointer, unrecField field) error {\n-\toi := o.index\n-\n-\terr := o.skip(t, tag, wire)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tif !unrecField.IsValid() {\n-\t\treturn nil\n-\t}\n-\n-\tptr := structPointer_Bytes(base, unrecField)\n-\n-\t// Add the skipped field to struct field\n-\tobuf := o.buf\n-\n-\to.buf = *ptr\n-\to.EncodeVarint(uint64(tag<<3 | wire))\n-\t*ptr = append(o.buf, obuf[oi:o.index]...)\n-\n-\to.buf = obuf\n-\n-\treturn nil\n-}\n-\n-// Skip the next item in the buffer. Its wire type is decoded and presented as an argument.\n-func (o *Buffer) skip(t reflect.Type, tag, wire int) error {\n-\n-\tvar u uint64\n-\tvar err error\n-\n-\tswitch wire {\n-\tcase WireVarint:\n-\t\t_, err = o.DecodeVarint()\n-\tcase WireFixed64:\n-\t\t_, err = o.DecodeFixed64()\n-\tcase WireBytes:\n-\t\t_, err = o.DecodeRawBytes(false)\n-\tcase WireFixed32:\n-\t\t_, err = o.DecodeFixed32()\n-\tcase WireStartGroup:\n-\t\tfor {\n-\t\t\tu, err = o.DecodeVarint()\n-\t\t\tif err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tfwire := int(u & 0x7)\n-\t\t\tif fwire == WireEndGroup {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tftag := int(u >> 3)\n-\t\t\terr = o.skip(t, ftag, fwire)\n-\t\t\tif err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\tdefault:\n-\t\terr = fmt.Errorf(\"proto: can't skip unknown wire type %d for %s\", wire, t)\n-\t}\n-\treturn err\n-}\n-\n // Unmarshaler is the interface representing objects that can\n-// unmarshal themselves.  The method should reset the receiver before\n-// decoding starts.  The argument points to data that may be\n+// unmarshal themselves.  The argument points to data that may be\n // overwritten, so implementations should not keep references to the\n // buffer.\n+// Unmarshal implementations should not clear the receiver.\n+// Any unmarshaled data should be merged into the receiver.\n+// Callers of Unmarshal that do not want to retain existing data\n+// should Reset the receiver before calling Unmarshal.\n type Unmarshaler interface {\n \tUnmarshal([]byte) error\n }\n \n+// newUnmarshaler is the interface representing objects that can\n+// unmarshal themselves. The semantics are identical to Unmarshaler.\n+//\n+// This exists to support protoc-gen-go generated messages.\n+// The proto package will stop type-asserting to this interface in the future.\n+//\n+// DO NOT DEPEND ON THIS.\n+type newUnmarshaler interface {\n+\tXXX_Unmarshal([]byte) error\n+}\n+\n // Unmarshal parses the protocol buffer representation in buf and places the\n // decoded result in pb.  If the struct underlying pb does not match\n // the data in buf, the results can be unpredictable.\n@@ -395,7 +334,13 @@ type Unmarshaler interface {\n // to preserve and append to existing data.\n func Unmarshal(buf []byte, pb Message) error {\n \tpb.Reset()\n-\treturn UnmarshalMerge(buf, pb)\n+\tif u, ok := pb.(newUnmarshaler); ok {\n+\t\treturn u.XXX_Unmarshal(buf)\n+\t}\n+\tif u, ok := pb.(Unmarshaler); ok {\n+\t\treturn u.Unmarshal(buf)\n+\t}\n+\treturn NewBuffer(buf).Unmarshal(pb)\n }\n \n // UnmarshalMerge parses the protocol buffer representation in buf and\n@@ -405,8 +350,16 @@ func Unmarshal(buf []byte, pb Message) error {\n // UnmarshalMerge merges into existing data in pb.\n // Most code should use Unmarshal instead.\n func UnmarshalMerge(buf []byte, pb Message) error {\n-\t// If the object can unmarshal itself, let it.\n+\tif u, ok := pb.(newUnmarshaler); ok {\n+\t\treturn u.XXX_Unmarshal(buf)\n+\t}\n \tif u, ok := pb.(Unmarshaler); ok {\n+\t\t// NOTE: The history of proto have unfortunately been inconsistent\n+\t\t// whether Unmarshaler should or should not implicitly clear itself.\n+\t\t// Some implementations do, most do not.\n+\t\t// Thus, calling this here may or may not do what people want.\n+\t\t//\n+\t\t// See https://github.com/golang/protobuf/issues/424\n \t\treturn u.Unmarshal(buf)\n \t}\n \treturn NewBuffer(buf).Unmarshal(pb)\n@@ -422,12 +375,17 @@ func (p *Buffer) DecodeMessage(pb Message) error {\n }\n \n // DecodeGroup reads a tag-delimited group from the Buffer.\n+// StartGroup tag is already consumed. This function consumes\n+// EndGroup tag.\n func (p *Buffer) DecodeGroup(pb Message) error {\n-\ttyp, base, err := getbase(pb)\n-\tif err != nil {\n-\t\treturn err\n+\tb := p.buf[p.index:]\n+\tx, y := findEndGroup(b)\n+\tif x < 0 {\n+\t\treturn io.ErrUnexpectedEOF\n \t}\n-\treturn p.unmarshalType(typ.Elem(), GetProperties(typ.Elem()), true, base)\n+\terr := Unmarshal(b[:x], pb)\n+\tp.index += y\n+\treturn err\n }\n \n // Unmarshal parses the protocol buffer representation in the\n@@ -438,533 +396,33 @@ func (p *Buffer) DecodeGroup(pb Message) error {\n // Unlike proto.Unmarshal, this does not reset pb before starting to unmarshal.\n func (p *Buffer) Unmarshal(pb Message) error {\n \t// If the object can unmarshal itself, let it.\n-\tif u, ok := pb.(Unmarshaler); ok {\n-\t\terr := u.Unmarshal(p.buf[p.index:])\n+\tif u, ok := pb.(newUnmarshaler); ok {\n+\t\terr := u.XXX_Unmarshal(p.buf[p.index:])\n \t\tp.index = len(p.buf)\n \t\treturn err\n \t}\n-\n-\ttyp, base, err := getbase(pb)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\terr = p.unmarshalType(typ.Elem(), GetProperties(typ.Elem()), false, base)\n-\n-\tif collectStats {\n-\t\tstats.Decode++\n-\t}\n-\n-\treturn err\n-}\n-\n-// unmarshalType does the work of unmarshaling a structure.\n-func (o *Buffer) unmarshalType(st reflect.Type, prop *StructProperties, is_group bool, base structPointer) error {\n-\tvar state errorState\n-\trequired, reqFields := prop.reqCount, uint64(0)\n-\n-\tvar err error\n-\tfor err == nil && o.index < len(o.buf) {\n-\t\toi := o.index\n-\t\tvar u uint64\n-\t\tu, err = o.DecodeVarint()\n-\t\tif err != nil {\n-\t\t\tbreak\n-\t\t}\n-\t\twire := int(u & 0x7)\n-\t\tif wire == WireEndGroup {\n-\t\t\tif is_group {\n-\t\t\t\tif required > 0 {\n-\t\t\t\t\t// Not enough information to determine the exact field.\n-\t\t\t\t\t// (See below.)\n-\t\t\t\t\treturn &RequiredNotSetError{\"{Unknown}\"}\n-\t\t\t\t}\n-\t\t\t\treturn nil // input is satisfied\n-\t\t\t}\n-\t\t\treturn fmt.Errorf(\"proto: %s: wiretype end group for non-group\", st)\n-\t\t}\n-\t\ttag := int(u >> 3)\n-\t\tif tag <= 0 {\n-\t\t\treturn fmt.Errorf(\"proto: %s: illegal tag %d (wire type %d)\", st, tag, wire)\n-\t\t}\n-\t\tfieldnum, ok := prop.decoderTags.get(tag)\n-\t\tif !ok {\n-\t\t\t// Maybe it's an extension?\n-\t\t\tif prop.extendable {\n-\t\t\t\tif e, _ := extendable(structPointer_Interface(base, st)); isExtensionField(e, int32(tag)) {\n-\t\t\t\t\tif err = o.skip(st, tag, wire); err == nil {\n-\t\t\t\t\t\textmap := e.extensionsWrite()\n-\t\t\t\t\t\text := extmap[int32(tag)] // may be missing\n-\t\t\t\t\t\text.enc = append(ext.enc, o.buf[oi:o.index]...)\n-\t\t\t\t\t\textmap[int32(tag)] = ext\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// Maybe it's a oneof?\n-\t\t\tif prop.oneofUnmarshaler != nil {\n-\t\t\t\tm := structPointer_Interface(base, st).(Message)\n-\t\t\t\t// First return value indicates whether tag is a oneof field.\n-\t\t\t\tok, err = prop.oneofUnmarshaler(m, tag, wire, o)\n-\t\t\t\tif err == ErrInternalBadWireType {\n-\t\t\t\t\t// Map the error to something more descriptive.\n-\t\t\t\t\t// Do the formatting here to save generated code space.\n-\t\t\t\t\terr = fmt.Errorf(\"bad wiretype for oneof field in %T\", m)\n-\t\t\t\t}\n-\t\t\t\tif ok {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\terr = o.skipAndSave(st, tag, wire, base, prop.unrecField)\n-\t\t\tcontinue\n-\t\t}\n-\t\tp := prop.Prop[fieldnum]\n-\n-\t\tif p.dec == nil {\n-\t\t\tfmt.Fprintf(os.Stderr, \"proto: no protobuf decoder for %s.%s\\n\", st, st.Field(fieldnum).Name)\n-\t\t\tcontinue\n-\t\t}\n-\t\tdec := p.dec\n-\t\tif wire != WireStartGroup && wire != p.WireType {\n-\t\t\tif wire == WireBytes && p.packedDec != nil {\n-\t\t\t\t// a packable field\n-\t\t\t\tdec = p.packedDec\n-\t\t\t} else {\n-\t\t\t\terr = fmt.Errorf(\"proto: bad wiretype for field %s.%s: got wiretype %d, want %d\", st, st.Field(fieldnum).Name, wire, p.WireType)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n-\t\tdecErr := dec(o, p, base)\n-\t\tif decErr != nil && !state.shouldContinue(decErr, p) {\n-\t\t\terr = decErr\n-\t\t}\n-\t\tif err == nil && p.Required {\n-\t\t\t// Successfully decoded a required field.\n-\t\t\tif tag <= 64 {\n-\t\t\t\t// use bitmap for fields 1-64 to catch field reuse.\n-\t\t\t\tvar mask uint64 = 1 << uint64(tag-1)\n-\t\t\t\tif reqFields&mask == 0 {\n-\t\t\t\t\t// new required field\n-\t\t\t\t\treqFields |= mask\n-\t\t\t\t\trequired--\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// This is imprecise. It can be fooled by a required field\n-\t\t\t\t// with a tag > 64 that is encoded twice; that's very rare.\n-\t\t\t\t// A fully correct implementation would require allocating\n-\t\t\t\t// a data structure, which we would like to avoid.\n-\t\t\t\trequired--\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif err == nil {\n-\t\tif is_group {\n-\t\t\treturn io.ErrUnexpectedEOF\n-\t\t}\n-\t\tif state.err != nil {\n-\t\t\treturn state.err\n-\t\t}\n-\t\tif required > 0 {\n-\t\t\t// Not enough information to determine the exact field. If we use extra\n-\t\t\t// CPU, we could determine the field only if the missing required field\n-\t\t\t// has a tag <= 64 and we check reqFields.\n-\t\t\treturn &RequiredNotSetError{\"{Unknown}\"}\n-\t\t}\n-\t}\n-\treturn err\n-}\n-\n-// Individual type decoders\n-// For each,\n-//\tu is the decoded value,\n-//\tv is a pointer to the field (pointer) in the struct\n-\n-// Sizes of the pools to allocate inside the Buffer.\n-// The goal is modest amortization and allocation\n-// on at least 16-byte boundaries.\n-const (\n-\tboolPoolSize   = 16\n-\tuint32PoolSize = 8\n-\tuint64PoolSize = 4\n-)\n-\n-// Decode a bool.\n-func (o *Buffer) dec_bool(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tif len(o.bools) == 0 {\n-\t\to.bools = make([]bool, boolPoolSize)\n-\t}\n-\to.bools[0] = u != 0\n-\t*structPointer_Bool(base, p.field) = &o.bools[0]\n-\to.bools = o.bools[1:]\n-\treturn nil\n-}\n-\n-func (o *Buffer) dec_proto3_bool(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t*structPointer_BoolVal(base, p.field) = u != 0\n-\treturn nil\n-}\n-\n-// Decode an int32.\n-func (o *Buffer) dec_int32(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tword32_Set(structPointer_Word32(base, p.field), o, uint32(u))\n-\treturn nil\n-}\n-\n-func (o *Buffer) dec_proto3_int32(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tword32Val_Set(structPointer_Word32Val(base, p.field), uint32(u))\n-\treturn nil\n-}\n-\n-// Decode an int64.\n-func (o *Buffer) dec_int64(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tword64_Set(structPointer_Word64(base, p.field), o, u)\n-\treturn nil\n-}\n-\n-func (o *Buffer) dec_proto3_int64(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tword64Val_Set(structPointer_Word64Val(base, p.field), o, u)\n-\treturn nil\n-}\n-\n-// Decode a string.\n-func (o *Buffer) dec_string(p *Properties, base structPointer) error {\n-\ts, err := o.DecodeStringBytes()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t*structPointer_String(base, p.field) = &s\n-\treturn nil\n-}\n-\n-func (o *Buffer) dec_proto3_string(p *Properties, base structPointer) error {\n-\ts, err := o.DecodeStringBytes()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t*structPointer_StringVal(base, p.field) = s\n-\treturn nil\n-}\n-\n-// Decode a slice of bytes ([]byte).\n-func (o *Buffer) dec_slice_byte(p *Properties, base structPointer) error {\n-\tb, err := o.DecodeRawBytes(true)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t*structPointer_Bytes(base, p.field) = b\n-\treturn nil\n-}\n-\n-// Decode a slice of bools ([]bool).\n-func (o *Buffer) dec_slice_bool(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tv := structPointer_BoolSlice(base, p.field)\n-\t*v = append(*v, u != 0)\n-\treturn nil\n-}\n-\n-// Decode a slice of bools ([]bool) in packed format.\n-func (o *Buffer) dec_slice_packed_bool(p *Properties, base structPointer) error {\n-\tv := structPointer_BoolSlice(base, p.field)\n-\n-\tnn, err := o.DecodeVarint()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tnb := int(nn) // number of bytes of encoded bools\n-\tfin := o.index + nb\n-\tif fin < o.index {\n-\t\treturn errOverflow\n-\t}\n-\n-\ty := *v\n-\tfor o.index < fin {\n-\t\tu, err := p.valDec(o)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\ty = append(y, u != 0)\n-\t}\n-\n-\t*v = y\n-\treturn nil\n-}\n-\n-// Decode a slice of int32s ([]int32).\n-func (o *Buffer) dec_slice_int32(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tstructPointer_Word32Slice(base, p.field).Append(uint32(u))\n-\treturn nil\n-}\n-\n-// Decode a slice of int32s ([]int32) in packed format.\n-func (o *Buffer) dec_slice_packed_int32(p *Properties, base structPointer) error {\n-\tv := structPointer_Word32Slice(base, p.field)\n-\n-\tnn, err := o.DecodeVarint()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tnb := int(nn) // number of bytes of encoded int32s\n-\n-\tfin := o.index + nb\n-\tif fin < o.index {\n-\t\treturn errOverflow\n-\t}\n-\tfor o.index < fin {\n-\t\tu, err := p.valDec(o)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tv.Append(uint32(u))\n-\t}\n-\treturn nil\n-}\n-\n-// Decode a slice of int64s ([]int64).\n-func (o *Buffer) dec_slice_int64(p *Properties, base structPointer) error {\n-\tu, err := p.valDec(o)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tstructPointer_Word64Slice(base, p.field).Append(u)\n-\treturn nil\n-}\n-\n-// Decode a slice of int64s ([]int64) in packed format.\n-func (o *Buffer) dec_slice_packed_int64(p *Properties, base structPointer) error {\n-\tv := structPointer_Word64Slice(base, p.field)\n-\n-\tnn, err := o.DecodeVarint()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tnb := int(nn) // number of bytes of encoded int64s\n-\n-\tfin := o.index + nb\n-\tif fin < o.index {\n-\t\treturn errOverflow\n-\t}\n-\tfor o.index < fin {\n-\t\tu, err := p.valDec(o)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tv.Append(u)\n-\t}\n-\treturn nil\n-}\n-\n-// Decode a slice of strings ([]string).\n-func (o *Buffer) dec_slice_string(p *Properties, base structPointer) error {\n-\ts, err := o.DecodeStringBytes()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tv := structPointer_StringSlice(base, p.field)\n-\t*v = append(*v, s)\n-\treturn nil\n-}\n-\n-// Decode a slice of slice of bytes ([][]byte).\n-func (o *Buffer) dec_slice_slice_byte(p *Properties, base structPointer) error {\n-\tb, err := o.DecodeRawBytes(true)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tv := structPointer_BytesSlice(base, p.field)\n-\t*v = append(*v, b)\n-\treturn nil\n-}\n-\n-// Decode a map field.\n-func (o *Buffer) dec_new_map(p *Properties, base structPointer) error {\n-\traw, err := o.DecodeRawBytes(false)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\toi := o.index       // index at the end of this map entry\n-\to.index -= len(raw) // move buffer back to start of map entry\n-\n-\tmptr := structPointer_NewAt(base, p.field, p.mtype) // *map[K]V\n-\tif mptr.Elem().IsNil() {\n-\t\tmptr.Elem().Set(reflect.MakeMap(mptr.Type().Elem()))\n-\t}\n-\tv := mptr.Elem() // map[K]V\n-\n-\t// Prepare addressable doubly-indirect placeholders for the key and value types.\n-\t// See enc_new_map for why.\n-\tkeyptr := reflect.New(reflect.PtrTo(p.mtype.Key())).Elem() // addressable *K\n-\tkeybase := toStructPointer(keyptr.Addr())                  // **K\n-\n-\tvar valbase structPointer\n-\tvar valptr reflect.Value\n-\tswitch p.mtype.Elem().Kind() {\n-\tcase reflect.Slice:\n-\t\t// []byte\n-\t\tvar dummy []byte\n-\t\tvalptr = reflect.ValueOf(&dummy)  // *[]byte\n-\t\tvalbase = toStructPointer(valptr) // *[]byte\n-\tcase reflect.Ptr:\n-\t\t// message; valptr is **Msg; need to allocate the intermediate pointer\n-\t\tvalptr = reflect.New(reflect.PtrTo(p.mtype.Elem())).Elem() // addressable *V\n-\t\tvalptr.Set(reflect.New(valptr.Type().Elem()))\n-\t\tvalbase = toStructPointer(valptr)\n-\tdefault:\n-\t\t// everything else\n-\t\tvalptr = reflect.New(reflect.PtrTo(p.mtype.Elem())).Elem() // addressable *V\n-\t\tvalbase = toStructPointer(valptr.Addr())                   // **V\n-\t}\n-\n-\t// Decode.\n-\t// This parses a restricted wire format, namely the encoding of a message\n-\t// with two fields. See enc_new_map for the format.\n-\tfor o.index < oi {\n-\t\t// tagcode for key and value properties are always a single byte\n-\t\t// because they have tags 1 and 2.\n-\t\ttagcode := o.buf[o.index]\n-\t\to.index++\n-\t\tswitch tagcode {\n-\t\tcase p.mkeyprop.tagcode[0]:\n-\t\t\tif err := p.mkeyprop.dec(o, p.mkeyprop, keybase); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\tcase p.mvalprop.tagcode[0]:\n-\t\t\tif err := p.mvalprop.dec(o, p.mvalprop, valbase); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\tdefault:\n-\t\t\t// TODO: Should we silently skip this instead?\n-\t\t\treturn fmt.Errorf(\"proto: bad map data tag %d\", raw[0])\n-\t\t}\n-\t}\n-\tkeyelem, valelem := keyptr.Elem(), valptr.Elem()\n-\tif !keyelem.IsValid() {\n-\t\tkeyelem = reflect.Zero(p.mtype.Key())\n-\t}\n-\tif !valelem.IsValid() {\n-\t\tvalelem = reflect.Zero(p.mtype.Elem())\n-\t}\n-\n-\tv.SetMapIndex(keyelem, valelem)\n-\treturn nil\n-}\n-\n-// Decode a group.\n-func (o *Buffer) dec_struct_group(p *Properties, base structPointer) error {\n-\tbas := structPointer_GetStructPointer(base, p.field)\n-\tif structPointer_IsNil(bas) {\n-\t\t// allocate new nested message\n-\t\tbas = toStructPointer(reflect.New(p.stype))\n-\t\tstructPointer_SetStructPointer(base, p.field, bas)\n-\t}\n-\treturn o.unmarshalType(p.stype, p.sprop, true, bas)\n-}\n-\n-// Decode an embedded message.\n-func (o *Buffer) dec_struct_message(p *Properties, base structPointer) (err error) {\n-\traw, e := o.DecodeRawBytes(false)\n-\tif e != nil {\n-\t\treturn e\n-\t}\n-\n-\tbas := structPointer_GetStructPointer(base, p.field)\n-\tif structPointer_IsNil(bas) {\n-\t\t// allocate new nested message\n-\t\tbas = toStructPointer(reflect.New(p.stype))\n-\t\tstructPointer_SetStructPointer(base, p.field, bas)\n-\t}\n-\n-\t// If the object can unmarshal itself, let it.\n-\tif p.isUnmarshaler {\n-\t\tiv := structPointer_Interface(bas, p.stype)\n-\t\treturn iv.(Unmarshaler).Unmarshal(raw)\n-\t}\n-\n-\tobuf := o.buf\n-\toi := o.index\n-\to.buf = raw\n-\to.index = 0\n-\n-\terr = o.unmarshalType(p.stype, p.sprop, false, bas)\n-\to.buf = obuf\n-\to.index = oi\n-\n-\treturn err\n-}\n-\n-// Decode a slice of embedded messages.\n-func (o *Buffer) dec_slice_struct_message(p *Properties, base structPointer) error {\n-\treturn o.dec_slice_struct(p, false, base)\n-}\n-\n-// Decode a slice of embedded groups.\n-func (o *Buffer) dec_slice_struct_group(p *Properties, base structPointer) error {\n-\treturn o.dec_slice_struct(p, true, base)\n-}\n-\n-// Decode a slice of structs ([]*struct).\n-func (o *Buffer) dec_slice_struct(p *Properties, is_group bool, base structPointer) error {\n-\tv := reflect.New(p.stype)\n-\tbas := toStructPointer(v)\n-\tstructPointer_StructPointerSlice(base, p.field).Append(bas)\n-\n-\tif is_group {\n-\t\terr := o.unmarshalType(p.stype, p.sprop, is_group, bas)\n-\t\treturn err\n-\t}\n-\n-\traw, err := o.DecodeRawBytes(false)\n-\tif err != nil {\n+\tif u, ok := pb.(Unmarshaler); ok {\n+\t\t// NOTE: The history of proto have unfortunately been inconsistent\n+\t\t// whether Unmarshaler should or should not implicitly clear itself.\n+\t\t// Some implementations do, most do not.\n+\t\t// Thus, calling this here may or may not do what people want.\n+\t\t//\n+\t\t// See https://github.com/golang/protobuf/issues/424\n+\t\terr := u.Unmarshal(p.buf[p.index:])\n+\t\tp.index = len(p.buf)\n \t\treturn err\n \t}\n \n-\t// If the object can unmarshal itself, let it.\n-\tif p.isUnmarshaler {\n-\t\tiv := v.Interface()\n-\t\treturn iv.(Unmarshaler).Unmarshal(raw)\n-\t}\n-\n-\tobuf := o.buf\n-\toi := o.index\n-\to.buf = raw\n-\to.index = 0\n-\n-\terr = o.unmarshalType(p.stype, p.sprop, is_group, bas)\n-\n-\to.buf = obuf\n-\to.index = oi\n-\n+\t// Slow workaround for messages that aren't Unmarshalers.\n+\t// This includes some hand-coded .pb.go files and\n+\t// bootstrap protos.\n+\t// TODO: fix all of those and then add Unmarshal to\n+\t// the Message interface. Then:\n+\t// The cast above and code below can be deleted.\n+\t// The old unmarshaler can be deleted.\n+\t// Clients can call Unmarshal directly (can already do that, actually).\n+\tvar info InternalMessageInfo\n+\terr := info.Unmarshal(pb, p.buf[p.index:])\n+\tp.index = len(p.buf)\n \treturn err\n }"
    },
    {
      "sha": "dea2617ced346ec98565c75713bbf71a0ffd0254",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/discard.go",
      "status": "modified",
      "additions": 200,
      "deletions": 1,
      "changes": 201,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/discard.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/discard.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/discard.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -35,8 +35,14 @@ import (\n \t\"fmt\"\n \t\"reflect\"\n \t\"strings\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n )\n \n+type generatedDiscarder interface {\n+\tXXX_DiscardUnknown()\n+}\n+\n // DiscardUnknown recursively discards all unknown fields from this message\n // and all embedded messages.\n //\n@@ -49,9 +55,202 @@ import (\n // For proto2 messages, the unknown fields of message extensions are only\n // discarded from messages that have been accessed via GetExtension.\n func DiscardUnknown(m Message) {\n+\tif m, ok := m.(generatedDiscarder); ok {\n+\t\tm.XXX_DiscardUnknown()\n+\t\treturn\n+\t}\n+\t// TODO: Dynamically populate a InternalMessageInfo for legacy messages,\n+\t// but the master branch has no implementation for InternalMessageInfo,\n+\t// so it would be more work to replicate that approach.\n \tdiscardLegacy(m)\n }\n \n+// DiscardUnknown recursively discards all unknown fields.\n+func (a *InternalMessageInfo) DiscardUnknown(m Message) {\n+\tdi := atomicLoadDiscardInfo(&a.discard)\n+\tif di == nil {\n+\t\tdi = getDiscardInfo(reflect.TypeOf(m).Elem())\n+\t\tatomicStoreDiscardInfo(&a.discard, di)\n+\t}\n+\tdi.discard(toPointer(&m))\n+}\n+\n+type discardInfo struct {\n+\ttyp reflect.Type\n+\n+\tinitialized int32 // 0: only typ is valid, 1: everything is valid\n+\tlock        sync.Mutex\n+\n+\tfields       []discardFieldInfo\n+\tunrecognized field\n+}\n+\n+type discardFieldInfo struct {\n+\tfield   field // Offset of field, guaranteed to be valid\n+\tdiscard func(src pointer)\n+}\n+\n+var (\n+\tdiscardInfoMap  = map[reflect.Type]*discardInfo{}\n+\tdiscardInfoLock sync.Mutex\n+)\n+\n+func getDiscardInfo(t reflect.Type) *discardInfo {\n+\tdiscardInfoLock.Lock()\n+\tdefer discardInfoLock.Unlock()\n+\tdi := discardInfoMap[t]\n+\tif di == nil {\n+\t\tdi = &discardInfo{typ: t}\n+\t\tdiscardInfoMap[t] = di\n+\t}\n+\treturn di\n+}\n+\n+func (di *discardInfo) discard(src pointer) {\n+\tif src.isNil() {\n+\t\treturn // Nothing to do.\n+\t}\n+\n+\tif atomic.LoadInt32(&di.initialized) == 0 {\n+\t\tdi.computeDiscardInfo()\n+\t}\n+\n+\tfor _, fi := range di.fields {\n+\t\tsfp := src.offset(fi.field)\n+\t\tfi.discard(sfp)\n+\t}\n+\n+\t// For proto2 messages, only discard unknown fields in message extensions\n+\t// that have been accessed via GetExtension.\n+\tif em, err := extendable(src.asPointerTo(di.typ).Interface()); err == nil {\n+\t\t// Ignore lock since DiscardUnknown is not concurrency safe.\n+\t\temm, _ := em.extensionsRead()\n+\t\tfor _, mx := range emm {\n+\t\t\tif m, ok := mx.value.(Message); ok {\n+\t\t\t\tDiscardUnknown(m)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif di.unrecognized.IsValid() {\n+\t\t*src.offset(di.unrecognized).toBytes() = nil\n+\t}\n+}\n+\n+func (di *discardInfo) computeDiscardInfo() {\n+\tdi.lock.Lock()\n+\tdefer di.lock.Unlock()\n+\tif di.initialized != 0 {\n+\t\treturn\n+\t}\n+\tt := di.typ\n+\tn := t.NumField()\n+\n+\tfor i := 0; i < n; i++ {\n+\t\tf := t.Field(i)\n+\t\tif strings.HasPrefix(f.Name, \"XXX_\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tdfi := discardFieldInfo{field: toField(&f)}\n+\t\ttf := f.Type\n+\n+\t\t// Unwrap tf to get its most basic type.\n+\t\tvar isPointer, isSlice bool\n+\t\tif tf.Kind() == reflect.Slice && tf.Elem().Kind() != reflect.Uint8 {\n+\t\t\tisSlice = true\n+\t\t\ttf = tf.Elem()\n+\t\t}\n+\t\tif tf.Kind() == reflect.Ptr {\n+\t\t\tisPointer = true\n+\t\t\ttf = tf.Elem()\n+\t\t}\n+\t\tif isPointer && isSlice && tf.Kind() != reflect.Struct {\n+\t\t\tpanic(fmt.Sprintf(\"%v.%s cannot be a slice of pointers to primitive types\", t, f.Name))\n+\t\t}\n+\n+\t\tswitch tf.Kind() {\n+\t\tcase reflect.Struct:\n+\t\t\tswitch {\n+\t\t\tcase !isPointer:\n+\t\t\t\tpanic(fmt.Sprintf(\"%v.%s cannot be a direct struct value\", t, f.Name))\n+\t\t\tcase isSlice: // E.g., []*pb.T\n+\t\t\t\tdi := getDiscardInfo(tf)\n+\t\t\t\tdfi.discard = func(src pointer) {\n+\t\t\t\t\tsps := src.getPointerSlice()\n+\t\t\t\t\tfor _, sp := range sps {\n+\t\t\t\t\t\tif !sp.isNil() {\n+\t\t\t\t\t\t\tdi.discard(sp)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., *pb.T\n+\t\t\t\tdi := getDiscardInfo(tf)\n+\t\t\t\tdfi.discard = func(src pointer) {\n+\t\t\t\t\tsp := src.getPointer()\n+\t\t\t\t\tif !sp.isNil() {\n+\t\t\t\t\t\tdi.discard(sp)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Map:\n+\t\t\tswitch {\n+\t\t\tcase isPointer || isSlice:\n+\t\t\t\tpanic(fmt.Sprintf(\"%v.%s cannot be a pointer to a map or a slice of map values\", t, f.Name))\n+\t\t\tdefault: // E.g., map[K]V\n+\t\t\t\tif tf.Elem().Kind() == reflect.Ptr { // Proto struct (e.g., *T)\n+\t\t\t\t\tdfi.discard = func(src pointer) {\n+\t\t\t\t\t\tsm := src.asPointerTo(tf).Elem()\n+\t\t\t\t\t\tif sm.Len() == 0 {\n+\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tfor _, key := range sm.MapKeys() {\n+\t\t\t\t\t\t\tval := sm.MapIndex(key)\n+\t\t\t\t\t\t\tDiscardUnknown(val.Interface().(Message))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tdfi.discard = func(pointer) {} // Noop\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Interface:\n+\t\t\t// Must be oneof field.\n+\t\t\tswitch {\n+\t\t\tcase isPointer || isSlice:\n+\t\t\t\tpanic(fmt.Sprintf(\"%v.%s cannot be a pointer to a interface or a slice of interface values\", t, f.Name))\n+\t\t\tdefault: // E.g., interface{}\n+\t\t\t\t// TODO: Make this faster?\n+\t\t\t\tdfi.discard = func(src pointer) {\n+\t\t\t\t\tsu := src.asPointerTo(tf).Elem()\n+\t\t\t\t\tif !su.IsNil() {\n+\t\t\t\t\t\tsv := su.Elem().Elem().Field(0)\n+\t\t\t\t\t\tif sv.Kind() == reflect.Ptr && sv.IsNil() {\n+\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tswitch sv.Type().Kind() {\n+\t\t\t\t\t\tcase reflect.Ptr: // Proto struct (e.g., *T)\n+\t\t\t\t\t\t\tDiscardUnknown(sv.Interface().(Message))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tcontinue\n+\t\t}\n+\t\tdi.fields = append(di.fields, dfi)\n+\t}\n+\n+\tdi.unrecognized = invalidField\n+\tif f, ok := t.FieldByName(\"XXX_unrecognized\"); ok {\n+\t\tif f.Type != reflect.TypeOf([]byte{}) {\n+\t\t\tpanic(\"expected XXX_unrecognized to be of type []byte\")\n+\t\t}\n+\t\tdi.unrecognized = toField(&f)\n+\t}\n+\n+\tatomic.StoreInt32(&di.initialized, 1)\n+}\n+\n func discardLegacy(m Message) {\n \tv := reflect.ValueOf(m)\n \tif v.Kind() != reflect.Ptr || v.IsNil() {\n@@ -139,7 +338,7 @@ func discardLegacy(m Message) {\n \n \t// For proto2 messages, only discard unknown fields in message extensions\n \t// that have been accessed via GetExtension.\n-\tif em, ok := extendable(m); ok {\n+\tif em, err := extendable(m); err == nil {\n \t\t// Ignore lock since discardLegacy is not concurrency safe.\n \t\temm, _ := em.extensionsRead()\n \t\tfor _, mx := range emm {"
    },
    {
      "sha": "3abfed2cff04bdf3bb72517b6f1807b82a151570",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/encode.go",
      "status": "modified",
      "additions": 25,
      "deletions": 1184,
      "changes": 1209,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/encode.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/encode.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/encode.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -37,28 +37,9 @@ package proto\n \n import (\n \t\"errors\"\n-\t\"fmt\"\n \t\"reflect\"\n-\t\"sort\"\n )\n \n-// RequiredNotSetError is the error returned if Marshal is called with\n-// a protocol buffer struct whose required fields have not\n-// all been initialized. It is also the error returned if Unmarshal is\n-// called with an encoded protocol buffer that does not include all the\n-// required fields.\n-//\n-// When printed, RequiredNotSetError reports the first unset required field in a\n-// message. If the field cannot be precisely determined, it is reported as\n-// \"{Unknown}\".\n-type RequiredNotSetError struct {\n-\tfield string\n-}\n-\n-func (e *RequiredNotSetError) Error() string {\n-\treturn fmt.Sprintf(\"proto: required field %q not set\", e.field)\n-}\n-\n var (\n \t// errRepeatedHasNil is the error returned if Marshal is called with\n \t// a struct with a repeated field containing a nil element.\n@@ -82,10 +63,6 @@ var (\n \n const maxVarintBytes = 10 // maximum length of a varint\n \n-// maxMarshalSize is the largest allowed size of an encoded protobuf,\n-// since C++ and Java use signed int32s for the size.\n-const maxMarshalSize = 1<<31 - 1\n-\n // EncodeVarint returns the varint encoding of x.\n // This is the format for the\n // int32, int64, uint32, uint64, bool, and enum\n@@ -119,18 +96,27 @@ func (p *Buffer) EncodeVarint(x uint64) error {\n \n // SizeVarint returns the varint encoding size of an integer.\n func SizeVarint(x uint64) int {\n-\treturn sizeVarint(x)\n-}\n-\n-func sizeVarint(x uint64) (n int) {\n-\tfor {\n-\t\tn++\n-\t\tx >>= 7\n-\t\tif x == 0 {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\treturn n\n+\tswitch {\n+\tcase x < 1<<7:\n+\t\treturn 1\n+\tcase x < 1<<14:\n+\t\treturn 2\n+\tcase x < 1<<21:\n+\t\treturn 3\n+\tcase x < 1<<28:\n+\t\treturn 4\n+\tcase x < 1<<35:\n+\t\treturn 5\n+\tcase x < 1<<42:\n+\t\treturn 6\n+\tcase x < 1<<49:\n+\t\treturn 7\n+\tcase x < 1<<56:\n+\t\treturn 8\n+\tcase x < 1<<63:\n+\t\treturn 9\n+\t}\n+\treturn 10\n }\n \n // EncodeFixed64 writes a 64-bit integer to the Buffer.\n@@ -149,10 +135,6 @@ func (p *Buffer) EncodeFixed64(x uint64) error {\n \treturn nil\n }\n \n-func sizeFixed64(x uint64) int {\n-\treturn 8\n-}\n-\n // EncodeFixed32 writes a 32-bit integer to the Buffer.\n // This is the format for the\n // fixed32, sfixed32, and float protocol buffer types.\n@@ -165,20 +147,12 @@ func (p *Buffer) EncodeFixed32(x uint64) error {\n \treturn nil\n }\n \n-func sizeFixed32(x uint64) int {\n-\treturn 4\n-}\n-\n // EncodeZigzag64 writes a zigzag-encoded 64-bit integer\n // to the Buffer.\n // This is the format used for the sint64 protocol buffer type.\n func (p *Buffer) EncodeZigzag64(x uint64) error {\n \t// use signed number to get arithmetic right shift.\n-\treturn p.EncodeVarint((x << 1) ^ uint64((int64(x) >> 63)))\n-}\n-\n-func sizeZigzag64(x uint64) int {\n-\treturn sizeVarint((x << 1) ^ uint64((int64(x) >> 63)))\n+\treturn p.EncodeVarint(uint64((x << 1) ^ uint64((int64(x) >> 63))))\n }\n \n // EncodeZigzag32 writes a zigzag-encoded 32-bit integer\n@@ -189,10 +163,6 @@ func (p *Buffer) EncodeZigzag32(x uint64) error {\n \treturn p.EncodeVarint(uint64((uint32(x) << 1) ^ uint32((int32(x) >> 31))))\n }\n \n-func sizeZigzag32(x uint64) int {\n-\treturn sizeVarint(uint64((uint32(x) << 1) ^ uint32((int32(x) >> 31))))\n-}\n-\n // EncodeRawBytes writes a count-delimited byte buffer to the Buffer.\n // This is the format used for the bytes protocol buffer\n // type and for embedded messages.\n@@ -202,11 +172,6 @@ func (p *Buffer) EncodeRawBytes(b []byte) error {\n \treturn nil\n }\n \n-func sizeRawBytes(b []byte) int {\n-\treturn sizeVarint(uint64(len(b))) +\n-\t\tlen(b)\n-}\n-\n // EncodeStringBytes writes an encoded string to the Buffer.\n // This is the format used for the proto2 string type.\n func (p *Buffer) EncodeStringBytes(s string) error {\n@@ -215,319 +180,17 @@ func (p *Buffer) EncodeStringBytes(s string) error {\n \treturn nil\n }\n \n-func sizeStringBytes(s string) int {\n-\treturn sizeVarint(uint64(len(s))) +\n-\t\tlen(s)\n-}\n-\n // Marshaler is the interface representing objects that can marshal themselves.\n type Marshaler interface {\n \tMarshal() ([]byte, error)\n }\n \n-// Marshal takes the protocol buffer\n-// and encodes it into the wire format, returning the data.\n-func Marshal(pb Message) ([]byte, error) {\n-\t// Can the object marshal itself?\n-\tif m, ok := pb.(Marshaler); ok {\n-\t\treturn m.Marshal()\n-\t}\n-\tp := NewBuffer(nil)\n-\terr := p.Marshal(pb)\n-\tif p.buf == nil && err == nil {\n-\t\t// Return a non-nil slice on success.\n-\t\treturn []byte{}, nil\n-\t}\n-\treturn p.buf, err\n-}\n-\n // EncodeMessage writes the protocol buffer to the Buffer,\n // prefixed by a varint-encoded length.\n func (p *Buffer) EncodeMessage(pb Message) error {\n-\tt, base, err := getbase(pb)\n-\tif structPointer_IsNil(base) {\n-\t\treturn ErrNil\n-\t}\n-\tif err == nil {\n-\t\tvar state errorState\n-\t\terr = p.enc_len_struct(GetProperties(t.Elem()), base, &state)\n-\t}\n-\treturn err\n-}\n-\n-// Marshal takes the protocol buffer\n-// and encodes it into the wire format, writing the result to the\n-// Buffer.\n-func (p *Buffer) Marshal(pb Message) error {\n-\t// Can the object marshal itself?\n-\tif m, ok := pb.(Marshaler); ok {\n-\t\tdata, err := m.Marshal()\n-\t\tp.buf = append(p.buf, data...)\n-\t\treturn err\n-\t}\n-\n-\tt, base, err := getbase(pb)\n-\tif structPointer_IsNil(base) {\n-\t\treturn ErrNil\n-\t}\n-\tif err == nil {\n-\t\terr = p.enc_struct(GetProperties(t.Elem()), base)\n-\t}\n-\n-\tif collectStats {\n-\t\t(stats).Encode++ // Parens are to work around a goimports bug.\n-\t}\n-\n-\tif len(p.buf) > maxMarshalSize {\n-\t\treturn ErrTooLarge\n-\t}\n-\treturn err\n-}\n-\n-// Size returns the encoded size of a protocol buffer.\n-func Size(pb Message) (n int) {\n-\t// Can the object marshal itself?  If so, Size is slow.\n-\t// TODO: add Size to Marshaler, or add a Sizer interface.\n-\tif m, ok := pb.(Marshaler); ok {\n-\t\tb, _ := m.Marshal()\n-\t\treturn len(b)\n-\t}\n-\n-\tt, base, err := getbase(pb)\n-\tif structPointer_IsNil(base) {\n-\t\treturn 0\n-\t}\n-\tif err == nil {\n-\t\tn = size_struct(GetProperties(t.Elem()), base)\n-\t}\n-\n-\tif collectStats {\n-\t\t(stats).Size++ // Parens are to work around a goimports bug.\n-\t}\n-\n-\treturn\n-}\n-\n-// Individual type encoders.\n-\n-// Encode a bool.\n-func (o *Buffer) enc_bool(p *Properties, base structPointer) error {\n-\tv := *structPointer_Bool(base, p.field)\n-\tif v == nil {\n-\t\treturn ErrNil\n-\t}\n-\tx := 0\n-\tif *v {\n-\t\tx = 1\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, uint64(x))\n-\treturn nil\n-}\n-\n-func (o *Buffer) enc_proto3_bool(p *Properties, base structPointer) error {\n-\tv := *structPointer_BoolVal(base, p.field)\n-\tif !v {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, 1)\n-\treturn nil\n-}\n-\n-func size_bool(p *Properties, base structPointer) int {\n-\tv := *structPointer_Bool(base, p.field)\n-\tif v == nil {\n-\t\treturn 0\n-\t}\n-\treturn len(p.tagcode) + 1 // each bool takes exactly one byte\n-}\n-\n-func size_proto3_bool(p *Properties, base structPointer) int {\n-\tv := *structPointer_BoolVal(base, p.field)\n-\tif !v && !p.oneof {\n-\t\treturn 0\n-\t}\n-\treturn len(p.tagcode) + 1 // each bool takes exactly one byte\n-}\n-\n-// Encode an int32.\n-func (o *Buffer) enc_int32(p *Properties, base structPointer) error {\n-\tv := structPointer_Word32(base, p.field)\n-\tif word32_IsNil(v) {\n-\t\treturn ErrNil\n-\t}\n-\tx := int32(word32_Get(v)) // permit sign extension to use full 64-bit range\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, uint64(x))\n-\treturn nil\n-}\n-\n-func (o *Buffer) enc_proto3_int32(p *Properties, base structPointer) error {\n-\tv := structPointer_Word32Val(base, p.field)\n-\tx := int32(word32Val_Get(v)) // permit sign extension to use full 64-bit range\n-\tif x == 0 {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, uint64(x))\n-\treturn nil\n-}\n-\n-func size_int32(p *Properties, base structPointer) (n int) {\n-\tv := structPointer_Word32(base, p.field)\n-\tif word32_IsNil(v) {\n-\t\treturn 0\n-\t}\n-\tx := int32(word32_Get(v)) // permit sign extension to use full 64-bit range\n-\tn += len(p.tagcode)\n-\tn += p.valSize(uint64(x))\n-\treturn\n-}\n-\n-func size_proto3_int32(p *Properties, base structPointer) (n int) {\n-\tv := structPointer_Word32Val(base, p.field)\n-\tx := int32(word32Val_Get(v)) // permit sign extension to use full 64-bit range\n-\tif x == 0 && !p.oneof {\n-\t\treturn 0\n-\t}\n-\tn += len(p.tagcode)\n-\tn += p.valSize(uint64(x))\n-\treturn\n-}\n-\n-// Encode a uint32.\n-// Exactly the same as int32, except for no sign extension.\n-func (o *Buffer) enc_uint32(p *Properties, base structPointer) error {\n-\tv := structPointer_Word32(base, p.field)\n-\tif word32_IsNil(v) {\n-\t\treturn ErrNil\n-\t}\n-\tx := word32_Get(v)\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, uint64(x))\n-\treturn nil\n-}\n-\n-func (o *Buffer) enc_proto3_uint32(p *Properties, base structPointer) error {\n-\tv := structPointer_Word32Val(base, p.field)\n-\tx := word32Val_Get(v)\n-\tif x == 0 {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, uint64(x))\n-\treturn nil\n-}\n-\n-func size_uint32(p *Properties, base structPointer) (n int) {\n-\tv := structPointer_Word32(base, p.field)\n-\tif word32_IsNil(v) {\n-\t\treturn 0\n-\t}\n-\tx := word32_Get(v)\n-\tn += len(p.tagcode)\n-\tn += p.valSize(uint64(x))\n-\treturn\n-}\n-\n-func size_proto3_uint32(p *Properties, base structPointer) (n int) {\n-\tv := structPointer_Word32Val(base, p.field)\n-\tx := word32Val_Get(v)\n-\tif x == 0 && !p.oneof {\n-\t\treturn 0\n-\t}\n-\tn += len(p.tagcode)\n-\tn += p.valSize(uint64(x))\n-\treturn\n-}\n-\n-// Encode an int64.\n-func (o *Buffer) enc_int64(p *Properties, base structPointer) error {\n-\tv := structPointer_Word64(base, p.field)\n-\tif word64_IsNil(v) {\n-\t\treturn ErrNil\n-\t}\n-\tx := word64_Get(v)\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, x)\n-\treturn nil\n-}\n-\n-func (o *Buffer) enc_proto3_int64(p *Properties, base structPointer) error {\n-\tv := structPointer_Word64Val(base, p.field)\n-\tx := word64Val_Get(v)\n-\tif x == 0 {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\tp.valEnc(o, x)\n-\treturn nil\n-}\n-\n-func size_int64(p *Properties, base structPointer) (n int) {\n-\tv := structPointer_Word64(base, p.field)\n-\tif word64_IsNil(v) {\n-\t\treturn 0\n-\t}\n-\tx := word64_Get(v)\n-\tn += len(p.tagcode)\n-\tn += p.valSize(x)\n-\treturn\n-}\n-\n-func size_proto3_int64(p *Properties, base structPointer) (n int) {\n-\tv := structPointer_Word64Val(base, p.field)\n-\tx := word64Val_Get(v)\n-\tif x == 0 && !p.oneof {\n-\t\treturn 0\n-\t}\n-\tn += len(p.tagcode)\n-\tn += p.valSize(x)\n-\treturn\n-}\n-\n-// Encode a string.\n-func (o *Buffer) enc_string(p *Properties, base structPointer) error {\n-\tv := *structPointer_String(base, p.field)\n-\tif v == nil {\n-\t\treturn ErrNil\n-\t}\n-\tx := *v\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeStringBytes(x)\n-\treturn nil\n-}\n-\n-func (o *Buffer) enc_proto3_string(p *Properties, base structPointer) error {\n-\tv := *structPointer_StringVal(base, p.field)\n-\tif v == \"\" {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeStringBytes(v)\n-\treturn nil\n-}\n-\n-func size_string(p *Properties, base structPointer) (n int) {\n-\tv := *structPointer_String(base, p.field)\n-\tif v == nil {\n-\t\treturn 0\n-\t}\n-\tx := *v\n-\tn += len(p.tagcode)\n-\tn += sizeStringBytes(x)\n-\treturn\n-}\n-\n-func size_proto3_string(p *Properties, base structPointer) (n int) {\n-\tv := *structPointer_StringVal(base, p.field)\n-\tif v == \"\" && !p.oneof {\n-\t\treturn 0\n-\t}\n-\tn += len(p.tagcode)\n-\tn += sizeStringBytes(v)\n-\treturn\n+\tsiz := Size(pb)\n+\tp.EncodeVarint(uint64(siz))\n+\treturn p.Marshal(pb)\n }\n \n // All protocol buffer fields are nillable, but be careful.\n@@ -538,825 +201,3 @@ func isNil(v reflect.Value) bool {\n \t}\n \treturn false\n }\n-\n-// Encode a message struct.\n-func (o *Buffer) enc_struct_message(p *Properties, base structPointer) error {\n-\tvar state errorState\n-\tstructp := structPointer_GetStructPointer(base, p.field)\n-\tif structPointer_IsNil(structp) {\n-\t\treturn ErrNil\n-\t}\n-\n-\t// Can the object marshal itself?\n-\tif p.isMarshaler {\n-\t\tm := structPointer_Interface(structp, p.stype).(Marshaler)\n-\t\tdata, err := m.Marshal()\n-\t\tif err != nil && !state.shouldContinue(err, nil) {\n-\t\t\treturn err\n-\t\t}\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\to.EncodeRawBytes(data)\n-\t\treturn state.err\n-\t}\n-\n-\to.buf = append(o.buf, p.tagcode...)\n-\treturn o.enc_len_struct(p.sprop, structp, &state)\n-}\n-\n-func size_struct_message(p *Properties, base structPointer) int {\n-\tstructp := structPointer_GetStructPointer(base, p.field)\n-\tif structPointer_IsNil(structp) {\n-\t\treturn 0\n-\t}\n-\n-\t// Can the object marshal itself?\n-\tif p.isMarshaler {\n-\t\tm := structPointer_Interface(structp, p.stype).(Marshaler)\n-\t\tdata, _ := m.Marshal()\n-\t\tn0 := len(p.tagcode)\n-\t\tn1 := sizeRawBytes(data)\n-\t\treturn n0 + n1\n-\t}\n-\n-\tn0 := len(p.tagcode)\n-\tn1 := size_struct(p.sprop, structp)\n-\tn2 := sizeVarint(uint64(n1)) // size of encoded length\n-\treturn n0 + n1 + n2\n-}\n-\n-// Encode a group struct.\n-func (o *Buffer) enc_struct_group(p *Properties, base structPointer) error {\n-\tvar state errorState\n-\tb := structPointer_GetStructPointer(base, p.field)\n-\tif structPointer_IsNil(b) {\n-\t\treturn ErrNil\n-\t}\n-\n-\to.EncodeVarint(uint64((p.Tag << 3) | WireStartGroup))\n-\terr := o.enc_struct(p.sprop, b)\n-\tif err != nil && !state.shouldContinue(err, nil) {\n-\t\treturn err\n-\t}\n-\to.EncodeVarint(uint64((p.Tag << 3) | WireEndGroup))\n-\treturn state.err\n-}\n-\n-func size_struct_group(p *Properties, base structPointer) (n int) {\n-\tb := structPointer_GetStructPointer(base, p.field)\n-\tif structPointer_IsNil(b) {\n-\t\treturn 0\n-\t}\n-\n-\tn += sizeVarint(uint64((p.Tag << 3) | WireStartGroup))\n-\tn += size_struct(p.sprop, b)\n-\tn += sizeVarint(uint64((p.Tag << 3) | WireEndGroup))\n-\treturn\n-}\n-\n-// Encode a slice of bools ([]bool).\n-func (o *Buffer) enc_slice_bool(p *Properties, base structPointer) error {\n-\ts := *structPointer_BoolSlice(base, p.field)\n-\tl := len(s)\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\tfor _, x := range s {\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\tv := uint64(0)\n-\t\tif x {\n-\t\t\tv = 1\n-\t\t}\n-\t\tp.valEnc(o, v)\n-\t}\n-\treturn nil\n-}\n-\n-func size_slice_bool(p *Properties, base structPointer) int {\n-\ts := *structPointer_BoolSlice(base, p.field)\n-\tl := len(s)\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\treturn l * (len(p.tagcode) + 1) // each bool takes exactly one byte\n-}\n-\n-// Encode a slice of bools ([]bool) in packed format.\n-func (o *Buffer) enc_slice_packed_bool(p *Properties, base structPointer) error {\n-\ts := *structPointer_BoolSlice(base, p.field)\n-\tl := len(s)\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeVarint(uint64(l)) // each bool takes exactly one byte\n-\tfor _, x := range s {\n-\t\tv := uint64(0)\n-\t\tif x {\n-\t\t\tv = 1\n-\t\t}\n-\t\tp.valEnc(o, v)\n-\t}\n-\treturn nil\n-}\n-\n-func size_slice_packed_bool(p *Properties, base structPointer) (n int) {\n-\ts := *structPointer_BoolSlice(base, p.field)\n-\tl := len(s)\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tn += len(p.tagcode)\n-\tn += sizeVarint(uint64(l))\n-\tn += l // each bool takes exactly one byte\n-\treturn\n-}\n-\n-// Encode a slice of bytes ([]byte).\n-func (o *Buffer) enc_slice_byte(p *Properties, base structPointer) error {\n-\ts := *structPointer_Bytes(base, p.field)\n-\tif s == nil {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeRawBytes(s)\n-\treturn nil\n-}\n-\n-func (o *Buffer) enc_proto3_slice_byte(p *Properties, base structPointer) error {\n-\ts := *structPointer_Bytes(base, p.field)\n-\tif len(s) == 0 {\n-\t\treturn ErrNil\n-\t}\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeRawBytes(s)\n-\treturn nil\n-}\n-\n-func size_slice_byte(p *Properties, base structPointer) (n int) {\n-\ts := *structPointer_Bytes(base, p.field)\n-\tif s == nil && !p.oneof {\n-\t\treturn 0\n-\t}\n-\tn += len(p.tagcode)\n-\tn += sizeRawBytes(s)\n-\treturn\n-}\n-\n-func size_proto3_slice_byte(p *Properties, base structPointer) (n int) {\n-\ts := *structPointer_Bytes(base, p.field)\n-\tif len(s) == 0 && !p.oneof {\n-\t\treturn 0\n-\t}\n-\tn += len(p.tagcode)\n-\tn += sizeRawBytes(s)\n-\treturn\n-}\n-\n-// Encode a slice of int32s ([]int32).\n-func (o *Buffer) enc_slice_int32(p *Properties, base structPointer) error {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\tfor i := 0; i < l; i++ {\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\tx := int32(s.Index(i)) // permit sign extension to use full 64-bit range\n-\t\tp.valEnc(o, uint64(x))\n-\t}\n-\treturn nil\n-}\n-\n-func size_slice_int32(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tfor i := 0; i < l; i++ {\n-\t\tn += len(p.tagcode)\n-\t\tx := int32(s.Index(i)) // permit sign extension to use full 64-bit range\n-\t\tn += p.valSize(uint64(x))\n-\t}\n-\treturn\n-}\n-\n-// Encode a slice of int32s ([]int32) in packed format.\n-func (o *Buffer) enc_slice_packed_int32(p *Properties, base structPointer) error {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\t// TODO: Reuse a Buffer.\n-\tbuf := NewBuffer(nil)\n-\tfor i := 0; i < l; i++ {\n-\t\tx := int32(s.Index(i)) // permit sign extension to use full 64-bit range\n-\t\tp.valEnc(buf, uint64(x))\n-\t}\n-\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeVarint(uint64(len(buf.buf)))\n-\to.buf = append(o.buf, buf.buf...)\n-\treturn nil\n-}\n-\n-func size_slice_packed_int32(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tvar bufSize int\n-\tfor i := 0; i < l; i++ {\n-\t\tx := int32(s.Index(i)) // permit sign extension to use full 64-bit range\n-\t\tbufSize += p.valSize(uint64(x))\n-\t}\n-\n-\tn += len(p.tagcode)\n-\tn += sizeVarint(uint64(bufSize))\n-\tn += bufSize\n-\treturn\n-}\n-\n-// Encode a slice of uint32s ([]uint32).\n-// Exactly the same as int32, except for no sign extension.\n-func (o *Buffer) enc_slice_uint32(p *Properties, base structPointer) error {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\tfor i := 0; i < l; i++ {\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\tx := s.Index(i)\n-\t\tp.valEnc(o, uint64(x))\n-\t}\n-\treturn nil\n-}\n-\n-func size_slice_uint32(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tfor i := 0; i < l; i++ {\n-\t\tn += len(p.tagcode)\n-\t\tx := s.Index(i)\n-\t\tn += p.valSize(uint64(x))\n-\t}\n-\treturn\n-}\n-\n-// Encode a slice of uint32s ([]uint32) in packed format.\n-// Exactly the same as int32, except for no sign extension.\n-func (o *Buffer) enc_slice_packed_uint32(p *Properties, base structPointer) error {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\t// TODO: Reuse a Buffer.\n-\tbuf := NewBuffer(nil)\n-\tfor i := 0; i < l; i++ {\n-\t\tp.valEnc(buf, uint64(s.Index(i)))\n-\t}\n-\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeVarint(uint64(len(buf.buf)))\n-\to.buf = append(o.buf, buf.buf...)\n-\treturn nil\n-}\n-\n-func size_slice_packed_uint32(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_Word32Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tvar bufSize int\n-\tfor i := 0; i < l; i++ {\n-\t\tbufSize += p.valSize(uint64(s.Index(i)))\n-\t}\n-\n-\tn += len(p.tagcode)\n-\tn += sizeVarint(uint64(bufSize))\n-\tn += bufSize\n-\treturn\n-}\n-\n-// Encode a slice of int64s ([]int64).\n-func (o *Buffer) enc_slice_int64(p *Properties, base structPointer) error {\n-\ts := structPointer_Word64Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\tfor i := 0; i < l; i++ {\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\tp.valEnc(o, s.Index(i))\n-\t}\n-\treturn nil\n-}\n-\n-func size_slice_int64(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_Word64Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tfor i := 0; i < l; i++ {\n-\t\tn += len(p.tagcode)\n-\t\tn += p.valSize(s.Index(i))\n-\t}\n-\treturn\n-}\n-\n-// Encode a slice of int64s ([]int64) in packed format.\n-func (o *Buffer) enc_slice_packed_int64(p *Properties, base structPointer) error {\n-\ts := structPointer_Word64Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\t// TODO: Reuse a Buffer.\n-\tbuf := NewBuffer(nil)\n-\tfor i := 0; i < l; i++ {\n-\t\tp.valEnc(buf, s.Index(i))\n-\t}\n-\n-\to.buf = append(o.buf, p.tagcode...)\n-\to.EncodeVarint(uint64(len(buf.buf)))\n-\to.buf = append(o.buf, buf.buf...)\n-\treturn nil\n-}\n-\n-func size_slice_packed_int64(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_Word64Slice(base, p.field)\n-\tl := s.Len()\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tvar bufSize int\n-\tfor i := 0; i < l; i++ {\n-\t\tbufSize += p.valSize(s.Index(i))\n-\t}\n-\n-\tn += len(p.tagcode)\n-\tn += sizeVarint(uint64(bufSize))\n-\tn += bufSize\n-\treturn\n-}\n-\n-// Encode a slice of slice of bytes ([][]byte).\n-func (o *Buffer) enc_slice_slice_byte(p *Properties, base structPointer) error {\n-\tss := *structPointer_BytesSlice(base, p.field)\n-\tl := len(ss)\n-\tif l == 0 {\n-\t\treturn ErrNil\n-\t}\n-\tfor i := 0; i < l; i++ {\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\to.EncodeRawBytes(ss[i])\n-\t}\n-\treturn nil\n-}\n-\n-func size_slice_slice_byte(p *Properties, base structPointer) (n int) {\n-\tss := *structPointer_BytesSlice(base, p.field)\n-\tl := len(ss)\n-\tif l == 0 {\n-\t\treturn 0\n-\t}\n-\tn += l * len(p.tagcode)\n-\tfor i := 0; i < l; i++ {\n-\t\tn += sizeRawBytes(ss[i])\n-\t}\n-\treturn\n-}\n-\n-// Encode a slice of strings ([]string).\n-func (o *Buffer) enc_slice_string(p *Properties, base structPointer) error {\n-\tss := *structPointer_StringSlice(base, p.field)\n-\tl := len(ss)\n-\tfor i := 0; i < l; i++ {\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\to.EncodeStringBytes(ss[i])\n-\t}\n-\treturn nil\n-}\n-\n-func size_slice_string(p *Properties, base structPointer) (n int) {\n-\tss := *structPointer_StringSlice(base, p.field)\n-\tl := len(ss)\n-\tn += l * len(p.tagcode)\n-\tfor i := 0; i < l; i++ {\n-\t\tn += sizeStringBytes(ss[i])\n-\t}\n-\treturn\n-}\n-\n-// Encode a slice of message structs ([]*struct).\n-func (o *Buffer) enc_slice_struct_message(p *Properties, base structPointer) error {\n-\tvar state errorState\n-\ts := structPointer_StructPointerSlice(base, p.field)\n-\tl := s.Len()\n-\n-\tfor i := 0; i < l; i++ {\n-\t\tstructp := s.Index(i)\n-\t\tif structPointer_IsNil(structp) {\n-\t\t\treturn errRepeatedHasNil\n-\t\t}\n-\n-\t\t// Can the object marshal itself?\n-\t\tif p.isMarshaler {\n-\t\t\tm := structPointer_Interface(structp, p.stype).(Marshaler)\n-\t\t\tdata, err := m.Marshal()\n-\t\t\tif err != nil && !state.shouldContinue(err, nil) {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\to.buf = append(o.buf, p.tagcode...)\n-\t\t\to.EncodeRawBytes(data)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\terr := o.enc_len_struct(p.sprop, structp, &state)\n-\t\tif err != nil && !state.shouldContinue(err, nil) {\n-\t\t\tif err == ErrNil {\n-\t\t\t\treturn errRepeatedHasNil\n-\t\t\t}\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn state.err\n-}\n-\n-func size_slice_struct_message(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_StructPointerSlice(base, p.field)\n-\tl := s.Len()\n-\tn += l * len(p.tagcode)\n-\tfor i := 0; i < l; i++ {\n-\t\tstructp := s.Index(i)\n-\t\tif structPointer_IsNil(structp) {\n-\t\t\treturn // return the size up to this point\n-\t\t}\n-\n-\t\t// Can the object marshal itself?\n-\t\tif p.isMarshaler {\n-\t\t\tm := structPointer_Interface(structp, p.stype).(Marshaler)\n-\t\t\tdata, _ := m.Marshal()\n-\t\t\tn += sizeRawBytes(data)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tn0 := size_struct(p.sprop, structp)\n-\t\tn1 := sizeVarint(uint64(n0)) // size of encoded length\n-\t\tn += n0 + n1\n-\t}\n-\treturn\n-}\n-\n-// Encode a slice of group structs ([]*struct).\n-func (o *Buffer) enc_slice_struct_group(p *Properties, base structPointer) error {\n-\tvar state errorState\n-\ts := structPointer_StructPointerSlice(base, p.field)\n-\tl := s.Len()\n-\n-\tfor i := 0; i < l; i++ {\n-\t\tb := s.Index(i)\n-\t\tif structPointer_IsNil(b) {\n-\t\t\treturn errRepeatedHasNil\n-\t\t}\n-\n-\t\to.EncodeVarint(uint64((p.Tag << 3) | WireStartGroup))\n-\n-\t\terr := o.enc_struct(p.sprop, b)\n-\n-\t\tif err != nil && !state.shouldContinue(err, nil) {\n-\t\t\tif err == ErrNil {\n-\t\t\t\treturn errRepeatedHasNil\n-\t\t\t}\n-\t\t\treturn err\n-\t\t}\n-\n-\t\to.EncodeVarint(uint64((p.Tag << 3) | WireEndGroup))\n-\t}\n-\treturn state.err\n-}\n-\n-func size_slice_struct_group(p *Properties, base structPointer) (n int) {\n-\ts := structPointer_StructPointerSlice(base, p.field)\n-\tl := s.Len()\n-\n-\tn += l * sizeVarint(uint64((p.Tag<<3)|WireStartGroup))\n-\tn += l * sizeVarint(uint64((p.Tag<<3)|WireEndGroup))\n-\tfor i := 0; i < l; i++ {\n-\t\tb := s.Index(i)\n-\t\tif structPointer_IsNil(b) {\n-\t\t\treturn // return size up to this point\n-\t\t}\n-\n-\t\tn += size_struct(p.sprop, b)\n-\t}\n-\treturn\n-}\n-\n-// Encode an extension map.\n-func (o *Buffer) enc_map(p *Properties, base structPointer) error {\n-\texts := structPointer_ExtMap(base, p.field)\n-\tif err := encodeExtensionsMap(*exts); err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn o.enc_map_body(*exts)\n-}\n-\n-func (o *Buffer) enc_exts(p *Properties, base structPointer) error {\n-\texts := structPointer_Extensions(base, p.field)\n-\n-\tv, mu := exts.extensionsRead()\n-\tif v == nil {\n-\t\treturn nil\n-\t}\n-\n-\tmu.Lock()\n-\tdefer mu.Unlock()\n-\tif err := encodeExtensionsMap(v); err != nil {\n-\t\treturn err\n-\t}\n-\n-\treturn o.enc_map_body(v)\n-}\n-\n-func (o *Buffer) enc_map_body(v map[int32]Extension) error {\n-\t// Fast-path for common cases: zero or one extensions.\n-\tif len(v) <= 1 {\n-\t\tfor _, e := range v {\n-\t\t\to.buf = append(o.buf, e.enc...)\n-\t\t}\n-\t\treturn nil\n-\t}\n-\n-\t// Sort keys to provide a deterministic encoding.\n-\tkeys := make([]int, 0, len(v))\n-\tfor k := range v {\n-\t\tkeys = append(keys, int(k))\n-\t}\n-\tsort.Ints(keys)\n-\n-\tfor _, k := range keys {\n-\t\to.buf = append(o.buf, v[int32(k)].enc...)\n-\t}\n-\treturn nil\n-}\n-\n-func size_map(p *Properties, base structPointer) int {\n-\tv := structPointer_ExtMap(base, p.field)\n-\treturn extensionsMapSize(*v)\n-}\n-\n-func size_exts(p *Properties, base structPointer) int {\n-\tv := structPointer_Extensions(base, p.field)\n-\treturn extensionsSize(v)\n-}\n-\n-// Encode a map field.\n-func (o *Buffer) enc_new_map(p *Properties, base structPointer) error {\n-\tvar state errorState // XXX: or do we need to plumb this through?\n-\n-\t/*\n-\t\tA map defined as\n-\t\t\tmap<key_type, value_type> map_field = N;\n-\t\tis encoded in the same way as\n-\t\t\tmessage MapFieldEntry {\n-\t\t\t\tkey_type key = 1;\n-\t\t\t\tvalue_type value = 2;\n-\t\t\t}\n-\t\t\trepeated MapFieldEntry map_field = N;\n-\t*/\n-\n-\tv := structPointer_NewAt(base, p.field, p.mtype).Elem() // map[K]V\n-\tif v.Len() == 0 {\n-\t\treturn nil\n-\t}\n-\n-\tkeycopy, valcopy, keybase, valbase := mapEncodeScratch(p.mtype)\n-\n-\tenc := func() error {\n-\t\tif err := p.mkeyprop.enc(o, p.mkeyprop, keybase); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif err := p.mvalprop.enc(o, p.mvalprop, valbase); err != nil && err != ErrNil {\n-\t\t\treturn err\n-\t\t}\n-\t\treturn nil\n-\t}\n-\n-\t// Don't sort map keys. It is not required by the spec, and C++ doesn't do it.\n-\tfor _, key := range v.MapKeys() {\n-\t\tval := v.MapIndex(key)\n-\n-\t\tkeycopy.Set(key)\n-\t\tvalcopy.Set(val)\n-\n-\t\to.buf = append(o.buf, p.tagcode...)\n-\t\tif err := o.enc_len_thing(enc, &state); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-func size_new_map(p *Properties, base structPointer) int {\n-\tv := structPointer_NewAt(base, p.field, p.mtype).Elem() // map[K]V\n-\n-\tkeycopy, valcopy, keybase, valbase := mapEncodeScratch(p.mtype)\n-\n-\tn := 0\n-\tfor _, key := range v.MapKeys() {\n-\t\tval := v.MapIndex(key)\n-\t\tkeycopy.Set(key)\n-\t\tvalcopy.Set(val)\n-\n-\t\t// Tag codes for key and val are the responsibility of the sub-sizer.\n-\t\tkeysize := p.mkeyprop.size(p.mkeyprop, keybase)\n-\t\tvalsize := p.mvalprop.size(p.mvalprop, valbase)\n-\t\tentry := keysize + valsize\n-\t\t// Add on tag code and length of map entry itself.\n-\t\tn += len(p.tagcode) + sizeVarint(uint64(entry)) + entry\n-\t}\n-\treturn n\n-}\n-\n-// mapEncodeScratch returns a new reflect.Value matching the map's value type,\n-// and a structPointer suitable for passing to an encoder or sizer.\n-func mapEncodeScratch(mapType reflect.Type) (keycopy, valcopy reflect.Value, keybase, valbase structPointer) {\n-\t// Prepare addressable doubly-indirect placeholders for the key and value types.\n-\t// This is needed because the element-type encoders expect **T, but the map iteration produces T.\n-\n-\tkeycopy = reflect.New(mapType.Key()).Elem()                 // addressable K\n-\tkeyptr := reflect.New(reflect.PtrTo(keycopy.Type())).Elem() // addressable *K\n-\tkeyptr.Set(keycopy.Addr())                                  //\n-\tkeybase = toStructPointer(keyptr.Addr())                    // **K\n-\n-\t// Value types are more varied and require special handling.\n-\tswitch mapType.Elem().Kind() {\n-\tcase reflect.Slice:\n-\t\t// []byte\n-\t\tvar dummy []byte\n-\t\tvalcopy = reflect.ValueOf(&dummy).Elem() // addressable []byte\n-\t\tvalbase = toStructPointer(valcopy.Addr())\n-\tcase reflect.Ptr:\n-\t\t// message; the generated field type is map[K]*Msg (so V is *Msg),\n-\t\t// so we only need one level of indirection.\n-\t\tvalcopy = reflect.New(mapType.Elem()).Elem() // addressable V\n-\t\tvalbase = toStructPointer(valcopy.Addr())\n-\tdefault:\n-\t\t// everything else\n-\t\tvalcopy = reflect.New(mapType.Elem()).Elem()                // addressable V\n-\t\tvalptr := reflect.New(reflect.PtrTo(valcopy.Type())).Elem() // addressable *V\n-\t\tvalptr.Set(valcopy.Addr())                                  //\n-\t\tvalbase = toStructPointer(valptr.Addr())                    // **V\n-\t}\n-\treturn\n-}\n-\n-// Encode a struct.\n-func (o *Buffer) enc_struct(prop *StructProperties, base structPointer) error {\n-\tvar state errorState\n-\t// Encode fields in tag order so that decoders may use optimizations\n-\t// that depend on the ordering.\n-\t// https://developers.google.com/protocol-buffers/docs/encoding#order\n-\tfor _, i := range prop.order {\n-\t\tp := prop.Prop[i]\n-\t\tif p.enc != nil {\n-\t\t\terr := p.enc(o, p, base)\n-\t\t\tif err != nil {\n-\t\t\t\tif err == ErrNil {\n-\t\t\t\t\tif p.Required && state.err == nil {\n-\t\t\t\t\t\tstate.err = &RequiredNotSetError{p.Name}\n-\t\t\t\t\t}\n-\t\t\t\t} else if err == errRepeatedHasNil {\n-\t\t\t\t\t// Give more context to nil values in repeated fields.\n-\t\t\t\t\treturn errors.New(\"repeated field \" + p.OrigName + \" has nil element\")\n-\t\t\t\t} else if !state.shouldContinue(err, p) {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif len(o.buf) > maxMarshalSize {\n-\t\t\t\treturn ErrTooLarge\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Do oneof fields.\n-\tif prop.oneofMarshaler != nil {\n-\t\tm := structPointer_Interface(base, prop.stype).(Message)\n-\t\tif err := prop.oneofMarshaler(m, o); err == ErrNil {\n-\t\t\treturn errOneofHasNil\n-\t\t} else if err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\n-\t// Add unrecognized fields at the end.\n-\tif prop.unrecField.IsValid() {\n-\t\tv := *structPointer_Bytes(base, prop.unrecField)\n-\t\tif len(o.buf)+len(v) > maxMarshalSize {\n-\t\t\treturn ErrTooLarge\n-\t\t}\n-\t\tif len(v) > 0 {\n-\t\t\to.buf = append(o.buf, v...)\n-\t\t}\n-\t}\n-\n-\treturn state.err\n-}\n-\n-func size_struct(prop *StructProperties, base structPointer) (n int) {\n-\tfor _, i := range prop.order {\n-\t\tp := prop.Prop[i]\n-\t\tif p.size != nil {\n-\t\t\tn += p.size(p, base)\n-\t\t}\n-\t}\n-\n-\t// Add unrecognized fields at the end.\n-\tif prop.unrecField.IsValid() {\n-\t\tv := *structPointer_Bytes(base, prop.unrecField)\n-\t\tn += len(v)\n-\t}\n-\n-\t// Factor in any oneof fields.\n-\tif prop.oneofSizer != nil {\n-\t\tm := structPointer_Interface(base, prop.stype).(Message)\n-\t\tn += prop.oneofSizer(m)\n-\t}\n-\n-\treturn\n-}\n-\n-var zeroes [20]byte // longer than any conceivable sizeVarint\n-\n-// Encode a struct, preceded by its encoded length (as a varint).\n-func (o *Buffer) enc_len_struct(prop *StructProperties, base structPointer, state *errorState) error {\n-\treturn o.enc_len_thing(func() error { return o.enc_struct(prop, base) }, state)\n-}\n-\n-// Encode something, preceded by its encoded length (as a varint).\n-func (o *Buffer) enc_len_thing(enc func() error, state *errorState) error {\n-\tiLen := len(o.buf)\n-\to.buf = append(o.buf, 0, 0, 0, 0) // reserve four bytes for length\n-\tiMsg := len(o.buf)\n-\terr := enc()\n-\tif err != nil && !state.shouldContinue(err, nil) {\n-\t\treturn err\n-\t}\n-\tlMsg := len(o.buf) - iMsg\n-\tlLen := sizeVarint(uint64(lMsg))\n-\tswitch x := lLen - (iMsg - iLen); {\n-\tcase x > 0: // actual length is x bytes larger than the space we reserved\n-\t\t// Move msg x bytes right.\n-\t\to.buf = append(o.buf, zeroes[:x]...)\n-\t\tcopy(o.buf[iMsg+x:], o.buf[iMsg:iMsg+lMsg])\n-\tcase x < 0: // actual length is x bytes smaller than the space we reserved\n-\t\t// Move msg x bytes left.\n-\t\tcopy(o.buf[iMsg+x:], o.buf[iMsg:iMsg+lMsg])\n-\t\to.buf = o.buf[:len(o.buf)+x] // x is negative\n-\t}\n-\t// Encode the length in the reserved space.\n-\to.buf = o.buf[:iLen]\n-\to.EncodeVarint(uint64(lMsg))\n-\to.buf = o.buf[:len(o.buf)+lMsg]\n-\treturn state.err\n-}\n-\n-// errorState maintains the first error that occurs and updates that error\n-// with additional context.\n-type errorState struct {\n-\terr error\n-}\n-\n-// shouldContinue reports whether encoding should continue upon encountering the\n-// given error. If the error is RequiredNotSetError, shouldContinue returns true\n-// and, if this is the first appearance of that error, remembers it for future\n-// reporting.\n-//\n-// If prop is not nil, it may update any error with additional context about the\n-// field with the error.\n-func (s *errorState) shouldContinue(err error, prop *Properties) bool {\n-\t// Ignore unset required fields.\n-\treqNotSet, ok := err.(*RequiredNotSetError)\n-\tif !ok {\n-\t\treturn false\n-\t}\n-\tif s.err == nil {\n-\t\tif prop != nil {\n-\t\t\terr = &RequiredNotSetError{prop.Name + \".\" + reqNotSet.field}\n-\t\t}\n-\t\ts.err = err\n-\t}\n-\treturn true\n-}"
    },
    {
      "sha": "d4db5a1c1457776f25424eedc9d9e64f4f4ab736",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/equal.go",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/equal.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/equal.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/equal.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -109,15 +109,6 @@ func equalStruct(v1, v2 reflect.Value) bool {\n \t\t\t\t// set/unset mismatch\n \t\t\t\treturn false\n \t\t\t}\n-\t\t\tb1, ok := f1.Interface().(raw)\n-\t\t\tif ok {\n-\t\t\t\tb2 := f2.Interface().(raw)\n-\t\t\t\t// RawMessage\n-\t\t\t\tif !bytes.Equal(b1.Bytes(), b2.Bytes()) {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\tf1, f2 = f1.Elem(), f2.Elem()\n \t\t}\n \t\tif !equalAny(f1, f2, sprop.Prop[i]) {\n@@ -146,11 +137,7 @@ func equalStruct(v1, v2 reflect.Value) bool {\n \n \tu1 := uf.Bytes()\n \tu2 := v2.FieldByName(\"XXX_unrecognized\").Bytes()\n-\tif !bytes.Equal(u1, u2) {\n-\t\treturn false\n-\t}\n-\n-\treturn true\n+\treturn bytes.Equal(u1, u2)\n }\n \n // v1 and v2 are known to have the same type.\n@@ -261,6 +248,15 @@ func equalExtMap(base reflect.Type, em1, em2 map[int32]Extension) bool {\n \n \t\tm1, m2 := e1.value, e2.value\n \n+\t\tif m1 == nil && m2 == nil {\n+\t\t\t// Both have only encoded form.\n+\t\t\tif bytes.Equal(e1.enc, e2.enc) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// The bytes are different, but the extensions might still be\n+\t\t\t// equal. We need to decode them to compare.\n+\t\t}\n+\n \t\tif m1 != nil && m2 != nil {\n \t\t\t// Both are unencoded.\n \t\t\tif !equalAny(reflect.ValueOf(m1), reflect.ValueOf(m2), nil) {\n@@ -276,8 +272,12 @@ func equalExtMap(base reflect.Type, em1, em2 map[int32]Extension) bool {\n \t\t\tdesc = m[extNum]\n \t\t}\n \t\tif desc == nil {\n+\t\t\t// If both have only encoded form and the bytes are the same,\n+\t\t\t// it is handled above. We get here when the bytes are different.\n+\t\t\t// We don't know how to decode it, so just compare them as byte\n+\t\t\t// slices.\n \t\t\tlog.Printf(\"proto: don't know how to compare extension %d of %v\", extNum, base)\n-\t\t\tcontinue\n+\t\t\treturn false\n \t\t}\n \t\tvar err error\n \t\tif m1 == nil {"
    },
    {
      "sha": "816a3b9d6c09faf075c20d839f6eddc0221ffae4",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/extensions.go",
      "status": "modified",
      "additions": 80,
      "deletions": 124,
      "changes": 204,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/extensions.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/extensions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/extensions.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -38,6 +38,7 @@ package proto\n import (\n \t\"errors\"\n \t\"fmt\"\n+\t\"io\"\n \t\"reflect\"\n \t\"strconv\"\n \t\"sync\"\n@@ -91,14 +92,29 @@ func (n notLocker) Unlock() {}\n // extendable returns the extendableProto interface for the given generated proto message.\n // If the proto message has the old extension format, it returns a wrapper that implements\n // the extendableProto interface.\n-func extendable(p interface{}) (extendableProto, bool) {\n-\tif ep, ok := p.(extendableProto); ok {\n-\t\treturn ep, ok\n-\t}\n-\tif ep, ok := p.(extendableProtoV1); ok {\n-\t\treturn extensionAdapter{ep}, ok\n+func extendable(p interface{}) (extendableProto, error) {\n+\tswitch p := p.(type) {\n+\tcase extendableProto:\n+\t\tif isNilPtr(p) {\n+\t\t\treturn nil, fmt.Errorf(\"proto: nil %T is not extendable\", p)\n+\t\t}\n+\t\treturn p, nil\n+\tcase extendableProtoV1:\n+\t\tif isNilPtr(p) {\n+\t\t\treturn nil, fmt.Errorf(\"proto: nil %T is not extendable\", p)\n+\t\t}\n+\t\treturn extensionAdapter{p}, nil\n \t}\n-\treturn nil, false\n+\t// Don't allocate a specific error containing %T:\n+\t// this is the hot path for Clone and MarshalText.\n+\treturn nil, errNotExtendable\n+}\n+\n+var errNotExtendable = errors.New(\"proto: not an extendable proto.Message\")\n+\n+func isNilPtr(x interface{}) bool {\n+\tv := reflect.ValueOf(x)\n+\treturn v.Kind() == reflect.Ptr && v.IsNil()\n }\n \n // XXX_InternalExtensions is an internal representation of proto extensions.\n@@ -143,9 +159,6 @@ func (e *XXX_InternalExtensions) extensionsRead() (map[int32]Extension, sync.Loc\n \treturn e.p.extensionMap, &e.p.mu\n }\n \n-var extendableProtoType = reflect.TypeOf((*extendableProto)(nil)).Elem()\n-var extendableProtoV1Type = reflect.TypeOf((*extendableProtoV1)(nil)).Elem()\n-\n // ExtensionDesc represents an extension specification.\n // Used in generated code from the protocol compiler.\n type ExtensionDesc struct {\n@@ -179,8 +192,8 @@ type Extension struct {\n \n // SetRawExtension is for testing only.\n func SetRawExtension(base Message, id int32, b []byte) {\n-\tepb, ok := extendable(base)\n-\tif !ok {\n+\tepb, err := extendable(base)\n+\tif err != nil {\n \t\treturn\n \t}\n \textmap := epb.extensionsWrite()\n@@ -205,7 +218,7 @@ func checkExtensionTypes(pb extendableProto, extension *ExtensionDesc) error {\n \t\tpbi = ea.extendableProtoV1\n \t}\n \tif a, b := reflect.TypeOf(pbi), reflect.TypeOf(extension.ExtendedType); a != b {\n-\t\treturn errors.New(\"proto: bad extended type; \" + b.String() + \" does not extend \" + a.String())\n+\t\treturn fmt.Errorf(\"proto: bad extended type; %v does not extend %v\", b, a)\n \t}\n \t// Check the range.\n \tif !isExtensionField(pb, extension.Field) {\n@@ -250,118 +263,54 @@ func extensionProperties(ed *ExtensionDesc) *Properties {\n \treturn prop\n }\n \n-// encode encodes any unmarshaled (unencoded) extensions in e.\n-func encodeExtensions(e *XXX_InternalExtensions) error {\n-\tm, mu := e.extensionsRead()\n-\tif m == nil {\n-\t\treturn nil // fast path\n-\t}\n-\tmu.Lock()\n-\tdefer mu.Unlock()\n-\treturn encodeExtensionsMap(m)\n-}\n-\n-// encode encodes any unmarshaled (unencoded) extensions in e.\n-func encodeExtensionsMap(m map[int32]Extension) error {\n-\tfor k, e := range m {\n-\t\tif e.value == nil || e.desc == nil {\n-\t\t\t// Extension is only in its encoded form.\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// We don't skip extensions that have an encoded form set,\n-\t\t// because the extension value may have been mutated after\n-\t\t// the last time this function was called.\n-\n-\t\tet := reflect.TypeOf(e.desc.ExtensionType)\n-\t\tprops := extensionProperties(e.desc)\n-\n-\t\tp := NewBuffer(nil)\n-\t\t// If e.value has type T, the encoder expects a *struct{ X T }.\n-\t\t// Pass a *T with a zero field and hope it all works out.\n-\t\tx := reflect.New(et)\n-\t\tx.Elem().Set(reflect.ValueOf(e.value))\n-\t\tif err := props.enc(p, props, toStructPointer(x)); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\te.enc = p.buf\n-\t\tm[k] = e\n-\t}\n-\treturn nil\n-}\n-\n-func extensionsSize(e *XXX_InternalExtensions) (n int) {\n-\tm, mu := e.extensionsRead()\n-\tif m == nil {\n-\t\treturn 0\n-\t}\n-\tmu.Lock()\n-\tdefer mu.Unlock()\n-\treturn extensionsMapSize(m)\n-}\n-\n-func extensionsMapSize(m map[int32]Extension) (n int) {\n-\tfor _, e := range m {\n-\t\tif e.value == nil || e.desc == nil {\n-\t\t\t// Extension is only in its encoded form.\n-\t\t\tn += len(e.enc)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\t// We don't skip extensions that have an encoded form set,\n-\t\t// because the extension value may have been mutated after\n-\t\t// the last time this function was called.\n-\n-\t\tet := reflect.TypeOf(e.desc.ExtensionType)\n-\t\tprops := extensionProperties(e.desc)\n-\n-\t\t// If e.value has type T, the encoder expects a *struct{ X T }.\n-\t\t// Pass a *T with a zero field and hope it all works out.\n-\t\tx := reflect.New(et)\n-\t\tx.Elem().Set(reflect.ValueOf(e.value))\n-\t\tn += props.size(props, toStructPointer(x))\n-\t}\n-\treturn\n-}\n-\n // HasExtension returns whether the given extension is present in pb.\n func HasExtension(pb Message, extension *ExtensionDesc) bool {\n \t// TODO: Check types, field numbers, etc.?\n-\tepb, ok := extendable(pb)\n-\tif !ok {\n+\tepb, err := extendable(pb)\n+\tif err != nil {\n \t\treturn false\n \t}\n \textmap, mu := epb.extensionsRead()\n \tif extmap == nil {\n \t\treturn false\n \t}\n \tmu.Lock()\n-\t_, ok = extmap[extension.Field]\n+\t_, ok := extmap[extension.Field]\n \tmu.Unlock()\n \treturn ok\n }\n \n // ClearExtension removes the given extension from pb.\n func ClearExtension(pb Message, extension *ExtensionDesc) {\n-\tepb, ok := extendable(pb)\n-\tif !ok {\n+\tepb, err := extendable(pb)\n+\tif err != nil {\n \t\treturn\n \t}\n \t// TODO: Check types, field numbers, etc.?\n \textmap := epb.extensionsWrite()\n \tdelete(extmap, extension.Field)\n }\n \n-// GetExtension parses and returns the given extension of pb.\n-// If the extension is not present and has no default value it returns ErrMissingExtension.\n+// GetExtension retrieves a proto2 extended field from pb.\n+//\n+// If the descriptor is type complete (i.e., ExtensionDesc.ExtensionType is non-nil),\n+// then GetExtension parses the encoded field and returns a Go value of the specified type.\n+// If the field is not present, then the default value is returned (if one is specified),\n+// otherwise ErrMissingExtension is reported.\n+//\n+// If the descriptor is not type complete (i.e., ExtensionDesc.ExtensionType is nil),\n+// then GetExtension returns the raw encoded bytes of the field extension.\n func GetExtension(pb Message, extension *ExtensionDesc) (interface{}, error) {\n-\tepb, ok := extendable(pb)\n-\tif !ok {\n-\t\treturn nil, errors.New(\"proto: not an extendable proto\")\n+\tepb, err := extendable(pb)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n-\tif err := checkExtensionTypes(epb, extension); err != nil {\n-\t\treturn nil, err\n+\tif extension.ExtendedType != nil {\n+\t\t// can only check type if this is a complete descriptor\n+\t\tif err := checkExtensionTypes(epb, extension); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n \t}\n \n \temap, mu := epb.extensionsRead()\n@@ -388,6 +337,11 @@ func GetExtension(pb Message, extension *ExtensionDesc) (interface{}, error) {\n \t\treturn e.value, nil\n \t}\n \n+\tif extension.ExtensionType == nil {\n+\t\t// incomplete descriptor\n+\t\treturn e.enc, nil\n+\t}\n+\n \tv, err := decodeExtension(e.enc, extension)\n \tif err != nil {\n \t\treturn nil, err\n@@ -405,6 +359,11 @@ func GetExtension(pb Message, extension *ExtensionDesc) (interface{}, error) {\n // defaultExtensionValue returns the default value for extension.\n // If no default for an extension is defined ErrMissingExtension is returned.\n func defaultExtensionValue(extension *ExtensionDesc) (interface{}, error) {\n+\tif extension.ExtensionType == nil {\n+\t\t// incomplete descriptor, so no default\n+\t\treturn nil, ErrMissingExtension\n+\t}\n+\n \tt := reflect.TypeOf(extension.ExtensionType)\n \tprops := extensionProperties(extension)\n \n@@ -439,31 +398,28 @@ func defaultExtensionValue(extension *ExtensionDesc) (interface{}, error) {\n \n // decodeExtension decodes an extension encoded in b.\n func decodeExtension(b []byte, extension *ExtensionDesc) (interface{}, error) {\n-\to := NewBuffer(b)\n-\n \tt := reflect.TypeOf(extension.ExtensionType)\n-\n-\tprops := extensionProperties(extension)\n+\tunmarshal := typeUnmarshaler(t, extension.Tag)\n \n \t// t is a pointer to a struct, pointer to basic type or a slice.\n-\t// Allocate a \"field\" to store the pointer/slice itself; the\n-\t// pointer/slice will be stored here. We pass\n-\t// the address of this field to props.dec.\n-\t// This passes a zero field and a *t and lets props.dec\n-\t// interpret it as a *struct{ x t }.\n+\t// Allocate space to store the pointer/slice.\n \tvalue := reflect.New(t).Elem()\n \n+\tvar err error\n \tfor {\n-\t\t// Discard wire type and field number varint. It isn't needed.\n-\t\tif _, err := o.DecodeVarint(); err != nil {\n-\t\t\treturn nil, err\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n \t\t}\n+\t\tb = b[n:]\n+\t\twire := int(x) & 7\n \n-\t\tif err := props.dec(o, props, toStructPointer(value.Addr())); err != nil {\n+\t\tb, err = unmarshal(b, valToPointer(value.Addr()), wire)\n+\t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \n-\t\tif o.index >= len(o.buf) {\n+\t\tif len(b) == 0 {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -473,9 +429,9 @@ func decodeExtension(b []byte, extension *ExtensionDesc) (interface{}, error) {\n // GetExtensions returns a slice of the extensions present in pb that are also listed in es.\n // The returned slice has the same length as es; missing extensions will appear as nil elements.\n func GetExtensions(pb Message, es []*ExtensionDesc) (extensions []interface{}, err error) {\n-\tepb, ok := extendable(pb)\n-\tif !ok {\n-\t\treturn nil, errors.New(\"proto: not an extendable proto\")\n+\tepb, err := extendable(pb)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \textensions = make([]interface{}, len(es))\n \tfor i, e := range es {\n@@ -494,9 +450,9 @@ func GetExtensions(pb Message, es []*ExtensionDesc) (extensions []interface{}, e\n // For non-registered extensions, ExtensionDescs returns an incomplete descriptor containing\n // just the Field field, which defines the extension's field number.\n func ExtensionDescs(pb Message) ([]*ExtensionDesc, error) {\n-\tepb, ok := extendable(pb)\n-\tif !ok {\n-\t\treturn nil, fmt.Errorf(\"proto: %T is not an extendable proto.Message\", pb)\n+\tepb, err := extendable(pb)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \tregisteredExtensions := RegisteredExtensions(pb)\n \n@@ -523,9 +479,9 @@ func ExtensionDescs(pb Message) ([]*ExtensionDesc, error) {\n \n // SetExtension sets the specified extension of pb to the specified value.\n func SetExtension(pb Message, extension *ExtensionDesc, value interface{}) error {\n-\tepb, ok := extendable(pb)\n-\tif !ok {\n-\t\treturn errors.New(\"proto: not an extendable proto\")\n+\tepb, err := extendable(pb)\n+\tif err != nil {\n+\t\treturn err\n \t}\n \tif err := checkExtensionTypes(epb, extension); err != nil {\n \t\treturn err\n@@ -550,8 +506,8 @@ func SetExtension(pb Message, extension *ExtensionDesc, value interface{}) error\n \n // ClearAllExtensions clears all extensions from pb.\n func ClearAllExtensions(pb Message) {\n-\tepb, ok := extendable(pb)\n-\tif !ok {\n+\tepb, err := extendable(pb)\n+\tif err != nil {\n \t\treturn\n \t}\n \tm := epb.extensionsWrite()"
    },
    {
      "sha": "75565cc6dcf41778c23783504fdeb54eb17a8c85",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/lib.go",
      "status": "modified",
      "additions": 105,
      "deletions": 23,
      "changes": 128,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/lib.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/lib.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/lib.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -273,6 +273,67 @@ import (\n \t\"sync\"\n )\n \n+// RequiredNotSetError is an error type returned by either Marshal or Unmarshal.\n+// Marshal reports this when a required field is not initialized.\n+// Unmarshal reports this when a required field is missing from the wire data.\n+type RequiredNotSetError struct{ field string }\n+\n+func (e *RequiredNotSetError) Error() string {\n+\tif e.field == \"\" {\n+\t\treturn fmt.Sprintf(\"proto: required field not set\")\n+\t}\n+\treturn fmt.Sprintf(\"proto: required field %q not set\", e.field)\n+}\n+func (e *RequiredNotSetError) RequiredNotSet() bool {\n+\treturn true\n+}\n+\n+type invalidUTF8Error struct{ field string }\n+\n+func (e *invalidUTF8Error) Error() string {\n+\tif e.field == \"\" {\n+\t\treturn \"proto: invalid UTF-8 detected\"\n+\t}\n+\treturn fmt.Sprintf(\"proto: field %q contains invalid UTF-8\", e.field)\n+}\n+func (e *invalidUTF8Error) InvalidUTF8() bool {\n+\treturn true\n+}\n+\n+// errInvalidUTF8 is a sentinel error to identify fields with invalid UTF-8.\n+// This error should not be exposed to the external API as such errors should\n+// be recreated with the field information.\n+var errInvalidUTF8 = &invalidUTF8Error{}\n+\n+// isNonFatal reports whether the error is either a RequiredNotSet error\n+// or a InvalidUTF8 error.\n+func isNonFatal(err error) bool {\n+\tif re, ok := err.(interface{ RequiredNotSet() bool }); ok && re.RequiredNotSet() {\n+\t\treturn true\n+\t}\n+\tif re, ok := err.(interface{ InvalidUTF8() bool }); ok && re.InvalidUTF8() {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+type nonFatal struct{ E error }\n+\n+// Merge merges err into nf and reports whether it was successful.\n+// Otherwise it returns false for any fatal non-nil errors.\n+func (nf *nonFatal) Merge(err error) (ok bool) {\n+\tif err == nil {\n+\t\treturn true // not an error\n+\t}\n+\tif !isNonFatal(err) {\n+\t\treturn false // fatal error\n+\t}\n+\tif nf.E == nil {\n+\t\tnf.E = err // store first instance of non-fatal error\n+\t}\n+\treturn true\n+}\n+\n // Message is implemented by generated protocol buffer messages.\n type Message interface {\n \tReset()\n@@ -309,16 +370,7 @@ type Buffer struct {\n \tbuf   []byte // encode/decode byte stream\n \tindex int    // read point\n \n-\t// pools of basic types to amortize allocation.\n-\tbools   []bool\n-\tuint32s []uint32\n-\tuint64s []uint64\n-\n-\t// extra pools, only used with pointer_reflect.go\n-\tint32s   []int32\n-\tint64s   []int64\n-\tfloat32s []float32\n-\tfloat64s []float64\n+\tdeterministic bool\n }\n \n // NewBuffer allocates a new Buffer and initializes its internal data to\n@@ -343,6 +395,30 @@ func (p *Buffer) SetBuf(s []byte) {\n // Bytes returns the contents of the Buffer.\n func (p *Buffer) Bytes() []byte { return p.buf }\n \n+// SetDeterministic sets whether to use deterministic serialization.\n+//\n+// Deterministic serialization guarantees that for a given binary, equal\n+// messages will always be serialized to the same bytes. This implies:\n+//\n+//   - Repeated serialization of a message will return the same bytes.\n+//   - Different processes of the same binary (which may be executing on\n+//     different machines) will serialize equal messages to the same bytes.\n+//\n+// Note that the deterministic serialization is NOT canonical across\n+// languages. It is not guaranteed to remain stable over time. It is unstable\n+// across different builds with schema changes due to unknown fields.\n+// Users who need canonical serialization (e.g., persistent storage in a\n+// canonical form, fingerprinting, etc.) should define their own\n+// canonicalization specification and implement their own serializer rather\n+// than relying on this API.\n+//\n+// If deterministic serialization is requested, map entries will be sorted\n+// by keys in lexographical order. This is an implementation detail and\n+// subject to change.\n+func (p *Buffer) SetDeterministic(deterministic bool) {\n+\tp.deterministic = deterministic\n+}\n+\n /*\n  * Helper routines for simplifying the creation of optional fields of basic type.\n  */\n@@ -831,22 +907,12 @@ func fieldDefault(ft reflect.Type, prop *Properties) (sf *scalarField, nestedMes\n \treturn sf, false, nil\n }\n \n+// mapKeys returns a sort.Interface to be used for sorting the map keys.\n // Map fields may have key types of non-float scalars, strings and enums.\n-// The easiest way to sort them in some deterministic order is to use fmt.\n-// If this turns out to be inefficient we can always consider other options,\n-// such as doing a Schwartzian transform.\n-\n func mapKeys(vs []reflect.Value) sort.Interface {\n-\ts := mapKeySorter{\n-\t\tvs: vs,\n-\t\t// default Less function: textual comparison\n-\t\tless: func(a, b reflect.Value) bool {\n-\t\t\treturn fmt.Sprint(a.Interface()) < fmt.Sprint(b.Interface())\n-\t\t},\n-\t}\n+\ts := mapKeySorter{vs: vs}\n \n-\t// Type specialization per https://developers.google.com/protocol-buffers/docs/proto#maps;\n-\t// numeric keys are sorted numerically.\n+\t// Type specialization per https://developers.google.com/protocol-buffers/docs/proto#maps.\n \tif len(vs) == 0 {\n \t\treturn s\n \t}\n@@ -855,6 +921,12 @@ func mapKeys(vs []reflect.Value) sort.Interface {\n \t\ts.less = func(a, b reflect.Value) bool { return a.Int() < b.Int() }\n \tcase reflect.Uint32, reflect.Uint64:\n \t\ts.less = func(a, b reflect.Value) bool { return a.Uint() < b.Uint() }\n+\tcase reflect.Bool:\n+\t\ts.less = func(a, b reflect.Value) bool { return !a.Bool() && b.Bool() } // false < true\n+\tcase reflect.String:\n+\t\ts.less = func(a, b reflect.Value) bool { return a.String() < b.String() }\n+\tdefault:\n+\t\tpanic(fmt.Sprintf(\"unsupported map key type: %v\", vs[0].Kind()))\n \t}\n \n \treturn s\n@@ -895,3 +967,13 @@ const ProtoPackageIsVersion2 = true\n // ProtoPackageIsVersion1 is referenced from generated protocol buffer files\n // to assert that that code is compatible with this version of the proto package.\n const ProtoPackageIsVersion1 = true\n+\n+// InternalMessageInfo is a type used internally by generated .pb.go files.\n+// This type is not intended to be used by non-generated code.\n+// This type is not subject to any compatibility guarantee.\n+type InternalMessageInfo struct {\n+\tmarshal   *marshalInfo\n+\tunmarshal *unmarshalInfo\n+\tmerge     *mergeInfo\n+\tdiscard   *discardInfo\n+}"
    },
    {
      "sha": "3b6ca41d5e5543dddafc5831203d3b8dcb109ba5",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/message_set.go",
      "status": "modified",
      "additions": 42,
      "deletions": 39,
      "changes": 81,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/message_set.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/message_set.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/message_set.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -42,6 +42,7 @@ import (\n \t\"fmt\"\n \t\"reflect\"\n \t\"sort\"\n+\t\"sync\"\n )\n \n // errNoMessageTypeID occurs when a protocol buffer does not have a message type ID.\n@@ -94,10 +95,7 @@ func (ms *messageSet) find(pb Message) *_MessageSet_Item {\n }\n \n func (ms *messageSet) Has(pb Message) bool {\n-\tif ms.find(pb) != nil {\n-\t\treturn true\n-\t}\n-\treturn false\n+\treturn ms.find(pb) != nil\n }\n \n func (ms *messageSet) Unmarshal(pb Message) error {\n@@ -150,46 +148,42 @@ func skipVarint(buf []byte) []byte {\n // MarshalMessageSet encodes the extension map represented by m in the message set wire format.\n // It is called by generated Marshal methods on protocol buffer messages with the message_set_wire_format option.\n func MarshalMessageSet(exts interface{}) ([]byte, error) {\n-\tvar m map[int32]Extension\n+\treturn marshalMessageSet(exts, false)\n+}\n+\n+// marshaMessageSet implements above function, with the opt to turn on / off deterministic during Marshal.\n+func marshalMessageSet(exts interface{}, deterministic bool) ([]byte, error) {\n \tswitch exts := exts.(type) {\n \tcase *XXX_InternalExtensions:\n-\t\tif err := encodeExtensions(exts); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tm, _ = exts.extensionsRead()\n+\t\tvar u marshalInfo\n+\t\tsiz := u.sizeMessageSet(exts)\n+\t\tb := make([]byte, 0, siz)\n+\t\treturn u.appendMessageSet(b, exts, deterministic)\n+\n \tcase map[int32]Extension:\n-\t\tif err := encodeExtensionsMap(exts); err != nil {\n-\t\t\treturn nil, err\n+\t\t// This is an old-style extension map.\n+\t\t// Wrap it in a new-style XXX_InternalExtensions.\n+\t\tie := XXX_InternalExtensions{\n+\t\t\tp: &struct {\n+\t\t\t\tmu           sync.Mutex\n+\t\t\t\textensionMap map[int32]Extension\n+\t\t\t}{\n+\t\t\t\textensionMap: exts,\n+\t\t\t},\n \t\t}\n-\t\tm = exts\n+\n+\t\tvar u marshalInfo\n+\t\tsiz := u.sizeMessageSet(&ie)\n+\t\tb := make([]byte, 0, siz)\n+\t\treturn u.appendMessageSet(b, &ie, deterministic)\n+\n \tdefault:\n \t\treturn nil, errors.New(\"proto: not an extension map\")\n \t}\n-\n-\t// Sort extension IDs to provide a deterministic encoding.\n-\t// See also enc_map in encode.go.\n-\tids := make([]int, 0, len(m))\n-\tfor id := range m {\n-\t\tids = append(ids, int(id))\n-\t}\n-\tsort.Ints(ids)\n-\n-\tms := &messageSet{Item: make([]*_MessageSet_Item, 0, len(m))}\n-\tfor _, id := range ids {\n-\t\te := m[int32(id)]\n-\t\t// Remove the wire type and field number varint, as well as the length varint.\n-\t\tmsg := skipVarint(skipVarint(e.enc))\n-\n-\t\tms.Item = append(ms.Item, &_MessageSet_Item{\n-\t\t\tTypeId:  Int32(int32(id)),\n-\t\t\tMessage: msg,\n-\t\t})\n-\t}\n-\treturn Marshal(ms)\n }\n \n // UnmarshalMessageSet decodes the extension map encoded in buf in the message set wire format.\n-// It is called by generated Unmarshal methods on protocol buffer messages with the message_set_wire_format option.\n+// It is called by Unmarshal methods on protocol buffer messages with the message_set_wire_format option.\n func UnmarshalMessageSet(buf []byte, exts interface{}) error {\n \tvar m map[int32]Extension\n \tswitch exts := exts.(type) {\n@@ -235,7 +229,15 @@ func MarshalMessageSetJSON(exts interface{}) ([]byte, error) {\n \tvar m map[int32]Extension\n \tswitch exts := exts.(type) {\n \tcase *XXX_InternalExtensions:\n-\t\tm, _ = exts.extensionsRead()\n+\t\tvar mu sync.Locker\n+\t\tm, mu = exts.extensionsRead()\n+\t\tif m != nil {\n+\t\t\t// Keep the extensions map locked until we're done marshaling to prevent\n+\t\t\t// races between marshaling and unmarshaling the lazily-{en,de}coded\n+\t\t\t// values.\n+\t\t\tmu.Lock()\n+\t\t\tdefer mu.Unlock()\n+\t\t}\n \tcase map[int32]Extension:\n \t\tm = exts\n \tdefault:\n@@ -253,15 +255,16 @@ func MarshalMessageSetJSON(exts interface{}) ([]byte, error) {\n \n \tfor i, id := range ids {\n \t\text := m[id]\n-\t\tif i > 0 {\n-\t\t\tb.WriteByte(',')\n-\t\t}\n-\n \t\tmsd, ok := messageSetMap[id]\n \t\tif !ok {\n \t\t\t// Unknown type; we can't render it, so skip it.\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif i > 0 && b.Len() > 1 {\n+\t\t\tb.WriteByte(',')\n+\t\t}\n+\n \t\tfmt.Fprintf(&b, `\"[%s]\":`, msd.name)\n \n \t\tx := ext.value"
    },
    {
      "sha": "b6cad90834b31a7e1ce445486d849285e9454573",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/pointer_reflect.go",
      "status": "modified",
      "additions": 234,
      "deletions": 361,
      "changes": 595,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/pointer_reflect.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/pointer_reflect.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/pointer_reflect.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -29,7 +29,7 @@\n // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-// +build appengine js\n+// +build purego appengine js\n \n // This file contains an implementation of proto field accesses using package reflect.\n // It is slower than the code in pointer_unsafe.go but it avoids package unsafe and can\n@@ -38,32 +38,13 @@\n package proto\n \n import (\n-\t\"math\"\n \t\"reflect\"\n+\t\"sync\"\n )\n \n-// A structPointer is a pointer to a struct.\n-type structPointer struct {\n-\tv reflect.Value\n-}\n-\n-// toStructPointer returns a structPointer equivalent to the given reflect value.\n-// The reflect value must itself be a pointer to a struct.\n-func toStructPointer(v reflect.Value) structPointer {\n-\treturn structPointer{v}\n-}\n-\n-// IsNil reports whether p is nil.\n-func structPointer_IsNil(p structPointer) bool {\n-\treturn p.v.IsNil()\n-}\n+const unsafeAllowed = false\n \n-// Interface returns the struct pointer as an interface value.\n-func structPointer_Interface(p structPointer, _ reflect.Type) interface{} {\n-\treturn p.v.Interface()\n-}\n-\n-// A field identifies a field in a struct, accessible from a structPointer.\n+// A field identifies a field in a struct, accessible from a pointer.\n // In this implementation, a field is identified by the sequence of field indices\n // passed to reflect's FieldByIndex.\n type field []int\n@@ -76,409 +57,301 @@ func toField(f *reflect.StructField) field {\n // invalidField is an invalid field identifier.\n var invalidField = field(nil)\n \n+// zeroField is a noop when calling pointer.offset.\n+var zeroField = field([]int{})\n+\n // IsValid reports whether the field identifier is valid.\n func (f field) IsValid() bool { return f != nil }\n \n-// field returns the given field in the struct as a reflect value.\n-func structPointer_field(p structPointer, f field) reflect.Value {\n-\t// Special case: an extension map entry with a value of type T\n-\t// passes a *T to the struct-handling code with a zero field,\n-\t// expecting that it will be treated as equivalent to *struct{ X T },\n-\t// which has the same memory layout. We have to handle that case\n-\t// specially, because reflect will panic if we call FieldByIndex on a\n-\t// non-struct.\n-\tif f == nil {\n-\t\treturn p.v.Elem()\n-\t}\n-\n-\treturn p.v.Elem().FieldByIndex(f)\n+// The pointer type is for the table-driven decoder.\n+// The implementation here uses a reflect.Value of pointer type to\n+// create a generic pointer. In pointer_unsafe.go we use unsafe\n+// instead of reflect to implement the same (but faster) interface.\n+type pointer struct {\n+\tv reflect.Value\n }\n \n-// ifield returns the given field in the struct as an interface value.\n-func structPointer_ifield(p structPointer, f field) interface{} {\n-\treturn structPointer_field(p, f).Addr().Interface()\n+// toPointer converts an interface of pointer type to a pointer\n+// that points to the same target.\n+func toPointer(i *Message) pointer {\n+\treturn pointer{v: reflect.ValueOf(*i)}\n }\n \n-// Bytes returns the address of a []byte field in the struct.\n-func structPointer_Bytes(p structPointer, f field) *[]byte {\n-\treturn structPointer_ifield(p, f).(*[]byte)\n+// toAddrPointer converts an interface to a pointer that points to\n+// the interface data.\n+func toAddrPointer(i *interface{}, isptr bool) pointer {\n+\tv := reflect.ValueOf(*i)\n+\tu := reflect.New(v.Type())\n+\tu.Elem().Set(v)\n+\treturn pointer{v: u}\n }\n \n-// BytesSlice returns the address of a [][]byte field in the struct.\n-func structPointer_BytesSlice(p structPointer, f field) *[][]byte {\n-\treturn structPointer_ifield(p, f).(*[][]byte)\n+// valToPointer converts v to a pointer.  v must be of pointer type.\n+func valToPointer(v reflect.Value) pointer {\n+\treturn pointer{v: v}\n }\n \n-// Bool returns the address of a *bool field in the struct.\n-func structPointer_Bool(p structPointer, f field) **bool {\n-\treturn structPointer_ifield(p, f).(**bool)\n+// offset converts from a pointer to a structure to a pointer to\n+// one of its fields.\n+func (p pointer) offset(f field) pointer {\n+\treturn pointer{v: p.v.Elem().FieldByIndex(f).Addr()}\n }\n \n-// BoolVal returns the address of a bool field in the struct.\n-func structPointer_BoolVal(p structPointer, f field) *bool {\n-\treturn structPointer_ifield(p, f).(*bool)\n+func (p pointer) isNil() bool {\n+\treturn p.v.IsNil()\n }\n \n-// BoolSlice returns the address of a []bool field in the struct.\n-func structPointer_BoolSlice(p structPointer, f field) *[]bool {\n-\treturn structPointer_ifield(p, f).(*[]bool)\n+// grow updates the slice s in place to make it one element longer.\n+// s must be addressable.\n+// Returns the (addressable) new element.\n+func grow(s reflect.Value) reflect.Value {\n+\tn, m := s.Len(), s.Cap()\n+\tif n < m {\n+\t\ts.SetLen(n + 1)\n+\t} else {\n+\t\ts.Set(reflect.Append(s, reflect.Zero(s.Type().Elem())))\n+\t}\n+\treturn s.Index(n)\n }\n \n-// String returns the address of a *string field in the struct.\n-func structPointer_String(p structPointer, f field) **string {\n-\treturn structPointer_ifield(p, f).(**string)\n+func (p pointer) toInt64() *int64 {\n+\treturn p.v.Interface().(*int64)\n }\n-\n-// StringVal returns the address of a string field in the struct.\n-func structPointer_StringVal(p structPointer, f field) *string {\n-\treturn structPointer_ifield(p, f).(*string)\n+func (p pointer) toInt64Ptr() **int64 {\n+\treturn p.v.Interface().(**int64)\n }\n-\n-// StringSlice returns the address of a []string field in the struct.\n-func structPointer_StringSlice(p structPointer, f field) *[]string {\n-\treturn structPointer_ifield(p, f).(*[]string)\n+func (p pointer) toInt64Slice() *[]int64 {\n+\treturn p.v.Interface().(*[]int64)\n }\n \n-// Extensions returns the address of an extension map field in the struct.\n-func structPointer_Extensions(p structPointer, f field) *XXX_InternalExtensions {\n-\treturn structPointer_ifield(p, f).(*XXX_InternalExtensions)\n-}\n+var int32ptr = reflect.TypeOf((*int32)(nil))\n \n-// ExtMap returns the address of an extension map field in the struct.\n-func structPointer_ExtMap(p structPointer, f field) *map[int32]Extension {\n-\treturn structPointer_ifield(p, f).(*map[int32]Extension)\n+func (p pointer) toInt32() *int32 {\n+\treturn p.v.Convert(int32ptr).Interface().(*int32)\n }\n \n-// NewAt returns the reflect.Value for a pointer to a field in the struct.\n-func structPointer_NewAt(p structPointer, f field, typ reflect.Type) reflect.Value {\n-\treturn structPointer_field(p, f).Addr()\n+// The toInt32Ptr/Slice methods don't work because of enums.\n+// Instead, we must use set/get methods for the int32ptr/slice case.\n+/*\n+\tfunc (p pointer) toInt32Ptr() **int32 {\n+\t\treturn p.v.Interface().(**int32)\n }\n-\n-// SetStructPointer writes a *struct field in the struct.\n-func structPointer_SetStructPointer(p structPointer, f field, q structPointer) {\n-\tstructPointer_field(p, f).Set(q.v)\n+\tfunc (p pointer) toInt32Slice() *[]int32 {\n+\t\treturn p.v.Interface().(*[]int32)\n }\n-\n-// GetStructPointer reads a *struct field in the struct.\n-func structPointer_GetStructPointer(p structPointer, f field) structPointer {\n-\treturn structPointer{structPointer_field(p, f)}\n+*/\n+func (p pointer) getInt32Ptr() *int32 {\n+\tif p.v.Type().Elem().Elem() == reflect.TypeOf(int32(0)) {\n+\t\t// raw int32 type\n+\t\treturn p.v.Elem().Interface().(*int32)\n+\t}\n+\t// an enum\n+\treturn p.v.Elem().Convert(int32PtrType).Interface().(*int32)\n+}\n+func (p pointer) setInt32Ptr(v int32) {\n+\t// Allocate value in a *int32. Possibly convert that to a *enum.\n+\t// Then assign it to a **int32 or **enum.\n+\t// Note: we can convert *int32 to *enum, but we can't convert\n+\t// **int32 to **enum!\n+\tp.v.Elem().Set(reflect.ValueOf(&v).Convert(p.v.Type().Elem()))\n+}\n+\n+// getInt32Slice copies []int32 from p as a new slice.\n+// This behavior differs from the implementation in pointer_unsafe.go.\n+func (p pointer) getInt32Slice() []int32 {\n+\tif p.v.Type().Elem().Elem() == reflect.TypeOf(int32(0)) {\n+\t\t// raw int32 type\n+\t\treturn p.v.Elem().Interface().([]int32)\n+\t}\n+\t// an enum\n+\t// Allocate a []int32, then assign []enum's values into it.\n+\t// Note: we can't convert []enum to []int32.\n+\tslice := p.v.Elem()\n+\ts := make([]int32, slice.Len())\n+\tfor i := 0; i < slice.Len(); i++ {\n+\t\ts[i] = int32(slice.Index(i).Int())\n+\t}\n+\treturn s\n }\n \n-// StructPointerSlice the address of a []*struct field in the struct.\n-func structPointer_StructPointerSlice(p structPointer, f field) structPointerSlice {\n-\treturn structPointerSlice{structPointer_field(p, f)}\n+// setInt32Slice copies []int32 into p as a new slice.\n+// This behavior differs from the implementation in pointer_unsafe.go.\n+func (p pointer) setInt32Slice(v []int32) {\n+\tif p.v.Type().Elem().Elem() == reflect.TypeOf(int32(0)) {\n+\t\t// raw int32 type\n+\t\tp.v.Elem().Set(reflect.ValueOf(v))\n+\t\treturn\n+\t}\n+\t// an enum\n+\t// Allocate a []enum, then assign []int32's values into it.\n+\t// Note: we can't convert []enum to []int32.\n+\tslice := reflect.MakeSlice(p.v.Type().Elem(), len(v), cap(v))\n+\tfor i, x := range v {\n+\t\tslice.Index(i).SetInt(int64(x))\n+\t}\n+\tp.v.Elem().Set(slice)\n }\n-\n-// A structPointerSlice represents the address of a slice of pointers to structs\n-// (themselves messages or groups). That is, v.Type() is *[]*struct{...}.\n-type structPointerSlice struct {\n-\tv reflect.Value\n+func (p pointer) appendInt32Slice(v int32) {\n+\tgrow(p.v.Elem()).SetInt(int64(v))\n }\n \n-func (p structPointerSlice) Len() int                  { return p.v.Len() }\n-func (p structPointerSlice) Index(i int) structPointer { return structPointer{p.v.Index(i)} }\n-func (p structPointerSlice) Append(q structPointer) {\n-\tp.v.Set(reflect.Append(p.v, q.v))\n+func (p pointer) toUint64() *uint64 {\n+\treturn p.v.Interface().(*uint64)\n }\n-\n-var (\n-\tint32Type   = reflect.TypeOf(int32(0))\n-\tuint32Type  = reflect.TypeOf(uint32(0))\n-\tfloat32Type = reflect.TypeOf(float32(0))\n-\tint64Type   = reflect.TypeOf(int64(0))\n-\tuint64Type  = reflect.TypeOf(uint64(0))\n-\tfloat64Type = reflect.TypeOf(float64(0))\n-)\n-\n-// A word32 represents a field of type *int32, *uint32, *float32, or *enum.\n-// That is, v.Type() is *int32, *uint32, *float32, or *enum and v is assignable.\n-type word32 struct {\n-\tv reflect.Value\n+func (p pointer) toUint64Ptr() **uint64 {\n+\treturn p.v.Interface().(**uint64)\n }\n-\n-// IsNil reports whether p is nil.\n-func word32_IsNil(p word32) bool {\n-\treturn p.v.IsNil()\n+func (p pointer) toUint64Slice() *[]uint64 {\n+\treturn p.v.Interface().(*[]uint64)\n }\n-\n-// Set sets p to point at a newly allocated word with bits set to x.\n-func word32_Set(p word32, o *Buffer, x uint32) {\n-\tt := p.v.Type().Elem()\n-\tswitch t {\n-\tcase int32Type:\n-\t\tif len(o.int32s) == 0 {\n-\t\t\to.int32s = make([]int32, uint32PoolSize)\n-\t\t}\n-\t\to.int32s[0] = int32(x)\n-\t\tp.v.Set(reflect.ValueOf(&o.int32s[0]))\n-\t\to.int32s = o.int32s[1:]\n-\t\treturn\n-\tcase uint32Type:\n-\t\tif len(o.uint32s) == 0 {\n-\t\t\to.uint32s = make([]uint32, uint32PoolSize)\n-\t\t}\n-\t\to.uint32s[0] = x\n-\t\tp.v.Set(reflect.ValueOf(&o.uint32s[0]))\n-\t\to.uint32s = o.uint32s[1:]\n-\t\treturn\n-\tcase float32Type:\n-\t\tif len(o.float32s) == 0 {\n-\t\t\to.float32s = make([]float32, uint32PoolSize)\n-\t\t}\n-\t\to.float32s[0] = math.Float32frombits(x)\n-\t\tp.v.Set(reflect.ValueOf(&o.float32s[0]))\n-\t\to.float32s = o.float32s[1:]\n-\t\treturn\n-\t}\n-\n-\t// must be enum\n-\tp.v.Set(reflect.New(t))\n-\tp.v.Elem().SetInt(int64(int32(x)))\n+func (p pointer) toUint32() *uint32 {\n+\treturn p.v.Interface().(*uint32)\n }\n-\n-// Get gets the bits pointed at by p, as a uint32.\n-func word32_Get(p word32) uint32 {\n-\telem := p.v.Elem()\n-\tswitch elem.Kind() {\n-\tcase reflect.Int32:\n-\t\treturn uint32(elem.Int())\n-\tcase reflect.Uint32:\n-\t\treturn uint32(elem.Uint())\n-\tcase reflect.Float32:\n-\t\treturn math.Float32bits(float32(elem.Float()))\n-\t}\n-\tpanic(\"unreachable\")\n+func (p pointer) toUint32Ptr() **uint32 {\n+\treturn p.v.Interface().(**uint32)\n }\n-\n-// Word32 returns a reference to a *int32, *uint32, *float32, or *enum field in the struct.\n-func structPointer_Word32(p structPointer, f field) word32 {\n-\treturn word32{structPointer_field(p, f)}\n+func (p pointer) toUint32Slice() *[]uint32 {\n+\treturn p.v.Interface().(*[]uint32)\n }\n-\n-// A word32Val represents a field of type int32, uint32, float32, or enum.\n-// That is, v.Type() is int32, uint32, float32, or enum and v is assignable.\n-type word32Val struct {\n-\tv reflect.Value\n+func (p pointer) toBool() *bool {\n+\treturn p.v.Interface().(*bool)\n }\n-\n-// Set sets *p to x.\n-func word32Val_Set(p word32Val, x uint32) {\n-\tswitch p.v.Type() {\n-\tcase int32Type:\n-\t\tp.v.SetInt(int64(x))\n-\t\treturn\n-\tcase uint32Type:\n-\t\tp.v.SetUint(uint64(x))\n-\t\treturn\n-\tcase float32Type:\n-\t\tp.v.SetFloat(float64(math.Float32frombits(x)))\n-\t\treturn\n-\t}\n-\n-\t// must be enum\n-\tp.v.SetInt(int64(int32(x)))\n+func (p pointer) toBoolPtr() **bool {\n+\treturn p.v.Interface().(**bool)\n }\n-\n-// Get gets the bits pointed at by p, as a uint32.\n-func word32Val_Get(p word32Val) uint32 {\n-\telem := p.v\n-\tswitch elem.Kind() {\n-\tcase reflect.Int32:\n-\t\treturn uint32(elem.Int())\n-\tcase reflect.Uint32:\n-\t\treturn uint32(elem.Uint())\n-\tcase reflect.Float32:\n-\t\treturn math.Float32bits(float32(elem.Float()))\n-\t}\n-\tpanic(\"unreachable\")\n+func (p pointer) toBoolSlice() *[]bool {\n+\treturn p.v.Interface().(*[]bool)\n }\n-\n-// Word32Val returns a reference to a int32, uint32, float32, or enum field in the struct.\n-func structPointer_Word32Val(p structPointer, f field) word32Val {\n-\treturn word32Val{structPointer_field(p, f)}\n+func (p pointer) toFloat64() *float64 {\n+\treturn p.v.Interface().(*float64)\n }\n-\n-// A word32Slice is a slice of 32-bit values.\n-// That is, v.Type() is []int32, []uint32, []float32, or []enum.\n-type word32Slice struct {\n-\tv reflect.Value\n+func (p pointer) toFloat64Ptr() **float64 {\n+\treturn p.v.Interface().(**float64)\n }\n-\n-func (p word32Slice) Append(x uint32) {\n-\tn, m := p.v.Len(), p.v.Cap()\n-\tif n < m {\n-\t\tp.v.SetLen(n + 1)\n-\t} else {\n-\t\tt := p.v.Type().Elem()\n-\t\tp.v.Set(reflect.Append(p.v, reflect.Zero(t)))\n-\t}\n-\telem := p.v.Index(n)\n-\tswitch elem.Kind() {\n-\tcase reflect.Int32:\n-\t\telem.SetInt(int64(int32(x)))\n-\tcase reflect.Uint32:\n-\t\telem.SetUint(uint64(x))\n-\tcase reflect.Float32:\n-\t\telem.SetFloat(float64(math.Float32frombits(x)))\n-\t}\n+func (p pointer) toFloat64Slice() *[]float64 {\n+\treturn p.v.Interface().(*[]float64)\n }\n-\n-func (p word32Slice) Len() int {\n-\treturn p.v.Len()\n+func (p pointer) toFloat32() *float32 {\n+\treturn p.v.Interface().(*float32)\n }\n-\n-func (p word32Slice) Index(i int) uint32 {\n-\telem := p.v.Index(i)\n-\tswitch elem.Kind() {\n-\tcase reflect.Int32:\n-\t\treturn uint32(elem.Int())\n-\tcase reflect.Uint32:\n-\t\treturn uint32(elem.Uint())\n-\tcase reflect.Float32:\n-\t\treturn math.Float32bits(float32(elem.Float()))\n-\t}\n-\tpanic(\"unreachable\")\n+func (p pointer) toFloat32Ptr() **float32 {\n+\treturn p.v.Interface().(**float32)\n }\n-\n-// Word32Slice returns a reference to a []int32, []uint32, []float32, or []enum field in the struct.\n-func structPointer_Word32Slice(p structPointer, f field) word32Slice {\n-\treturn word32Slice{structPointer_field(p, f)}\n+func (p pointer) toFloat32Slice() *[]float32 {\n+\treturn p.v.Interface().(*[]float32)\n }\n-\n-// word64 is like word32 but for 64-bit values.\n-type word64 struct {\n-\tv reflect.Value\n+func (p pointer) toString() *string {\n+\treturn p.v.Interface().(*string)\n }\n-\n-func word64_Set(p word64, o *Buffer, x uint64) {\n-\tt := p.v.Type().Elem()\n-\tswitch t {\n-\tcase int64Type:\n-\t\tif len(o.int64s) == 0 {\n-\t\t\to.int64s = make([]int64, uint64PoolSize)\n-\t\t}\n-\t\to.int64s[0] = int64(x)\n-\t\tp.v.Set(reflect.ValueOf(&o.int64s[0]))\n-\t\to.int64s = o.int64s[1:]\n-\t\treturn\n-\tcase uint64Type:\n-\t\tif len(o.uint64s) == 0 {\n-\t\t\to.uint64s = make([]uint64, uint64PoolSize)\n-\t\t}\n-\t\to.uint64s[0] = x\n-\t\tp.v.Set(reflect.ValueOf(&o.uint64s[0]))\n-\t\to.uint64s = o.uint64s[1:]\n-\t\treturn\n-\tcase float64Type:\n-\t\tif len(o.float64s) == 0 {\n-\t\t\to.float64s = make([]float64, uint64PoolSize)\n-\t\t}\n-\t\to.float64s[0] = math.Float64frombits(x)\n-\t\tp.v.Set(reflect.ValueOf(&o.float64s[0]))\n-\t\to.float64s = o.float64s[1:]\n-\t\treturn\n-\t}\n-\tpanic(\"unreachable\")\n+func (p pointer) toStringPtr() **string {\n+\treturn p.v.Interface().(**string)\n }\n-\n-func word64_IsNil(p word64) bool {\n-\treturn p.v.IsNil()\n+func (p pointer) toStringSlice() *[]string {\n+\treturn p.v.Interface().(*[]string)\n }\n-\n-func word64_Get(p word64) uint64 {\n-\telem := p.v.Elem()\n-\tswitch elem.Kind() {\n-\tcase reflect.Int64:\n-\t\treturn uint64(elem.Int())\n-\tcase reflect.Uint64:\n-\t\treturn elem.Uint()\n-\tcase reflect.Float64:\n-\t\treturn math.Float64bits(elem.Float())\n-\t}\n-\tpanic(\"unreachable\")\n+func (p pointer) toBytes() *[]byte {\n+\treturn p.v.Interface().(*[]byte)\n }\n-\n-func structPointer_Word64(p structPointer, f field) word64 {\n-\treturn word64{structPointer_field(p, f)}\n+func (p pointer) toBytesSlice() *[][]byte {\n+\treturn p.v.Interface().(*[][]byte)\n+}\n+func (p pointer) toExtensions() *XXX_InternalExtensions {\n+\treturn p.v.Interface().(*XXX_InternalExtensions)\n+}\n+func (p pointer) toOldExtensions() *map[int32]Extension {\n+\treturn p.v.Interface().(*map[int32]Extension)\n+}\n+func (p pointer) getPointer() pointer {\n+\treturn pointer{v: p.v.Elem()}\n+}\n+func (p pointer) setPointer(q pointer) {\n+\tp.v.Elem().Set(q.v)\n+}\n+func (p pointer) appendPointer(q pointer) {\n+\tgrow(p.v.Elem()).Set(q.v)\n }\n \n-// word64Val is like word32Val but for 64-bit values.\n-type word64Val struct {\n-\tv reflect.Value\n+// getPointerSlice copies []*T from p as a new []pointer.\n+// This behavior differs from the implementation in pointer_unsafe.go.\n+func (p pointer) getPointerSlice() []pointer {\n+\tif p.v.IsNil() {\n+\t\treturn nil\n+\t}\n+\tn := p.v.Elem().Len()\n+\ts := make([]pointer, n)\n+\tfor i := 0; i < n; i++ {\n+\t\ts[i] = pointer{v: p.v.Elem().Index(i)}\n+\t}\n+\treturn s\n }\n \n-func word64Val_Set(p word64Val, o *Buffer, x uint64) {\n-\tswitch p.v.Type() {\n-\tcase int64Type:\n-\t\tp.v.SetInt(int64(x))\n-\t\treturn\n-\tcase uint64Type:\n-\t\tp.v.SetUint(x)\n-\t\treturn\n-\tcase float64Type:\n-\t\tp.v.SetFloat(math.Float64frombits(x))\n+// setPointerSlice copies []pointer into p as a new []*T.\n+// This behavior differs from the implementation in pointer_unsafe.go.\n+func (p pointer) setPointerSlice(v []pointer) {\n+\tif v == nil {\n+\t\tp.v.Elem().Set(reflect.New(p.v.Elem().Type()).Elem())\n \t\treturn\n \t}\n-\tpanic(\"unreachable\")\n+\ts := reflect.MakeSlice(p.v.Elem().Type(), 0, len(v))\n+\tfor _, p := range v {\n+\t\ts = reflect.Append(s, p.v)\n+\t}\n+\tp.v.Elem().Set(s)\n }\n \n-func word64Val_Get(p word64Val) uint64 {\n-\telem := p.v\n-\tswitch elem.Kind() {\n-\tcase reflect.Int64:\n-\t\treturn uint64(elem.Int())\n-\tcase reflect.Uint64:\n-\t\treturn elem.Uint()\n-\tcase reflect.Float64:\n-\t\treturn math.Float64bits(elem.Float())\n+// getInterfacePointer returns a pointer that points to the\n+// interface data of the interface pointed by p.\n+func (p pointer) getInterfacePointer() pointer {\n+\tif p.v.Elem().IsNil() {\n+\t\treturn pointer{v: p.v.Elem()}\n \t}\n-\tpanic(\"unreachable\")\n+\treturn pointer{v: p.v.Elem().Elem().Elem().Field(0).Addr()} // *interface -> interface -> *struct -> struct\n }\n \n-func structPointer_Word64Val(p structPointer, f field) word64Val {\n-\treturn word64Val{structPointer_field(p, f)}\n+func (p pointer) asPointerTo(t reflect.Type) reflect.Value {\n+\t// TODO: check that p.v.Type().Elem() == t?\n+\treturn p.v\n }\n \n-type word64Slice struct {\n-\tv reflect.Value\n+func atomicLoadUnmarshalInfo(p **unmarshalInfo) *unmarshalInfo {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\treturn *p\n }\n-\n-func (p word64Slice) Append(x uint64) {\n-\tn, m := p.v.Len(), p.v.Cap()\n-\tif n < m {\n-\t\tp.v.SetLen(n + 1)\n-\t} else {\n-\t\tt := p.v.Type().Elem()\n-\t\tp.v.Set(reflect.Append(p.v, reflect.Zero(t)))\n-\t}\n-\telem := p.v.Index(n)\n-\tswitch elem.Kind() {\n-\tcase reflect.Int64:\n-\t\telem.SetInt(int64(int64(x)))\n-\tcase reflect.Uint64:\n-\t\telem.SetUint(uint64(x))\n-\tcase reflect.Float64:\n-\t\telem.SetFloat(float64(math.Float64frombits(x)))\n-\t}\n+func atomicStoreUnmarshalInfo(p **unmarshalInfo, v *unmarshalInfo) {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\t*p = v\n }\n-\n-func (p word64Slice) Len() int {\n-\treturn p.v.Len()\n+func atomicLoadMarshalInfo(p **marshalInfo) *marshalInfo {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\treturn *p\n }\n-\n-func (p word64Slice) Index(i int) uint64 {\n-\telem := p.v.Index(i)\n-\tswitch elem.Kind() {\n-\tcase reflect.Int64:\n-\t\treturn uint64(elem.Int())\n-\tcase reflect.Uint64:\n-\t\treturn uint64(elem.Uint())\n-\tcase reflect.Float64:\n-\t\treturn math.Float64bits(float64(elem.Float()))\n-\t}\n-\tpanic(\"unreachable\")\n+func atomicStoreMarshalInfo(p **marshalInfo, v *marshalInfo) {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\t*p = v\n }\n-\n-func structPointer_Word64Slice(p structPointer, f field) word64Slice {\n-\treturn word64Slice{structPointer_field(p, f)}\n+func atomicLoadMergeInfo(p **mergeInfo) *mergeInfo {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\treturn *p\n+}\n+func atomicStoreMergeInfo(p **mergeInfo, v *mergeInfo) {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\t*p = v\n }\n+func atomicLoadDiscardInfo(p **discardInfo) *discardInfo {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\treturn *p\n+}\n+func atomicStoreDiscardInfo(p **discardInfo, v *discardInfo) {\n+\tatomicLock.Lock()\n+\tdefer atomicLock.Unlock()\n+\t*p = v\n+}\n+\n+var atomicLock sync.Mutex"
    },
    {
      "sha": "d55a335d9453204ae01c7c21d474efdbefa7d120",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/pointer_unsafe.go",
      "status": "modified",
      "additions": 202,
      "deletions": 164,
      "changes": 366,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/pointer_unsafe.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/pointer_unsafe.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/pointer_unsafe.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -29,46 +29,21 @@\n // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-// +build !appengine,!js\n+// +build !purego,!appengine,!js\n \n // This file contains the implementation of the proto field accesses using package unsafe.\n \n package proto\n \n import (\n \t\"reflect\"\n+\t\"sync/atomic\"\n \t\"unsafe\"\n )\n \n-// NOTE: These type_Foo functions would more idiomatically be methods,\n-// but Go does not allow methods on pointer types, and we must preserve\n-// some pointer type for the garbage collector. We use these\n-// funcs with clunky names as our poor approximation to methods.\n-//\n-// An alternative would be\n-//\ttype structPointer struct { p unsafe.Pointer }\n-// but that does not registerize as well.\n-\n-// A structPointer is a pointer to a struct.\n-type structPointer unsafe.Pointer\n-\n-// toStructPointer returns a structPointer equivalent to the given reflect value.\n-func toStructPointer(v reflect.Value) structPointer {\n-\treturn structPointer(unsafe.Pointer(v.Pointer()))\n-}\n-\n-// IsNil reports whether p is nil.\n-func structPointer_IsNil(p structPointer) bool {\n-\treturn p == nil\n-}\n-\n-// Interface returns the struct pointer, assumed to have element type t,\n-// as an interface value.\n-func structPointer_Interface(p structPointer, t reflect.Type) interface{} {\n-\treturn reflect.NewAt(t, unsafe.Pointer(p)).Interface()\n-}\n+const unsafeAllowed = true\n \n-// A field identifies a field in a struct, accessible from a structPointer.\n+// A field identifies a field in a struct, accessible from a pointer.\n // In this implementation, a field is identified by its byte offset from the start of the struct.\n type field uintptr\n \n@@ -80,191 +55,254 @@ func toField(f *reflect.StructField) field {\n // invalidField is an invalid field identifier.\n const invalidField = ^field(0)\n \n+// zeroField is a noop when calling pointer.offset.\n+const zeroField = field(0)\n+\n // IsValid reports whether the field identifier is valid.\n func (f field) IsValid() bool {\n-\treturn f != ^field(0)\n+\treturn f != invalidField\n }\n \n-// Bytes returns the address of a []byte field in the struct.\n-func structPointer_Bytes(p structPointer, f field) *[]byte {\n-\treturn (*[]byte)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+// The pointer type below is for the new table-driven encoder/decoder.\n+// The implementation here uses unsafe.Pointer to create a generic pointer.\n+// In pointer_reflect.go we use reflect instead of unsafe to implement\n+// the same (but slower) interface.\n+type pointer struct {\n+\tp unsafe.Pointer\n }\n \n-// BytesSlice returns the address of a [][]byte field in the struct.\n-func structPointer_BytesSlice(p structPointer, f field) *[][]byte {\n-\treturn (*[][]byte)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n-}\n+// size of pointer\n+var ptrSize = unsafe.Sizeof(uintptr(0))\n \n-// Bool returns the address of a *bool field in the struct.\n-func structPointer_Bool(p structPointer, f field) **bool {\n-\treturn (**bool)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+// toPointer converts an interface of pointer type to a pointer\n+// that points to the same target.\n+func toPointer(i *Message) pointer {\n+\t// Super-tricky - read pointer out of data word of interface value.\n+\t// Saves ~25ns over the equivalent:\n+\t// return valToPointer(reflect.ValueOf(*i))\n+\treturn pointer{p: (*[2]unsafe.Pointer)(unsafe.Pointer(i))[1]}\n }\n \n-// BoolVal returns the address of a bool field in the struct.\n-func structPointer_BoolVal(p structPointer, f field) *bool {\n-\treturn (*bool)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+// toAddrPointer converts an interface to a pointer that points to\n+// the interface data.\n+func toAddrPointer(i *interface{}, isptr bool) pointer {\n+\t// Super-tricky - read or get the address of data word of interface value.\n+\tif isptr {\n+\t\t// The interface is of pointer type, thus it is a direct interface.\n+\t\t// The data word is the pointer data itself. We take its address.\n+\t\treturn pointer{p: unsafe.Pointer(uintptr(unsafe.Pointer(i)) + ptrSize)}\n+\t}\n+\t// The interface is not of pointer type. The data word is the pointer\n+\t// to the data.\n+\treturn pointer{p: (*[2]unsafe.Pointer)(unsafe.Pointer(i))[1]}\n }\n \n-// BoolSlice returns the address of a []bool field in the struct.\n-func structPointer_BoolSlice(p structPointer, f field) *[]bool {\n-\treturn (*[]bool)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+// valToPointer converts v to a pointer. v must be of pointer type.\n+func valToPointer(v reflect.Value) pointer {\n+\treturn pointer{p: unsafe.Pointer(v.Pointer())}\n }\n \n-// String returns the address of a *string field in the struct.\n-func structPointer_String(p structPointer, f field) **string {\n-\treturn (**string)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+// offset converts from a pointer to a structure to a pointer to\n+// one of its fields.\n+func (p pointer) offset(f field) pointer {\n+\t// For safety, we should panic if !f.IsValid, however calling panic causes\n+\t// this to no longer be inlineable, which is a serious performance cost.\n+\t/*\n+\t\tif !f.IsValid() {\n+\t\t\tpanic(\"invalid field\")\n+\t\t}\n+\t*/\n+\treturn pointer{p: unsafe.Pointer(uintptr(p.p) + uintptr(f))}\n }\n \n-// StringVal returns the address of a string field in the struct.\n-func structPointer_StringVal(p structPointer, f field) *string {\n-\treturn (*string)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+func (p pointer) isNil() bool {\n+\treturn p.p == nil\n }\n \n-// StringSlice returns the address of a []string field in the struct.\n-func structPointer_StringSlice(p structPointer, f field) *[]string {\n-\treturn (*[]string)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+func (p pointer) toInt64() *int64 {\n+\treturn (*int64)(p.p)\n }\n-\n-// ExtMap returns the address of an extension map field in the struct.\n-func structPointer_Extensions(p structPointer, f field) *XXX_InternalExtensions {\n-\treturn (*XXX_InternalExtensions)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+func (p pointer) toInt64Ptr() **int64 {\n+\treturn (**int64)(p.p)\n }\n-\n-func structPointer_ExtMap(p structPointer, f field) *map[int32]Extension {\n-\treturn (*map[int32]Extension)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+func (p pointer) toInt64Slice() *[]int64 {\n+\treturn (*[]int64)(p.p)\n }\n-\n-// NewAt returns the reflect.Value for a pointer to a field in the struct.\n-func structPointer_NewAt(p structPointer, f field, typ reflect.Type) reflect.Value {\n-\treturn reflect.NewAt(typ, unsafe.Pointer(uintptr(p)+uintptr(f)))\n+func (p pointer) toInt32() *int32 {\n+\treturn (*int32)(p.p)\n }\n \n-// SetStructPointer writes a *struct field in the struct.\n-func structPointer_SetStructPointer(p structPointer, f field, q structPointer) {\n-\t*(*structPointer)(unsafe.Pointer(uintptr(p) + uintptr(f))) = q\n+// See pointer_reflect.go for why toInt32Ptr/Slice doesn't exist.\n+/*\n+\tfunc (p pointer) toInt32Ptr() **int32 {\n+\t\treturn (**int32)(p.p)\n+\t}\n+\tfunc (p pointer) toInt32Slice() *[]int32 {\n+\t\treturn (*[]int32)(p.p)\n+\t}\n+*/\n+func (p pointer) getInt32Ptr() *int32 {\n+\treturn *(**int32)(p.p)\n }\n-\n-// GetStructPointer reads a *struct field in the struct.\n-func structPointer_GetStructPointer(p structPointer, f field) structPointer {\n-\treturn *(*structPointer)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+func (p pointer) setInt32Ptr(v int32) {\n+\t*(**int32)(p.p) = &v\n }\n \n-// StructPointerSlice the address of a []*struct field in the struct.\n-func structPointer_StructPointerSlice(p structPointer, f field) *structPointerSlice {\n-\treturn (*structPointerSlice)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+// getInt32Slice loads a []int32 from p.\n+// The value returned is aliased with the original slice.\n+// This behavior differs from the implementation in pointer_reflect.go.\n+func (p pointer) getInt32Slice() []int32 {\n+\treturn *(*[]int32)(p.p)\n }\n \n-// A structPointerSlice represents a slice of pointers to structs (themselves submessages or groups).\n-type structPointerSlice []structPointer\n-\n-func (v *structPointerSlice) Len() int                  { return len(*v) }\n-func (v *structPointerSlice) Index(i int) structPointer { return (*v)[i] }\n-func (v *structPointerSlice) Append(p structPointer)    { *v = append(*v, p) }\n-\n-// A word32 is the address of a \"pointer to 32-bit value\" field.\n-type word32 **uint32\n-\n-// IsNil reports whether *v is nil.\n-func word32_IsNil(p word32) bool {\n-\treturn *p == nil\n+// setInt32Slice stores a []int32 to p.\n+// The value set is aliased with the input slice.\n+// This behavior differs from the implementation in pointer_reflect.go.\n+func (p pointer) setInt32Slice(v []int32) {\n+\t*(*[]int32)(p.p) = v\n }\n \n-// Set sets *v to point at a newly allocated word set to x.\n-func word32_Set(p word32, o *Buffer, x uint32) {\n-\tif len(o.uint32s) == 0 {\n-\t\to.uint32s = make([]uint32, uint32PoolSize)\n-\t}\n-\to.uint32s[0] = x\n-\t*p = &o.uint32s[0]\n-\to.uint32s = o.uint32s[1:]\n+// TODO: Can we get rid of appendInt32Slice and use setInt32Slice instead?\n+func (p pointer) appendInt32Slice(v int32) {\n+\ts := (*[]int32)(p.p)\n+\t*s = append(*s, v)\n }\n \n-// Get gets the value pointed at by *v.\n-func word32_Get(p word32) uint32 {\n-\treturn **p\n+func (p pointer) toUint64() *uint64 {\n+\treturn (*uint64)(p.p)\n }\n-\n-// Word32 returns the address of a *int32, *uint32, *float32, or *enum field in the struct.\n-func structPointer_Word32(p structPointer, f field) word32 {\n-\treturn word32((**uint32)(unsafe.Pointer(uintptr(p) + uintptr(f))))\n+func (p pointer) toUint64Ptr() **uint64 {\n+\treturn (**uint64)(p.p)\n }\n-\n-// A word32Val is the address of a 32-bit value field.\n-type word32Val *uint32\n-\n-// Set sets *p to x.\n-func word32Val_Set(p word32Val, x uint32) {\n-\t*p = x\n+func (p pointer) toUint64Slice() *[]uint64 {\n+\treturn (*[]uint64)(p.p)\n }\n-\n-// Get gets the value pointed at by p.\n-func word32Val_Get(p word32Val) uint32 {\n-\treturn *p\n+func (p pointer) toUint32() *uint32 {\n+\treturn (*uint32)(p.p)\n }\n-\n-// Word32Val returns the address of a *int32, *uint32, *float32, or *enum field in the struct.\n-func structPointer_Word32Val(p structPointer, f field) word32Val {\n-\treturn word32Val((*uint32)(unsafe.Pointer(uintptr(p) + uintptr(f))))\n+func (p pointer) toUint32Ptr() **uint32 {\n+\treturn (**uint32)(p.p)\n }\n-\n-// A word32Slice is a slice of 32-bit values.\n-type word32Slice []uint32\n-\n-func (v *word32Slice) Append(x uint32)    { *v = append(*v, x) }\n-func (v *word32Slice) Len() int           { return len(*v) }\n-func (v *word32Slice) Index(i int) uint32 { return (*v)[i] }\n-\n-// Word32Slice returns the address of a []int32, []uint32, []float32, or []enum field in the struct.\n-func structPointer_Word32Slice(p structPointer, f field) *word32Slice {\n-\treturn (*word32Slice)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+func (p pointer) toUint32Slice() *[]uint32 {\n+\treturn (*[]uint32)(p.p)\n }\n-\n-// word64 is like word32 but for 64-bit values.\n-type word64 **uint64\n-\n-func word64_Set(p word64, o *Buffer, x uint64) {\n-\tif len(o.uint64s) == 0 {\n-\t\to.uint64s = make([]uint64, uint64PoolSize)\n-\t}\n-\to.uint64s[0] = x\n-\t*p = &o.uint64s[0]\n-\to.uint64s = o.uint64s[1:]\n+func (p pointer) toBool() *bool {\n+\treturn (*bool)(p.p)\n }\n-\n-func word64_IsNil(p word64) bool {\n-\treturn *p == nil\n+func (p pointer) toBoolPtr() **bool {\n+\treturn (**bool)(p.p)\n }\n-\n-func word64_Get(p word64) uint64 {\n-\treturn **p\n+func (p pointer) toBoolSlice() *[]bool {\n+\treturn (*[]bool)(p.p)\n+}\n+func (p pointer) toFloat64() *float64 {\n+\treturn (*float64)(p.p)\n+}\n+func (p pointer) toFloat64Ptr() **float64 {\n+\treturn (**float64)(p.p)\n+}\n+func (p pointer) toFloat64Slice() *[]float64 {\n+\treturn (*[]float64)(p.p)\n+}\n+func (p pointer) toFloat32() *float32 {\n+\treturn (*float32)(p.p)\n+}\n+func (p pointer) toFloat32Ptr() **float32 {\n+\treturn (**float32)(p.p)\n+}\n+func (p pointer) toFloat32Slice() *[]float32 {\n+\treturn (*[]float32)(p.p)\n+}\n+func (p pointer) toString() *string {\n+\treturn (*string)(p.p)\n+}\n+func (p pointer) toStringPtr() **string {\n+\treturn (**string)(p.p)\n+}\n+func (p pointer) toStringSlice() *[]string {\n+\treturn (*[]string)(p.p)\n+}\n+func (p pointer) toBytes() *[]byte {\n+\treturn (*[]byte)(p.p)\n+}\n+func (p pointer) toBytesSlice() *[][]byte {\n+\treturn (*[][]byte)(p.p)\n+}\n+func (p pointer) toExtensions() *XXX_InternalExtensions {\n+\treturn (*XXX_InternalExtensions)(p.p)\n+}\n+func (p pointer) toOldExtensions() *map[int32]Extension {\n+\treturn (*map[int32]Extension)(p.p)\n }\n \n-func structPointer_Word64(p structPointer, f field) word64 {\n-\treturn word64((**uint64)(unsafe.Pointer(uintptr(p) + uintptr(f))))\n+// getPointerSlice loads []*T from p as a []pointer.\n+// The value returned is aliased with the original slice.\n+// This behavior differs from the implementation in pointer_reflect.go.\n+func (p pointer) getPointerSlice() []pointer {\n+\t// Super-tricky - p should point to a []*T where T is a\n+\t// message type. We load it as []pointer.\n+\treturn *(*[]pointer)(p.p)\n }\n \n-// word64Val is like word32Val but for 64-bit values.\n-type word64Val *uint64\n+// setPointerSlice stores []pointer into p as a []*T.\n+// The value set is aliased with the input slice.\n+// This behavior differs from the implementation in pointer_reflect.go.\n+func (p pointer) setPointerSlice(v []pointer) {\n+\t// Super-tricky - p should point to a []*T where T is a\n+\t// message type. We store it as []pointer.\n+\t*(*[]pointer)(p.p) = v\n+}\n \n-func word64Val_Set(p word64Val, o *Buffer, x uint64) {\n-\t*p = x\n+// getPointer loads the pointer at p and returns it.\n+func (p pointer) getPointer() pointer {\n+\treturn pointer{p: *(*unsafe.Pointer)(p.p)}\n }\n \n-func word64Val_Get(p word64Val) uint64 {\n-\treturn *p\n+// setPointer stores the pointer q at p.\n+func (p pointer) setPointer(q pointer) {\n+\t*(*unsafe.Pointer)(p.p) = q.p\n }\n \n-func structPointer_Word64Val(p structPointer, f field) word64Val {\n-\treturn word64Val((*uint64)(unsafe.Pointer(uintptr(p) + uintptr(f))))\n+// append q to the slice pointed to by p.\n+func (p pointer) appendPointer(q pointer) {\n+\ts := (*[]unsafe.Pointer)(p.p)\n+\t*s = append(*s, q.p)\n }\n \n-// word64Slice is like word32Slice but for 64-bit values.\n-type word64Slice []uint64\n+// getInterfacePointer returns a pointer that points to the\n+// interface data of the interface pointed by p.\n+func (p pointer) getInterfacePointer() pointer {\n+\t// Super-tricky - read pointer out of data word of interface value.\n+\treturn pointer{p: (*(*[2]unsafe.Pointer)(p.p))[1]}\n+}\n \n-func (v *word64Slice) Append(x uint64)    { *v = append(*v, x) }\n-func (v *word64Slice) Len() int           { return len(*v) }\n-func (v *word64Slice) Index(i int) uint64 { return (*v)[i] }\n+// asPointerTo returns a reflect.Value that is a pointer to an\n+// object of type t stored at p.\n+func (p pointer) asPointerTo(t reflect.Type) reflect.Value {\n+\treturn reflect.NewAt(t, p.p)\n+}\n \n-func structPointer_Word64Slice(p structPointer, f field) *word64Slice {\n-\treturn (*word64Slice)(unsafe.Pointer(uintptr(p) + uintptr(f)))\n+func atomicLoadUnmarshalInfo(p **unmarshalInfo) *unmarshalInfo {\n+\treturn (*unmarshalInfo)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(p))))\n+}\n+func atomicStoreUnmarshalInfo(p **unmarshalInfo, v *unmarshalInfo) {\n+\tatomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(p)), unsafe.Pointer(v))\n+}\n+func atomicLoadMarshalInfo(p **marshalInfo) *marshalInfo {\n+\treturn (*marshalInfo)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(p))))\n+}\n+func atomicStoreMarshalInfo(p **marshalInfo, v *marshalInfo) {\n+\tatomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(p)), unsafe.Pointer(v))\n+}\n+func atomicLoadMergeInfo(p **mergeInfo) *mergeInfo {\n+\treturn (*mergeInfo)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(p))))\n+}\n+func atomicStoreMergeInfo(p **mergeInfo, v *mergeInfo) {\n+\tatomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(p)), unsafe.Pointer(v))\n+}\n+func atomicLoadDiscardInfo(p **discardInfo) *discardInfo {\n+\treturn (*discardInfo)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(p))))\n+}\n+func atomicStoreDiscardInfo(p **discardInfo, v *discardInfo) {\n+\tatomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(p)), unsafe.Pointer(v))\n }"
    },
    {
      "sha": "50b99b83a8c79b001ce4efe70986717c89bdee5f",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/properties.go",
      "status": "modified",
      "additions": 57,
      "deletions": 385,
      "changes": 442,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/properties.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/properties.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/properties.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -58,42 +58,6 @@ const (\n \tWireFixed32    = 5\n )\n \n-const startSize = 10 // initial slice/string sizes\n-\n-// Encoders are defined in encode.go\n-// An encoder outputs the full representation of a field, including its\n-// tag and encoder type.\n-type encoder func(p *Buffer, prop *Properties, base structPointer) error\n-\n-// A valueEncoder encodes a single integer in a particular encoding.\n-type valueEncoder func(o *Buffer, x uint64) error\n-\n-// Sizers are defined in encode.go\n-// A sizer returns the encoded size of a field, including its tag and encoder\n-// type.\n-type sizer func(prop *Properties, base structPointer) int\n-\n-// A valueSizer returns the encoded size of a single integer in a particular\n-// encoding.\n-type valueSizer func(x uint64) int\n-\n-// Decoders are defined in decode.go\n-// A decoder creates a value from its wire representation.\n-// Unrecognized subelements are saved in unrec.\n-type decoder func(p *Buffer, prop *Properties, base structPointer) error\n-\n-// A valueDecoder decodes a single integer in a particular encoding.\n-type valueDecoder func(o *Buffer) (x uint64, err error)\n-\n-// A oneofMarshaler does the marshaling for all oneof fields in a message.\n-type oneofMarshaler func(Message, *Buffer) error\n-\n-// A oneofUnmarshaler does the unmarshaling for a oneof field in a message.\n-type oneofUnmarshaler func(Message, int, int, *Buffer) (bool, error)\n-\n-// A oneofSizer does the sizing for all oneof fields in a message.\n-type oneofSizer func(Message) int\n-\n // tagMap is an optimization over map[int]int for typical protocol buffer\n // use-cases. Encoded protocol buffers are often in tag order with small tag\n // numbers.\n@@ -140,13 +104,6 @@ type StructProperties struct {\n \tdecoderTags      tagMap         // map from proto tag to struct field number\n \tdecoderOrigNames map[string]int // map from original name to struct field number\n \torder            []int          // list of struct field numbers in tag order\n-\tunrecField       field          // field id of the XXX_unrecognized []byte field\n-\textendable       bool           // is this an extendable proto\n-\n-\toneofMarshaler   oneofMarshaler\n-\toneofUnmarshaler oneofUnmarshaler\n-\toneofSizer       oneofSizer\n-\tstype            reflect.Type\n \n \t// OneofTypes contains information about the oneof fields in this message.\n \t// It is keyed by the original name of a field.\n@@ -182,41 +139,24 @@ type Properties struct {\n \tRepeated bool\n \tPacked   bool   // relevant for repeated primitives only\n \tEnum     string // set for enum types only\n-\tproto3   bool   // whether this is known to be a proto3 field; set for []byte only\n+\tproto3   bool   // whether this is known to be a proto3 field\n \toneof    bool   // whether this is a oneof field\n \n \tDefault    string // default value\n \tHasDefault bool   // whether an explicit default was provided\n-\tdef_uint64 uint64\n-\n-\tenc           encoder\n-\tvalEnc        valueEncoder // set for bool and numeric types only\n-\tfield         field\n-\ttagcode       []byte // encoding of EncodeVarint((Tag<<3)|WireType)\n-\ttagbuf        [8]byte\n-\tstype         reflect.Type      // set for struct types only\n-\tsprop         *StructProperties // set for struct types only\n-\tisMarshaler   bool\n-\tisUnmarshaler bool\n-\n-\tmtype    reflect.Type // set for map types only\n-\tmkeyprop *Properties  // set for map types only\n-\tmvalprop *Properties  // set for map types only\n-\n-\tsize    sizer\n-\tvalSize valueSizer // set for bool and numeric types only\n-\n-\tdec    decoder\n-\tvalDec valueDecoder // set for bool and numeric types only\n-\n-\t// If this is a packable field, this will be the decoder for the packed version of the field.\n-\tpackedDec decoder\n+\n+\tstype reflect.Type      // set for struct types only\n+\tsprop *StructProperties // set for struct types only\n+\n+\tmtype      reflect.Type // set for map types only\n+\tMapKeyProp *Properties  // set for map types only\n+\tMapValProp *Properties  // set for map types only\n }\n \n // String formats the properties in the protobuf struct field tag style.\n func (p *Properties) String() string {\n \ts := p.Wire\n-\ts = \",\"\n+\ts += \",\"\n \ts += strconv.Itoa(p.Tag)\n \tif p.Required {\n \t\ts += \",req\"\n@@ -262,29 +202,14 @@ func (p *Properties) Parse(s string) {\n \tswitch p.Wire {\n \tcase \"varint\":\n \t\tp.WireType = WireVarint\n-\t\tp.valEnc = (*Buffer).EncodeVarint\n-\t\tp.valDec = (*Buffer).DecodeVarint\n-\t\tp.valSize = sizeVarint\n \tcase \"fixed32\":\n \t\tp.WireType = WireFixed32\n-\t\tp.valEnc = (*Buffer).EncodeFixed32\n-\t\tp.valDec = (*Buffer).DecodeFixed32\n-\t\tp.valSize = sizeFixed32\n \tcase \"fixed64\":\n \t\tp.WireType = WireFixed64\n-\t\tp.valEnc = (*Buffer).EncodeFixed64\n-\t\tp.valDec = (*Buffer).DecodeFixed64\n-\t\tp.valSize = sizeFixed64\n \tcase \"zigzag32\":\n \t\tp.WireType = WireVarint\n-\t\tp.valEnc = (*Buffer).EncodeZigzag32\n-\t\tp.valDec = (*Buffer).DecodeZigzag32\n-\t\tp.valSize = sizeZigzag32\n \tcase \"zigzag64\":\n \t\tp.WireType = WireVarint\n-\t\tp.valEnc = (*Buffer).EncodeZigzag64\n-\t\tp.valDec = (*Buffer).DecodeZigzag64\n-\t\tp.valSize = sizeZigzag64\n \tcase \"bytes\", \"group\":\n \t\tp.WireType = WireBytes\n \t\t// no numeric converter for non-numeric types\n@@ -299,6 +224,7 @@ func (p *Properties) Parse(s string) {\n \t\treturn\n \t}\n \n+outer:\n \tfor i := 2; i < len(fields); i++ {\n \t\tf := fields[i]\n \t\tswitch {\n@@ -326,256 +252,41 @@ func (p *Properties) Parse(s string) {\n \t\t\tif i+1 < len(fields) {\n \t\t\t\t// Commas aren't escaped, and def is always last.\n \t\t\t\tp.Default += \",\" + strings.Join(fields[i+1:], \",\")\n-\t\t\t\tbreak\n+\t\t\t\tbreak outer\n \t\t\t}\n \t\t}\n \t}\n }\n \n-func logNoSliceEnc(t1, t2 reflect.Type) {\n-\tfmt.Fprintf(os.Stderr, \"proto: no slice oenc for %T = []%T\\n\", t1, t2)\n-}\n-\n var protoMessageType = reflect.TypeOf((*Message)(nil)).Elem()\n \n-// Initialize the fields for encoding and decoding.\n-func (p *Properties) setEncAndDec(typ reflect.Type, f *reflect.StructField, lockGetProp bool) {\n-\tp.enc = nil\n-\tp.dec = nil\n-\tp.size = nil\n-\n+// setFieldProps initializes the field properties for submessages and maps.\n+func (p *Properties) setFieldProps(typ reflect.Type, f *reflect.StructField, lockGetProp bool) {\n \tswitch t1 := typ; t1.Kind() {\n-\tdefault:\n-\t\tfmt.Fprintf(os.Stderr, \"proto: no coders for %v\\n\", t1)\n-\n-\t// proto3 scalar types\n-\n-\tcase reflect.Bool:\n-\t\tp.enc = (*Buffer).enc_proto3_bool\n-\t\tp.dec = (*Buffer).dec_proto3_bool\n-\t\tp.size = size_proto3_bool\n-\tcase reflect.Int32:\n-\t\tp.enc = (*Buffer).enc_proto3_int32\n-\t\tp.dec = (*Buffer).dec_proto3_int32\n-\t\tp.size = size_proto3_int32\n-\tcase reflect.Uint32:\n-\t\tp.enc = (*Buffer).enc_proto3_uint32\n-\t\tp.dec = (*Buffer).dec_proto3_int32 // can reuse\n-\t\tp.size = size_proto3_uint32\n-\tcase reflect.Int64, reflect.Uint64:\n-\t\tp.enc = (*Buffer).enc_proto3_int64\n-\t\tp.dec = (*Buffer).dec_proto3_int64\n-\t\tp.size = size_proto3_int64\n-\tcase reflect.Float32:\n-\t\tp.enc = (*Buffer).enc_proto3_uint32 // can just treat them as bits\n-\t\tp.dec = (*Buffer).dec_proto3_int32\n-\t\tp.size = size_proto3_uint32\n-\tcase reflect.Float64:\n-\t\tp.enc = (*Buffer).enc_proto3_int64 // can just treat them as bits\n-\t\tp.dec = (*Buffer).dec_proto3_int64\n-\t\tp.size = size_proto3_int64\n-\tcase reflect.String:\n-\t\tp.enc = (*Buffer).enc_proto3_string\n-\t\tp.dec = (*Buffer).dec_proto3_string\n-\t\tp.size = size_proto3_string\n-\n \tcase reflect.Ptr:\n-\t\tswitch t2 := t1.Elem(); t2.Kind() {\n-\t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"proto: no encoder function for %v -> %v\\n\", t1, t2)\n-\t\t\tbreak\n-\t\tcase reflect.Bool:\n-\t\t\tp.enc = (*Buffer).enc_bool\n-\t\t\tp.dec = (*Buffer).dec_bool\n-\t\t\tp.size = size_bool\n-\t\tcase reflect.Int32:\n-\t\t\tp.enc = (*Buffer).enc_int32\n-\t\t\tp.dec = (*Buffer).dec_int32\n-\t\t\tp.size = size_int32\n-\t\tcase reflect.Uint32:\n-\t\t\tp.enc = (*Buffer).enc_uint32\n-\t\t\tp.dec = (*Buffer).dec_int32 // can reuse\n-\t\t\tp.size = size_uint32\n-\t\tcase reflect.Int64, reflect.Uint64:\n-\t\t\tp.enc = (*Buffer).enc_int64\n-\t\t\tp.dec = (*Buffer).dec_int64\n-\t\t\tp.size = size_int64\n-\t\tcase reflect.Float32:\n-\t\t\tp.enc = (*Buffer).enc_uint32 // can just treat them as bits\n-\t\t\tp.dec = (*Buffer).dec_int32\n-\t\t\tp.size = size_uint32\n-\t\tcase reflect.Float64:\n-\t\t\tp.enc = (*Buffer).enc_int64 // can just treat them as bits\n-\t\t\tp.dec = (*Buffer).dec_int64\n-\t\t\tp.size = size_int64\n-\t\tcase reflect.String:\n-\t\t\tp.enc = (*Buffer).enc_string\n-\t\t\tp.dec = (*Buffer).dec_string\n-\t\t\tp.size = size_string\n-\t\tcase reflect.Struct:\n+\t\tif t1.Elem().Kind() == reflect.Struct {\n \t\t\tp.stype = t1.Elem()\n-\t\t\tp.isMarshaler = isMarshaler(t1)\n-\t\t\tp.isUnmarshaler = isUnmarshaler(t1)\n-\t\t\tif p.Wire == \"bytes\" {\n-\t\t\t\tp.enc = (*Buffer).enc_struct_message\n-\t\t\t\tp.dec = (*Buffer).dec_struct_message\n-\t\t\t\tp.size = size_struct_message\n-\t\t\t} else {\n-\t\t\t\tp.enc = (*Buffer).enc_struct_group\n-\t\t\t\tp.dec = (*Buffer).dec_struct_group\n-\t\t\t\tp.size = size_struct_group\n-\t\t\t}\n \t\t}\n \n \tcase reflect.Slice:\n-\t\tswitch t2 := t1.Elem(); t2.Kind() {\n-\t\tdefault:\n-\t\t\tlogNoSliceEnc(t1, t2)\n-\t\t\tbreak\n-\t\tcase reflect.Bool:\n-\t\t\tif p.Packed {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_packed_bool\n-\t\t\t\tp.size = size_slice_packed_bool\n-\t\t\t} else {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_bool\n-\t\t\t\tp.size = size_slice_bool\n-\t\t\t}\n-\t\t\tp.dec = (*Buffer).dec_slice_bool\n-\t\t\tp.packedDec = (*Buffer).dec_slice_packed_bool\n-\t\tcase reflect.Int32:\n-\t\t\tif p.Packed {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_packed_int32\n-\t\t\t\tp.size = size_slice_packed_int32\n-\t\t\t} else {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_int32\n-\t\t\t\tp.size = size_slice_int32\n-\t\t\t}\n-\t\t\tp.dec = (*Buffer).dec_slice_int32\n-\t\t\tp.packedDec = (*Buffer).dec_slice_packed_int32\n-\t\tcase reflect.Uint32:\n-\t\t\tif p.Packed {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_packed_uint32\n-\t\t\t\tp.size = size_slice_packed_uint32\n-\t\t\t} else {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_uint32\n-\t\t\t\tp.size = size_slice_uint32\n-\t\t\t}\n-\t\t\tp.dec = (*Buffer).dec_slice_int32\n-\t\t\tp.packedDec = (*Buffer).dec_slice_packed_int32\n-\t\tcase reflect.Int64, reflect.Uint64:\n-\t\t\tif p.Packed {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_packed_int64\n-\t\t\t\tp.size = size_slice_packed_int64\n-\t\t\t} else {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_int64\n-\t\t\t\tp.size = size_slice_int64\n-\t\t\t}\n-\t\t\tp.dec = (*Buffer).dec_slice_int64\n-\t\t\tp.packedDec = (*Buffer).dec_slice_packed_int64\n-\t\tcase reflect.Uint8:\n-\t\t\tp.dec = (*Buffer).dec_slice_byte\n-\t\t\tif p.proto3 {\n-\t\t\t\tp.enc = (*Buffer).enc_proto3_slice_byte\n-\t\t\t\tp.size = size_proto3_slice_byte\n-\t\t\t} else {\n-\t\t\t\tp.enc = (*Buffer).enc_slice_byte\n-\t\t\t\tp.size = size_slice_byte\n-\t\t\t}\n-\t\tcase reflect.Float32, reflect.Float64:\n-\t\t\tswitch t2.Bits() {\n-\t\t\tcase 32:\n-\t\t\t\t// can just treat them as bits\n-\t\t\t\tif p.Packed {\n-\t\t\t\t\tp.enc = (*Buffer).enc_slice_packed_uint32\n-\t\t\t\t\tp.size = size_slice_packed_uint32\n-\t\t\t\t} else {\n-\t\t\t\t\tp.enc = (*Buffer).enc_slice_uint32\n-\t\t\t\t\tp.size = size_slice_uint32\n-\t\t\t\t}\n-\t\t\t\tp.dec = (*Buffer).dec_slice_int32\n-\t\t\t\tp.packedDec = (*Buffer).dec_slice_packed_int32\n-\t\t\tcase 64:\n-\t\t\t\t// can just treat them as bits\n-\t\t\t\tif p.Packed {\n-\t\t\t\t\tp.enc = (*Buffer).enc_slice_packed_int64\n-\t\t\t\t\tp.size = size_slice_packed_int64\n-\t\t\t\t} else {\n-\t\t\t\t\tp.enc = (*Buffer).enc_slice_int64\n-\t\t\t\t\tp.size = size_slice_int64\n-\t\t\t\t}\n-\t\t\t\tp.dec = (*Buffer).dec_slice_int64\n-\t\t\t\tp.packedDec = (*Buffer).dec_slice_packed_int64\n-\t\t\tdefault:\n-\t\t\t\tlogNoSliceEnc(t1, t2)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\tcase reflect.String:\n-\t\t\tp.enc = (*Buffer).enc_slice_string\n-\t\t\tp.dec = (*Buffer).dec_slice_string\n-\t\t\tp.size = size_slice_string\n-\t\tcase reflect.Ptr:\n-\t\t\tswitch t3 := t2.Elem(); t3.Kind() {\n-\t\t\tdefault:\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"proto: no ptr oenc for %T -> %T -> %T\\n\", t1, t2, t3)\n-\t\t\t\tbreak\n-\t\t\tcase reflect.Struct:\n-\t\t\t\tp.stype = t2.Elem()\n-\t\t\t\tp.isMarshaler = isMarshaler(t2)\n-\t\t\t\tp.isUnmarshaler = isUnmarshaler(t2)\n-\t\t\t\tif p.Wire == \"bytes\" {\n-\t\t\t\t\tp.enc = (*Buffer).enc_slice_struct_message\n-\t\t\t\t\tp.dec = (*Buffer).dec_slice_struct_message\n-\t\t\t\t\tp.size = size_slice_struct_message\n-\t\t\t\t} else {\n-\t\t\t\t\tp.enc = (*Buffer).enc_slice_struct_group\n-\t\t\t\t\tp.dec = (*Buffer).dec_slice_struct_group\n-\t\t\t\t\tp.size = size_slice_struct_group\n-\t\t\t\t}\n-\t\t\t}\n-\t\tcase reflect.Slice:\n-\t\t\tswitch t2.Elem().Kind() {\n-\t\t\tdefault:\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"proto: no slice elem oenc for %T -> %T -> %T\\n\", t1, t2, t2.Elem())\n-\t\t\t\tbreak\n-\t\t\tcase reflect.Uint8:\n-\t\t\t\tp.enc = (*Buffer).enc_slice_slice_byte\n-\t\t\t\tp.dec = (*Buffer).dec_slice_slice_byte\n-\t\t\t\tp.size = size_slice_slice_byte\n-\t\t\t}\n+\t\tif t2 := t1.Elem(); t2.Kind() == reflect.Ptr && t2.Elem().Kind() == reflect.Struct {\n+\t\t\tp.stype = t2.Elem()\n \t\t}\n \n \tcase reflect.Map:\n-\t\tp.enc = (*Buffer).enc_new_map\n-\t\tp.dec = (*Buffer).dec_new_map\n-\t\tp.size = size_new_map\n-\n \t\tp.mtype = t1\n-\t\tp.mkeyprop = &Properties{}\n-\t\tp.mkeyprop.init(reflect.PtrTo(p.mtype.Key()), \"Key\", f.Tag.Get(\"protobuf_key\"), nil, lockGetProp)\n-\t\tp.mvalprop = &Properties{}\n+\t\tp.MapKeyProp = &Properties{}\n+\t\tp.MapKeyProp.init(reflect.PtrTo(p.mtype.Key()), \"Key\", f.Tag.Get(\"protobuf_key\"), nil, lockGetProp)\n+\t\tp.MapValProp = &Properties{}\n \t\tvtype := p.mtype.Elem()\n \t\tif vtype.Kind() != reflect.Ptr && vtype.Kind() != reflect.Slice {\n \t\t\t// The value type is not a message (*T) or bytes ([]byte),\n \t\t\t// so we need encoders for the pointer to this type.\n \t\t\tvtype = reflect.PtrTo(vtype)\n \t\t}\n-\t\tp.mvalprop.init(vtype, \"Value\", f.Tag.Get(\"protobuf_val\"), nil, lockGetProp)\n+\t\tp.MapValProp.init(vtype, \"Value\", f.Tag.Get(\"protobuf_val\"), nil, lockGetProp)\n \t}\n \n-\t// precalculate tag code\n-\twire := p.WireType\n-\tif p.Packed {\n-\t\twire = WireBytes\n-\t}\n-\tx := uint32(p.Tag)<<3 | uint32(wire)\n-\ti := 0\n-\tfor i = 0; x > 127; i++ {\n-\t\tp.tagbuf[i] = 0x80 | uint8(x&0x7F)\n-\t\tx >>= 7\n-\t}\n-\tp.tagbuf[i] = uint8(x)\n-\tp.tagcode = p.tagbuf[0 : i+1]\n-\n \tif p.stype != nil {\n \t\tif lockGetProp {\n \t\t\tp.sprop = GetProperties(p.stype)\n@@ -586,32 +297,9 @@ func (p *Properties) setEncAndDec(typ reflect.Type, f *reflect.StructField, lock\n }\n \n var (\n-\tmarshalerType   = reflect.TypeOf((*Marshaler)(nil)).Elem()\n-\tunmarshalerType = reflect.TypeOf((*Unmarshaler)(nil)).Elem()\n+\tmarshalerType = reflect.TypeOf((*Marshaler)(nil)).Elem()\n )\n \n-// isMarshaler reports whether type t implements Marshaler.\n-func isMarshaler(t reflect.Type) bool {\n-\t// We're checking for (likely) pointer-receiver methods\n-\t// so if t is not a pointer, something is very wrong.\n-\t// The calls above only invoke isMarshaler on pointer types.\n-\tif t.Kind() != reflect.Ptr {\n-\t\tpanic(\"proto: misuse of isMarshaler\")\n-\t}\n-\treturn t.Implements(marshalerType)\n-}\n-\n-// isUnmarshaler reports whether type t implements Unmarshaler.\n-func isUnmarshaler(t reflect.Type) bool {\n-\t// We're checking for (likely) pointer-receiver methods\n-\t// so if t is not a pointer, something is very wrong.\n-\t// The calls above only invoke isUnmarshaler on pointer types.\n-\tif t.Kind() != reflect.Ptr {\n-\t\tpanic(\"proto: misuse of isUnmarshaler\")\n-\t}\n-\treturn t.Implements(unmarshalerType)\n-}\n-\n // Init populates the properties from a protocol buffer struct tag.\n func (p *Properties) Init(typ reflect.Type, name, tag string, f *reflect.StructField) {\n \tp.init(typ, name, tag, f, true)\n@@ -621,14 +309,11 @@ func (p *Properties) init(typ reflect.Type, name, tag string, f *reflect.StructF\n \t// \"bytes,49,opt,def=hello!\"\n \tp.Name = name\n \tp.OrigName = name\n-\tif f != nil {\n-\t\tp.field = toField(f)\n-\t}\n \tif tag == \"\" {\n \t\treturn\n \t}\n \tp.Parse(tag)\n-\tp.setEncAndDec(typ, f, lockGetProp)\n+\tp.setFieldProps(typ, f, lockGetProp)\n }\n \n var (\n@@ -678,9 +363,6 @@ func getPropertiesLocked(t reflect.Type) *StructProperties {\n \tpropertiesMap[t] = prop\n \n \t// build properties\n-\tprop.extendable = reflect.PtrTo(t).Implements(extendableProtoType) ||\n-\t\treflect.PtrTo(t).Implements(extendableProtoV1Type)\n-\tprop.unrecField = invalidField\n \tprop.Prop = make([]*Properties, t.NumField())\n \tprop.order = make([]int, t.NumField())\n \n@@ -690,17 +372,6 @@ func getPropertiesLocked(t reflect.Type) *StructProperties {\n \t\tname := f.Name\n \t\tp.init(f.Type, name, f.Tag.Get(\"protobuf\"), &f, false)\n \n-\t\tif f.Name == \"XXX_InternalExtensions\" { // special case\n-\t\t\tp.enc = (*Buffer).enc_exts\n-\t\t\tp.dec = nil // not needed\n-\t\t\tp.size = size_exts\n-\t\t} else if f.Name == \"XXX_extensions\" { // special case\n-\t\t\tp.enc = (*Buffer).enc_map\n-\t\t\tp.dec = nil // not needed\n-\t\t\tp.size = size_map\n-\t\t} else if f.Name == \"XXX_unrecognized\" { // special case\n-\t\t\tprop.unrecField = toField(&f)\n-\t\t}\n \t\toneof := f.Tag.Get(\"protobuf_oneof\") // special case\n \t\tif oneof != \"\" {\n \t\t\t// Oneof fields don't use the traditional protobuf tag.\n@@ -715,9 +386,6 @@ func getPropertiesLocked(t reflect.Type) *StructProperties {\n \t\t\t}\n \t\t\tprint(\"\\n\")\n \t\t}\n-\t\tif p.enc == nil && !strings.HasPrefix(f.Name, \"XXX_\") && oneof == \"\" {\n-\t\t\tfmt.Fprintln(os.Stderr, \"proto: no encoder for\", f.Name, f.Type.String(), \"[GetProperties]\")\n-\t\t}\n \t}\n \n \t// Re-order prop.order.\n@@ -728,8 +396,7 @@ func getPropertiesLocked(t reflect.Type) *StructProperties {\n \t}\n \tif om, ok := reflect.Zero(reflect.PtrTo(t)).Interface().(oneofMessage); ok {\n \t\tvar oots []interface{}\n-\t\tprop.oneofMarshaler, prop.oneofUnmarshaler, prop.oneofSizer, oots = om.XXX_OneofFuncs()\n-\t\tprop.stype = t\n+\t\t_, _, _, oots = om.XXX_OneofFuncs()\n \n \t\t// Interpret oneof metadata.\n \t\tprop.OneofTypes = make(map[string]*OneofProperties)\n@@ -779,30 +446,6 @@ func getPropertiesLocked(t reflect.Type) *StructProperties {\n \treturn prop\n }\n \n-// Return the Properties object for the x[0]'th field of the structure.\n-func propByIndex(t reflect.Type, x []int) *Properties {\n-\tif len(x) != 1 {\n-\t\tfmt.Fprintf(os.Stderr, \"proto: field index dimension %d (not 1) for type %s\\n\", len(x), t)\n-\t\treturn nil\n-\t}\n-\tprop := GetProperties(t)\n-\treturn prop.Prop[x[0]]\n-}\n-\n-// Get the address and type of a pointer to a struct from an interface.\n-func getbase(pb Message) (t reflect.Type, b structPointer, err error) {\n-\tif pb == nil {\n-\t\terr = ErrNil\n-\t\treturn\n-\t}\n-\t// get the reflect type of the pointer to the struct.\n-\tt = reflect.TypeOf(pb)\n-\t// get the address of the struct.\n-\tvalue := reflect.ValueOf(pb)\n-\tb = toStructPointer(value)\n-\treturn\n-}\n-\n // A global registry of enum types.\n // The generated code will register the generated maps by calling RegisterEnum.\n \n@@ -826,20 +469,42 @@ func EnumValueMap(enumType string) map[string]int32 {\n // A registry of all linked message types.\n // The string is a fully-qualified proto name (\"pkg.Message\").\n var (\n-\tprotoTypes    = make(map[string]reflect.Type)\n-\trevProtoTypes = make(map[reflect.Type]string)\n+\tprotoTypedNils = make(map[string]Message)      // a map from proto names to typed nil pointers\n+\tprotoMapTypes  = make(map[string]reflect.Type) // a map from proto names to map types\n+\trevProtoTypes  = make(map[reflect.Type]string)\n )\n \n // RegisterType is called from generated code and maps from the fully qualified\n // proto name to the type (pointer to struct) of the protocol buffer.\n func RegisterType(x Message, name string) {\n-\tif _, ok := protoTypes[name]; ok {\n+\tif _, ok := protoTypedNils[name]; ok {\n \t\t// TODO: Some day, make this a panic.\n \t\tlog.Printf(\"proto: duplicate proto type registered: %s\", name)\n \t\treturn\n \t}\n \tt := reflect.TypeOf(x)\n-\tprotoTypes[name] = t\n+\tif v := reflect.ValueOf(x); v.Kind() == reflect.Ptr && v.Pointer() == 0 {\n+\t\t// Generated code always calls RegisterType with nil x.\n+\t\t// This check is just for extra safety.\n+\t\tprotoTypedNils[name] = x\n+\t} else {\n+\t\tprotoTypedNils[name] = reflect.Zero(t).Interface().(Message)\n+\t}\n+\trevProtoTypes[t] = name\n+}\n+\n+// RegisterMapType is called from generated code and maps from the fully qualified\n+// proto name to the native map type of the proto map definition.\n+func RegisterMapType(x interface{}, name string) {\n+\tif reflect.TypeOf(x).Kind() != reflect.Map {\n+\t\tpanic(fmt.Sprintf(\"RegisterMapType(%T, %q); want map\", x, name))\n+\t}\n+\tif _, ok := protoMapTypes[name]; ok {\n+\t\tlog.Printf(\"proto: duplicate proto type registered: %s\", name)\n+\t\treturn\n+\t}\n+\tt := reflect.TypeOf(x)\n+\tprotoMapTypes[name] = t\n \trevProtoTypes[t] = name\n }\n \n@@ -855,7 +520,14 @@ func MessageName(x Message) string {\n }\n \n // MessageType returns the message type (pointer to struct) for a named message.\n-func MessageType(name string) reflect.Type { return protoTypes[name] }\n+// The type is not guaranteed to implement proto.Message if the name refers to a\n+// map entry.\n+func MessageType(name string) reflect.Type {\n+\tif t, ok := protoTypedNils[name]; ok {\n+\t\treturn reflect.TypeOf(t)\n+\t}\n+\treturn protoMapTypes[name]\n+}\n \n // A registry of all linked proto files.\n var ("
    },
    {
      "sha": "b16794496f5f1d4b0448489e7259f1d103681b9c",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/table_marshal.go",
      "status": "added",
      "additions": 2767,
      "deletions": 0,
      "changes": 2767,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/table_marshal.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/table_marshal.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/table_marshal.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -0,0 +1,2767 @@\n+// Go support for Protocol Buffers - Google's data interchange format\n+//\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// https://github.com/golang/protobuf\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+package proto\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\t\"unicode/utf8\"\n+)\n+\n+// a sizer takes a pointer to a field and the size of its tag, computes the size of\n+// the encoded data.\n+type sizer func(pointer, int) int\n+\n+// a marshaler takes a byte slice, a pointer to a field, and its tag (in wire format),\n+// marshals the field to the end of the slice, returns the slice and error (if any).\n+type marshaler func(b []byte, ptr pointer, wiretag uint64, deterministic bool) ([]byte, error)\n+\n+// marshalInfo is the information used for marshaling a message.\n+type marshalInfo struct {\n+\ttyp          reflect.Type\n+\tfields       []*marshalFieldInfo\n+\tunrecognized field                      // offset of XXX_unrecognized\n+\textensions   field                      // offset of XXX_InternalExtensions\n+\tv1extensions field                      // offset of XXX_extensions\n+\tsizecache    field                      // offset of XXX_sizecache\n+\tinitialized  int32                      // 0 -- only typ is set, 1 -- fully initialized\n+\tmessageset   bool                       // uses message set wire format\n+\thasmarshaler bool                       // has custom marshaler\n+\tsync.RWMutex                            // protect extElems map, also for initialization\n+\textElems     map[int32]*marshalElemInfo // info of extension elements\n+}\n+\n+// marshalFieldInfo is the information used for marshaling a field of a message.\n+type marshalFieldInfo struct {\n+\tfield      field\n+\twiretag    uint64 // tag in wire format\n+\ttagsize    int    // size of tag in wire format\n+\tsizer      sizer\n+\tmarshaler  marshaler\n+\tisPointer  bool\n+\trequired   bool                              // field is required\n+\tname       string                            // name of the field, for error reporting\n+\toneofElems map[reflect.Type]*marshalElemInfo // info of oneof elements\n+}\n+\n+// marshalElemInfo is the information used for marshaling an extension or oneof element.\n+type marshalElemInfo struct {\n+\twiretag   uint64 // tag in wire format\n+\ttagsize   int    // size of tag in wire format\n+\tsizer     sizer\n+\tmarshaler marshaler\n+\tisptr     bool // elem is pointer typed, thus interface of this type is a direct interface (extension only)\n+}\n+\n+var (\n+\tmarshalInfoMap  = map[reflect.Type]*marshalInfo{}\n+\tmarshalInfoLock sync.Mutex\n+)\n+\n+// getMarshalInfo returns the information to marshal a given type of message.\n+// The info it returns may not necessarily initialized.\n+// t is the type of the message (NOT the pointer to it).\n+func getMarshalInfo(t reflect.Type) *marshalInfo {\n+\tmarshalInfoLock.Lock()\n+\tu, ok := marshalInfoMap[t]\n+\tif !ok {\n+\t\tu = &marshalInfo{typ: t}\n+\t\tmarshalInfoMap[t] = u\n+\t}\n+\tmarshalInfoLock.Unlock()\n+\treturn u\n+}\n+\n+// Size is the entry point from generated code,\n+// and should be ONLY called by generated code.\n+// It computes the size of encoded data of msg.\n+// a is a pointer to a place to store cached marshal info.\n+func (a *InternalMessageInfo) Size(msg Message) int {\n+\tu := getMessageMarshalInfo(msg, a)\n+\tptr := toPointer(&msg)\n+\tif ptr.isNil() {\n+\t\t// We get here if msg is a typed nil ((*SomeMessage)(nil)),\n+\t\t// so it satisfies the interface, and msg == nil wouldn't\n+\t\t// catch it. We don't want crash in this case.\n+\t\treturn 0\n+\t}\n+\treturn u.size(ptr)\n+}\n+\n+// Marshal is the entry point from generated code,\n+// and should be ONLY called by generated code.\n+// It marshals msg to the end of b.\n+// a is a pointer to a place to store cached marshal info.\n+func (a *InternalMessageInfo) Marshal(b []byte, msg Message, deterministic bool) ([]byte, error) {\n+\tu := getMessageMarshalInfo(msg, a)\n+\tptr := toPointer(&msg)\n+\tif ptr.isNil() {\n+\t\t// We get here if msg is a typed nil ((*SomeMessage)(nil)),\n+\t\t// so it satisfies the interface, and msg == nil wouldn't\n+\t\t// catch it. We don't want crash in this case.\n+\t\treturn b, ErrNil\n+\t}\n+\treturn u.marshal(b, ptr, deterministic)\n+}\n+\n+func getMessageMarshalInfo(msg interface{}, a *InternalMessageInfo) *marshalInfo {\n+\t// u := a.marshal, but atomically.\n+\t// We use an atomic here to ensure memory consistency.\n+\tu := atomicLoadMarshalInfo(&a.marshal)\n+\tif u == nil {\n+\t\t// Get marshal information from type of message.\n+\t\tt := reflect.ValueOf(msg).Type()\n+\t\tif t.Kind() != reflect.Ptr {\n+\t\t\tpanic(fmt.Sprintf(\"cannot handle non-pointer message type %v\", t))\n+\t\t}\n+\t\tu = getMarshalInfo(t.Elem())\n+\t\t// Store it in the cache for later users.\n+\t\t// a.marshal = u, but atomically.\n+\t\tatomicStoreMarshalInfo(&a.marshal, u)\n+\t}\n+\treturn u\n+}\n+\n+// size is the main function to compute the size of the encoded data of a message.\n+// ptr is the pointer to the message.\n+func (u *marshalInfo) size(ptr pointer) int {\n+\tif atomic.LoadInt32(&u.initialized) == 0 {\n+\t\tu.computeMarshalInfo()\n+\t}\n+\n+\t// If the message can marshal itself, let it do it, for compatibility.\n+\t// NOTE: This is not efficient.\n+\tif u.hasmarshaler {\n+\t\tm := ptr.asPointerTo(u.typ).Interface().(Marshaler)\n+\t\tb, _ := m.Marshal()\n+\t\treturn len(b)\n+\t}\n+\n+\tn := 0\n+\tfor _, f := range u.fields {\n+\t\tif f.isPointer && ptr.offset(f.field).getPointer().isNil() {\n+\t\t\t// nil pointer always marshals to nothing\n+\t\t\tcontinue\n+\t\t}\n+\t\tn += f.sizer(ptr.offset(f.field), f.tagsize)\n+\t}\n+\tif u.extensions.IsValid() {\n+\t\te := ptr.offset(u.extensions).toExtensions()\n+\t\tif u.messageset {\n+\t\t\tn += u.sizeMessageSet(e)\n+\t\t} else {\n+\t\t\tn += u.sizeExtensions(e)\n+\t\t}\n+\t}\n+\tif u.v1extensions.IsValid() {\n+\t\tm := *ptr.offset(u.v1extensions).toOldExtensions()\n+\t\tn += u.sizeV1Extensions(m)\n+\t}\n+\tif u.unrecognized.IsValid() {\n+\t\ts := *ptr.offset(u.unrecognized).toBytes()\n+\t\tn += len(s)\n+\t}\n+\t// cache the result for use in marshal\n+\tif u.sizecache.IsValid() {\n+\t\tatomic.StoreInt32(ptr.offset(u.sizecache).toInt32(), int32(n))\n+\t}\n+\treturn n\n+}\n+\n+// cachedsize gets the size from cache. If there is no cache (i.e. message is not generated),\n+// fall back to compute the size.\n+func (u *marshalInfo) cachedsize(ptr pointer) int {\n+\tif u.sizecache.IsValid() {\n+\t\treturn int(atomic.LoadInt32(ptr.offset(u.sizecache).toInt32()))\n+\t}\n+\treturn u.size(ptr)\n+}\n+\n+// marshal is the main function to marshal a message. It takes a byte slice and appends\n+// the encoded data to the end of the slice, returns the slice and error (if any).\n+// ptr is the pointer to the message.\n+// If deterministic is true, map is marshaled in deterministic order.\n+func (u *marshalInfo) marshal(b []byte, ptr pointer, deterministic bool) ([]byte, error) {\n+\tif atomic.LoadInt32(&u.initialized) == 0 {\n+\t\tu.computeMarshalInfo()\n+\t}\n+\n+\t// If the message can marshal itself, let it do it, for compatibility.\n+\t// NOTE: This is not efficient.\n+\tif u.hasmarshaler {\n+\t\tm := ptr.asPointerTo(u.typ).Interface().(Marshaler)\n+\t\tb1, err := m.Marshal()\n+\t\tb = append(b, b1...)\n+\t\treturn b, err\n+\t}\n+\n+\tvar err, errLater error\n+\t// The old marshaler encodes extensions at beginning.\n+\tif u.extensions.IsValid() {\n+\t\te := ptr.offset(u.extensions).toExtensions()\n+\t\tif u.messageset {\n+\t\t\tb, err = u.appendMessageSet(b, e, deterministic)\n+\t\t} else {\n+\t\t\tb, err = u.appendExtensions(b, e, deterministic)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn b, err\n+\t\t}\n+\t}\n+\tif u.v1extensions.IsValid() {\n+\t\tm := *ptr.offset(u.v1extensions).toOldExtensions()\n+\t\tb, err = u.appendV1Extensions(b, m, deterministic)\n+\t\tif err != nil {\n+\t\t\treturn b, err\n+\t\t}\n+\t}\n+\tfor _, f := range u.fields {\n+\t\tif f.required {\n+\t\t\tif ptr.offset(f.field).getPointer().isNil() {\n+\t\t\t\t// Required field is not set.\n+\t\t\t\t// We record the error but keep going, to give a complete marshaling.\n+\t\t\t\tif errLater == nil {\n+\t\t\t\t\terrLater = &RequiredNotSetError{f.name}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tif f.isPointer && ptr.offset(f.field).getPointer().isNil() {\n+\t\t\t// nil pointer always marshals to nothing\n+\t\t\tcontinue\n+\t\t}\n+\t\tb, err = f.marshaler(b, ptr.offset(f.field), f.wiretag, deterministic)\n+\t\tif err != nil {\n+\t\t\tif err1, ok := err.(*RequiredNotSetError); ok {\n+\t\t\t\t// Required field in submessage is not set.\n+\t\t\t\t// We record the error but keep going, to give a complete marshaling.\n+\t\t\t\tif errLater == nil {\n+\t\t\t\t\terrLater = &RequiredNotSetError{f.name + \".\" + err1.field}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err == errRepeatedHasNil {\n+\t\t\t\terr = errors.New(\"proto: repeated field \" + f.name + \" has nil element\")\n+\t\t\t}\n+\t\t\tif err == errInvalidUTF8 {\n+\t\t\t\tif errLater == nil {\n+\t\t\t\t\tfullName := revProtoTypes[reflect.PtrTo(u.typ)] + \".\" + f.name\n+\t\t\t\t\terrLater = &invalidUTF8Error{fullName}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn b, err\n+\t\t}\n+\t}\n+\tif u.unrecognized.IsValid() {\n+\t\ts := *ptr.offset(u.unrecognized).toBytes()\n+\t\tb = append(b, s...)\n+\t}\n+\treturn b, errLater\n+}\n+\n+// computeMarshalInfo initializes the marshal info.\n+func (u *marshalInfo) computeMarshalInfo() {\n+\tu.Lock()\n+\tdefer u.Unlock()\n+\tif u.initialized != 0 { // non-atomic read is ok as it is protected by the lock\n+\t\treturn\n+\t}\n+\n+\tt := u.typ\n+\tu.unrecognized = invalidField\n+\tu.extensions = invalidField\n+\tu.v1extensions = invalidField\n+\tu.sizecache = invalidField\n+\n+\t// If the message can marshal itself, let it do it, for compatibility.\n+\t// NOTE: This is not efficient.\n+\tif reflect.PtrTo(t).Implements(marshalerType) {\n+\t\tu.hasmarshaler = true\n+\t\tatomic.StoreInt32(&u.initialized, 1)\n+\t\treturn\n+\t}\n+\n+\t// get oneof implementers\n+\tvar oneofImplementers []interface{}\n+\tif m, ok := reflect.Zero(reflect.PtrTo(t)).Interface().(oneofMessage); ok {\n+\t\t_, _, _, oneofImplementers = m.XXX_OneofFuncs()\n+\t}\n+\n+\tn := t.NumField()\n+\n+\t// deal with XXX fields first\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\tf := t.Field(i)\n+\t\tif !strings.HasPrefix(f.Name, \"XXX_\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch f.Name {\n+\t\tcase \"XXX_sizecache\":\n+\t\t\tu.sizecache = toField(&f)\n+\t\tcase \"XXX_unrecognized\":\n+\t\t\tu.unrecognized = toField(&f)\n+\t\tcase \"XXX_InternalExtensions\":\n+\t\t\tu.extensions = toField(&f)\n+\t\t\tu.messageset = f.Tag.Get(\"protobuf_messageset\") == \"1\"\n+\t\tcase \"XXX_extensions\":\n+\t\t\tu.v1extensions = toField(&f)\n+\t\tcase \"XXX_NoUnkeyedLiteral\":\n+\t\t\t// nothing to do\n+\t\tdefault:\n+\t\t\tpanic(\"unknown XXX field: \" + f.Name)\n+\t\t}\n+\t\tn--\n+\t}\n+\n+\t// normal fields\n+\tfields := make([]marshalFieldInfo, n) // batch allocation\n+\tu.fields = make([]*marshalFieldInfo, 0, n)\n+\tfor i, j := 0, 0; i < t.NumField(); i++ {\n+\t\tf := t.Field(i)\n+\n+\t\tif strings.HasPrefix(f.Name, \"XXX_\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfield := &fields[j]\n+\t\tj++\n+\t\tfield.name = f.Name\n+\t\tu.fields = append(u.fields, field)\n+\t\tif f.Tag.Get(\"protobuf_oneof\") != \"\" {\n+\t\t\tfield.computeOneofFieldInfo(&f, oneofImplementers)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f.Tag.Get(\"protobuf\") == \"\" {\n+\t\t\t// field has no tag (not in generated message), ignore it\n+\t\t\tu.fields = u.fields[:len(u.fields)-1]\n+\t\t\tj--\n+\t\t\tcontinue\n+\t\t}\n+\t\tfield.computeMarshalFieldInfo(&f)\n+\t}\n+\n+\t// fields are marshaled in tag order on the wire.\n+\tsort.Sort(byTag(u.fields))\n+\n+\tatomic.StoreInt32(&u.initialized, 1)\n+}\n+\n+// helper for sorting fields by tag\n+type byTag []*marshalFieldInfo\n+\n+func (a byTag) Len() int           { return len(a) }\n+func (a byTag) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n+func (a byTag) Less(i, j int) bool { return a[i].wiretag < a[j].wiretag }\n+\n+// getExtElemInfo returns the information to marshal an extension element.\n+// The info it returns is initialized.\n+func (u *marshalInfo) getExtElemInfo(desc *ExtensionDesc) *marshalElemInfo {\n+\t// get from cache first\n+\tu.RLock()\n+\te, ok := u.extElems[desc.Field]\n+\tu.RUnlock()\n+\tif ok {\n+\t\treturn e\n+\t}\n+\n+\tt := reflect.TypeOf(desc.ExtensionType) // pointer or slice to basic type or struct\n+\ttags := strings.Split(desc.Tag, \",\")\n+\ttag, err := strconv.Atoi(tags[1])\n+\tif err != nil {\n+\t\tpanic(\"tag is not an integer\")\n+\t}\n+\twt := wiretype(tags[0])\n+\tsizer, marshaler := typeMarshaler(t, tags, false, false)\n+\te = &marshalElemInfo{\n+\t\twiretag:   uint64(tag)<<3 | wt,\n+\t\ttagsize:   SizeVarint(uint64(tag) << 3),\n+\t\tsizer:     sizer,\n+\t\tmarshaler: marshaler,\n+\t\tisptr:     t.Kind() == reflect.Ptr,\n+\t}\n+\n+\t// update cache\n+\tu.Lock()\n+\tif u.extElems == nil {\n+\t\tu.extElems = make(map[int32]*marshalElemInfo)\n+\t}\n+\tu.extElems[desc.Field] = e\n+\tu.Unlock()\n+\treturn e\n+}\n+\n+// computeMarshalFieldInfo fills up the information to marshal a field.\n+func (fi *marshalFieldInfo) computeMarshalFieldInfo(f *reflect.StructField) {\n+\t// parse protobuf tag of the field.\n+\t// tag has format of \"bytes,49,opt,name=foo,def=hello!\"\n+\ttags := strings.Split(f.Tag.Get(\"protobuf\"), \",\")\n+\tif tags[0] == \"\" {\n+\t\treturn\n+\t}\n+\ttag, err := strconv.Atoi(tags[1])\n+\tif err != nil {\n+\t\tpanic(\"tag is not an integer\")\n+\t}\n+\twt := wiretype(tags[0])\n+\tif tags[2] == \"req\" {\n+\t\tfi.required = true\n+\t}\n+\tfi.setTag(f, tag, wt)\n+\tfi.setMarshaler(f, tags)\n+}\n+\n+func (fi *marshalFieldInfo) computeOneofFieldInfo(f *reflect.StructField, oneofImplementers []interface{}) {\n+\tfi.field = toField(f)\n+\tfi.wiretag = 1<<31 - 1 // Use a large tag number, make oneofs sorted at the end. This tag will not appear on the wire.\n+\tfi.isPointer = true\n+\tfi.sizer, fi.marshaler = makeOneOfMarshaler(fi, f)\n+\tfi.oneofElems = make(map[reflect.Type]*marshalElemInfo)\n+\n+\tityp := f.Type // interface type\n+\tfor _, o := range oneofImplementers {\n+\t\tt := reflect.TypeOf(o)\n+\t\tif !t.Implements(ityp) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsf := t.Elem().Field(0) // oneof implementer is a struct with a single field\n+\t\ttags := strings.Split(sf.Tag.Get(\"protobuf\"), \",\")\n+\t\ttag, err := strconv.Atoi(tags[1])\n+\t\tif err != nil {\n+\t\t\tpanic(\"tag is not an integer\")\n+\t\t}\n+\t\twt := wiretype(tags[0])\n+\t\tsizer, marshaler := typeMarshaler(sf.Type, tags, false, true) // oneof should not omit any zero value\n+\t\tfi.oneofElems[t.Elem()] = &marshalElemInfo{\n+\t\t\twiretag:   uint64(tag)<<3 | wt,\n+\t\t\ttagsize:   SizeVarint(uint64(tag) << 3),\n+\t\t\tsizer:     sizer,\n+\t\t\tmarshaler: marshaler,\n+\t\t}\n+\t}\n+}\n+\n+type oneofMessage interface {\n+\tXXX_OneofFuncs() (func(Message, *Buffer) error, func(Message, int, int, *Buffer) (bool, error), func(Message) int, []interface{})\n+}\n+\n+// wiretype returns the wire encoding of the type.\n+func wiretype(encoding string) uint64 {\n+\tswitch encoding {\n+\tcase \"fixed32\":\n+\t\treturn WireFixed32\n+\tcase \"fixed64\":\n+\t\treturn WireFixed64\n+\tcase \"varint\", \"zigzag32\", \"zigzag64\":\n+\t\treturn WireVarint\n+\tcase \"bytes\":\n+\t\treturn WireBytes\n+\tcase \"group\":\n+\t\treturn WireStartGroup\n+\t}\n+\tpanic(\"unknown wire type \" + encoding)\n+}\n+\n+// setTag fills up the tag (in wire format) and its size in the info of a field.\n+func (fi *marshalFieldInfo) setTag(f *reflect.StructField, tag int, wt uint64) {\n+\tfi.field = toField(f)\n+\tfi.wiretag = uint64(tag)<<3 | wt\n+\tfi.tagsize = SizeVarint(uint64(tag) << 3)\n+}\n+\n+// setMarshaler fills up the sizer and marshaler in the info of a field.\n+func (fi *marshalFieldInfo) setMarshaler(f *reflect.StructField, tags []string) {\n+\tswitch f.Type.Kind() {\n+\tcase reflect.Map:\n+\t\t// map field\n+\t\tfi.isPointer = true\n+\t\tfi.sizer, fi.marshaler = makeMapMarshaler(f)\n+\t\treturn\n+\tcase reflect.Ptr, reflect.Slice:\n+\t\tfi.isPointer = true\n+\t}\n+\tfi.sizer, fi.marshaler = typeMarshaler(f.Type, tags, true, false)\n+}\n+\n+// typeMarshaler returns the sizer and marshaler of a given field.\n+// t is the type of the field.\n+// tags is the generated \"protobuf\" tag of the field.\n+// If nozero is true, zero value is not marshaled to the wire.\n+// If oneof is true, it is a oneof field.\n+func typeMarshaler(t reflect.Type, tags []string, nozero, oneof bool) (sizer, marshaler) {\n+\tencoding := tags[0]\n+\n+\tpointer := false\n+\tslice := false\n+\tif t.Kind() == reflect.Slice && t.Elem().Kind() != reflect.Uint8 {\n+\t\tslice = true\n+\t\tt = t.Elem()\n+\t}\n+\tif t.Kind() == reflect.Ptr {\n+\t\tpointer = true\n+\t\tt = t.Elem()\n+\t}\n+\n+\tpacked := false\n+\tproto3 := false\n+\tvalidateUTF8 := true\n+\tfor i := 2; i < len(tags); i++ {\n+\t\tif tags[i] == \"packed\" {\n+\t\t\tpacked = true\n+\t\t}\n+\t\tif tags[i] == \"proto3\" {\n+\t\t\tproto3 = true\n+\t\t}\n+\t}\n+\tvalidateUTF8 = validateUTF8 && proto3\n+\n+\tswitch t.Kind() {\n+\tcase reflect.Bool:\n+\t\tif pointer {\n+\t\t\treturn sizeBoolPtr, appendBoolPtr\n+\t\t}\n+\t\tif slice {\n+\t\t\tif packed {\n+\t\t\t\treturn sizeBoolPackedSlice, appendBoolPackedSlice\n+\t\t\t}\n+\t\t\treturn sizeBoolSlice, appendBoolSlice\n+\t\t}\n+\t\tif nozero {\n+\t\t\treturn sizeBoolValueNoZero, appendBoolValueNoZero\n+\t\t}\n+\t\treturn sizeBoolValue, appendBoolValue\n+\tcase reflect.Uint32:\n+\t\tswitch encoding {\n+\t\tcase \"fixed32\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeFixed32Ptr, appendFixed32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeFixed32PackedSlice, appendFixed32PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeFixed32Slice, appendFixed32Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeFixed32ValueNoZero, appendFixed32ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeFixed32Value, appendFixed32Value\n+\t\tcase \"varint\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeVarint32Ptr, appendVarint32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeVarint32PackedSlice, appendVarint32PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeVarint32Slice, appendVarint32Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeVarint32ValueNoZero, appendVarint32ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeVarint32Value, appendVarint32Value\n+\t\t}\n+\tcase reflect.Int32:\n+\t\tswitch encoding {\n+\t\tcase \"fixed32\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeFixedS32Ptr, appendFixedS32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeFixedS32PackedSlice, appendFixedS32PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeFixedS32Slice, appendFixedS32Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeFixedS32ValueNoZero, appendFixedS32ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeFixedS32Value, appendFixedS32Value\n+\t\tcase \"varint\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeVarintS32Ptr, appendVarintS32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeVarintS32PackedSlice, appendVarintS32PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeVarintS32Slice, appendVarintS32Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeVarintS32ValueNoZero, appendVarintS32ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeVarintS32Value, appendVarintS32Value\n+\t\tcase \"zigzag32\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeZigzag32Ptr, appendZigzag32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeZigzag32PackedSlice, appendZigzag32PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeZigzag32Slice, appendZigzag32Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeZigzag32ValueNoZero, appendZigzag32ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeZigzag32Value, appendZigzag32Value\n+\t\t}\n+\tcase reflect.Uint64:\n+\t\tswitch encoding {\n+\t\tcase \"fixed64\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeFixed64Ptr, appendFixed64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeFixed64PackedSlice, appendFixed64PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeFixed64Slice, appendFixed64Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeFixed64ValueNoZero, appendFixed64ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeFixed64Value, appendFixed64Value\n+\t\tcase \"varint\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeVarint64Ptr, appendVarint64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeVarint64PackedSlice, appendVarint64PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeVarint64Slice, appendVarint64Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeVarint64ValueNoZero, appendVarint64ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeVarint64Value, appendVarint64Value\n+\t\t}\n+\tcase reflect.Int64:\n+\t\tswitch encoding {\n+\t\tcase \"fixed64\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeFixedS64Ptr, appendFixedS64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeFixedS64PackedSlice, appendFixedS64PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeFixedS64Slice, appendFixedS64Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeFixedS64ValueNoZero, appendFixedS64ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeFixedS64Value, appendFixedS64Value\n+\t\tcase \"varint\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeVarintS64Ptr, appendVarintS64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeVarintS64PackedSlice, appendVarintS64PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeVarintS64Slice, appendVarintS64Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeVarintS64ValueNoZero, appendVarintS64ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeVarintS64Value, appendVarintS64Value\n+\t\tcase \"zigzag64\":\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeZigzag64Ptr, appendZigzag64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\tif packed {\n+\t\t\t\t\treturn sizeZigzag64PackedSlice, appendZigzag64PackedSlice\n+\t\t\t\t}\n+\t\t\t\treturn sizeZigzag64Slice, appendZigzag64Slice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeZigzag64ValueNoZero, appendZigzag64ValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeZigzag64Value, appendZigzag64Value\n+\t\t}\n+\tcase reflect.Float32:\n+\t\tif pointer {\n+\t\t\treturn sizeFloat32Ptr, appendFloat32Ptr\n+\t\t}\n+\t\tif slice {\n+\t\t\tif packed {\n+\t\t\t\treturn sizeFloat32PackedSlice, appendFloat32PackedSlice\n+\t\t\t}\n+\t\t\treturn sizeFloat32Slice, appendFloat32Slice\n+\t\t}\n+\t\tif nozero {\n+\t\t\treturn sizeFloat32ValueNoZero, appendFloat32ValueNoZero\n+\t\t}\n+\t\treturn sizeFloat32Value, appendFloat32Value\n+\tcase reflect.Float64:\n+\t\tif pointer {\n+\t\t\treturn sizeFloat64Ptr, appendFloat64Ptr\n+\t\t}\n+\t\tif slice {\n+\t\t\tif packed {\n+\t\t\t\treturn sizeFloat64PackedSlice, appendFloat64PackedSlice\n+\t\t\t}\n+\t\t\treturn sizeFloat64Slice, appendFloat64Slice\n+\t\t}\n+\t\tif nozero {\n+\t\t\treturn sizeFloat64ValueNoZero, appendFloat64ValueNoZero\n+\t\t}\n+\t\treturn sizeFloat64Value, appendFloat64Value\n+\tcase reflect.String:\n+\t\tif validateUTF8 {\n+\t\t\tif pointer {\n+\t\t\t\treturn sizeStringPtr, appendUTF8StringPtr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn sizeStringSlice, appendUTF8StringSlice\n+\t\t\t}\n+\t\t\tif nozero {\n+\t\t\t\treturn sizeStringValueNoZero, appendUTF8StringValueNoZero\n+\t\t\t}\n+\t\t\treturn sizeStringValue, appendUTF8StringValue\n+\t\t}\n+\t\tif pointer {\n+\t\t\treturn sizeStringPtr, appendStringPtr\n+\t\t}\n+\t\tif slice {\n+\t\t\treturn sizeStringSlice, appendStringSlice\n+\t\t}\n+\t\tif nozero {\n+\t\t\treturn sizeStringValueNoZero, appendStringValueNoZero\n+\t\t}\n+\t\treturn sizeStringValue, appendStringValue\n+\tcase reflect.Slice:\n+\t\tif slice {\n+\t\t\treturn sizeBytesSlice, appendBytesSlice\n+\t\t}\n+\t\tif oneof {\n+\t\t\t// Oneof bytes field may also have \"proto3\" tag.\n+\t\t\t// We want to marshal it as a oneof field. Do this\n+\t\t\t// check before the proto3 check.\n+\t\t\treturn sizeBytesOneof, appendBytesOneof\n+\t\t}\n+\t\tif proto3 {\n+\t\t\treturn sizeBytes3, appendBytes3\n+\t\t}\n+\t\treturn sizeBytes, appendBytes\n+\tcase reflect.Struct:\n+\t\tswitch encoding {\n+\t\tcase \"group\":\n+\t\t\tif slice {\n+\t\t\t\treturn makeGroupSliceMarshaler(getMarshalInfo(t))\n+\t\t\t}\n+\t\t\treturn makeGroupMarshaler(getMarshalInfo(t))\n+\t\tcase \"bytes\":\n+\t\t\tif slice {\n+\t\t\t\treturn makeMessageSliceMarshaler(getMarshalInfo(t))\n+\t\t\t}\n+\t\t\treturn makeMessageMarshaler(getMarshalInfo(t))\n+\t\t}\n+\t}\n+\tpanic(fmt.Sprintf(\"unknown or mismatched type: type: %v, wire type: %v\", t, encoding))\n+}\n+\n+// Below are functions to size/marshal a specific type of a field.\n+// They are stored in the field's info, and called by function pointers.\n+// They have type sizer or marshaler.\n+\n+func sizeFixed32Value(_ pointer, tagsize int) int {\n+\treturn 4 + tagsize\n+}\n+func sizeFixed32ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toUint32()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 4 + tagsize\n+}\n+func sizeFixed32Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toUint32Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn 4 + tagsize\n+}\n+func sizeFixed32Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint32Slice()\n+\treturn (4 + tagsize) * len(s)\n+}\n+func sizeFixed32PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint32Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 4*len(s) + SizeVarint(uint64(4*len(s))) + tagsize\n+}\n+func sizeFixedS32Value(_ pointer, tagsize int) int {\n+\treturn 4 + tagsize\n+}\n+func sizeFixedS32ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt32()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 4 + tagsize\n+}\n+func sizeFixedS32Ptr(ptr pointer, tagsize int) int {\n+\tp := ptr.getInt32Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn 4 + tagsize\n+}\n+func sizeFixedS32Slice(ptr pointer, tagsize int) int {\n+\ts := ptr.getInt32Slice()\n+\treturn (4 + tagsize) * len(s)\n+}\n+func sizeFixedS32PackedSlice(ptr pointer, tagsize int) int {\n+\ts := ptr.getInt32Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 4*len(s) + SizeVarint(uint64(4*len(s))) + tagsize\n+}\n+func sizeFloat32Value(_ pointer, tagsize int) int {\n+\treturn 4 + tagsize\n+}\n+func sizeFloat32ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := math.Float32bits(*ptr.toFloat32())\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 4 + tagsize\n+}\n+func sizeFloat32Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toFloat32Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn 4 + tagsize\n+}\n+func sizeFloat32Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toFloat32Slice()\n+\treturn (4 + tagsize) * len(s)\n+}\n+func sizeFloat32PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toFloat32Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 4*len(s) + SizeVarint(uint64(4*len(s))) + tagsize\n+}\n+func sizeFixed64Value(_ pointer, tagsize int) int {\n+\treturn 8 + tagsize\n+}\n+func sizeFixed64ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toUint64()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 8 + tagsize\n+}\n+func sizeFixed64Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toUint64Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn 8 + tagsize\n+}\n+func sizeFixed64Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint64Slice()\n+\treturn (8 + tagsize) * len(s)\n+}\n+func sizeFixed64PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint64Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 8*len(s) + SizeVarint(uint64(8*len(s))) + tagsize\n+}\n+func sizeFixedS64Value(_ pointer, tagsize int) int {\n+\treturn 8 + tagsize\n+}\n+func sizeFixedS64ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt64()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 8 + tagsize\n+}\n+func sizeFixedS64Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toInt64Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn 8 + tagsize\n+}\n+func sizeFixedS64Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toInt64Slice()\n+\treturn (8 + tagsize) * len(s)\n+}\n+func sizeFixedS64PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toInt64Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 8*len(s) + SizeVarint(uint64(8*len(s))) + tagsize\n+}\n+func sizeFloat64Value(_ pointer, tagsize int) int {\n+\treturn 8 + tagsize\n+}\n+func sizeFloat64ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := math.Float64bits(*ptr.toFloat64())\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 8 + tagsize\n+}\n+func sizeFloat64Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toFloat64Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn 8 + tagsize\n+}\n+func sizeFloat64Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toFloat64Slice()\n+\treturn (8 + tagsize) * len(s)\n+}\n+func sizeFloat64PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toFloat64Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn 8*len(s) + SizeVarint(uint64(8*len(s))) + tagsize\n+}\n+func sizeVarint32Value(ptr pointer, tagsize int) int {\n+\tv := *ptr.toUint32()\n+\treturn SizeVarint(uint64(v)) + tagsize\n+}\n+func sizeVarint32ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toUint32()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64(v)) + tagsize\n+}\n+func sizeVarint32Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toUint32Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64(*p)) + tagsize\n+}\n+func sizeVarint32Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint32Slice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v)) + tagsize\n+\t}\n+\treturn n\n+}\n+func sizeVarint32PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint32Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v))\n+\t}\n+\treturn n + SizeVarint(uint64(n)) + tagsize\n+}\n+func sizeVarintS32Value(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt32()\n+\treturn SizeVarint(uint64(v)) + tagsize\n+}\n+func sizeVarintS32ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt32()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64(v)) + tagsize\n+}\n+func sizeVarintS32Ptr(ptr pointer, tagsize int) int {\n+\tp := ptr.getInt32Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64(*p)) + tagsize\n+}\n+func sizeVarintS32Slice(ptr pointer, tagsize int) int {\n+\ts := ptr.getInt32Slice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v)) + tagsize\n+\t}\n+\treturn n\n+}\n+func sizeVarintS32PackedSlice(ptr pointer, tagsize int) int {\n+\ts := ptr.getInt32Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v))\n+\t}\n+\treturn n + SizeVarint(uint64(n)) + tagsize\n+}\n+func sizeVarint64Value(ptr pointer, tagsize int) int {\n+\tv := *ptr.toUint64()\n+\treturn SizeVarint(v) + tagsize\n+}\n+func sizeVarint64ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toUint64()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(v) + tagsize\n+}\n+func sizeVarint64Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toUint64Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(*p) + tagsize\n+}\n+func sizeVarint64Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint64Slice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(v) + tagsize\n+\t}\n+\treturn n\n+}\n+func sizeVarint64PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toUint64Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(v)\n+\t}\n+\treturn n + SizeVarint(uint64(n)) + tagsize\n+}\n+func sizeVarintS64Value(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt64()\n+\treturn SizeVarint(uint64(v)) + tagsize\n+}\n+func sizeVarintS64ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt64()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64(v)) + tagsize\n+}\n+func sizeVarintS64Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toInt64Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64(*p)) + tagsize\n+}\n+func sizeVarintS64Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toInt64Slice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v)) + tagsize\n+\t}\n+\treturn n\n+}\n+func sizeVarintS64PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toInt64Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v))\n+\t}\n+\treturn n + SizeVarint(uint64(n)) + tagsize\n+}\n+func sizeZigzag32Value(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt32()\n+\treturn SizeVarint(uint64((uint32(v)<<1)^uint32((int32(v)>>31)))) + tagsize\n+}\n+func sizeZigzag32ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt32()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64((uint32(v)<<1)^uint32((int32(v)>>31)))) + tagsize\n+}\n+func sizeZigzag32Ptr(ptr pointer, tagsize int) int {\n+\tp := ptr.getInt32Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\tv := *p\n+\treturn SizeVarint(uint64((uint32(v)<<1)^uint32((int32(v)>>31)))) + tagsize\n+}\n+func sizeZigzag32Slice(ptr pointer, tagsize int) int {\n+\ts := ptr.getInt32Slice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64((uint32(v)<<1)^uint32((int32(v)>>31)))) + tagsize\n+\t}\n+\treturn n\n+}\n+func sizeZigzag32PackedSlice(ptr pointer, tagsize int) int {\n+\ts := ptr.getInt32Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64((uint32(v) << 1) ^ uint32((int32(v) >> 31))))\n+\t}\n+\treturn n + SizeVarint(uint64(n)) + tagsize\n+}\n+func sizeZigzag64Value(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt64()\n+\treturn SizeVarint(uint64(v<<1)^uint64((int64(v)>>63))) + tagsize\n+}\n+func sizeZigzag64ValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toInt64()\n+\tif v == 0 {\n+\t\treturn 0\n+\t}\n+\treturn SizeVarint(uint64(v<<1)^uint64((int64(v)>>63))) + tagsize\n+}\n+func sizeZigzag64Ptr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toInt64Ptr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\tv := *p\n+\treturn SizeVarint(uint64(v<<1)^uint64((int64(v)>>63))) + tagsize\n+}\n+func sizeZigzag64Slice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toInt64Slice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v<<1)^uint64((int64(v)>>63))) + tagsize\n+\t}\n+\treturn n\n+}\n+func sizeZigzag64PackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toInt64Slice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v<<1) ^ uint64((int64(v) >> 63)))\n+\t}\n+\treturn n + SizeVarint(uint64(n)) + tagsize\n+}\n+func sizeBoolValue(_ pointer, tagsize int) int {\n+\treturn 1 + tagsize\n+}\n+func sizeBoolValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toBool()\n+\tif !v {\n+\t\treturn 0\n+\t}\n+\treturn 1 + tagsize\n+}\n+func sizeBoolPtr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toBoolPtr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\treturn 1 + tagsize\n+}\n+func sizeBoolSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toBoolSlice()\n+\treturn (1 + tagsize) * len(s)\n+}\n+func sizeBoolPackedSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toBoolSlice()\n+\tif len(s) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn len(s) + SizeVarint(uint64(len(s))) + tagsize\n+}\n+func sizeStringValue(ptr pointer, tagsize int) int {\n+\tv := *ptr.toString()\n+\treturn len(v) + SizeVarint(uint64(len(v))) + tagsize\n+}\n+func sizeStringValueNoZero(ptr pointer, tagsize int) int {\n+\tv := *ptr.toString()\n+\tif v == \"\" {\n+\t\treturn 0\n+\t}\n+\treturn len(v) + SizeVarint(uint64(len(v))) + tagsize\n+}\n+func sizeStringPtr(ptr pointer, tagsize int) int {\n+\tp := *ptr.toStringPtr()\n+\tif p == nil {\n+\t\treturn 0\n+\t}\n+\tv := *p\n+\treturn len(v) + SizeVarint(uint64(len(v))) + tagsize\n+}\n+func sizeStringSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toStringSlice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += len(v) + SizeVarint(uint64(len(v))) + tagsize\n+\t}\n+\treturn n\n+}\n+func sizeBytes(ptr pointer, tagsize int) int {\n+\tv := *ptr.toBytes()\n+\tif v == nil {\n+\t\treturn 0\n+\t}\n+\treturn len(v) + SizeVarint(uint64(len(v))) + tagsize\n+}\n+func sizeBytes3(ptr pointer, tagsize int) int {\n+\tv := *ptr.toBytes()\n+\tif len(v) == 0 {\n+\t\treturn 0\n+\t}\n+\treturn len(v) + SizeVarint(uint64(len(v))) + tagsize\n+}\n+func sizeBytesOneof(ptr pointer, tagsize int) int {\n+\tv := *ptr.toBytes()\n+\treturn len(v) + SizeVarint(uint64(len(v))) + tagsize\n+}\n+func sizeBytesSlice(ptr pointer, tagsize int) int {\n+\ts := *ptr.toBytesSlice()\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += len(v) + SizeVarint(uint64(len(v))) + tagsize\n+\t}\n+\treturn n\n+}\n+\n+// appendFixed32 appends an encoded fixed32 to b.\n+func appendFixed32(b []byte, v uint32) []byte {\n+\tb = append(b,\n+\t\tbyte(v),\n+\t\tbyte(v>>8),\n+\t\tbyte(v>>16),\n+\t\tbyte(v>>24))\n+\treturn b\n+}\n+\n+// appendFixed64 appends an encoded fixed64 to b.\n+func appendFixed64(b []byte, v uint64) []byte {\n+\tb = append(b,\n+\t\tbyte(v),\n+\t\tbyte(v>>8),\n+\t\tbyte(v>>16),\n+\t\tbyte(v>>24),\n+\t\tbyte(v>>32),\n+\t\tbyte(v>>40),\n+\t\tbyte(v>>48),\n+\t\tbyte(v>>56))\n+\treturn b\n+}\n+\n+// appendVarint appends an encoded varint to b.\n+func appendVarint(b []byte, v uint64) []byte {\n+\t// TODO: make 1-byte (maybe 2-byte) case inline-able, once we\n+\t// have non-leaf inliner.\n+\tswitch {\n+\tcase v < 1<<7:\n+\t\tb = append(b, byte(v))\n+\tcase v < 1<<14:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte(v>>7))\n+\tcase v < 1<<21:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte(v>>14))\n+\tcase v < 1<<28:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte((v>>14)&0x7f|0x80),\n+\t\t\tbyte(v>>21))\n+\tcase v < 1<<35:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte((v>>14)&0x7f|0x80),\n+\t\t\tbyte((v>>21)&0x7f|0x80),\n+\t\t\tbyte(v>>28))\n+\tcase v < 1<<42:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte((v>>14)&0x7f|0x80),\n+\t\t\tbyte((v>>21)&0x7f|0x80),\n+\t\t\tbyte((v>>28)&0x7f|0x80),\n+\t\t\tbyte(v>>35))\n+\tcase v < 1<<49:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte((v>>14)&0x7f|0x80),\n+\t\t\tbyte((v>>21)&0x7f|0x80),\n+\t\t\tbyte((v>>28)&0x7f|0x80),\n+\t\t\tbyte((v>>35)&0x7f|0x80),\n+\t\t\tbyte(v>>42))\n+\tcase v < 1<<56:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte((v>>14)&0x7f|0x80),\n+\t\t\tbyte((v>>21)&0x7f|0x80),\n+\t\t\tbyte((v>>28)&0x7f|0x80),\n+\t\t\tbyte((v>>35)&0x7f|0x80),\n+\t\t\tbyte((v>>42)&0x7f|0x80),\n+\t\t\tbyte(v>>49))\n+\tcase v < 1<<63:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte((v>>14)&0x7f|0x80),\n+\t\t\tbyte((v>>21)&0x7f|0x80),\n+\t\t\tbyte((v>>28)&0x7f|0x80),\n+\t\t\tbyte((v>>35)&0x7f|0x80),\n+\t\t\tbyte((v>>42)&0x7f|0x80),\n+\t\t\tbyte((v>>49)&0x7f|0x80),\n+\t\t\tbyte(v>>56))\n+\tdefault:\n+\t\tb = append(b,\n+\t\t\tbyte(v&0x7f|0x80),\n+\t\t\tbyte((v>>7)&0x7f|0x80),\n+\t\t\tbyte((v>>14)&0x7f|0x80),\n+\t\t\tbyte((v>>21)&0x7f|0x80),\n+\t\t\tbyte((v>>28)&0x7f|0x80),\n+\t\t\tbyte((v>>35)&0x7f|0x80),\n+\t\t\tbyte((v>>42)&0x7f|0x80),\n+\t\t\tbyte((v>>49)&0x7f|0x80),\n+\t\t\tbyte((v>>56)&0x7f|0x80),\n+\t\t\t1)\n+\t}\n+\treturn b\n+}\n+\n+func appendFixed32Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint32()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, v)\n+\treturn b, nil\n+}\n+func appendFixed32ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint32()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, v)\n+\treturn b, nil\n+}\n+func appendFixed32Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toUint32Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, *p)\n+\treturn b, nil\n+}\n+func appendFixed32Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint32Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendFixed32(b, v)\n+\t}\n+\treturn b, nil\n+}\n+func appendFixed32PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint32Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\tb = appendVarint(b, uint64(4*len(s)))\n+\tfor _, v := range s {\n+\t\tb = appendFixed32(b, v)\n+\t}\n+\treturn b, nil\n+}\n+func appendFixedS32Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt32()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, uint32(v))\n+\treturn b, nil\n+}\n+func appendFixedS32ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt32()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, uint32(v))\n+\treturn b, nil\n+}\n+func appendFixedS32Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := ptr.getInt32Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, uint32(*p))\n+\treturn b, nil\n+}\n+func appendFixedS32Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := ptr.getInt32Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendFixed32(b, uint32(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendFixedS32PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := ptr.getInt32Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\tb = appendVarint(b, uint64(4*len(s)))\n+\tfor _, v := range s {\n+\t\tb = appendFixed32(b, uint32(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendFloat32Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := math.Float32bits(*ptr.toFloat32())\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, v)\n+\treturn b, nil\n+}\n+func appendFloat32ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := math.Float32bits(*ptr.toFloat32())\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, v)\n+\treturn b, nil\n+}\n+func appendFloat32Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toFloat32Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed32(b, math.Float32bits(*p))\n+\treturn b, nil\n+}\n+func appendFloat32Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toFloat32Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendFixed32(b, math.Float32bits(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendFloat32PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toFloat32Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\tb = appendVarint(b, uint64(4*len(s)))\n+\tfor _, v := range s {\n+\t\tb = appendFixed32(b, math.Float32bits(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendFixed64Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint64()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, v)\n+\treturn b, nil\n+}\n+func appendFixed64ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint64()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, v)\n+\treturn b, nil\n+}\n+func appendFixed64Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toUint64Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, *p)\n+\treturn b, nil\n+}\n+func appendFixed64Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint64Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendFixed64(b, v)\n+\t}\n+\treturn b, nil\n+}\n+func appendFixed64PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint64Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\tb = appendVarint(b, uint64(8*len(s)))\n+\tfor _, v := range s {\n+\t\tb = appendFixed64(b, v)\n+\t}\n+\treturn b, nil\n+}\n+func appendFixedS64Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt64()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendFixedS64ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt64()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendFixedS64Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toInt64Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, uint64(*p))\n+\treturn b, nil\n+}\n+func appendFixedS64Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toInt64Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendFixed64(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendFixedS64PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toInt64Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\tb = appendVarint(b, uint64(8*len(s)))\n+\tfor _, v := range s {\n+\t\tb = appendFixed64(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendFloat64Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := math.Float64bits(*ptr.toFloat64())\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, v)\n+\treturn b, nil\n+}\n+func appendFloat64ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := math.Float64bits(*ptr.toFloat64())\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, v)\n+\treturn b, nil\n+}\n+func appendFloat64Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toFloat64Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendFixed64(b, math.Float64bits(*p))\n+\treturn b, nil\n+}\n+func appendFloat64Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toFloat64Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendFixed64(b, math.Float64bits(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendFloat64PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toFloat64Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\tb = appendVarint(b, uint64(8*len(s)))\n+\tfor _, v := range s {\n+\t\tb = appendFixed64(b, math.Float64bits(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendVarint32Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint32()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendVarint32ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint32()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendVarint32Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toUint32Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(*p))\n+\treturn b, nil\n+}\n+func appendVarint32Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint32Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendVarint32PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint32Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\t// compute size\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v))\n+\t}\n+\tb = appendVarint(b, uint64(n))\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendVarintS32Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt32()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendVarintS32ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt32()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendVarintS32Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := ptr.getInt32Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(*p))\n+\treturn b, nil\n+}\n+func appendVarintS32Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := ptr.getInt32Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendVarintS32PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := ptr.getInt32Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\t// compute size\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v))\n+\t}\n+\tb = appendVarint(b, uint64(n))\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendVarint64Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint64()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, v)\n+\treturn b, nil\n+}\n+func appendVarint64ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toUint64()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, v)\n+\treturn b, nil\n+}\n+func appendVarint64Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toUint64Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, *p)\n+\treturn b, nil\n+}\n+func appendVarint64Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint64Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, v)\n+\t}\n+\treturn b, nil\n+}\n+func appendVarint64PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toUint64Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\t// compute size\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(v)\n+\t}\n+\tb = appendVarint(b, uint64(n))\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, v)\n+\t}\n+\treturn b, nil\n+}\n+func appendVarintS64Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt64()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendVarintS64ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt64()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v))\n+\treturn b, nil\n+}\n+func appendVarintS64Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toInt64Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(*p))\n+\treturn b, nil\n+}\n+func appendVarintS64Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toInt64Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendVarintS64PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toInt64Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\t// compute size\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v))\n+\t}\n+\tb = appendVarint(b, uint64(n))\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, uint64(v))\n+\t}\n+\treturn b, nil\n+}\n+func appendZigzag32Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt32()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64((uint32(v)<<1)^uint32((int32(v)>>31))))\n+\treturn b, nil\n+}\n+func appendZigzag32ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt32()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64((uint32(v)<<1)^uint32((int32(v)>>31))))\n+\treturn b, nil\n+}\n+func appendZigzag32Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := ptr.getInt32Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tv := *p\n+\tb = appendVarint(b, uint64((uint32(v)<<1)^uint32((int32(v)>>31))))\n+\treturn b, nil\n+}\n+func appendZigzag32Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := ptr.getInt32Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64((uint32(v)<<1)^uint32((int32(v)>>31))))\n+\t}\n+\treturn b, nil\n+}\n+func appendZigzag32PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := ptr.getInt32Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\t// compute size\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64((uint32(v) << 1) ^ uint32((int32(v) >> 31))))\n+\t}\n+\tb = appendVarint(b, uint64(n))\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, uint64((uint32(v)<<1)^uint32((int32(v)>>31))))\n+\t}\n+\treturn b, nil\n+}\n+func appendZigzag64Value(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt64()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v<<1)^uint64((int64(v)>>63)))\n+\treturn b, nil\n+}\n+func appendZigzag64ValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toInt64()\n+\tif v == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(v<<1)^uint64((int64(v)>>63)))\n+\treturn b, nil\n+}\n+func appendZigzag64Ptr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toInt64Ptr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tv := *p\n+\tb = appendVarint(b, uint64(v<<1)^uint64((int64(v)>>63)))\n+\treturn b, nil\n+}\n+func appendZigzag64Slice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toInt64Slice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64(v<<1)^uint64((int64(v)>>63)))\n+\t}\n+\treturn b, nil\n+}\n+func appendZigzag64PackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toInt64Slice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\t// compute size\n+\tn := 0\n+\tfor _, v := range s {\n+\t\tn += SizeVarint(uint64(v<<1) ^ uint64((int64(v) >> 63)))\n+\t}\n+\tb = appendVarint(b, uint64(n))\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, uint64(v<<1)^uint64((int64(v)>>63)))\n+\t}\n+\treturn b, nil\n+}\n+func appendBoolValue(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toBool()\n+\tb = appendVarint(b, wiretag)\n+\tif v {\n+\t\tb = append(b, 1)\n+\t} else {\n+\t\tb = append(b, 0)\n+\t}\n+\treturn b, nil\n+}\n+func appendBoolValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toBool()\n+\tif !v {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = append(b, 1)\n+\treturn b, nil\n+}\n+\n+func appendBoolPtr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toBoolPtr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tif *p {\n+\t\tb = append(b, 1)\n+\t} else {\n+\t\tb = append(b, 0)\n+\t}\n+\treturn b, nil\n+}\n+func appendBoolSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toBoolSlice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tif v {\n+\t\t\tb = append(b, 1)\n+\t\t} else {\n+\t\t\tb = append(b, 0)\n+\t\t}\n+\t}\n+\treturn b, nil\n+}\n+func appendBoolPackedSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toBoolSlice()\n+\tif len(s) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag&^7|WireBytes)\n+\tb = appendVarint(b, uint64(len(s)))\n+\tfor _, v := range s {\n+\t\tif v {\n+\t\t\tb = append(b, 1)\n+\t\t} else {\n+\t\t\tb = append(b, 0)\n+\t\t}\n+\t}\n+\treturn b, nil\n+}\n+func appendStringValue(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toString()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\treturn b, nil\n+}\n+func appendStringValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toString()\n+\tif v == \"\" {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\treturn b, nil\n+}\n+func appendStringPtr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tp := *ptr.toStringPtr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tv := *p\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\treturn b, nil\n+}\n+func appendStringSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toStringSlice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64(len(v)))\n+\t\tb = append(b, v...)\n+\t}\n+\treturn b, nil\n+}\n+func appendUTF8StringValue(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tvar invalidUTF8 bool\n+\tv := *ptr.toString()\n+\tif !utf8.ValidString(v) {\n+\t\tinvalidUTF8 = true\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\tif invalidUTF8 {\n+\t\treturn b, errInvalidUTF8\n+\t}\n+\treturn b, nil\n+}\n+func appendUTF8StringValueNoZero(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tvar invalidUTF8 bool\n+\tv := *ptr.toString()\n+\tif v == \"\" {\n+\t\treturn b, nil\n+\t}\n+\tif !utf8.ValidString(v) {\n+\t\tinvalidUTF8 = true\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\tif invalidUTF8 {\n+\t\treturn b, errInvalidUTF8\n+\t}\n+\treturn b, nil\n+}\n+func appendUTF8StringPtr(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tvar invalidUTF8 bool\n+\tp := *ptr.toStringPtr()\n+\tif p == nil {\n+\t\treturn b, nil\n+\t}\n+\tv := *p\n+\tif !utf8.ValidString(v) {\n+\t\tinvalidUTF8 = true\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\tif invalidUTF8 {\n+\t\treturn b, errInvalidUTF8\n+\t}\n+\treturn b, nil\n+}\n+func appendUTF8StringSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tvar invalidUTF8 bool\n+\ts := *ptr.toStringSlice()\n+\tfor _, v := range s {\n+\t\tif !utf8.ValidString(v) {\n+\t\t\tinvalidUTF8 = true\n+\t\t}\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64(len(v)))\n+\t\tb = append(b, v...)\n+\t}\n+\tif invalidUTF8 {\n+\t\treturn b, errInvalidUTF8\n+\t}\n+\treturn b, nil\n+}\n+func appendBytes(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toBytes()\n+\tif v == nil {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\treturn b, nil\n+}\n+func appendBytes3(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toBytes()\n+\tif len(v) == 0 {\n+\t\treturn b, nil\n+\t}\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\treturn b, nil\n+}\n+func appendBytesOneof(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\tv := *ptr.toBytes()\n+\tb = appendVarint(b, wiretag)\n+\tb = appendVarint(b, uint64(len(v)))\n+\tb = append(b, v...)\n+\treturn b, nil\n+}\n+func appendBytesSlice(b []byte, ptr pointer, wiretag uint64, _ bool) ([]byte, error) {\n+\ts := *ptr.toBytesSlice()\n+\tfor _, v := range s {\n+\t\tb = appendVarint(b, wiretag)\n+\t\tb = appendVarint(b, uint64(len(v)))\n+\t\tb = append(b, v...)\n+\t}\n+\treturn b, nil\n+}\n+\n+// makeGroupMarshaler returns the sizer and marshaler for a group.\n+// u is the marshal info of the underlying message.\n+func makeGroupMarshaler(u *marshalInfo) (sizer, marshaler) {\n+\treturn func(ptr pointer, tagsize int) int {\n+\t\t\tp := ptr.getPointer()\n+\t\t\tif p.isNil() {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\treturn u.size(p) + 2*tagsize\n+\t\t},\n+\t\tfunc(b []byte, ptr pointer, wiretag uint64, deterministic bool) ([]byte, error) {\n+\t\t\tp := ptr.getPointer()\n+\t\t\tif p.isNil() {\n+\t\t\t\treturn b, nil\n+\t\t\t}\n+\t\t\tvar err error\n+\t\t\tb = appendVarint(b, wiretag) // start group\n+\t\t\tb, err = u.marshal(b, p, deterministic)\n+\t\t\tb = appendVarint(b, wiretag+(WireEndGroup-WireStartGroup)) // end group\n+\t\t\treturn b, err\n+\t\t}\n+}\n+\n+// makeGroupSliceMarshaler returns the sizer and marshaler for a group slice.\n+// u is the marshal info of the underlying message.\n+func makeGroupSliceMarshaler(u *marshalInfo) (sizer, marshaler) {\n+\treturn func(ptr pointer, tagsize int) int {\n+\t\t\ts := ptr.getPointerSlice()\n+\t\t\tn := 0\n+\t\t\tfor _, v := range s {\n+\t\t\t\tif v.isNil() {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tn += u.size(v) + 2*tagsize\n+\t\t\t}\n+\t\t\treturn n\n+\t\t},\n+\t\tfunc(b []byte, ptr pointer, wiretag uint64, deterministic bool) ([]byte, error) {\n+\t\t\ts := ptr.getPointerSlice()\n+\t\t\tvar err error\n+\t\t\tvar nerr nonFatal\n+\t\t\tfor _, v := range s {\n+\t\t\t\tif v.isNil() {\n+\t\t\t\t\treturn b, errRepeatedHasNil\n+\t\t\t\t}\n+\t\t\t\tb = appendVarint(b, wiretag) // start group\n+\t\t\t\tb, err = u.marshal(b, v, deterministic)\n+\t\t\t\tb = appendVarint(b, wiretag+(WireEndGroup-WireStartGroup)) // end group\n+\t\t\t\tif !nerr.Merge(err) {\n+\t\t\t\t\tif err == ErrNil {\n+\t\t\t\t\t\terr = errRepeatedHasNil\n+\t\t\t\t\t}\n+\t\t\t\t\treturn b, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn b, nerr.E\n+\t\t}\n+}\n+\n+// makeMessageMarshaler returns the sizer and marshaler for a message field.\n+// u is the marshal info of the message.\n+func makeMessageMarshaler(u *marshalInfo) (sizer, marshaler) {\n+\treturn func(ptr pointer, tagsize int) int {\n+\t\t\tp := ptr.getPointer()\n+\t\t\tif p.isNil() {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\tsiz := u.size(p)\n+\t\t\treturn siz + SizeVarint(uint64(siz)) + tagsize\n+\t\t},\n+\t\tfunc(b []byte, ptr pointer, wiretag uint64, deterministic bool) ([]byte, error) {\n+\t\t\tp := ptr.getPointer()\n+\t\t\tif p.isNil() {\n+\t\t\t\treturn b, nil\n+\t\t\t}\n+\t\t\tb = appendVarint(b, wiretag)\n+\t\t\tsiz := u.cachedsize(p)\n+\t\t\tb = appendVarint(b, uint64(siz))\n+\t\t\treturn u.marshal(b, p, deterministic)\n+\t\t}\n+}\n+\n+// makeMessageSliceMarshaler returns the sizer and marshaler for a message slice.\n+// u is the marshal info of the message.\n+func makeMessageSliceMarshaler(u *marshalInfo) (sizer, marshaler) {\n+\treturn func(ptr pointer, tagsize int) int {\n+\t\t\ts := ptr.getPointerSlice()\n+\t\t\tn := 0\n+\t\t\tfor _, v := range s {\n+\t\t\t\tif v.isNil() {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tsiz := u.size(v)\n+\t\t\t\tn += siz + SizeVarint(uint64(siz)) + tagsize\n+\t\t\t}\n+\t\t\treturn n\n+\t\t},\n+\t\tfunc(b []byte, ptr pointer, wiretag uint64, deterministic bool) ([]byte, error) {\n+\t\t\ts := ptr.getPointerSlice()\n+\t\t\tvar err error\n+\t\t\tvar nerr nonFatal\n+\t\t\tfor _, v := range s {\n+\t\t\t\tif v.isNil() {\n+\t\t\t\t\treturn b, errRepeatedHasNil\n+\t\t\t\t}\n+\t\t\t\tb = appendVarint(b, wiretag)\n+\t\t\t\tsiz := u.cachedsize(v)\n+\t\t\t\tb = appendVarint(b, uint64(siz))\n+\t\t\t\tb, err = u.marshal(b, v, deterministic)\n+\n+\t\t\t\tif !nerr.Merge(err) {\n+\t\t\t\t\tif err == ErrNil {\n+\t\t\t\t\t\terr = errRepeatedHasNil\n+\t\t\t\t\t}\n+\t\t\t\t\treturn b, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn b, nerr.E\n+\t\t}\n+}\n+\n+// makeMapMarshaler returns the sizer and marshaler for a map field.\n+// f is the pointer to the reflect data structure of the field.\n+func makeMapMarshaler(f *reflect.StructField) (sizer, marshaler) {\n+\t// figure out key and value type\n+\tt := f.Type\n+\tkeyType := t.Key()\n+\tvalType := t.Elem()\n+\tkeyTags := strings.Split(f.Tag.Get(\"protobuf_key\"), \",\")\n+\tvalTags := strings.Split(f.Tag.Get(\"protobuf_val\"), \",\")\n+\tkeySizer, keyMarshaler := typeMarshaler(keyType, keyTags, false, false) // don't omit zero value in map\n+\tvalSizer, valMarshaler := typeMarshaler(valType, valTags, false, false) // don't omit zero value in map\n+\tkeyWireTag := 1<<3 | wiretype(keyTags[0])\n+\tvalWireTag := 2<<3 | wiretype(valTags[0])\n+\n+\t// We create an interface to get the addresses of the map key and value.\n+\t// If value is pointer-typed, the interface is a direct interface, the\n+\t// idata itself is the value. Otherwise, the idata is the pointer to the\n+\t// value.\n+\t// Key cannot be pointer-typed.\n+\tvalIsPtr := valType.Kind() == reflect.Ptr\n+\n+\t// If value is a message with nested maps, calling\n+\t// valSizer in marshal may be quadratic. We should use\n+\t// cached version in marshal (but not in size).\n+\t// If value is not message type, we don't have size cache,\n+\t// but it cannot be nested either. Just use valSizer.\n+\tvalCachedSizer := valSizer\n+\tif valIsPtr && valType.Elem().Kind() == reflect.Struct {\n+\t\tu := getMarshalInfo(valType.Elem())\n+\t\tvalCachedSizer = func(ptr pointer, tagsize int) int {\n+\t\t\t// Same as message sizer, but use cache.\n+\t\t\tp := ptr.getPointer()\n+\t\t\tif p.isNil() {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\tsiz := u.cachedsize(p)\n+\t\t\treturn siz + SizeVarint(uint64(siz)) + tagsize\n+\t\t}\n+\t}\n+\treturn func(ptr pointer, tagsize int) int {\n+\t\t\tm := ptr.asPointerTo(t).Elem() // the map\n+\t\t\tn := 0\n+\t\t\tfor _, k := range m.MapKeys() {\n+\t\t\t\tki := k.Interface()\n+\t\t\t\tvi := m.MapIndex(k).Interface()\n+\t\t\t\tkaddr := toAddrPointer(&ki, false)             // pointer to key\n+\t\t\t\tvaddr := toAddrPointer(&vi, valIsPtr)          // pointer to value\n+\t\t\t\tsiz := keySizer(kaddr, 1) + valSizer(vaddr, 1) // tag of key = 1 (size=1), tag of val = 2 (size=1)\n+\t\t\t\tn += siz + SizeVarint(uint64(siz)) + tagsize\n+\t\t\t}\n+\t\t\treturn n\n+\t\t},\n+\t\tfunc(b []byte, ptr pointer, tag uint64, deterministic bool) ([]byte, error) {\n+\t\t\tm := ptr.asPointerTo(t).Elem() // the map\n+\t\t\tvar err error\n+\t\t\tkeys := m.MapKeys()\n+\t\t\tif len(keys) > 1 && deterministic {\n+\t\t\t\tsort.Sort(mapKeys(keys))\n+\t\t\t}\n+\n+\t\t\tvar nerr nonFatal\n+\t\t\tfor _, k := range keys {\n+\t\t\t\tki := k.Interface()\n+\t\t\t\tvi := m.MapIndex(k).Interface()\n+\t\t\t\tkaddr := toAddrPointer(&ki, false)    // pointer to key\n+\t\t\t\tvaddr := toAddrPointer(&vi, valIsPtr) // pointer to value\n+\t\t\t\tb = appendVarint(b, tag)\n+\t\t\t\tsiz := keySizer(kaddr, 1) + valCachedSizer(vaddr, 1) // tag of key = 1 (size=1), tag of val = 2 (size=1)\n+\t\t\t\tb = appendVarint(b, uint64(siz))\n+\t\t\t\tb, err = keyMarshaler(b, kaddr, keyWireTag, deterministic)\n+\t\t\t\tif !nerr.Merge(err) {\n+\t\t\t\t\treturn b, err\n+\t\t\t\t}\n+\t\t\t\tb, err = valMarshaler(b, vaddr, valWireTag, deterministic)\n+\t\t\t\tif err != ErrNil && !nerr.Merge(err) { // allow nil value in map\n+\t\t\t\t\treturn b, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn b, nerr.E\n+\t\t}\n+}\n+\n+// makeOneOfMarshaler returns the sizer and marshaler for a oneof field.\n+// fi is the marshal info of the field.\n+// f is the pointer to the reflect data structure of the field.\n+func makeOneOfMarshaler(fi *marshalFieldInfo, f *reflect.StructField) (sizer, marshaler) {\n+\t// Oneof field is an interface. We need to get the actual data type on the fly.\n+\tt := f.Type\n+\treturn func(ptr pointer, _ int) int {\n+\t\t\tp := ptr.getInterfacePointer()\n+\t\t\tif p.isNil() {\n+\t\t\t\treturn 0\n+\t\t\t}\n+\t\t\tv := ptr.asPointerTo(t).Elem().Elem().Elem() // *interface -> interface -> *struct -> struct\n+\t\t\ttelem := v.Type()\n+\t\t\te := fi.oneofElems[telem]\n+\t\t\treturn e.sizer(p, e.tagsize)\n+\t\t},\n+\t\tfunc(b []byte, ptr pointer, _ uint64, deterministic bool) ([]byte, error) {\n+\t\t\tp := ptr.getInterfacePointer()\n+\t\t\tif p.isNil() {\n+\t\t\t\treturn b, nil\n+\t\t\t}\n+\t\t\tv := ptr.asPointerTo(t).Elem().Elem().Elem() // *interface -> interface -> *struct -> struct\n+\t\t\ttelem := v.Type()\n+\t\t\tif telem.Field(0).Type.Kind() == reflect.Ptr && p.getPointer().isNil() {\n+\t\t\t\treturn b, errOneofHasNil\n+\t\t\t}\n+\t\t\te := fi.oneofElems[telem]\n+\t\t\treturn e.marshaler(b, p, e.wiretag, deterministic)\n+\t\t}\n+}\n+\n+// sizeExtensions computes the size of encoded data for a XXX_InternalExtensions field.\n+func (u *marshalInfo) sizeExtensions(ext *XXX_InternalExtensions) int {\n+\tm, mu := ext.extensionsRead()\n+\tif m == nil {\n+\t\treturn 0\n+\t}\n+\tmu.Lock()\n+\n+\tn := 0\n+\tfor _, e := range m {\n+\t\tif e.value == nil || e.desc == nil {\n+\t\t\t// Extension is only in its encoded form.\n+\t\t\tn += len(e.enc)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We don't skip extensions that have an encoded form set,\n+\t\t// because the extension value may have been mutated after\n+\t\t// the last time this function was called.\n+\t\tei := u.getExtElemInfo(e.desc)\n+\t\tv := e.value\n+\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\tn += ei.sizer(p, ei.tagsize)\n+\t}\n+\tmu.Unlock()\n+\treturn n\n+}\n+\n+// appendExtensions marshals a XXX_InternalExtensions field to the end of byte slice b.\n+func (u *marshalInfo) appendExtensions(b []byte, ext *XXX_InternalExtensions, deterministic bool) ([]byte, error) {\n+\tm, mu := ext.extensionsRead()\n+\tif m == nil {\n+\t\treturn b, nil\n+\t}\n+\tmu.Lock()\n+\tdefer mu.Unlock()\n+\n+\tvar err error\n+\tvar nerr nonFatal\n+\n+\t// Fast-path for common cases: zero or one extensions.\n+\t// Don't bother sorting the keys.\n+\tif len(m) <= 1 {\n+\t\tfor _, e := range m {\n+\t\t\tif e.value == nil || e.desc == nil {\n+\t\t\t\t// Extension is only in its encoded form.\n+\t\t\t\tb = append(b, e.enc...)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// We don't skip extensions that have an encoded form set,\n+\t\t\t// because the extension value may have been mutated after\n+\t\t\t// the last time this function was called.\n+\n+\t\t\tei := u.getExtElemInfo(e.desc)\n+\t\t\tv := e.value\n+\t\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\t\tb, err = ei.marshaler(b, p, ei.wiretag, deterministic)\n+\t\t\tif !nerr.Merge(err) {\n+\t\t\t\treturn b, err\n+\t\t\t}\n+\t\t}\n+\t\treturn b, nerr.E\n+\t}\n+\n+\t// Sort the keys to provide a deterministic encoding.\n+\t// Not sure this is required, but the old code does it.\n+\tkeys := make([]int, 0, len(m))\n+\tfor k := range m {\n+\t\tkeys = append(keys, int(k))\n+\t}\n+\tsort.Ints(keys)\n+\n+\tfor _, k := range keys {\n+\t\te := m[int32(k)]\n+\t\tif e.value == nil || e.desc == nil {\n+\t\t\t// Extension is only in its encoded form.\n+\t\t\tb = append(b, e.enc...)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We don't skip extensions that have an encoded form set,\n+\t\t// because the extension value may have been mutated after\n+\t\t// the last time this function was called.\n+\n+\t\tei := u.getExtElemInfo(e.desc)\n+\t\tv := e.value\n+\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\tb, err = ei.marshaler(b, p, ei.wiretag, deterministic)\n+\t\tif !nerr.Merge(err) {\n+\t\t\treturn b, err\n+\t\t}\n+\t}\n+\treturn b, nerr.E\n+}\n+\n+// message set format is:\n+//   message MessageSet {\n+//     repeated group Item = 1 {\n+//       required int32 type_id = 2;\n+//       required string message = 3;\n+//     };\n+//   }\n+\n+// sizeMessageSet computes the size of encoded data for a XXX_InternalExtensions field\n+// in message set format (above).\n+func (u *marshalInfo) sizeMessageSet(ext *XXX_InternalExtensions) int {\n+\tm, mu := ext.extensionsRead()\n+\tif m == nil {\n+\t\treturn 0\n+\t}\n+\tmu.Lock()\n+\n+\tn := 0\n+\tfor id, e := range m {\n+\t\tn += 2                          // start group, end group. tag = 1 (size=1)\n+\t\tn += SizeVarint(uint64(id)) + 1 // type_id, tag = 2 (size=1)\n+\n+\t\tif e.value == nil || e.desc == nil {\n+\t\t\t// Extension is only in its encoded form.\n+\t\t\tmsgWithLen := skipVarint(e.enc) // skip old tag, but leave the length varint\n+\t\t\tsiz := len(msgWithLen)\n+\t\t\tn += siz + 1 // message, tag = 3 (size=1)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We don't skip extensions that have an encoded form set,\n+\t\t// because the extension value may have been mutated after\n+\t\t// the last time this function was called.\n+\n+\t\tei := u.getExtElemInfo(e.desc)\n+\t\tv := e.value\n+\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\tn += ei.sizer(p, 1) // message, tag = 3 (size=1)\n+\t}\n+\tmu.Unlock()\n+\treturn n\n+}\n+\n+// appendMessageSet marshals a XXX_InternalExtensions field in message set format (above)\n+// to the end of byte slice b.\n+func (u *marshalInfo) appendMessageSet(b []byte, ext *XXX_InternalExtensions, deterministic bool) ([]byte, error) {\n+\tm, mu := ext.extensionsRead()\n+\tif m == nil {\n+\t\treturn b, nil\n+\t}\n+\tmu.Lock()\n+\tdefer mu.Unlock()\n+\n+\tvar err error\n+\tvar nerr nonFatal\n+\n+\t// Fast-path for common cases: zero or one extensions.\n+\t// Don't bother sorting the keys.\n+\tif len(m) <= 1 {\n+\t\tfor id, e := range m {\n+\t\t\tb = append(b, 1<<3|WireStartGroup)\n+\t\t\tb = append(b, 2<<3|WireVarint)\n+\t\t\tb = appendVarint(b, uint64(id))\n+\n+\t\t\tif e.value == nil || e.desc == nil {\n+\t\t\t\t// Extension is only in its encoded form.\n+\t\t\t\tmsgWithLen := skipVarint(e.enc) // skip old tag, but leave the length varint\n+\t\t\t\tb = append(b, 3<<3|WireBytes)\n+\t\t\t\tb = append(b, msgWithLen...)\n+\t\t\t\tb = append(b, 1<<3|WireEndGroup)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// We don't skip extensions that have an encoded form set,\n+\t\t\t// because the extension value may have been mutated after\n+\t\t\t// the last time this function was called.\n+\n+\t\t\tei := u.getExtElemInfo(e.desc)\n+\t\t\tv := e.value\n+\t\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\t\tb, err = ei.marshaler(b, p, 3<<3|WireBytes, deterministic)\n+\t\t\tif !nerr.Merge(err) {\n+\t\t\t\treturn b, err\n+\t\t\t}\n+\t\t\tb = append(b, 1<<3|WireEndGroup)\n+\t\t}\n+\t\treturn b, nerr.E\n+\t}\n+\n+\t// Sort the keys to provide a deterministic encoding.\n+\tkeys := make([]int, 0, len(m))\n+\tfor k := range m {\n+\t\tkeys = append(keys, int(k))\n+\t}\n+\tsort.Ints(keys)\n+\n+\tfor _, id := range keys {\n+\t\te := m[int32(id)]\n+\t\tb = append(b, 1<<3|WireStartGroup)\n+\t\tb = append(b, 2<<3|WireVarint)\n+\t\tb = appendVarint(b, uint64(id))\n+\n+\t\tif e.value == nil || e.desc == nil {\n+\t\t\t// Extension is only in its encoded form.\n+\t\t\tmsgWithLen := skipVarint(e.enc) // skip old tag, but leave the length varint\n+\t\t\tb = append(b, 3<<3|WireBytes)\n+\t\t\tb = append(b, msgWithLen...)\n+\t\t\tb = append(b, 1<<3|WireEndGroup)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We don't skip extensions that have an encoded form set,\n+\t\t// because the extension value may have been mutated after\n+\t\t// the last time this function was called.\n+\n+\t\tei := u.getExtElemInfo(e.desc)\n+\t\tv := e.value\n+\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\tb, err = ei.marshaler(b, p, 3<<3|WireBytes, deterministic)\n+\t\tb = append(b, 1<<3|WireEndGroup)\n+\t\tif !nerr.Merge(err) {\n+\t\t\treturn b, err\n+\t\t}\n+\t}\n+\treturn b, nerr.E\n+}\n+\n+// sizeV1Extensions computes the size of encoded data for a V1-API extension field.\n+func (u *marshalInfo) sizeV1Extensions(m map[int32]Extension) int {\n+\tif m == nil {\n+\t\treturn 0\n+\t}\n+\n+\tn := 0\n+\tfor _, e := range m {\n+\t\tif e.value == nil || e.desc == nil {\n+\t\t\t// Extension is only in its encoded form.\n+\t\t\tn += len(e.enc)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We don't skip extensions that have an encoded form set,\n+\t\t// because the extension value may have been mutated after\n+\t\t// the last time this function was called.\n+\n+\t\tei := u.getExtElemInfo(e.desc)\n+\t\tv := e.value\n+\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\tn += ei.sizer(p, ei.tagsize)\n+\t}\n+\treturn n\n+}\n+\n+// appendV1Extensions marshals a V1-API extension field to the end of byte slice b.\n+func (u *marshalInfo) appendV1Extensions(b []byte, m map[int32]Extension, deterministic bool) ([]byte, error) {\n+\tif m == nil {\n+\t\treturn b, nil\n+\t}\n+\n+\t// Sort the keys to provide a deterministic encoding.\n+\tkeys := make([]int, 0, len(m))\n+\tfor k := range m {\n+\t\tkeys = append(keys, int(k))\n+\t}\n+\tsort.Ints(keys)\n+\n+\tvar err error\n+\tvar nerr nonFatal\n+\tfor _, k := range keys {\n+\t\te := m[int32(k)]\n+\t\tif e.value == nil || e.desc == nil {\n+\t\t\t// Extension is only in its encoded form.\n+\t\t\tb = append(b, e.enc...)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We don't skip extensions that have an encoded form set,\n+\t\t// because the extension value may have been mutated after\n+\t\t// the last time this function was called.\n+\n+\t\tei := u.getExtElemInfo(e.desc)\n+\t\tv := e.value\n+\t\tp := toAddrPointer(&v, ei.isptr)\n+\t\tb, err = ei.marshaler(b, p, ei.wiretag, deterministic)\n+\t\tif !nerr.Merge(err) {\n+\t\t\treturn b, err\n+\t\t}\n+\t}\n+\treturn b, nerr.E\n+}\n+\n+// newMarshaler is the interface representing objects that can marshal themselves.\n+//\n+// This exists to support protoc-gen-go generated messages.\n+// The proto package will stop type-asserting to this interface in the future.\n+//\n+// DO NOT DEPEND ON THIS.\n+type newMarshaler interface {\n+\tXXX_Size() int\n+\tXXX_Marshal(b []byte, deterministic bool) ([]byte, error)\n+}\n+\n+// Size returns the encoded size of a protocol buffer message.\n+// This is the main entry point.\n+func Size(pb Message) int {\n+\tif m, ok := pb.(newMarshaler); ok {\n+\t\treturn m.XXX_Size()\n+\t}\n+\tif m, ok := pb.(Marshaler); ok {\n+\t\t// If the message can marshal itself, let it do it, for compatibility.\n+\t\t// NOTE: This is not efficient.\n+\t\tb, _ := m.Marshal()\n+\t\treturn len(b)\n+\t}\n+\t// in case somehow we didn't generate the wrapper\n+\tif pb == nil {\n+\t\treturn 0\n+\t}\n+\tvar info InternalMessageInfo\n+\treturn info.Size(pb)\n+}\n+\n+// Marshal takes a protocol buffer message\n+// and encodes it into the wire format, returning the data.\n+// This is the main entry point.\n+func Marshal(pb Message) ([]byte, error) {\n+\tif m, ok := pb.(newMarshaler); ok {\n+\t\tsiz := m.XXX_Size()\n+\t\tb := make([]byte, 0, siz)\n+\t\treturn m.XXX_Marshal(b, false)\n+\t}\n+\tif m, ok := pb.(Marshaler); ok {\n+\t\t// If the message can marshal itself, let it do it, for compatibility.\n+\t\t// NOTE: This is not efficient.\n+\t\treturn m.Marshal()\n+\t}\n+\t// in case somehow we didn't generate the wrapper\n+\tif pb == nil {\n+\t\treturn nil, ErrNil\n+\t}\n+\tvar info InternalMessageInfo\n+\tsiz := info.Size(pb)\n+\tb := make([]byte, 0, siz)\n+\treturn info.Marshal(b, pb, false)\n+}\n+\n+// Marshal takes a protocol buffer message\n+// and encodes it into the wire format, writing the result to the\n+// Buffer.\n+// This is an alternative entry point. It is not necessary to use\n+// a Buffer for most applications.\n+func (p *Buffer) Marshal(pb Message) error {\n+\tvar err error\n+\tif m, ok := pb.(newMarshaler); ok {\n+\t\tsiz := m.XXX_Size()\n+\t\tp.grow(siz) // make sure buf has enough capacity\n+\t\tp.buf, err = m.XXX_Marshal(p.buf, p.deterministic)\n+\t\treturn err\n+\t}\n+\tif m, ok := pb.(Marshaler); ok {\n+\t\t// If the message can marshal itself, let it do it, for compatibility.\n+\t\t// NOTE: This is not efficient.\n+\t\tb, err := m.Marshal()\n+\t\tp.buf = append(p.buf, b...)\n+\t\treturn err\n+\t}\n+\t// in case somehow we didn't generate the wrapper\n+\tif pb == nil {\n+\t\treturn ErrNil\n+\t}\n+\tvar info InternalMessageInfo\n+\tsiz := info.Size(pb)\n+\tp.grow(siz) // make sure buf has enough capacity\n+\tp.buf, err = info.Marshal(p.buf, pb, p.deterministic)\n+\treturn err\n+}\n+\n+// grow grows the buffer's capacity, if necessary, to guarantee space for\n+// another n bytes. After grow(n), at least n bytes can be written to the\n+// buffer without another allocation.\n+func (p *Buffer) grow(n int) {\n+\tneed := len(p.buf) + n\n+\tif need <= cap(p.buf) {\n+\t\treturn\n+\t}\n+\tnewCap := len(p.buf) * 2\n+\tif newCap < need {\n+\t\tnewCap = need\n+\t}\n+\tp.buf = append(make([]byte, 0, newCap), p.buf...)\n+}"
    },
    {
      "sha": "5525def6a5da89fee6a0528924cefdbc5ef987e1",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/table_merge.go",
      "status": "added",
      "additions": 654,
      "deletions": 0,
      "changes": 654,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/table_merge.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/table_merge.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/table_merge.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -0,0 +1,654 @@\n+// Go support for Protocol Buffers - Google's data interchange format\n+//\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// https://github.com/golang/protobuf\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+package proto\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+)\n+\n+// Merge merges the src message into dst.\n+// This assumes that dst and src of the same type and are non-nil.\n+func (a *InternalMessageInfo) Merge(dst, src Message) {\n+\tmi := atomicLoadMergeInfo(&a.merge)\n+\tif mi == nil {\n+\t\tmi = getMergeInfo(reflect.TypeOf(dst).Elem())\n+\t\tatomicStoreMergeInfo(&a.merge, mi)\n+\t}\n+\tmi.merge(toPointer(&dst), toPointer(&src))\n+}\n+\n+type mergeInfo struct {\n+\ttyp reflect.Type\n+\n+\tinitialized int32 // 0: only typ is valid, 1: everything is valid\n+\tlock        sync.Mutex\n+\n+\tfields       []mergeFieldInfo\n+\tunrecognized field // Offset of XXX_unrecognized\n+}\n+\n+type mergeFieldInfo struct {\n+\tfield field // Offset of field, guaranteed to be valid\n+\n+\t// isPointer reports whether the value in the field is a pointer.\n+\t// This is true for the following situations:\n+\t//\t* Pointer to struct\n+\t//\t* Pointer to basic type (proto2 only)\n+\t//\t* Slice (first value in slice header is a pointer)\n+\t//\t* String (first value in string header is a pointer)\n+\tisPointer bool\n+\n+\t// basicWidth reports the width of the field assuming that it is directly\n+\t// embedded in the struct (as is the case for basic types in proto3).\n+\t// The possible values are:\n+\t// \t0: invalid\n+\t//\t1: bool\n+\t//\t4: int32, uint32, float32\n+\t//\t8: int64, uint64, float64\n+\tbasicWidth int\n+\n+\t// Where dst and src are pointers to the types being merged.\n+\tmerge func(dst, src pointer)\n+}\n+\n+var (\n+\tmergeInfoMap  = map[reflect.Type]*mergeInfo{}\n+\tmergeInfoLock sync.Mutex\n+)\n+\n+func getMergeInfo(t reflect.Type) *mergeInfo {\n+\tmergeInfoLock.Lock()\n+\tdefer mergeInfoLock.Unlock()\n+\tmi := mergeInfoMap[t]\n+\tif mi == nil {\n+\t\tmi = &mergeInfo{typ: t}\n+\t\tmergeInfoMap[t] = mi\n+\t}\n+\treturn mi\n+}\n+\n+// merge merges src into dst assuming they are both of type *mi.typ.\n+func (mi *mergeInfo) merge(dst, src pointer) {\n+\tif dst.isNil() {\n+\t\tpanic(\"proto: nil destination\")\n+\t}\n+\tif src.isNil() {\n+\t\treturn // Nothing to do.\n+\t}\n+\n+\tif atomic.LoadInt32(&mi.initialized) == 0 {\n+\t\tmi.computeMergeInfo()\n+\t}\n+\n+\tfor _, fi := range mi.fields {\n+\t\tsfp := src.offset(fi.field)\n+\n+\t\t// As an optimization, we can avoid the merge function call cost\n+\t\t// if we know for sure that the source will have no effect\n+\t\t// by checking if it is the zero value.\n+\t\tif unsafeAllowed {\n+\t\t\tif fi.isPointer && sfp.getPointer().isNil() { // Could be slice or string\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif fi.basicWidth > 0 {\n+\t\t\t\tswitch {\n+\t\t\t\tcase fi.basicWidth == 1 && !*sfp.toBool():\n+\t\t\t\t\tcontinue\n+\t\t\t\tcase fi.basicWidth == 4 && *sfp.toUint32() == 0:\n+\t\t\t\t\tcontinue\n+\t\t\t\tcase fi.basicWidth == 8 && *sfp.toUint64() == 0:\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tdfp := dst.offset(fi.field)\n+\t\tfi.merge(dfp, sfp)\n+\t}\n+\n+\t// TODO: Make this faster?\n+\tout := dst.asPointerTo(mi.typ).Elem()\n+\tin := src.asPointerTo(mi.typ).Elem()\n+\tif emIn, err := extendable(in.Addr().Interface()); err == nil {\n+\t\temOut, _ := extendable(out.Addr().Interface())\n+\t\tmIn, muIn := emIn.extensionsRead()\n+\t\tif mIn != nil {\n+\t\t\tmOut := emOut.extensionsWrite()\n+\t\t\tmuIn.Lock()\n+\t\t\tmergeExtension(mOut, mIn)\n+\t\t\tmuIn.Unlock()\n+\t\t}\n+\t}\n+\n+\tif mi.unrecognized.IsValid() {\n+\t\tif b := *src.offset(mi.unrecognized).toBytes(); len(b) > 0 {\n+\t\t\t*dst.offset(mi.unrecognized).toBytes() = append([]byte(nil), b...)\n+\t\t}\n+\t}\n+}\n+\n+func (mi *mergeInfo) computeMergeInfo() {\n+\tmi.lock.Lock()\n+\tdefer mi.lock.Unlock()\n+\tif mi.initialized != 0 {\n+\t\treturn\n+\t}\n+\tt := mi.typ\n+\tn := t.NumField()\n+\n+\tprops := GetProperties(t)\n+\tfor i := 0; i < n; i++ {\n+\t\tf := t.Field(i)\n+\t\tif strings.HasPrefix(f.Name, \"XXX_\") {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tmfi := mergeFieldInfo{field: toField(&f)}\n+\t\ttf := f.Type\n+\n+\t\t// As an optimization, we can avoid the merge function call cost\n+\t\t// if we know for sure that the source will have no effect\n+\t\t// by checking if it is the zero value.\n+\t\tif unsafeAllowed {\n+\t\t\tswitch tf.Kind() {\n+\t\t\tcase reflect.Ptr, reflect.Slice, reflect.String:\n+\t\t\t\t// As a special case, we assume slices and strings are pointers\n+\t\t\t\t// since we know that the first field in the SliceSlice or\n+\t\t\t\t// StringHeader is a data pointer.\n+\t\t\t\tmfi.isPointer = true\n+\t\t\tcase reflect.Bool:\n+\t\t\t\tmfi.basicWidth = 1\n+\t\t\tcase reflect.Int32, reflect.Uint32, reflect.Float32:\n+\t\t\t\tmfi.basicWidth = 4\n+\t\t\tcase reflect.Int64, reflect.Uint64, reflect.Float64:\n+\t\t\t\tmfi.basicWidth = 8\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Unwrap tf to get at its most basic type.\n+\t\tvar isPointer, isSlice bool\n+\t\tif tf.Kind() == reflect.Slice && tf.Elem().Kind() != reflect.Uint8 {\n+\t\t\tisSlice = true\n+\t\t\ttf = tf.Elem()\n+\t\t}\n+\t\tif tf.Kind() == reflect.Ptr {\n+\t\t\tisPointer = true\n+\t\t\ttf = tf.Elem()\n+\t\t}\n+\t\tif isPointer && isSlice && tf.Kind() != reflect.Struct {\n+\t\t\tpanic(\"both pointer and slice for basic type in \" + tf.Name())\n+\t\t}\n+\n+\t\tswitch tf.Kind() {\n+\t\tcase reflect.Int32:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []int32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\t// NOTE: toInt32Slice is not defined (see pointer_reflect.go).\n+\t\t\t\t\t/*\n+\t\t\t\t\t\tsfsp := src.toInt32Slice()\n+\t\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\t\tdfsp := dst.toInt32Slice()\n+\t\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t\t*dfsp = []int64{}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t*/\n+\t\t\t\t\tsfs := src.getInt32Slice()\n+\t\t\t\t\tif sfs != nil {\n+\t\t\t\t\t\tdfs := dst.getInt32Slice()\n+\t\t\t\t\t\tdfs = append(dfs, sfs...)\n+\t\t\t\t\t\tif dfs == nil {\n+\t\t\t\t\t\t\tdfs = []int32{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tdst.setInt32Slice(dfs)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *int32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\t// NOTE: toInt32Ptr is not defined (see pointer_reflect.go).\n+\t\t\t\t\t/*\n+\t\t\t\t\t\tsfpp := src.toInt32Ptr()\n+\t\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\t\tdfpp := dst.toInt32Ptr()\n+\t\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t\t*dfpp = Int32(**sfpp)\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t*/\n+\t\t\t\t\tsfp := src.getInt32Ptr()\n+\t\t\t\t\tif sfp != nil {\n+\t\t\t\t\t\tdfp := dst.getInt32Ptr()\n+\t\t\t\t\t\tif dfp == nil {\n+\t\t\t\t\t\t\tdst.setInt32Ptr(*sfp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t*dfp = *sfp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., int32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toInt32(); v != 0 {\n+\t\t\t\t\t\t*dst.toInt32() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Int64:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []int64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfsp := src.toInt64Slice()\n+\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\tdfsp := dst.toInt64Slice()\n+\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t*dfsp = []int64{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *int64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfpp := src.toInt64Ptr()\n+\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\tdfpp := dst.toInt64Ptr()\n+\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t*dfpp = Int64(**sfpp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., int64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toInt64(); v != 0 {\n+\t\t\t\t\t\t*dst.toInt64() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Uint32:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []uint32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfsp := src.toUint32Slice()\n+\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\tdfsp := dst.toUint32Slice()\n+\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t*dfsp = []uint32{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *uint32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfpp := src.toUint32Ptr()\n+\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\tdfpp := dst.toUint32Ptr()\n+\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t*dfpp = Uint32(**sfpp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., uint32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toUint32(); v != 0 {\n+\t\t\t\t\t\t*dst.toUint32() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Uint64:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []uint64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfsp := src.toUint64Slice()\n+\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\tdfsp := dst.toUint64Slice()\n+\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t*dfsp = []uint64{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *uint64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfpp := src.toUint64Ptr()\n+\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\tdfpp := dst.toUint64Ptr()\n+\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t*dfpp = Uint64(**sfpp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., uint64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toUint64(); v != 0 {\n+\t\t\t\t\t\t*dst.toUint64() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Float32:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []float32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfsp := src.toFloat32Slice()\n+\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\tdfsp := dst.toFloat32Slice()\n+\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t*dfsp = []float32{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *float32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfpp := src.toFloat32Ptr()\n+\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\tdfpp := dst.toFloat32Ptr()\n+\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t*dfpp = Float32(**sfpp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., float32\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toFloat32(); v != 0 {\n+\t\t\t\t\t\t*dst.toFloat32() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Float64:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []float64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfsp := src.toFloat64Slice()\n+\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\tdfsp := dst.toFloat64Slice()\n+\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t*dfsp = []float64{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *float64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfpp := src.toFloat64Ptr()\n+\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\tdfpp := dst.toFloat64Ptr()\n+\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t*dfpp = Float64(**sfpp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., float64\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toFloat64(); v != 0 {\n+\t\t\t\t\t\t*dst.toFloat64() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Bool:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []bool\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfsp := src.toBoolSlice()\n+\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\tdfsp := dst.toBoolSlice()\n+\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t*dfsp = []bool{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *bool\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfpp := src.toBoolPtr()\n+\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\tdfpp := dst.toBoolPtr()\n+\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t*dfpp = Bool(**sfpp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., bool\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toBool(); v {\n+\t\t\t\t\t\t*dst.toBool() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.String:\n+\t\t\tswitch {\n+\t\t\tcase isSlice: // E.g., []string\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfsp := src.toStringSlice()\n+\t\t\t\t\tif *sfsp != nil {\n+\t\t\t\t\t\tdfsp := dst.toStringSlice()\n+\t\t\t\t\t\t*dfsp = append(*dfsp, *sfsp...)\n+\t\t\t\t\t\tif *dfsp == nil {\n+\t\t\t\t\t\t\t*dfsp = []string{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isPointer: // E.g., *string\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsfpp := src.toStringPtr()\n+\t\t\t\t\tif *sfpp != nil {\n+\t\t\t\t\t\tdfpp := dst.toStringPtr()\n+\t\t\t\t\t\tif *dfpp == nil {\n+\t\t\t\t\t\t\t*dfpp = String(**sfpp)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t**dfpp = **sfpp\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., string\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tif v := *src.toString(); v != \"\" {\n+\t\t\t\t\t\t*dst.toString() = v\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Slice:\n+\t\t\tisProto3 := props.Prop[i].proto3\n+\t\t\tswitch {\n+\t\t\tcase isPointer:\n+\t\t\t\tpanic(\"bad pointer in byte slice case in \" + tf.Name())\n+\t\t\tcase tf.Elem().Kind() != reflect.Uint8:\n+\t\t\t\tpanic(\"bad element kind in byte slice case in \" + tf.Name())\n+\t\t\tcase isSlice: // E.g., [][]byte\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsbsp := src.toBytesSlice()\n+\t\t\t\t\tif *sbsp != nil {\n+\t\t\t\t\t\tdbsp := dst.toBytesSlice()\n+\t\t\t\t\t\tfor _, sb := range *sbsp {\n+\t\t\t\t\t\t\tif sb == nil {\n+\t\t\t\t\t\t\t\t*dbsp = append(*dbsp, nil)\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t*dbsp = append(*dbsp, append([]byte{}, sb...))\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif *dbsp == nil {\n+\t\t\t\t\t\t\t*dbsp = [][]byte{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., []byte\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsbp := src.toBytes()\n+\t\t\t\t\tif *sbp != nil {\n+\t\t\t\t\t\tdbp := dst.toBytes()\n+\t\t\t\t\t\tif !isProto3 || len(*sbp) > 0 {\n+\t\t\t\t\t\t\t*dbp = append([]byte{}, *sbp...)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Struct:\n+\t\t\tswitch {\n+\t\t\tcase !isPointer:\n+\t\t\t\tpanic(fmt.Sprintf(\"message field %s without pointer\", tf))\n+\t\t\tcase isSlice: // E.g., []*pb.T\n+\t\t\t\tmi := getMergeInfo(tf)\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsps := src.getPointerSlice()\n+\t\t\t\t\tif sps != nil {\n+\t\t\t\t\t\tdps := dst.getPointerSlice()\n+\t\t\t\t\t\tfor _, sp := range sps {\n+\t\t\t\t\t\t\tvar dp pointer\n+\t\t\t\t\t\t\tif !sp.isNil() {\n+\t\t\t\t\t\t\t\tdp = valToPointer(reflect.New(tf))\n+\t\t\t\t\t\t\t\tmi.merge(dp, sp)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tdps = append(dps, dp)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif dps == nil {\n+\t\t\t\t\t\t\tdps = []pointer{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tdst.setPointerSlice(dps)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tdefault: // E.g., *pb.T\n+\t\t\t\tmi := getMergeInfo(tf)\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsp := src.getPointer()\n+\t\t\t\t\tif !sp.isNil() {\n+\t\t\t\t\t\tdp := dst.getPointer()\n+\t\t\t\t\t\tif dp.isNil() {\n+\t\t\t\t\t\t\tdp = valToPointer(reflect.New(tf))\n+\t\t\t\t\t\t\tdst.setPointer(dp)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tmi.merge(dp, sp)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Map:\n+\t\t\tswitch {\n+\t\t\tcase isPointer || isSlice:\n+\t\t\t\tpanic(\"bad pointer or slice in map case in \" + tf.Name())\n+\t\t\tdefault: // E.g., map[K]V\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsm := src.asPointerTo(tf).Elem()\n+\t\t\t\t\tif sm.Len() == 0 {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t\tdm := dst.asPointerTo(tf).Elem()\n+\t\t\t\t\tif dm.IsNil() {\n+\t\t\t\t\t\tdm.Set(reflect.MakeMap(tf))\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tswitch tf.Elem().Kind() {\n+\t\t\t\t\tcase reflect.Ptr: // Proto struct (e.g., *T)\n+\t\t\t\t\t\tfor _, key := range sm.MapKeys() {\n+\t\t\t\t\t\t\tval := sm.MapIndex(key)\n+\t\t\t\t\t\t\tval = reflect.ValueOf(Clone(val.Interface().(Message)))\n+\t\t\t\t\t\t\tdm.SetMapIndex(key, val)\n+\t\t\t\t\t\t}\n+\t\t\t\t\tcase reflect.Slice: // E.g. Bytes type (e.g., []byte)\n+\t\t\t\t\t\tfor _, key := range sm.MapKeys() {\n+\t\t\t\t\t\t\tval := sm.MapIndex(key)\n+\t\t\t\t\t\t\tval = reflect.ValueOf(append([]byte{}, val.Bytes()...))\n+\t\t\t\t\t\t\tdm.SetMapIndex(key, val)\n+\t\t\t\t\t\t}\n+\t\t\t\t\tdefault: // Basic type (e.g., string)\n+\t\t\t\t\t\tfor _, key := range sm.MapKeys() {\n+\t\t\t\t\t\t\tval := sm.MapIndex(key)\n+\t\t\t\t\t\t\tdm.SetMapIndex(key, val)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase reflect.Interface:\n+\t\t\t// Must be oneof field.\n+\t\t\tswitch {\n+\t\t\tcase isPointer || isSlice:\n+\t\t\t\tpanic(\"bad pointer or slice in interface case in \" + tf.Name())\n+\t\t\tdefault: // E.g., interface{}\n+\t\t\t\t// TODO: Make this faster?\n+\t\t\t\tmfi.merge = func(dst, src pointer) {\n+\t\t\t\t\tsu := src.asPointerTo(tf).Elem()\n+\t\t\t\t\tif !su.IsNil() {\n+\t\t\t\t\t\tdu := dst.asPointerTo(tf).Elem()\n+\t\t\t\t\t\ttyp := su.Elem().Type()\n+\t\t\t\t\t\tif du.IsNil() || du.Elem().Type() != typ {\n+\t\t\t\t\t\t\tdu.Set(reflect.New(typ.Elem())) // Initialize interface if empty\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tsv := su.Elem().Elem().Field(0)\n+\t\t\t\t\t\tif sv.Kind() == reflect.Ptr && sv.IsNil() {\n+\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tdv := du.Elem().Elem().Field(0)\n+\t\t\t\t\t\tif dv.Kind() == reflect.Ptr && dv.IsNil() {\n+\t\t\t\t\t\t\tdv.Set(reflect.New(sv.Type().Elem())) // Initialize proto message if empty\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tswitch sv.Type().Kind() {\n+\t\t\t\t\t\tcase reflect.Ptr: // Proto struct (e.g., *T)\n+\t\t\t\t\t\t\tMerge(dv.Interface().(Message), sv.Interface().(Message))\n+\t\t\t\t\t\tcase reflect.Slice: // E.g. Bytes type (e.g., []byte)\n+\t\t\t\t\t\t\tdv.Set(reflect.ValueOf(append([]byte{}, sv.Bytes()...)))\n+\t\t\t\t\t\tdefault: // Basic type (e.g., string)\n+\t\t\t\t\t\t\tdv.Set(sv)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tpanic(fmt.Sprintf(\"merger not found for type:%s\", tf))\n+\t\t}\n+\t\tmi.fields = append(mi.fields, mfi)\n+\t}\n+\n+\tmi.unrecognized = invalidField\n+\tif f, ok := t.FieldByName(\"XXX_unrecognized\"); ok {\n+\t\tif f.Type != reflect.TypeOf([]byte{}) {\n+\t\t\tpanic(\"expected XXX_unrecognized to be of type []byte\")\n+\t\t}\n+\t\tmi.unrecognized = toField(&f)\n+\t}\n+\n+\tatomic.StoreInt32(&mi.initialized, 1)\n+}"
    },
    {
      "sha": "ebf1caa56a268dc6552a5aa4d26af5890e2d8834",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/table_unmarshal.go",
      "status": "added",
      "additions": 2051,
      "deletions": 0,
      "changes": 2051,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/table_unmarshal.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/table_unmarshal.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/table_unmarshal.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -0,0 +1,2051 @@\n+// Go support for Protocol Buffers - Google's data interchange format\n+//\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// https://github.com/golang/protobuf\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+package proto\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\t\"unicode/utf8\"\n+)\n+\n+// Unmarshal is the entry point from the generated .pb.go files.\n+// This function is not intended to be used by non-generated code.\n+// This function is not subject to any compatibility guarantee.\n+// msg contains a pointer to a protocol buffer struct.\n+// b is the data to be unmarshaled into the protocol buffer.\n+// a is a pointer to a place to store cached unmarshal information.\n+func (a *InternalMessageInfo) Unmarshal(msg Message, b []byte) error {\n+\t// Load the unmarshal information for this message type.\n+\t// The atomic load ensures memory consistency.\n+\tu := atomicLoadUnmarshalInfo(&a.unmarshal)\n+\tif u == nil {\n+\t\t// Slow path: find unmarshal info for msg, update a with it.\n+\t\tu = getUnmarshalInfo(reflect.TypeOf(msg).Elem())\n+\t\tatomicStoreUnmarshalInfo(&a.unmarshal, u)\n+\t}\n+\t// Then do the unmarshaling.\n+\terr := u.unmarshal(toPointer(&msg), b)\n+\treturn err\n+}\n+\n+type unmarshalInfo struct {\n+\ttyp reflect.Type // type of the protobuf struct\n+\n+\t// 0 = only typ field is initialized\n+\t// 1 = completely initialized\n+\tinitialized     int32\n+\tlock            sync.Mutex                    // prevents double initialization\n+\tdense           []unmarshalFieldInfo          // fields indexed by tag #\n+\tsparse          map[uint64]unmarshalFieldInfo // fields indexed by tag #\n+\treqFields       []string                      // names of required fields\n+\treqMask         uint64                        // 1<<len(reqFields)-1\n+\tunrecognized    field                         // offset of []byte to put unrecognized data (or invalidField if we should throw it away)\n+\textensions      field                         // offset of extensions field (of type proto.XXX_InternalExtensions), or invalidField if it does not exist\n+\toldExtensions   field                         // offset of old-form extensions field (of type map[int]Extension)\n+\textensionRanges []ExtensionRange              // if non-nil, implies extensions field is valid\n+\tisMessageSet    bool                          // if true, implies extensions field is valid\n+}\n+\n+// An unmarshaler takes a stream of bytes and a pointer to a field of a message.\n+// It decodes the field, stores it at f, and returns the unused bytes.\n+// w is the wire encoding.\n+// b is the data after the tag and wire encoding have been read.\n+type unmarshaler func(b []byte, f pointer, w int) ([]byte, error)\n+\n+type unmarshalFieldInfo struct {\n+\t// location of the field in the proto message structure.\n+\tfield field\n+\n+\t// function to unmarshal the data for the field.\n+\tunmarshal unmarshaler\n+\n+\t// if a required field, contains a single set bit at this field's index in the required field list.\n+\treqMask uint64\n+\n+\tname string // name of the field, for error reporting\n+}\n+\n+var (\n+\tunmarshalInfoMap  = map[reflect.Type]*unmarshalInfo{}\n+\tunmarshalInfoLock sync.Mutex\n+)\n+\n+// getUnmarshalInfo returns the data structure which can be\n+// subsequently used to unmarshal a message of the given type.\n+// t is the type of the message (note: not pointer to message).\n+func getUnmarshalInfo(t reflect.Type) *unmarshalInfo {\n+\t// It would be correct to return a new unmarshalInfo\n+\t// unconditionally. We would end up allocating one\n+\t// per occurrence of that type as a message or submessage.\n+\t// We use a cache here just to reduce memory usage.\n+\tunmarshalInfoLock.Lock()\n+\tdefer unmarshalInfoLock.Unlock()\n+\tu := unmarshalInfoMap[t]\n+\tif u == nil {\n+\t\tu = &unmarshalInfo{typ: t}\n+\t\t// Note: we just set the type here. The rest of the fields\n+\t\t// will be initialized on first use.\n+\t\tunmarshalInfoMap[t] = u\n+\t}\n+\treturn u\n+}\n+\n+// unmarshal does the main work of unmarshaling a message.\n+// u provides type information used to unmarshal the message.\n+// m is a pointer to a protocol buffer message.\n+// b is a byte stream to unmarshal into m.\n+// This is top routine used when recursively unmarshaling submessages.\n+func (u *unmarshalInfo) unmarshal(m pointer, b []byte) error {\n+\tif atomic.LoadInt32(&u.initialized) == 0 {\n+\t\tu.computeUnmarshalInfo()\n+\t}\n+\tif u.isMessageSet {\n+\t\treturn UnmarshalMessageSet(b, m.offset(u.extensions).toExtensions())\n+\t}\n+\tvar reqMask uint64 // bitmask of required fields we've seen.\n+\tvar errLater error\n+\tfor len(b) > 0 {\n+\t\t// Read tag and wire type.\n+\t\t// Special case 1 and 2 byte varints.\n+\t\tvar x uint64\n+\t\tif b[0] < 128 {\n+\t\t\tx = uint64(b[0])\n+\t\t\tb = b[1:]\n+\t\t} else if len(b) >= 2 && b[1] < 128 {\n+\t\t\tx = uint64(b[0]&0x7f) + uint64(b[1])<<7\n+\t\t\tb = b[2:]\n+\t\t} else {\n+\t\t\tvar n int\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tb = b[n:]\n+\t\t}\n+\t\ttag := x >> 3\n+\t\twire := int(x) & 7\n+\n+\t\t// Dispatch on the tag to one of the unmarshal* functions below.\n+\t\tvar f unmarshalFieldInfo\n+\t\tif tag < uint64(len(u.dense)) {\n+\t\t\tf = u.dense[tag]\n+\t\t} else {\n+\t\t\tf = u.sparse[tag]\n+\t\t}\n+\t\tif fn := f.unmarshal; fn != nil {\n+\t\t\tvar err error\n+\t\t\tb, err = fn(b, m.offset(f.field), wire)\n+\t\t\tif err == nil {\n+\t\t\t\treqMask |= f.reqMask\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif r, ok := err.(*RequiredNotSetError); ok {\n+\t\t\t\t// Remember this error, but keep parsing. We need to produce\n+\t\t\t\t// a full parse even if a required field is missing.\n+\t\t\t\tif errLater == nil {\n+\t\t\t\t\terrLater = r\n+\t\t\t\t}\n+\t\t\t\treqMask |= f.reqMask\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err != errInternalBadWireType {\n+\t\t\t\tif err == errInvalidUTF8 {\n+\t\t\t\t\tif errLater == nil {\n+\t\t\t\t\t\tfullName := revProtoTypes[reflect.PtrTo(u.typ)] + \".\" + f.name\n+\t\t\t\t\t\terrLater = &invalidUTF8Error{fullName}\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t// Fragments with bad wire type are treated as unknown fields.\n+\t\t}\n+\n+\t\t// Unknown tag.\n+\t\tif !u.unrecognized.IsValid() {\n+\t\t\t// Don't keep unrecognized data; just skip it.\n+\t\t\tvar err error\n+\t\t\tb, err = skipField(b, wire)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Keep unrecognized data around.\n+\t\t// maybe in extensions, maybe in the unrecognized field.\n+\t\tz := m.offset(u.unrecognized).toBytes()\n+\t\tvar emap map[int32]Extension\n+\t\tvar e Extension\n+\t\tfor _, r := range u.extensionRanges {\n+\t\t\tif uint64(r.Start) <= tag && tag <= uint64(r.End) {\n+\t\t\t\tif u.extensions.IsValid() {\n+\t\t\t\t\tmp := m.offset(u.extensions).toExtensions()\n+\t\t\t\t\temap = mp.extensionsWrite()\n+\t\t\t\t\te = emap[int32(tag)]\n+\t\t\t\t\tz = &e.enc\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif u.oldExtensions.IsValid() {\n+\t\t\t\t\tp := m.offset(u.oldExtensions).toOldExtensions()\n+\t\t\t\t\temap = *p\n+\t\t\t\t\tif emap == nil {\n+\t\t\t\t\t\temap = map[int32]Extension{}\n+\t\t\t\t\t\t*p = emap\n+\t\t\t\t\t}\n+\t\t\t\t\te = emap[int32(tag)]\n+\t\t\t\t\tz = &e.enc\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tpanic(\"no extensions field available\")\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Use wire type to skip data.\n+\t\tvar err error\n+\t\tb0 := b\n+\t\tb, err = skipField(b, wire)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t*z = encodeVarint(*z, tag<<3|uint64(wire))\n+\t\t*z = append(*z, b0[:len(b0)-len(b)]...)\n+\n+\t\tif emap != nil {\n+\t\t\temap[int32(tag)] = e\n+\t\t}\n+\t}\n+\tif reqMask != u.reqMask && errLater == nil {\n+\t\t// A required field of this message is missing.\n+\t\tfor _, n := range u.reqFields {\n+\t\t\tif reqMask&1 == 0 {\n+\t\t\t\terrLater = &RequiredNotSetError{n}\n+\t\t\t}\n+\t\t\treqMask >>= 1\n+\t\t}\n+\t}\n+\treturn errLater\n+}\n+\n+// computeUnmarshalInfo fills in u with information for use\n+// in unmarshaling protocol buffers of type u.typ.\n+func (u *unmarshalInfo) computeUnmarshalInfo() {\n+\tu.lock.Lock()\n+\tdefer u.lock.Unlock()\n+\tif u.initialized != 0 {\n+\t\treturn\n+\t}\n+\tt := u.typ\n+\tn := t.NumField()\n+\n+\t// Set up the \"not found\" value for the unrecognized byte buffer.\n+\t// This is the default for proto3.\n+\tu.unrecognized = invalidField\n+\tu.extensions = invalidField\n+\tu.oldExtensions = invalidField\n+\n+\t// List of the generated type and offset for each oneof field.\n+\ttype oneofField struct {\n+\t\tityp  reflect.Type // interface type of oneof field\n+\t\tfield field        // offset in containing message\n+\t}\n+\tvar oneofFields []oneofField\n+\n+\tfor i := 0; i < n; i++ {\n+\t\tf := t.Field(i)\n+\t\tif f.Name == \"XXX_unrecognized\" {\n+\t\t\t// The byte slice used to hold unrecognized input is special.\n+\t\t\tif f.Type != reflect.TypeOf(([]byte)(nil)) {\n+\t\t\t\tpanic(\"bad type for XXX_unrecognized field: \" + f.Type.Name())\n+\t\t\t}\n+\t\t\tu.unrecognized = toField(&f)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f.Name == \"XXX_InternalExtensions\" {\n+\t\t\t// Ditto here.\n+\t\t\tif f.Type != reflect.TypeOf(XXX_InternalExtensions{}) {\n+\t\t\t\tpanic(\"bad type for XXX_InternalExtensions field: \" + f.Type.Name())\n+\t\t\t}\n+\t\t\tu.extensions = toField(&f)\n+\t\t\tif f.Tag.Get(\"protobuf_messageset\") == \"1\" {\n+\t\t\t\tu.isMessageSet = true\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f.Name == \"XXX_extensions\" {\n+\t\t\t// An older form of the extensions field.\n+\t\t\tif f.Type != reflect.TypeOf((map[int32]Extension)(nil)) {\n+\t\t\t\tpanic(\"bad type for XXX_extensions field: \" + f.Type.Name())\n+\t\t\t}\n+\t\t\tu.oldExtensions = toField(&f)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f.Name == \"XXX_NoUnkeyedLiteral\" || f.Name == \"XXX_sizecache\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\toneof := f.Tag.Get(\"protobuf_oneof\")\n+\t\tif oneof != \"\" {\n+\t\t\toneofFields = append(oneofFields, oneofField{f.Type, toField(&f)})\n+\t\t\t// The rest of oneof processing happens below.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\ttags := f.Tag.Get(\"protobuf\")\n+\t\ttagArray := strings.Split(tags, \",\")\n+\t\tif len(tagArray) < 2 {\n+\t\t\tpanic(\"protobuf tag not enough fields in \" + t.Name() + \".\" + f.Name + \": \" + tags)\n+\t\t}\n+\t\ttag, err := strconv.Atoi(tagArray[1])\n+\t\tif err != nil {\n+\t\t\tpanic(\"protobuf tag field not an integer: \" + tagArray[1])\n+\t\t}\n+\n+\t\tname := \"\"\n+\t\tfor _, tag := range tagArray[3:] {\n+\t\t\tif strings.HasPrefix(tag, \"name=\") {\n+\t\t\t\tname = tag[5:]\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Extract unmarshaling function from the field (its type and tags).\n+\t\tunmarshal := fieldUnmarshaler(&f)\n+\n+\t\t// Required field?\n+\t\tvar reqMask uint64\n+\t\tif tagArray[2] == \"req\" {\n+\t\t\tbit := len(u.reqFields)\n+\t\t\tu.reqFields = append(u.reqFields, name)\n+\t\t\treqMask = uint64(1) << uint(bit)\n+\t\t\t// TODO: if we have more than 64 required fields, we end up\n+\t\t\t// not verifying that all required fields are present.\n+\t\t\t// Fix this, perhaps using a count of required fields?\n+\t\t}\n+\n+\t\t// Store the info in the correct slot in the message.\n+\t\tu.setTag(tag, toField(&f), unmarshal, reqMask, name)\n+\t}\n+\n+\t// Find any types associated with oneof fields.\n+\t// TODO: XXX_OneofFuncs returns more info than we need.  Get rid of some of it?\n+\tfn := reflect.Zero(reflect.PtrTo(t)).MethodByName(\"XXX_OneofFuncs\")\n+\tif fn.IsValid() {\n+\t\tres := fn.Call(nil)[3] // last return value from XXX_OneofFuncs: []interface{}\n+\t\tfor i := res.Len() - 1; i >= 0; i-- {\n+\t\t\tv := res.Index(i)                             // interface{}\n+\t\t\ttptr := reflect.ValueOf(v.Interface()).Type() // *Msg_X\n+\t\t\ttyp := tptr.Elem()                            // Msg_X\n+\n+\t\t\tf := typ.Field(0) // oneof implementers have one field\n+\t\t\tbaseUnmarshal := fieldUnmarshaler(&f)\n+\t\t\ttags := strings.Split(f.Tag.Get(\"protobuf\"), \",\")\n+\t\t\tfieldNum, err := strconv.Atoi(tags[1])\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(\"protobuf tag field not an integer: \" + tags[1])\n+\t\t\t}\n+\t\t\tvar name string\n+\t\t\tfor _, tag := range tags {\n+\t\t\t\tif strings.HasPrefix(tag, \"name=\") {\n+\t\t\t\t\tname = strings.TrimPrefix(tag, \"name=\")\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Find the oneof field that this struct implements.\n+\t\t\t// Might take O(n^2) to process all of the oneofs, but who cares.\n+\t\t\tfor _, of := range oneofFields {\n+\t\t\t\tif tptr.Implements(of.ityp) {\n+\t\t\t\t\t// We have found the corresponding interface for this struct.\n+\t\t\t\t\t// That lets us know where this struct should be stored\n+\t\t\t\t\t// when we encounter it during unmarshaling.\n+\t\t\t\t\tunmarshal := makeUnmarshalOneof(typ, of.ityp, baseUnmarshal)\n+\t\t\t\t\tu.setTag(fieldNum, of.field, unmarshal, 0, name)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Get extension ranges, if any.\n+\tfn = reflect.Zero(reflect.PtrTo(t)).MethodByName(\"ExtensionRangeArray\")\n+\tif fn.IsValid() {\n+\t\tif !u.extensions.IsValid() && !u.oldExtensions.IsValid() {\n+\t\t\tpanic(\"a message with extensions, but no extensions field in \" + t.Name())\n+\t\t}\n+\t\tu.extensionRanges = fn.Call(nil)[0].Interface().([]ExtensionRange)\n+\t}\n+\n+\t// Explicitly disallow tag 0. This will ensure we flag an error\n+\t// when decoding a buffer of all zeros. Without this code, we\n+\t// would decode and skip an all-zero buffer of even length.\n+\t// [0 0] is [tag=0/wiretype=varint varint-encoded-0].\n+\tu.setTag(0, zeroField, func(b []byte, f pointer, w int) ([]byte, error) {\n+\t\treturn nil, fmt.Errorf(\"proto: %s: illegal tag 0 (wire type %d)\", t, w)\n+\t}, 0, \"\")\n+\n+\t// Set mask for required field check.\n+\tu.reqMask = uint64(1)<<uint(len(u.reqFields)) - 1\n+\n+\tatomic.StoreInt32(&u.initialized, 1)\n+}\n+\n+// setTag stores the unmarshal information for the given tag.\n+// tag = tag # for field\n+// field/unmarshal = unmarshal info for that field.\n+// reqMask = if required, bitmask for field position in required field list. 0 otherwise.\n+// name = short name of the field.\n+func (u *unmarshalInfo) setTag(tag int, field field, unmarshal unmarshaler, reqMask uint64, name string) {\n+\ti := unmarshalFieldInfo{field: field, unmarshal: unmarshal, reqMask: reqMask, name: name}\n+\tn := u.typ.NumField()\n+\tif tag >= 0 && (tag < 16 || tag < 2*n) { // TODO: what are the right numbers here?\n+\t\tfor len(u.dense) <= tag {\n+\t\t\tu.dense = append(u.dense, unmarshalFieldInfo{})\n+\t\t}\n+\t\tu.dense[tag] = i\n+\t\treturn\n+\t}\n+\tif u.sparse == nil {\n+\t\tu.sparse = map[uint64]unmarshalFieldInfo{}\n+\t}\n+\tu.sparse[uint64(tag)] = i\n+}\n+\n+// fieldUnmarshaler returns an unmarshaler for the given field.\n+func fieldUnmarshaler(f *reflect.StructField) unmarshaler {\n+\tif f.Type.Kind() == reflect.Map {\n+\t\treturn makeUnmarshalMap(f)\n+\t}\n+\treturn typeUnmarshaler(f.Type, f.Tag.Get(\"protobuf\"))\n+}\n+\n+// typeUnmarshaler returns an unmarshaler for the given field type / field tag pair.\n+func typeUnmarshaler(t reflect.Type, tags string) unmarshaler {\n+\ttagArray := strings.Split(tags, \",\")\n+\tencoding := tagArray[0]\n+\tname := \"unknown\"\n+\tproto3 := false\n+\tvalidateUTF8 := true\n+\tfor _, tag := range tagArray[3:] {\n+\t\tif strings.HasPrefix(tag, \"name=\") {\n+\t\t\tname = tag[5:]\n+\t\t}\n+\t\tif tag == \"proto3\" {\n+\t\t\tproto3 = true\n+\t\t}\n+\t}\n+\tvalidateUTF8 = validateUTF8 && proto3\n+\n+\t// Figure out packaging (pointer, slice, or both)\n+\tslice := false\n+\tpointer := false\n+\tif t.Kind() == reflect.Slice && t.Elem().Kind() != reflect.Uint8 {\n+\t\tslice = true\n+\t\tt = t.Elem()\n+\t}\n+\tif t.Kind() == reflect.Ptr {\n+\t\tpointer = true\n+\t\tt = t.Elem()\n+\t}\n+\n+\t// We'll never have both pointer and slice for basic types.\n+\tif pointer && slice && t.Kind() != reflect.Struct {\n+\t\tpanic(\"both pointer and slice for basic type in \" + t.Name())\n+\t}\n+\n+\tswitch t.Kind() {\n+\tcase reflect.Bool:\n+\t\tif pointer {\n+\t\t\treturn unmarshalBoolPtr\n+\t\t}\n+\t\tif slice {\n+\t\t\treturn unmarshalBoolSlice\n+\t\t}\n+\t\treturn unmarshalBoolValue\n+\tcase reflect.Int32:\n+\t\tswitch encoding {\n+\t\tcase \"fixed32\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalFixedS32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalFixedS32Slice\n+\t\t\t}\n+\t\t\treturn unmarshalFixedS32Value\n+\t\tcase \"varint\":\n+\t\t\t// this could be int32 or enum\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalInt32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalInt32Slice\n+\t\t\t}\n+\t\t\treturn unmarshalInt32Value\n+\t\tcase \"zigzag32\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalSint32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalSint32Slice\n+\t\t\t}\n+\t\t\treturn unmarshalSint32Value\n+\t\t}\n+\tcase reflect.Int64:\n+\t\tswitch encoding {\n+\t\tcase \"fixed64\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalFixedS64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalFixedS64Slice\n+\t\t\t}\n+\t\t\treturn unmarshalFixedS64Value\n+\t\tcase \"varint\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalInt64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalInt64Slice\n+\t\t\t}\n+\t\t\treturn unmarshalInt64Value\n+\t\tcase \"zigzag64\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalSint64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalSint64Slice\n+\t\t\t}\n+\t\t\treturn unmarshalSint64Value\n+\t\t}\n+\tcase reflect.Uint32:\n+\t\tswitch encoding {\n+\t\tcase \"fixed32\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalFixed32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalFixed32Slice\n+\t\t\t}\n+\t\t\treturn unmarshalFixed32Value\n+\t\tcase \"varint\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalUint32Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalUint32Slice\n+\t\t\t}\n+\t\t\treturn unmarshalUint32Value\n+\t\t}\n+\tcase reflect.Uint64:\n+\t\tswitch encoding {\n+\t\tcase \"fixed64\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalFixed64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalFixed64Slice\n+\t\t\t}\n+\t\t\treturn unmarshalFixed64Value\n+\t\tcase \"varint\":\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalUint64Ptr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalUint64Slice\n+\t\t\t}\n+\t\t\treturn unmarshalUint64Value\n+\t\t}\n+\tcase reflect.Float32:\n+\t\tif pointer {\n+\t\t\treturn unmarshalFloat32Ptr\n+\t\t}\n+\t\tif slice {\n+\t\t\treturn unmarshalFloat32Slice\n+\t\t}\n+\t\treturn unmarshalFloat32Value\n+\tcase reflect.Float64:\n+\t\tif pointer {\n+\t\t\treturn unmarshalFloat64Ptr\n+\t\t}\n+\t\tif slice {\n+\t\t\treturn unmarshalFloat64Slice\n+\t\t}\n+\t\treturn unmarshalFloat64Value\n+\tcase reflect.Map:\n+\t\tpanic(\"map type in typeUnmarshaler in \" + t.Name())\n+\tcase reflect.Slice:\n+\t\tif pointer {\n+\t\t\tpanic(\"bad pointer in slice case in \" + t.Name())\n+\t\t}\n+\t\tif slice {\n+\t\t\treturn unmarshalBytesSlice\n+\t\t}\n+\t\treturn unmarshalBytesValue\n+\tcase reflect.String:\n+\t\tif validateUTF8 {\n+\t\t\tif pointer {\n+\t\t\t\treturn unmarshalUTF8StringPtr\n+\t\t\t}\n+\t\t\tif slice {\n+\t\t\t\treturn unmarshalUTF8StringSlice\n+\t\t\t}\n+\t\t\treturn unmarshalUTF8StringValue\n+\t\t}\n+\t\tif pointer {\n+\t\t\treturn unmarshalStringPtr\n+\t\t}\n+\t\tif slice {\n+\t\t\treturn unmarshalStringSlice\n+\t\t}\n+\t\treturn unmarshalStringValue\n+\tcase reflect.Struct:\n+\t\t// message or group field\n+\t\tif !pointer {\n+\t\t\tpanic(fmt.Sprintf(\"message/group field %s:%s without pointer\", t, encoding))\n+\t\t}\n+\t\tswitch encoding {\n+\t\tcase \"bytes\":\n+\t\t\tif slice {\n+\t\t\t\treturn makeUnmarshalMessageSlicePtr(getUnmarshalInfo(t), name)\n+\t\t\t}\n+\t\t\treturn makeUnmarshalMessagePtr(getUnmarshalInfo(t), name)\n+\t\tcase \"group\":\n+\t\t\tif slice {\n+\t\t\t\treturn makeUnmarshalGroupSlicePtr(getUnmarshalInfo(t), name)\n+\t\t\t}\n+\t\t\treturn makeUnmarshalGroupPtr(getUnmarshalInfo(t), name)\n+\t\t}\n+\t}\n+\tpanic(fmt.Sprintf(\"unmarshaler not found type:%s encoding:%s\", t, encoding))\n+}\n+\n+// Below are all the unmarshalers for individual fields of various types.\n+\n+func unmarshalInt64Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int64(x)\n+\t*f.toInt64() = v\n+\treturn b, nil\n+}\n+\n+func unmarshalInt64Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int64(x)\n+\t*f.toInt64Ptr() = &v\n+\treturn b, nil\n+}\n+\n+func unmarshalInt64Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tb = b[n:]\n+\t\t\tv := int64(x)\n+\t\t\ts := f.toInt64Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int64(x)\n+\ts := f.toInt64Slice()\n+\t*s = append(*s, v)\n+\treturn b, nil\n+}\n+\n+func unmarshalSint64Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int64(x>>1) ^ int64(x)<<63>>63\n+\t*f.toInt64() = v\n+\treturn b, nil\n+}\n+\n+func unmarshalSint64Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int64(x>>1) ^ int64(x)<<63>>63\n+\t*f.toInt64Ptr() = &v\n+\treturn b, nil\n+}\n+\n+func unmarshalSint64Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tb = b[n:]\n+\t\t\tv := int64(x>>1) ^ int64(x)<<63>>63\n+\t\t\ts := f.toInt64Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int64(x>>1) ^ int64(x)<<63>>63\n+\ts := f.toInt64Slice()\n+\t*s = append(*s, v)\n+\treturn b, nil\n+}\n+\n+func unmarshalUint64Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := uint64(x)\n+\t*f.toUint64() = v\n+\treturn b, nil\n+}\n+\n+func unmarshalUint64Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := uint64(x)\n+\t*f.toUint64Ptr() = &v\n+\treturn b, nil\n+}\n+\n+func unmarshalUint64Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tb = b[n:]\n+\t\t\tv := uint64(x)\n+\t\t\ts := f.toUint64Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := uint64(x)\n+\ts := f.toUint64Slice()\n+\t*s = append(*s, v)\n+\treturn b, nil\n+}\n+\n+func unmarshalInt32Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int32(x)\n+\t*f.toInt32() = v\n+\treturn b, nil\n+}\n+\n+func unmarshalInt32Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int32(x)\n+\tf.setInt32Ptr(v)\n+\treturn b, nil\n+}\n+\n+func unmarshalInt32Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tb = b[n:]\n+\t\t\tv := int32(x)\n+\t\t\tf.appendInt32Slice(v)\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int32(x)\n+\tf.appendInt32Slice(v)\n+\treturn b, nil\n+}\n+\n+func unmarshalSint32Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int32(x>>1) ^ int32(x)<<31>>31\n+\t*f.toInt32() = v\n+\treturn b, nil\n+}\n+\n+func unmarshalSint32Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int32(x>>1) ^ int32(x)<<31>>31\n+\tf.setInt32Ptr(v)\n+\treturn b, nil\n+}\n+\n+func unmarshalSint32Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tb = b[n:]\n+\t\t\tv := int32(x>>1) ^ int32(x)<<31>>31\n+\t\t\tf.appendInt32Slice(v)\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := int32(x>>1) ^ int32(x)<<31>>31\n+\tf.appendInt32Slice(v)\n+\treturn b, nil\n+}\n+\n+func unmarshalUint32Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := uint32(x)\n+\t*f.toUint32() = v\n+\treturn b, nil\n+}\n+\n+func unmarshalUint32Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := uint32(x)\n+\t*f.toUint32Ptr() = &v\n+\treturn b, nil\n+}\n+\n+func unmarshalUint32Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tb = b[n:]\n+\t\t\tv := uint32(x)\n+\t\t\ts := f.toUint32Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tv := uint32(x)\n+\ts := f.toUint32Slice()\n+\t*s = append(*s, v)\n+\treturn b, nil\n+}\n+\n+func unmarshalFixed64Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56\n+\t*f.toUint64() = v\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFixed64Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56\n+\t*f.toUint64Ptr() = &v\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFixed64Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tif len(b) < 8 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tv := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56\n+\t\t\ts := f.toUint64Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t\tb = b[8:]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56\n+\ts := f.toUint64Slice()\n+\t*s = append(*s, v)\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFixedS64Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := int64(b[0]) | int64(b[1])<<8 | int64(b[2])<<16 | int64(b[3])<<24 | int64(b[4])<<32 | int64(b[5])<<40 | int64(b[6])<<48 | int64(b[7])<<56\n+\t*f.toInt64() = v\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFixedS64Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := int64(b[0]) | int64(b[1])<<8 | int64(b[2])<<16 | int64(b[3])<<24 | int64(b[4])<<32 | int64(b[5])<<40 | int64(b[6])<<48 | int64(b[7])<<56\n+\t*f.toInt64Ptr() = &v\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFixedS64Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tif len(b) < 8 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tv := int64(b[0]) | int64(b[1])<<8 | int64(b[2])<<16 | int64(b[3])<<24 | int64(b[4])<<32 | int64(b[5])<<40 | int64(b[6])<<48 | int64(b[7])<<56\n+\t\t\ts := f.toInt64Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t\tb = b[8:]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := int64(b[0]) | int64(b[1])<<8 | int64(b[2])<<16 | int64(b[3])<<24 | int64(b[4])<<32 | int64(b[5])<<40 | int64(b[6])<<48 | int64(b[7])<<56\n+\ts := f.toInt64Slice()\n+\t*s = append(*s, v)\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFixed32Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n+\t*f.toUint32() = v\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalFixed32Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n+\t*f.toUint32Ptr() = &v\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalFixed32Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tif len(b) < 4 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tv := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n+\t\t\ts := f.toUint32Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t\tb = b[4:]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n+\ts := f.toUint32Slice()\n+\t*s = append(*s, v)\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalFixedS32Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := int32(b[0]) | int32(b[1])<<8 | int32(b[2])<<16 | int32(b[3])<<24\n+\t*f.toInt32() = v\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalFixedS32Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := int32(b[0]) | int32(b[1])<<8 | int32(b[2])<<16 | int32(b[3])<<24\n+\tf.setInt32Ptr(v)\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalFixedS32Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tif len(b) < 4 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tv := int32(b[0]) | int32(b[1])<<8 | int32(b[2])<<16 | int32(b[3])<<24\n+\t\t\tf.appendInt32Slice(v)\n+\t\t\tb = b[4:]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := int32(b[0]) | int32(b[1])<<8 | int32(b[2])<<16 | int32(b[3])<<24\n+\tf.appendInt32Slice(v)\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalBoolValue(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\t// Note: any length varint is allowed, even though any sane\n+\t// encoder will use one byte.\n+\t// See https://github.com/golang/protobuf/issues/76\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\t// TODO: check if x>1? Tests seem to indicate no.\n+\tv := x != 0\n+\t*f.toBool() = v\n+\treturn b[n:], nil\n+}\n+\n+func unmarshalBoolPtr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := x != 0\n+\t*f.toBoolPtr() = &v\n+\treturn b[n:], nil\n+}\n+\n+func unmarshalBoolSlice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n = decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tv := x != 0\n+\t\t\ts := f.toBoolSlice()\n+\t\t\t*s = append(*s, v)\n+\t\t\tb = b[n:]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireVarint {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := x != 0\n+\ts := f.toBoolSlice()\n+\t*s = append(*s, v)\n+\treturn b[n:], nil\n+}\n+\n+func unmarshalFloat64Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := math.Float64frombits(uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56)\n+\t*f.toFloat64() = v\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFloat64Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := math.Float64frombits(uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56)\n+\t*f.toFloat64Ptr() = &v\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFloat64Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tif len(b) < 8 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tv := math.Float64frombits(uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56)\n+\t\t\ts := f.toFloat64Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t\tb = b[8:]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireFixed64 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 8 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := math.Float64frombits(uint64(b[0]) | uint64(b[1])<<8 | uint64(b[2])<<16 | uint64(b[3])<<24 | uint64(b[4])<<32 | uint64(b[5])<<40 | uint64(b[6])<<48 | uint64(b[7])<<56)\n+\ts := f.toFloat64Slice()\n+\t*s = append(*s, v)\n+\treturn b[8:], nil\n+}\n+\n+func unmarshalFloat32Value(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := math.Float32frombits(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)\n+\t*f.toFloat32() = v\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalFloat32Ptr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := math.Float32frombits(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)\n+\t*f.toFloat32Ptr() = &v\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalFloat32Slice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w == WireBytes { // packed\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tres := b[x:]\n+\t\tb = b[:x]\n+\t\tfor len(b) > 0 {\n+\t\t\tif len(b) < 4 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tv := math.Float32frombits(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)\n+\t\t\ts := f.toFloat32Slice()\n+\t\t\t*s = append(*s, v)\n+\t\t\tb = b[4:]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\tif w != WireFixed32 {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tif len(b) < 4 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := math.Float32frombits(uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24)\n+\ts := f.toFloat32Slice()\n+\t*s = append(*s, v)\n+\treturn b[4:], nil\n+}\n+\n+func unmarshalStringValue(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := string(b[:x])\n+\t*f.toString() = v\n+\treturn b[x:], nil\n+}\n+\n+func unmarshalStringPtr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := string(b[:x])\n+\t*f.toStringPtr() = &v\n+\treturn b[x:], nil\n+}\n+\n+func unmarshalStringSlice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := string(b[:x])\n+\ts := f.toStringSlice()\n+\t*s = append(*s, v)\n+\treturn b[x:], nil\n+}\n+\n+func unmarshalUTF8StringValue(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := string(b[:x])\n+\t*f.toString() = v\n+\tif !utf8.ValidString(v) {\n+\t\treturn b[x:], errInvalidUTF8\n+\t}\n+\treturn b[x:], nil\n+}\n+\n+func unmarshalUTF8StringPtr(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := string(b[:x])\n+\t*f.toStringPtr() = &v\n+\tif !utf8.ValidString(v) {\n+\t\treturn b[x:], errInvalidUTF8\n+\t}\n+\treturn b[x:], nil\n+}\n+\n+func unmarshalUTF8StringSlice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := string(b[:x])\n+\ts := f.toStringSlice()\n+\t*s = append(*s, v)\n+\tif !utf8.ValidString(v) {\n+\t\treturn b[x:], errInvalidUTF8\n+\t}\n+\treturn b[x:], nil\n+}\n+\n+var emptyBuf [0]byte\n+\n+func unmarshalBytesValue(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\t// The use of append here is a trick which avoids the zeroing\n+\t// that would be required if we used a make/copy pair.\n+\t// We append to emptyBuf instead of nil because we want\n+\t// a non-nil result even when the length is 0.\n+\tv := append(emptyBuf[:], b[:x]...)\n+\t*f.toBytes() = v\n+\treturn b[x:], nil\n+}\n+\n+func unmarshalBytesSlice(b []byte, f pointer, w int) ([]byte, error) {\n+\tif w != WireBytes {\n+\t\treturn b, errInternalBadWireType\n+\t}\n+\tx, n := decodeVarint(b)\n+\tif n == 0 {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tb = b[n:]\n+\tif x > uint64(len(b)) {\n+\t\treturn nil, io.ErrUnexpectedEOF\n+\t}\n+\tv := append(emptyBuf[:], b[:x]...)\n+\ts := f.toBytesSlice()\n+\t*s = append(*s, v)\n+\treturn b[x:], nil\n+}\n+\n+func makeUnmarshalMessagePtr(sub *unmarshalInfo, name string) unmarshaler {\n+\treturn func(b []byte, f pointer, w int) ([]byte, error) {\n+\t\tif w != WireBytes {\n+\t\t\treturn b, errInternalBadWireType\n+\t\t}\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\t// First read the message field to see if something is there.\n+\t\t// The semantics of multiple submessages are weird.  Instead of\n+\t\t// the last one winning (as it is for all other fields), multiple\n+\t\t// submessages are merged.\n+\t\tv := f.getPointer()\n+\t\tif v.isNil() {\n+\t\t\tv = valToPointer(reflect.New(sub.typ))\n+\t\t\tf.setPointer(v)\n+\t\t}\n+\t\terr := sub.unmarshal(v, b[:x])\n+\t\tif err != nil {\n+\t\t\tif r, ok := err.(*RequiredNotSetError); ok {\n+\t\t\t\tr.field = name + \".\" + r.field\n+\t\t\t} else {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t\treturn b[x:], err\n+\t}\n+}\n+\n+func makeUnmarshalMessageSlicePtr(sub *unmarshalInfo, name string) unmarshaler {\n+\treturn func(b []byte, f pointer, w int) ([]byte, error) {\n+\t\tif w != WireBytes {\n+\t\t\treturn b, errInternalBadWireType\n+\t\t}\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tv := valToPointer(reflect.New(sub.typ))\n+\t\terr := sub.unmarshal(v, b[:x])\n+\t\tif err != nil {\n+\t\t\tif r, ok := err.(*RequiredNotSetError); ok {\n+\t\t\t\tr.field = name + \".\" + r.field\n+\t\t\t} else {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t\tf.appendPointer(v)\n+\t\treturn b[x:], err\n+\t}\n+}\n+\n+func makeUnmarshalGroupPtr(sub *unmarshalInfo, name string) unmarshaler {\n+\treturn func(b []byte, f pointer, w int) ([]byte, error) {\n+\t\tif w != WireStartGroup {\n+\t\t\treturn b, errInternalBadWireType\n+\t\t}\n+\t\tx, y := findEndGroup(b)\n+\t\tif x < 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tv := f.getPointer()\n+\t\tif v.isNil() {\n+\t\t\tv = valToPointer(reflect.New(sub.typ))\n+\t\t\tf.setPointer(v)\n+\t\t}\n+\t\terr := sub.unmarshal(v, b[:x])\n+\t\tif err != nil {\n+\t\t\tif r, ok := err.(*RequiredNotSetError); ok {\n+\t\t\t\tr.field = name + \".\" + r.field\n+\t\t\t} else {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t\treturn b[y:], err\n+\t}\n+}\n+\n+func makeUnmarshalGroupSlicePtr(sub *unmarshalInfo, name string) unmarshaler {\n+\treturn func(b []byte, f pointer, w int) ([]byte, error) {\n+\t\tif w != WireStartGroup {\n+\t\t\treturn b, errInternalBadWireType\n+\t\t}\n+\t\tx, y := findEndGroup(b)\n+\t\tif x < 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tv := valToPointer(reflect.New(sub.typ))\n+\t\terr := sub.unmarshal(v, b[:x])\n+\t\tif err != nil {\n+\t\t\tif r, ok := err.(*RequiredNotSetError); ok {\n+\t\t\t\tr.field = name + \".\" + r.field\n+\t\t\t} else {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t\tf.appendPointer(v)\n+\t\treturn b[y:], err\n+\t}\n+}\n+\n+func makeUnmarshalMap(f *reflect.StructField) unmarshaler {\n+\tt := f.Type\n+\tkt := t.Key()\n+\tvt := t.Elem()\n+\tunmarshalKey := typeUnmarshaler(kt, f.Tag.Get(\"protobuf_key\"))\n+\tunmarshalVal := typeUnmarshaler(vt, f.Tag.Get(\"protobuf_val\"))\n+\treturn func(b []byte, f pointer, w int) ([]byte, error) {\n+\t\t// The map entry is a submessage. Figure out how big it is.\n+\t\tif w != WireBytes {\n+\t\t\treturn nil, fmt.Errorf(\"proto: bad wiretype for map field: got %d want %d\", w, WireBytes)\n+\t\t}\n+\t\tx, n := decodeVarint(b)\n+\t\tif n == 0 {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[n:]\n+\t\tif x > uint64(len(b)) {\n+\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tr := b[x:] // unused data to return\n+\t\tb = b[:x]  // data for map entry\n+\n+\t\t// Note: we could use #keys * #values ~= 200 functions\n+\t\t// to do map decoding without reflection. Probably not worth it.\n+\t\t// Maps will be somewhat slow. Oh well.\n+\n+\t\t// Read key and value from data.\n+\t\tvar nerr nonFatal\n+\t\tk := reflect.New(kt)\n+\t\tv := reflect.New(vt)\n+\t\tfor len(b) > 0 {\n+\t\t\tx, n := decodeVarint(b)\n+\t\t\tif n == 0 {\n+\t\t\t\treturn nil, io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\twire := int(x) & 7\n+\t\t\tb = b[n:]\n+\n+\t\t\tvar err error\n+\t\t\tswitch x >> 3 {\n+\t\t\tcase 1:\n+\t\t\t\tb, err = unmarshalKey(b, valToPointer(k), wire)\n+\t\t\tcase 2:\n+\t\t\t\tb, err = unmarshalVal(b, valToPointer(v), wire)\n+\t\t\tdefault:\n+\t\t\t\terr = errInternalBadWireType // skip unknown tag\n+\t\t\t}\n+\n+\t\t\tif nerr.Merge(err) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err != errInternalBadWireType {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\t// Skip past unknown fields.\n+\t\t\tb, err = skipField(b, wire)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Get map, allocate if needed.\n+\t\tm := f.asPointerTo(t).Elem() // an addressable map[K]T\n+\t\tif m.IsNil() {\n+\t\t\tm.Set(reflect.MakeMap(t))\n+\t\t}\n+\n+\t\t// Insert into map.\n+\t\tm.SetMapIndex(k.Elem(), v.Elem())\n+\n+\t\treturn r, nerr.E\n+\t}\n+}\n+\n+// makeUnmarshalOneof makes an unmarshaler for oneof fields.\n+// for:\n+// message Msg {\n+//   oneof F {\n+//     int64 X = 1;\n+//     float64 Y = 2;\n+//   }\n+// }\n+// typ is the type of the concrete entry for a oneof case (e.g. Msg_X).\n+// ityp is the interface type of the oneof field (e.g. isMsg_F).\n+// unmarshal is the unmarshaler for the base type of the oneof case (e.g. int64).\n+// Note that this function will be called once for each case in the oneof.\n+func makeUnmarshalOneof(typ, ityp reflect.Type, unmarshal unmarshaler) unmarshaler {\n+\tsf := typ.Field(0)\n+\tfield0 := toField(&sf)\n+\treturn func(b []byte, f pointer, w int) ([]byte, error) {\n+\t\t// Allocate holder for value.\n+\t\tv := reflect.New(typ)\n+\n+\t\t// Unmarshal data into holder.\n+\t\t// We unmarshal into the first field of the holder object.\n+\t\tvar err error\n+\t\tvar nerr nonFatal\n+\t\tb, err = unmarshal(b, valToPointer(v).offset(field0), w)\n+\t\tif !nerr.Merge(err) {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Write pointer to holder into target field.\n+\t\tf.asPointerTo(ityp).Elem().Set(v)\n+\n+\t\treturn b, nerr.E\n+\t}\n+}\n+\n+// Error used by decode internally.\n+var errInternalBadWireType = errors.New(\"proto: internal error: bad wiretype\")\n+\n+// skipField skips past a field of type wire and returns the remaining bytes.\n+func skipField(b []byte, wire int) ([]byte, error) {\n+\tswitch wire {\n+\tcase WireVarint:\n+\t\t_, k := decodeVarint(b)\n+\t\tif k == 0 {\n+\t\t\treturn b, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[k:]\n+\tcase WireFixed32:\n+\t\tif len(b) < 4 {\n+\t\t\treturn b, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[4:]\n+\tcase WireFixed64:\n+\t\tif len(b) < 8 {\n+\t\t\treturn b, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[8:]\n+\tcase WireBytes:\n+\t\tm, k := decodeVarint(b)\n+\t\tif k == 0 || uint64(len(b)-k) < m {\n+\t\t\treturn b, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[uint64(k)+m:]\n+\tcase WireStartGroup:\n+\t\t_, i := findEndGroup(b)\n+\t\tif i == -1 {\n+\t\t\treturn b, io.ErrUnexpectedEOF\n+\t\t}\n+\t\tb = b[i:]\n+\tdefault:\n+\t\treturn b, fmt.Errorf(\"proto: can't skip unknown wire type %d\", wire)\n+\t}\n+\treturn b, nil\n+}\n+\n+// findEndGroup finds the index of the next EndGroup tag.\n+// Groups may be nested, so the \"next\" EndGroup tag is the first\n+// unpaired EndGroup.\n+// findEndGroup returns the indexes of the start and end of the EndGroup tag.\n+// Returns (-1,-1) if it can't find one.\n+func findEndGroup(b []byte) (int, int) {\n+\tdepth := 1\n+\ti := 0\n+\tfor {\n+\t\tx, n := decodeVarint(b[i:])\n+\t\tif n == 0 {\n+\t\t\treturn -1, -1\n+\t\t}\n+\t\tj := i\n+\t\ti += n\n+\t\tswitch x & 7 {\n+\t\tcase WireVarint:\n+\t\t\t_, k := decodeVarint(b[i:])\n+\t\t\tif k == 0 {\n+\t\t\t\treturn -1, -1\n+\t\t\t}\n+\t\t\ti += k\n+\t\tcase WireFixed32:\n+\t\t\tif len(b)-4 < i {\n+\t\t\t\treturn -1, -1\n+\t\t\t}\n+\t\t\ti += 4\n+\t\tcase WireFixed64:\n+\t\t\tif len(b)-8 < i {\n+\t\t\t\treturn -1, -1\n+\t\t\t}\n+\t\t\ti += 8\n+\t\tcase WireBytes:\n+\t\t\tm, k := decodeVarint(b[i:])\n+\t\t\tif k == 0 {\n+\t\t\t\treturn -1, -1\n+\t\t\t}\n+\t\t\ti += k\n+\t\t\tif uint64(len(b)-i) < m {\n+\t\t\t\treturn -1, -1\n+\t\t\t}\n+\t\t\ti += int(m)\n+\t\tcase WireStartGroup:\n+\t\t\tdepth++\n+\t\tcase WireEndGroup:\n+\t\t\tdepth--\n+\t\t\tif depth == 0 {\n+\t\t\t\treturn j, i\n+\t\t\t}\n+\t\tdefault:\n+\t\t\treturn -1, -1\n+\t\t}\n+\t}\n+}\n+\n+// encodeVarint appends a varint-encoded integer to b and returns the result.\n+func encodeVarint(b []byte, x uint64) []byte {\n+\tfor x >= 1<<7 {\n+\t\tb = append(b, byte(x&0x7f|0x80))\n+\t\tx >>= 7\n+\t}\n+\treturn append(b, byte(x))\n+}\n+\n+// decodeVarint reads a varint-encoded integer from b.\n+// Returns the decoded integer and the number of bytes read.\n+// If there is an error, it returns 0,0.\n+func decodeVarint(b []byte) (uint64, int) {\n+\tvar x, y uint64\n+\tif len(b) <= 0 {\n+\t\tgoto bad\n+\t}\n+\tx = uint64(b[0])\n+\tif x < 0x80 {\n+\t\treturn x, 1\n+\t}\n+\tx -= 0x80\n+\n+\tif len(b) <= 1 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[1])\n+\tx += y << 7\n+\tif y < 0x80 {\n+\t\treturn x, 2\n+\t}\n+\tx -= 0x80 << 7\n+\n+\tif len(b) <= 2 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[2])\n+\tx += y << 14\n+\tif y < 0x80 {\n+\t\treturn x, 3\n+\t}\n+\tx -= 0x80 << 14\n+\n+\tif len(b) <= 3 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[3])\n+\tx += y << 21\n+\tif y < 0x80 {\n+\t\treturn x, 4\n+\t}\n+\tx -= 0x80 << 21\n+\n+\tif len(b) <= 4 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[4])\n+\tx += y << 28\n+\tif y < 0x80 {\n+\t\treturn x, 5\n+\t}\n+\tx -= 0x80 << 28\n+\n+\tif len(b) <= 5 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[5])\n+\tx += y << 35\n+\tif y < 0x80 {\n+\t\treturn x, 6\n+\t}\n+\tx -= 0x80 << 35\n+\n+\tif len(b) <= 6 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[6])\n+\tx += y << 42\n+\tif y < 0x80 {\n+\t\treturn x, 7\n+\t}\n+\tx -= 0x80 << 42\n+\n+\tif len(b) <= 7 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[7])\n+\tx += y << 49\n+\tif y < 0x80 {\n+\t\treturn x, 8\n+\t}\n+\tx -= 0x80 << 49\n+\n+\tif len(b) <= 8 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[8])\n+\tx += y << 56\n+\tif y < 0x80 {\n+\t\treturn x, 9\n+\t}\n+\tx -= 0x80 << 56\n+\n+\tif len(b) <= 9 {\n+\t\tgoto bad\n+\t}\n+\ty = uint64(b[9])\n+\tx += y << 63\n+\tif y < 2 {\n+\t\treturn x, 10\n+\t}\n+\n+bad:\n+\treturn 0, 0\n+}"
    },
    {
      "sha": "1aaee725b45b3e141a710273ec098ec601a71ecd",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/text.go",
      "status": "modified",
      "additions": 27,
      "deletions": 38,
      "changes": 65,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/text.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/text.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/text.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -50,7 +50,6 @@ import (\n var (\n \tnewline         = []byte(\"\\n\")\n \tspaces          = []byte(\"                                        \")\n-\tgtNewline       = []byte(\">\\n\")\n \tendBraceNewline = []byte(\"}\\n\")\n \tbackslashN      = []byte{'\\\\', 'n'}\n \tbackslashR      = []byte{'\\\\', 'r'}\n@@ -170,11 +169,6 @@ func writeName(w *textWriter, props *Properties) error {\n \treturn nil\n }\n \n-// raw is the interface satisfied by RawMessage.\n-type raw interface {\n-\tBytes() []byte\n-}\n-\n func requiresQuotes(u string) bool {\n \t// When type URL contains any characters except [0-9A-Za-z./\\-]*, it must be quoted.\n \tfor _, ch := range u {\n@@ -269,6 +263,10 @@ func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {\n \t\tprops := sprops.Prop[i]\n \t\tname := st.Field(i).Name\n \n+\t\tif name == \"XXX_NoUnkeyedLiteral\" {\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif strings.HasPrefix(name, \"XXX_\") {\n \t\t\t// There are two XXX_ fields:\n \t\t\t//   XXX_unrecognized []byte\n@@ -355,7 +353,7 @@ func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tif err := tm.writeAny(w, key, props.mkeyprop); err != nil {\n+\t\t\t\tif err := tm.writeAny(w, key, props.MapKeyProp); err != nil {\n \t\t\t\t\treturn err\n \t\t\t\t}\n \t\t\t\tif err := w.WriteByte('\\n'); err != nil {\n@@ -372,7 +370,7 @@ func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {\n \t\t\t\t\t\t\treturn err\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif err := tm.writeAny(w, val, props.mvalprop); err != nil {\n+\t\t\t\t\tif err := tm.writeAny(w, val, props.MapValProp); err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n \t\t\t\t\tif err := w.WriteByte('\\n'); err != nil {\n@@ -436,12 +434,6 @@ func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n-\t\tif b, ok := fv.Interface().(raw); ok {\n-\t\t\tif err := writeRaw(w, b.Bytes()); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n \n \t\t// Enums have a String method, so writeAny will work fine.\n \t\tif err := tm.writeAny(w, fv, props); err != nil {\n@@ -455,7 +447,7 @@ func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {\n \n \t// Extensions (the XXX_extensions field).\n \tpv := sv.Addr()\n-\tif _, ok := extendable(pv.Interface()); ok {\n+\tif _, err := extendable(pv.Interface()); err == nil {\n \t\tif err := tm.writeExtensions(w, pv); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -464,27 +456,6 @@ func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {\n \treturn nil\n }\n \n-// writeRaw writes an uninterpreted raw message.\n-func writeRaw(w *textWriter, b []byte) error {\n-\tif err := w.WriteByte('<'); err != nil {\n-\t\treturn err\n-\t}\n-\tif !w.compact {\n-\t\tif err := w.WriteByte('\\n'); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\tw.indent()\n-\tif err := writeUnknownStruct(w, b); err != nil {\n-\t\treturn err\n-\t}\n-\tw.unindent()\n-\tif err := w.WriteByte('>'); err != nil {\n-\t\treturn err\n-\t}\n-\treturn nil\n-}\n-\n // writeAny writes an arbitrary field.\n func (tm *TextMarshaler) writeAny(w *textWriter, v reflect.Value, props *Properties) error {\n \tv = reflect.Indirect(v)\n@@ -535,6 +506,19 @@ func (tm *TextMarshaler) writeAny(w *textWriter, v reflect.Value, props *Propert\n \t\t\t}\n \t\t}\n \t\tw.indent()\n+\t\tif v.CanAddr() {\n+\t\t\t// Calling v.Interface on a struct causes the reflect package to\n+\t\t\t// copy the entire struct. This is racy with the new Marshaler\n+\t\t\t// since we atomically update the XXX_sizecache.\n+\t\t\t//\n+\t\t\t// Thus, we retrieve a pointer to the struct if possible to avoid\n+\t\t\t// a race since v.Interface on the pointer doesn't copy the struct.\n+\t\t\t//\n+\t\t\t// If v is not addressable, then we are not worried about a race\n+\t\t\t// since it implies that the binary Marshaler cannot possibly be\n+\t\t\t// mutating this value.\n+\t\t\tv = v.Addr()\n+\t\t}\n \t\tif etm, ok := v.Interface().(encoding.TextMarshaler); ok {\n \t\t\ttext, err := etm.MarshalText()\n \t\t\tif err != nil {\n@@ -543,8 +527,13 @@ func (tm *TextMarshaler) writeAny(w *textWriter, v reflect.Value, props *Propert\n \t\t\tif _, err = w.Write(text); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n-\t\t} else if err := tm.writeStruct(w, v); err != nil {\n-\t\t\treturn err\n+\t\t} else {\n+\t\t\tif v.Kind() == reflect.Ptr {\n+\t\t\t\tv = v.Elem()\n+\t\t\t}\n+\t\t\tif err := tm.writeStruct(w, v); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n \t\tw.unindent()\n \t\tif err := w.WriteByte(ket); err != nil {"
    },
    {
      "sha": "bb55a3af276941639621b1e591ce1b8304afcd41",
      "filename": "backend/vendor/github.com/golang/protobuf/proto/text_parser.go",
      "status": "modified",
      "additions": 34,
      "deletions": 49,
      "changes": 83,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/text_parser.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/golang/protobuf/proto/text_parser.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/golang/protobuf/proto/text_parser.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -206,7 +206,6 @@ func (p *textParser) advance() {\n \n var (\n \terrBadUTF8 = errors.New(\"proto: bad UTF-8\")\n-\terrBadHex  = errors.New(\"proto: bad hexadecimal\")\n )\n \n func unquoteC(s string, quote rune) (string, error) {\n@@ -277,60 +276,47 @@ func unescape(s string) (ch string, tail string, err error) {\n \t\treturn \"?\", s, nil // trigraph workaround\n \tcase '\\'', '\"', '\\\\':\n \t\treturn string(r), s, nil\n-\tcase '0', '1', '2', '3', '4', '5', '6', '7', 'x', 'X':\n+\tcase '0', '1', '2', '3', '4', '5', '6', '7':\n \t\tif len(s) < 2 {\n \t\t\treturn \"\", \"\", fmt.Errorf(`\\%c requires 2 following digits`, r)\n \t\t}\n-\t\tbase := 8\n-\t\tss := s[:2]\n+\t\tss := string(r) + s[:2]\n \t\ts = s[2:]\n-\t\tif r == 'x' || r == 'X' {\n-\t\t\tbase = 16\n-\t\t} else {\n-\t\t\tss = string(r) + ss\n-\t\t}\n-\t\ti, err := strconv.ParseUint(ss, base, 8)\n+\t\ti, err := strconv.ParseUint(ss, 8, 8)\n \t\tif err != nil {\n-\t\t\treturn \"\", \"\", err\n+\t\t\treturn \"\", \"\", fmt.Errorf(`\\%s contains non-octal digits`, ss)\n \t\t}\n \t\treturn string([]byte{byte(i)}), s, nil\n-\tcase 'u', 'U':\n-\t\tn := 4\n-\t\tif r == 'U' {\n+\tcase 'x', 'X', 'u', 'U':\n+\t\tvar n int\n+\t\tswitch r {\n+\t\tcase 'x', 'X':\n+\t\t\tn = 2\n+\t\tcase 'u':\n+\t\t\tn = 4\n+\t\tcase 'U':\n \t\t\tn = 8\n \t\t}\n \t\tif len(s) < n {\n-\t\t\treturn \"\", \"\", fmt.Errorf(`\\%c requires %d digits`, r, n)\n-\t\t}\n-\n-\t\tbs := make([]byte, n/2)\n-\t\tfor i := 0; i < n; i += 2 {\n-\t\t\ta, ok1 := unhex(s[i])\n-\t\t\tb, ok2 := unhex(s[i+1])\n-\t\t\tif !ok1 || !ok2 {\n-\t\t\t\treturn \"\", \"\", errBadHex\n-\t\t\t}\n-\t\t\tbs[i/2] = a<<4 | b\n+\t\t\treturn \"\", \"\", fmt.Errorf(`\\%c requires %d following digits`, r, n)\n \t\t}\n+\t\tss := s[:n]\n \t\ts = s[n:]\n-\t\treturn string(bs), s, nil\n+\t\ti, err := strconv.ParseUint(ss, 16, 64)\n+\t\tif err != nil {\n+\t\t\treturn \"\", \"\", fmt.Errorf(`\\%c%s contains non-hexadecimal digits`, r, ss)\n+\t\t}\n+\t\tif r == 'x' || r == 'X' {\n+\t\t\treturn string([]byte{byte(i)}), s, nil\n+\t\t}\n+\t\tif i > utf8.MaxRune {\n+\t\t\treturn \"\", \"\", fmt.Errorf(`\\%c%s is not a valid Unicode code point`, r, ss)\n+\t\t}\n+\t\treturn string(i), s, nil\n \t}\n \treturn \"\", \"\", fmt.Errorf(`unknown escape \\%c`, r)\n }\n \n-// Adapted from src/pkg/strconv/quote.go.\n-func unhex(b byte) (v byte, ok bool) {\n-\tswitch {\n-\tcase '0' <= b && b <= '9':\n-\t\treturn b - '0', true\n-\tcase 'a' <= b && b <= 'f':\n-\t\treturn b - 'a' + 10, true\n-\tcase 'A' <= b && b <= 'F':\n-\t\treturn b - 'A' + 10, true\n-\t}\n-\treturn 0, false\n-}\n-\n // Back off the parser by one token. Can only be done between calls to next().\n // It makes the next advance() a no-op.\n func (p *textParser) back() { p.backed = true }\n@@ -644,17 +630,17 @@ func (p *textParser) readStruct(sv reflect.Value, terminator string) error {\n \t\t\t\t\tif err := p.consumeToken(\":\"); err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n-\t\t\t\t\tif err := p.readAny(key, props.mkeyprop); err != nil {\n+\t\t\t\t\tif err := p.readAny(key, props.MapKeyProp); err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n \t\t\t\t\tif err := p.consumeOptionalSeparator(); err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n \t\t\t\tcase \"value\":\n-\t\t\t\t\tif err := p.checkForColon(props.mvalprop, dst.Type().Elem()); err != nil {\n+\t\t\t\t\tif err := p.checkForColon(props.MapValProp, dst.Type().Elem()); err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n-\t\t\t\t\tif err := p.readAny(val, props.mvalprop); err != nil {\n+\t\t\t\t\tif err := p.readAny(val, props.MapValProp); err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n \t\t\t\t\tif err := p.consumeOptionalSeparator(); err != nil {\n@@ -728,6 +714,9 @@ func (p *textParser) consumeExtName() (string, error) {\n \t\tif tok.err != nil {\n \t\t\treturn \"\", p.errorf(\"unrecognized type_url or extension name: %s\", tok.err)\n \t\t}\n+\t\tif p.done && tok.value != \"]\" {\n+\t\t\treturn \"\", p.errorf(\"unclosed type_url or extension name\")\n+\t\t}\n \t}\n \treturn strings.Join(parts, \"\"), nil\n }\n@@ -865,7 +854,7 @@ func (p *textParser) readAny(v reflect.Value, props *Properties) error {\n \t\treturn p.readStruct(fv, terminator)\n \tcase reflect.Uint32:\n \t\tif x, err := strconv.ParseUint(tok.value, 0, 32); err == nil {\n-\t\t\tfv.SetUint(x)\n+\t\t\tfv.SetUint(uint64(x))\n \t\t\treturn nil\n \t\t}\n \tcase reflect.Uint64:\n@@ -883,13 +872,9 @@ func (p *textParser) readAny(v reflect.Value, props *Properties) error {\n // UnmarshalText returns *RequiredNotSetError.\n func UnmarshalText(s string, pb Message) error {\n \tif um, ok := pb.(encoding.TextUnmarshaler); ok {\n-\t\terr := um.UnmarshalText([]byte(s))\n-\t\treturn err\n+\t\treturn um.UnmarshalText([]byte(s))\n \t}\n \tpb.Reset()\n \tv := reflect.ValueOf(pb)\n-\tif pe := newTextParser(s).readStruct(v.Elem(), \"\"); pe != nil {\n-\t\treturn pe\n-\t}\n-\treturn nil\n+\treturn newTextParser(s).readStruct(v.Elem(), \"\")\n }"
    },
    {
      "sha": "824cb97e8346d182f037e0a2ea57cb5f982624ea",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/go.mod",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/hashicorp/golang-lru/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/hashicorp/golang-lru/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/hashicorp/golang-lru/go.mod?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -0,0 +1 @@\n+module github.com/hashicorp/golang-lru"
    },
    {
      "sha": "1cbe04b7d0fc0a49ce0a82006b288a6b29733f62",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/lru.go",
      "status": "modified",
      "additions": 18,
      "deletions": 12,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/hashicorp/golang-lru/lru.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/hashicorp/golang-lru/lru.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/hashicorp/golang-lru/lru.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -40,31 +40,35 @@ func (c *Cache) Purge() {\n // Add adds a value to the cache.  Returns true if an eviction occurred.\n func (c *Cache) Add(key, value interface{}) (evicted bool) {\n \tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\treturn c.lru.Add(key, value)\n+\tevicted = c.lru.Add(key, value)\n+\tc.lock.Unlock()\n+\treturn evicted\n }\n \n // Get looks up a key's value from the cache.\n func (c *Cache) Get(key interface{}) (value interface{}, ok bool) {\n \tc.lock.Lock()\n-\tdefer c.lock.Unlock()\n-\treturn c.lru.Get(key)\n+\tvalue, ok = c.lru.Get(key)\n+\tc.lock.Unlock()\n+\treturn value, ok\n }\n \n // Contains checks if a key is in the cache, without updating the\n // recent-ness or deleting it for being stale.\n func (c *Cache) Contains(key interface{}) bool {\n \tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\treturn c.lru.Contains(key)\n+\tcontainKey := c.lru.Contains(key)\n+\tc.lock.RUnlock()\n+\treturn containKey\n }\n \n // Peek returns the key value (or undefined if not found) without updating\n // the \"recently used\"-ness of the key.\n func (c *Cache) Peek(key interface{}) (value interface{}, ok bool) {\n \tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\treturn c.lru.Peek(key)\n+\tvalue, ok = c.lru.Peek(key)\n+\tc.lock.RUnlock()\n+\treturn value, ok\n }\n \n // ContainsOrAdd checks if a key is in the cache  without updating the\n@@ -98,13 +102,15 @@ func (c *Cache) RemoveOldest() {\n // Keys returns a slice of the keys in the cache, from oldest to newest.\n func (c *Cache) Keys() []interface{} {\n \tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\treturn c.lru.Keys()\n+\tkeys := c.lru.Keys()\n+\tc.lock.RUnlock()\n+\treturn keys\n }\n \n // Len returns the number of items in the cache.\n func (c *Cache) Len() int {\n \tc.lock.RLock()\n-\tdefer c.lock.RUnlock()\n-\treturn c.lru.Len()\n+\tlength := c.lru.Len()\n+\tc.lock.RUnlock()\n+\treturn length\n }"
    },
    {
      "sha": "74c7077440c917d518bd8139d312e00a709bfa25",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/simplelru/lru_interface.go",
      "status": "modified",
      "additions": 22,
      "deletions": 23,
      "changes": 45,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/hashicorp/golang-lru/simplelru/lru_interface.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/hashicorp/golang-lru/simplelru/lru_interface.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/hashicorp/golang-lru/simplelru/lru_interface.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,37 +1,36 @@\n package simplelru\n \n-\n // LRUCache is the interface for simple LRU cache.\n type LRUCache interface {\n-  // Adds a value to the cache, returns true if an eviction occurred and\n-  // updates the \"recently used\"-ness of the key.\n-  Add(key, value interface{}) bool\n+\t// Adds a value to the cache, returns true if an eviction occurred and\n+\t// updates the \"recently used\"-ness of the key.\n+\tAdd(key, value interface{}) bool\n \n-  // Returns key's value from the cache and\n-  // updates the \"recently used\"-ness of the key. #value, isFound\n-  Get(key interface{}) (value interface{}, ok bool)\n+\t// Returns key's value from the cache and\n+\t// updates the \"recently used\"-ness of the key. #value, isFound\n+\tGet(key interface{}) (value interface{}, ok bool)\n \n-  // Check if a key exsists in cache without updating the recent-ness.\n-  Contains(key interface{}) (ok bool)\n+\t// Check if a key exsists in cache without updating the recent-ness.\n+\tContains(key interface{}) (ok bool)\n \n-  // Returns key's value without updating the \"recently used\"-ness of the key.\n-  Peek(key interface{}) (value interface{}, ok bool)\n+\t// Returns key's value without updating the \"recently used\"-ness of the key.\n+\tPeek(key interface{}) (value interface{}, ok bool)\n \n-  // Removes a key from the cache.\n-  Remove(key interface{}) bool\n+\t// Removes a key from the cache.\n+\tRemove(key interface{}) bool\n \n-  // Removes the oldest entry from cache.\n-  RemoveOldest() (interface{}, interface{}, bool)\n+\t// Removes the oldest entry from cache.\n+\tRemoveOldest() (interface{}, interface{}, bool)\n \n-  // Returns the oldest entry from the cache. #key, value, isFound\n-  GetOldest() (interface{}, interface{}, bool)\n+\t// Returns the oldest entry from the cache. #key, value, isFound\n+\tGetOldest() (interface{}, interface{}, bool)\n \n-  // Returns a slice of the keys in the cache, from oldest to newest.\n-  Keys() []interface{}\n+\t// Returns a slice of the keys in the cache, from oldest to newest.\n+\tKeys() []interface{}\n \n-  // Returns the number of items in the cache.\n-  Len() int\n+\t// Returns the number of items in the cache.\n+\tLen() int\n \n-  // Clear all cache entries\n-  Purge()\n+\t// Clear all cache entries\n+\tPurge()\n }"
    },
    {
      "sha": null,
      "filename": "backend/vendor/github.com/jessevdk/go-flags/check_crosscompile.sh",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/jessevdk/go-flags/check_crosscompile.sh",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/jessevdk/go-flags/check_crosscompile.sh",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/jessevdk/go-flags/check_crosscompile.sh?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d4b92663bacfbb101cda87c41711b9d54d3a87cb",
      "filename": "backend/vendor/github.com/pkg/errors/.travis.yml",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/.travis.yml",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/pkg/errors/.travis.yml?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,10 +1,14 @@\n language: go\n go_import_path: github.com/pkg/errors\n go:\n-  - 1.4.3\n-  - 1.5.4\n-  - 1.6.2\n-  - 1.7.1\n+  - 1.4.x\n+  - 1.5.x\n+  - 1.6.x\n+  - 1.7.x\n+  - 1.8.x\n+  - 1.9.x\n+  - 1.10.x\n+  - 1.11.x\n   - tip\n \n script:"
    },
    {
      "sha": "6483ba2afb51278516423dc013fcfa275ee597a9",
      "filename": "backend/vendor/github.com/pkg/errors/README.md",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/pkg/errors/README.md?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,4 +1,4 @@\n-# errors [![Travis-CI](https://travis-ci.org/pkg/errors.svg)](https://travis-ci.org/pkg/errors) [![AppVeyor](https://ci.appveyor.com/api/projects/status/b98mptawhudj53ep/branch/master?svg=true)](https://ci.appveyor.com/project/davecheney/errors/branch/master) [![GoDoc](https://godoc.org/github.com/pkg/errors?status.svg)](http://godoc.org/github.com/pkg/errors) [![Report card](https://goreportcard.com/badge/github.com/pkg/errors)](https://goreportcard.com/report/github.com/pkg/errors)\n+# errors [![Travis-CI](https://travis-ci.org/pkg/errors.svg)](https://travis-ci.org/pkg/errors) [![AppVeyor](https://ci.appveyor.com/api/projects/status/b98mptawhudj53ep/branch/master?svg=true)](https://ci.appveyor.com/project/davecheney/errors/branch/master) [![GoDoc](https://godoc.org/github.com/pkg/errors?status.svg)](http://godoc.org/github.com/pkg/errors) [![Report card](https://goreportcard.com/badge/github.com/pkg/errors)](https://goreportcard.com/report/github.com/pkg/errors) [![Sourcegraph](https://sourcegraph.com/github.com/pkg/errors/-/badge.svg)](https://sourcegraph.com/github.com/pkg/errors?badge)\n \n Package errors provides simple error handling primitives.\n \n@@ -47,6 +47,6 @@ We welcome pull requests, bug fixes and issue reports. With that said, the bar f\n \n Before proposing a change, please discuss your change by raising an issue.\n \n-## Licence\n+## License\n \n BSD-2-Clause"
    },
    {
      "sha": "7421f326ffe8402b17f4b064d33a862d786a6ef1",
      "filename": "backend/vendor/github.com/pkg/errors/errors.go",
      "status": "modified",
      "additions": 28,
      "deletions": 15,
      "changes": 43,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/errors.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/errors.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/pkg/errors/errors.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -6,7 +6,7 @@\n //             return err\n //     }\n //\n-// which applied recursively up the call stack results in error reports\n+// which when applied recursively up the call stack results in error reports\n // without context or debugging information. The errors package allows\n // programmers to add context to the failure path in their code in a way\n // that does not destroy the original value of the error.\n@@ -15,16 +15,17 @@\n //\n // The errors.Wrap function returns a new error that adds context to the\n // original error by recording a stack trace at the point Wrap is called,\n-// and the supplied message. For example\n+// together with the supplied message. For example\n //\n //     _, err := ioutil.ReadAll(r)\n //     if err != nil {\n //             return errors.Wrap(err, \"read failed\")\n //     }\n //\n-// If additional control is required the errors.WithStack and errors.WithMessage\n-// functions destructure errors.Wrap into its component operations of annotating\n-// an error with a stack trace and an a message, respectively.\n+// If additional control is required, the errors.WithStack and\n+// errors.WithMessage functions destructure errors.Wrap into its component\n+// operations: annotating an error with a stack trace and with a message,\n+// respectively.\n //\n // Retrieving the cause of an error\n //\n@@ -38,7 +39,7 @@\n //     }\n //\n // can be inspected by errors.Cause. errors.Cause will recursively retrieve\n-// the topmost error which does not implement causer, which is assumed to be\n+// the topmost error that does not implement causer, which is assumed to be\n // the original cause. For example:\n //\n //     switch err := errors.Cause(err).(type) {\n@@ -48,30 +49,30 @@\n //             // unknown error\n //     }\n //\n-// causer interface is not exported by this package, but is considered a part\n-// of stable public API.\n+// Although the causer interface is not exported by this package, it is\n+// considered a part of its stable public interface.\n //\n // Formatted printing of errors\n //\n // All error values returned from this package implement fmt.Formatter and can\n-// be formatted by the fmt package. The following verbs are supported\n+// be formatted by the fmt package. The following verbs are supported:\n //\n //     %s    print the error. If the error has a Cause it will be\n-//           printed recursively\n+//           printed recursively.\n //     %v    see %s\n //     %+v   extended format. Each Frame of the error's StackTrace will\n //           be printed in detail.\n //\n // Retrieving the stack trace of an error or wrapper\n //\n // New, Errorf, Wrap, and Wrapf record a stack trace at the point they are\n-// invoked. This information can be retrieved with the following interface.\n+// invoked. This information can be retrieved with the following interface:\n //\n //     type stackTracer interface {\n //             StackTrace() errors.StackTrace\n //     }\n //\n-// Where errors.StackTrace is defined as\n+// The returned errors.StackTrace type is defined as\n //\n //     type StackTrace []Frame\n //\n@@ -85,8 +86,8 @@\n //             }\n //     }\n //\n-// stackTracer interface is not exported by this package, but is considered a part\n-// of stable public API.\n+// Although the stackTracer interface is not exported by this package, it is\n+// considered a part of its stable public interface.\n //\n // See the documentation for Frame.Format for more details.\n package errors\n@@ -192,7 +193,7 @@ func Wrap(err error, message string) error {\n }\n \n // Wrapf returns an error annotating err with a stack trace\n-// at the point Wrapf is call, and the format specifier.\n+// at the point Wrapf is called, and the format specifier.\n // If err is nil, Wrapf returns nil.\n func Wrapf(err error, format string, args ...interface{}) error {\n \tif err == nil {\n@@ -220,6 +221,18 @@ func WithMessage(err error, message string) error {\n \t}\n }\n \n+// WithMessagef annotates err with the format specifier.\n+// If err is nil, WithMessagef returns nil.\n+func WithMessagef(err error, format string, args ...interface{}) error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\treturn &withMessage{\n+\t\tcause: err,\n+\t\tmsg:   fmt.Sprintf(format, args...),\n+\t}\n+}\n+\n type withMessage struct {\n \tcause error\n \tmsg   string"
    },
    {
      "sha": "2874a048cf3e6f03a74179e408aaeedd6b2951b4",
      "filename": "backend/vendor/github.com/pkg/errors/stack.go",
      "status": "modified",
      "additions": 10,
      "deletions": 41,
      "changes": 51,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/stack.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/pkg/errors/stack.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/pkg/errors/stack.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -46,7 +46,8 @@ func (f Frame) line() int {\n //\n // Format accepts flags that alter the printing of some verbs, as follows:\n //\n-//    %+s   path of source file relative to the compile time GOPATH\n+//    %+s   function name and path of source file relative to the compile time\n+//          GOPATH separated by \\n\\t (<funcname>\\n\\t<path>)\n //    %+v   equivalent to %+s:%d\n func (f Frame) Format(s fmt.State, verb rune) {\n \tswitch verb {\n@@ -79,6 +80,14 @@ func (f Frame) Format(s fmt.State, verb rune) {\n // StackTrace is stack of Frames from innermost (newest) to outermost (oldest).\n type StackTrace []Frame\n \n+// Format formats the stack of Frames according to the fmt.Formatter interface.\n+//\n+//    %s\tlists source files for each Frame in the stack\n+//    %v\tlists the source file and line number for each Frame in the stack\n+//\n+// Format accepts flags that alter the printing of some verbs, as follows:\n+//\n+//    %+v   Prints filename, function, and line number for each Frame in the stack.\n func (st StackTrace) Format(s fmt.State, verb rune) {\n \tswitch verb {\n \tcase 'v':\n@@ -136,43 +145,3 @@ func funcname(name string) string {\n \ti = strings.Index(name, \".\")\n \treturn name[i+1:]\n }\n-\n-func trimGOPATH(name, file string) string {\n-\t// Here we want to get the source file path relative to the compile time\n-\t// GOPATH. As of Go 1.6.x there is no direct way to know the compiled\n-\t// GOPATH at runtime, but we can infer the number of path segments in the\n-\t// GOPATH. We note that fn.Name() returns the function name qualified by\n-\t// the import path, which does not include the GOPATH. Thus we can trim\n-\t// segments from the beginning of the file path until the number of path\n-\t// separators remaining is one more than the number of path separators in\n-\t// the function name. For example, given:\n-\t//\n-\t//    GOPATH     /home/user\n-\t//    file       /home/user/src/pkg/sub/file.go\n-\t//    fn.Name()  pkg/sub.Type.Method\n-\t//\n-\t// We want to produce:\n-\t//\n-\t//    pkg/sub/file.go\n-\t//\n-\t// From this we can easily see that fn.Name() has one less path separator\n-\t// than our desired output. We count separators from the end of the file\n-\t// path until it finds two more than in the function name and then move\n-\t// one character forward to preserve the initial path segment without a\n-\t// leading separator.\n-\tconst sep = \"/\"\n-\tgoal := strings.Count(name, sep) + 2\n-\ti := len(file)\n-\tfor n := 0; n < goal; n++ {\n-\t\ti = strings.LastIndex(file[:i], sep)\n-\t\tif i == -1 {\n-\t\t\t// not enough separators found, set i so that the slice expression\n-\t\t\t// below leaves file unmodified\n-\t\t\ti = -len(sep)\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\t// get back to 0 or trim the leading separator\n-\tfile = file[i+len(sep):]\n-\treturn file\n-}"
    },
    {
      "sha": "f38ec5956b6400841b45ca7c44940d9312e37e9e",
      "filename": "backend/vendor/github.com/stretchr/testify/LICENSE",
      "status": "modified",
      "additions": 17,
      "deletions": 18,
      "changes": 35,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/LICENSE",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/LICENSE?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,22 +1,21 @@\n-Copyright (c) 2012 - 2013 Mat Ryer and Tyler Bunnell\n+MIT License\n \n-Please consider promoting this project if you find it useful.\n+Copyright (c) 2012-2018 Mat Ryer and Tyler Bunnell\n \n-Permission is hereby granted, free of charge, to any person \n-obtaining a copy of this software and associated documentation \n-files (the \"Software\"), to deal in the Software without restriction, \n-including without limitation the rights to use, copy, modify, merge, \n-publish, distribute, sublicense, and/or sell copies of the Software, \n-and to permit persons to whom the Software is furnished to do so, \n-subject to the following conditions:\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n \n-The above copyright notice and this permission notice shall be included\n-in all copies or substantial portions of the Software.\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n \n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \n-OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n-DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT \n-OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE \n-OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
    },
    {
      "sha": "aa1c2b95cddb861f99392ba9e84f99dcb1c04699",
      "filename": "backend/vendor/github.com/stretchr/testify/assert/assertion_format.go",
      "status": "modified",
      "additions": 137,
      "deletions": 2,
      "changes": 139,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_format.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_format.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/assert/assertion_format.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -13,6 +13,9 @@ import (\n \n // Conditionf uses a Comparison to assert a complex condition.\n func Conditionf(t TestingT, comp Comparison, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Condition(t, comp, append([]interface{}{msg}, args...)...)\n }\n \n@@ -23,11 +26,17 @@ func Conditionf(t TestingT, comp Comparison, msg string, args ...interface{}) bo\n //    assert.Containsf(t, [\"Hello\", \"World\"], \"World\", \"error message %s\", \"formatted\")\n //    assert.Containsf(t, {\"Hello\": \"World\"}, \"Hello\", \"error message %s\", \"formatted\")\n func Containsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Contains(t, s, contains, append([]interface{}{msg}, args...)...)\n }\n \n // DirExistsf checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func DirExistsf(t TestingT, path string, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn DirExists(t, path, append([]interface{}{msg}, args...)...)\n }\n \n@@ -37,6 +46,9 @@ func DirExistsf(t TestingT, path string, msg string, args ...interface{}) bool {\n //\n // assert.ElementsMatchf(t, [1, 3, 2, 3], [1, 3, 3, 2], \"error message %s\", \"formatted\")\n func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn ElementsMatch(t, listA, listB, append([]interface{}{msg}, args...)...)\n }\n \n@@ -45,6 +57,9 @@ func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string\n //\n //  assert.Emptyf(t, obj, \"error message %s\", \"formatted\")\n func Emptyf(t TestingT, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Empty(t, object, append([]interface{}{msg}, args...)...)\n }\n \n@@ -56,6 +71,9 @@ func Emptyf(t TestingT, object interface{}, msg string, args ...interface{}) boo\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func Equalf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Equal(t, expected, actual, append([]interface{}{msg}, args...)...)\n }\n \n@@ -65,6 +83,9 @@ func Equalf(t TestingT, expected interface{}, actual interface{}, msg string, ar\n //   actualObj, err := SomeFunction()\n //   assert.EqualErrorf(t, err,  expectedErrorString, \"error message %s\", \"formatted\")\n func EqualErrorf(t TestingT, theError error, errString string, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn EqualError(t, theError, errString, append([]interface{}{msg}, args...)...)\n }\n \n@@ -73,6 +94,9 @@ func EqualErrorf(t TestingT, theError error, errString string, msg string, args\n //\n //    assert.EqualValuesf(t, uint32(123, \"error message %s\", \"formatted\"), int32(123))\n func EqualValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn EqualValues(t, expected, actual, append([]interface{}{msg}, args...)...)\n }\n \n@@ -83,55 +107,79 @@ func EqualValuesf(t TestingT, expected interface{}, actual interface{}, msg stri\n // \t   assert.Equal(t, expectedErrorf, err)\n //   }\n func Errorf(t TestingT, err error, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Error(t, err, append([]interface{}{msg}, args...)...)\n }\n \n // Exactlyf asserts that two objects are equal in value and type.\n //\n //    assert.Exactlyf(t, int32(123, \"error message %s\", \"formatted\"), int64(123))\n func Exactlyf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Exactly(t, expected, actual, append([]interface{}{msg}, args...)...)\n }\n \n // Failf reports a failure through\n func Failf(t TestingT, failureMessage string, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Fail(t, failureMessage, append([]interface{}{msg}, args...)...)\n }\n \n // FailNowf fails test\n func FailNowf(t TestingT, failureMessage string, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn FailNow(t, failureMessage, append([]interface{}{msg}, args...)...)\n }\n \n // Falsef asserts that the specified value is false.\n //\n //    assert.Falsef(t, myBool, \"error message %s\", \"formatted\")\n func Falsef(t TestingT, value bool, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn False(t, value, append([]interface{}{msg}, args...)...)\n }\n \n // FileExistsf checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func FileExistsf(t TestingT, path string, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn FileExists(t, path, append([]interface{}{msg}, args...)...)\n }\n \n // HTTPBodyContainsf asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  assert.HTTPBodyContainsf(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  assert.HTTPBodyContainsf(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPBodyContains(t, handler, method, url, values, str, append([]interface{}{msg}, args...)...)\n }\n \n // HTTPBodyNotContainsf asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  assert.HTTPBodyNotContainsf(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  assert.HTTPBodyNotContainsf(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyNotContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPBodyNotContains(t, handler, method, url, values, str, append([]interface{}{msg}, args...)...)\n }\n \n@@ -141,6 +189,9 @@ func HTTPBodyNotContainsf(t TestingT, handler http.HandlerFunc, method string, u\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func HTTPErrorf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPError(t, handler, method, url, values, append([]interface{}{msg}, args...)...)\n }\n \n@@ -150,6 +201,9 @@ func HTTPErrorf(t TestingT, handler http.HandlerFunc, method string, url string,\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func HTTPRedirectf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPRedirect(t, handler, method, url, values, append([]interface{}{msg}, args...)...)\n }\n \n@@ -159,52 +213,79 @@ func HTTPRedirectf(t TestingT, handler http.HandlerFunc, method string, url stri\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPSuccessf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPSuccess(t, handler, method, url, values, append([]interface{}{msg}, args...)...)\n }\n \n // Implementsf asserts that an object is implemented by the specified interface.\n //\n //    assert.Implementsf(t, (*MyInterface, \"error message %s\", \"formatted\")(nil), new(MyObject))\n func Implementsf(t TestingT, interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Implements(t, interfaceObject, object, append([]interface{}{msg}, args...)...)\n }\n \n // InDeltaf asserts that the two numerals are within delta of each other.\n //\n // \t assert.InDeltaf(t, math.Pi, (22 / 7.0, \"error message %s\", \"formatted\"), 0.01)\n func InDeltaf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDelta(t, expected, actual, delta, append([]interface{}{msg}, args...)...)\n }\n \n // InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func InDeltaMapValuesf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDeltaMapValues(t, expected, actual, delta, append([]interface{}{msg}, args...)...)\n }\n \n // InDeltaSlicef is the same as InDelta, except it compares two slices.\n func InDeltaSlicef(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDeltaSlice(t, expected, actual, delta, append([]interface{}{msg}, args...)...)\n }\n \n // InEpsilonf asserts that expected and actual have a relative error less than epsilon\n func InEpsilonf(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InEpsilon(t, expected, actual, epsilon, append([]interface{}{msg}, args...)...)\n }\n \n // InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.\n func InEpsilonSlicef(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InEpsilonSlice(t, expected, actual, epsilon, append([]interface{}{msg}, args...)...)\n }\n \n // IsTypef asserts that the specified objects are of the same type.\n func IsTypef(t TestingT, expectedType interface{}, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn IsType(t, expectedType, object, append([]interface{}{msg}, args...)...)\n }\n \n // JSONEqf asserts that two JSON strings are equivalent.\n //\n //  assert.JSONEqf(t, `{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`, \"error message %s\", \"formatted\")\n func JSONEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn JSONEq(t, expected, actual, append([]interface{}{msg}, args...)...)\n }\n \n@@ -213,13 +294,19 @@ func JSONEqf(t TestingT, expected string, actual string, msg string, args ...int\n //\n //    assert.Lenf(t, mySlice, 3, \"error message %s\", \"formatted\")\n func Lenf(t TestingT, object interface{}, length int, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Len(t, object, length, append([]interface{}{msg}, args...)...)\n }\n \n // Nilf asserts that the specified object is nil.\n //\n //    assert.Nilf(t, err, \"error message %s\", \"formatted\")\n func Nilf(t TestingT, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Nil(t, object, append([]interface{}{msg}, args...)...)\n }\n \n@@ -230,6 +317,9 @@ func Nilf(t TestingT, object interface{}, msg string, args ...interface{}) bool\n // \t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func NoErrorf(t TestingT, err error, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NoError(t, err, append([]interface{}{msg}, args...)...)\n }\n \n@@ -240,6 +330,9 @@ func NoErrorf(t TestingT, err error, msg string, args ...interface{}) bool {\n //    assert.NotContainsf(t, [\"Hello\", \"World\"], \"Earth\", \"error message %s\", \"formatted\")\n //    assert.NotContainsf(t, {\"Hello\": \"World\"}, \"Earth\", \"error message %s\", \"formatted\")\n func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotContains(t, s, contains, append([]interface{}{msg}, args...)...)\n }\n \n@@ -250,6 +343,9 @@ func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, a\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func NotEmptyf(t TestingT, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotEmpty(t, object, append([]interface{}{msg}, args...)...)\n }\n \n@@ -260,20 +356,29 @@ func NotEmptyf(t TestingT, object interface{}, msg string, args ...interface{})\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func NotEqualf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotEqual(t, expected, actual, append([]interface{}{msg}, args...)...)\n }\n \n // NotNilf asserts that the specified object is not nil.\n //\n //    assert.NotNilf(t, err, \"error message %s\", \"formatted\")\n func NotNilf(t TestingT, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotNil(t, object, append([]interface{}{msg}, args...)...)\n }\n \n // NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.\n //\n //   assert.NotPanicsf(t, func(){ RemainCalm() }, \"error message %s\", \"formatted\")\n func NotPanicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotPanics(t, f, append([]interface{}{msg}, args...)...)\n }\n \n@@ -282,6 +387,9 @@ func NotPanicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bo\n //  assert.NotRegexpf(t, regexp.MustCompile(\"starts\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  assert.NotRegexpf(t, \"^start\", \"it's not starting\", \"error message %s\", \"formatted\")\n func NotRegexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotRegexp(t, rx, str, append([]interface{}{msg}, args...)...)\n }\n \n@@ -290,18 +398,27 @@ func NotRegexpf(t TestingT, rx interface{}, str interface{}, msg string, args ..\n //\n //    assert.NotSubsetf(t, [1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\", \"error message %s\", \"formatted\")\n func NotSubsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotSubset(t, list, subset, append([]interface{}{msg}, args...)...)\n }\n \n // NotZerof asserts that i is not the zero value for its type.\n func NotZerof(t TestingT, i interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotZero(t, i, append([]interface{}{msg}, args...)...)\n }\n \n // Panicsf asserts that the code inside the specified PanicTestFunc panics.\n //\n //   assert.Panicsf(t, func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func Panicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Panics(t, f, append([]interface{}{msg}, args...)...)\n }\n \n@@ -310,6 +427,9 @@ func Panicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bool\n //\n //   assert.PanicsWithValuef(t, \"crazy error\", func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func PanicsWithValuef(t TestingT, expected interface{}, f PanicTestFunc, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn PanicsWithValue(t, expected, f, append([]interface{}{msg}, args...)...)\n }\n \n@@ -318,6 +438,9 @@ func PanicsWithValuef(t TestingT, expected interface{}, f PanicTestFunc, msg str\n //  assert.Regexpf(t, regexp.MustCompile(\"start\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  assert.Regexpf(t, \"start...$\", \"it's not starting\", \"error message %s\", \"formatted\")\n func Regexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Regexp(t, rx, str, append([]interface{}{msg}, args...)...)\n }\n \n@@ -326,24 +449,36 @@ func Regexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...in\n //\n //    assert.Subsetf(t, [1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\", \"error message %s\", \"formatted\")\n func Subsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Subset(t, list, subset, append([]interface{}{msg}, args...)...)\n }\n \n // Truef asserts that the specified value is true.\n //\n //    assert.Truef(t, myBool, \"error message %s\", \"formatted\")\n func Truef(t TestingT, value bool, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn True(t, value, append([]interface{}{msg}, args...)...)\n }\n \n // WithinDurationf asserts that the two times are within duration delta of each other.\n //\n //   assert.WithinDurationf(t, time.Now(), time.Now(), 10*time.Second, \"error message %s\", \"formatted\")\n func WithinDurationf(t TestingT, expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn WithinDuration(t, expected, actual, delta, append([]interface{}{msg}, args...)...)\n }\n \n // Zerof asserts that i is the zero value for its type.\n func Zerof(t TestingT, i interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Zero(t, i, append([]interface{}{msg}, args...)...)\n }"
    },
    {
      "sha": "d2bb0b81778858c364f4b3694c00cdd4c72b1c5b",
      "filename": "backend/vendor/github.com/stretchr/testify/assert/assertion_format.go.tmpl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_format.go.tmpl",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_format.go.tmpl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/assert/assertion_format.go.tmpl?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,4 +1,5 @@\n {{.CommentFormat}}\n func {{.DocInfo.Name}}f(t TestingT, {{.ParamsFormat}}) bool {\n+\tif h, ok := t.(tHelper); ok { h.Helper() }\n \treturn {{.DocInfo.Name}}(t, {{.ForwardedParamsFormat}})\n }"
    },
    {
      "sha": "de39f794e72162679cc754b2864ecdacc8c21387",
      "filename": "backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go",
      "status": "modified",
      "additions": 274,
      "deletions": 4,
      "changes": 278,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -13,11 +13,17 @@ import (\n \n // Condition uses a Comparison to assert a complex condition.\n func (a *Assertions) Condition(comp Comparison, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Condition(a.t, comp, msgAndArgs...)\n }\n \n // Conditionf uses a Comparison to assert a complex condition.\n func (a *Assertions) Conditionf(comp Comparison, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Conditionf(a.t, comp, msg, args...)\n }\n \n@@ -28,6 +34,9 @@ func (a *Assertions) Conditionf(comp Comparison, msg string, args ...interface{}\n //    a.Contains([\"Hello\", \"World\"], \"World\")\n //    a.Contains({\"Hello\": \"World\"}, \"Hello\")\n func (a *Assertions) Contains(s interface{}, contains interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Contains(a.t, s, contains, msgAndArgs...)\n }\n \n@@ -38,16 +47,25 @@ func (a *Assertions) Contains(s interface{}, contains interface{}, msgAndArgs ..\n //    a.Containsf([\"Hello\", \"World\"], \"World\", \"error message %s\", \"formatted\")\n //    a.Containsf({\"Hello\": \"World\"}, \"Hello\", \"error message %s\", \"formatted\")\n func (a *Assertions) Containsf(s interface{}, contains interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Containsf(a.t, s, contains, msg, args...)\n }\n \n // DirExists checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func (a *Assertions) DirExists(path string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn DirExists(a.t, path, msgAndArgs...)\n }\n \n // DirExistsf checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func (a *Assertions) DirExistsf(path string, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn DirExistsf(a.t, path, msg, args...)\n }\n \n@@ -57,6 +75,9 @@ func (a *Assertions) DirExistsf(path string, msg string, args ...interface{}) bo\n //\n // a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])\n func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn ElementsMatch(a.t, listA, listB, msgAndArgs...)\n }\n \n@@ -66,6 +87,9 @@ func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndA\n //\n // a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], \"error message %s\", \"formatted\")\n func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn ElementsMatchf(a.t, listA, listB, msg, args...)\n }\n \n@@ -74,6 +98,9 @@ func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg st\n //\n //  a.Empty(obj)\n func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Empty(a.t, object, msgAndArgs...)\n }\n \n@@ -82,6 +109,9 @@ func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) bool {\n //\n //  a.Emptyf(obj, \"error message %s\", \"formatted\")\n func (a *Assertions) Emptyf(object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Emptyf(a.t, object, msg, args...)\n }\n \n@@ -93,6 +123,9 @@ func (a *Assertions) Emptyf(object interface{}, msg string, args ...interface{})\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func (a *Assertions) Equal(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Equal(a.t, expected, actual, msgAndArgs...)\n }\n \n@@ -102,6 +135,9 @@ func (a *Assertions) Equal(expected interface{}, actual interface{}, msgAndArgs\n //   actualObj, err := SomeFunction()\n //   a.EqualError(err,  expectedErrorString)\n func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn EqualError(a.t, theError, errString, msgAndArgs...)\n }\n \n@@ -111,6 +147,9 @@ func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...\n //   actualObj, err := SomeFunction()\n //   a.EqualErrorf(err,  expectedErrorString, \"error message %s\", \"formatted\")\n func (a *Assertions) EqualErrorf(theError error, errString string, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn EqualErrorf(a.t, theError, errString, msg, args...)\n }\n \n@@ -119,6 +158,9 @@ func (a *Assertions) EqualErrorf(theError error, errString string, msg string, a\n //\n //    a.EqualValues(uint32(123), int32(123))\n func (a *Assertions) EqualValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn EqualValues(a.t, expected, actual, msgAndArgs...)\n }\n \n@@ -127,6 +169,9 @@ func (a *Assertions) EqualValues(expected interface{}, actual interface{}, msgAn\n //\n //    a.EqualValuesf(uint32(123, \"error message %s\", \"formatted\"), int32(123))\n func (a *Assertions) EqualValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn EqualValuesf(a.t, expected, actual, msg, args...)\n }\n \n@@ -138,6 +183,9 @@ func (a *Assertions) EqualValuesf(expected interface{}, actual interface{}, msg\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func (a *Assertions) Equalf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Equalf(a.t, expected, actual, msg, args...)\n }\n \n@@ -148,6 +196,9 @@ func (a *Assertions) Equalf(expected interface{}, actual interface{}, msg string\n // \t   assert.Equal(t, expectedError, err)\n //   }\n func (a *Assertions) Error(err error, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Error(a.t, err, msgAndArgs...)\n }\n \n@@ -158,104 +209,149 @@ func (a *Assertions) Error(err error, msgAndArgs ...interface{}) bool {\n // \t   assert.Equal(t, expectedErrorf, err)\n //   }\n func (a *Assertions) Errorf(err error, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Errorf(a.t, err, msg, args...)\n }\n \n // Exactly asserts that two objects are equal in value and type.\n //\n //    a.Exactly(int32(123), int64(123))\n func (a *Assertions) Exactly(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Exactly(a.t, expected, actual, msgAndArgs...)\n }\n \n // Exactlyf asserts that two objects are equal in value and type.\n //\n //    a.Exactlyf(int32(123, \"error message %s\", \"formatted\"), int64(123))\n func (a *Assertions) Exactlyf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Exactlyf(a.t, expected, actual, msg, args...)\n }\n \n // Fail reports a failure through\n func (a *Assertions) Fail(failureMessage string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Fail(a.t, failureMessage, msgAndArgs...)\n }\n \n // FailNow fails test\n func (a *Assertions) FailNow(failureMessage string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn FailNow(a.t, failureMessage, msgAndArgs...)\n }\n \n // FailNowf fails test\n func (a *Assertions) FailNowf(failureMessage string, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn FailNowf(a.t, failureMessage, msg, args...)\n }\n \n // Failf reports a failure through\n func (a *Assertions) Failf(failureMessage string, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Failf(a.t, failureMessage, msg, args...)\n }\n \n // False asserts that the specified value is false.\n //\n //    a.False(myBool)\n func (a *Assertions) False(value bool, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn False(a.t, value, msgAndArgs...)\n }\n \n // Falsef asserts that the specified value is false.\n //\n //    a.Falsef(myBool, \"error message %s\", \"formatted\")\n func (a *Assertions) Falsef(value bool, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Falsef(a.t, value, msg, args...)\n }\n \n // FileExists checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func (a *Assertions) FileExists(path string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn FileExists(a.t, path, msgAndArgs...)\n }\n \n // FileExistsf checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func (a *Assertions) FileExistsf(path string, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn FileExistsf(a.t, path, msg, args...)\n }\n \n // HTTPBodyContains asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  a.HTTPBodyContains(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  a.HTTPBodyContains(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPBodyContains(a.t, handler, method, url, values, str, msgAndArgs...)\n }\n \n // HTTPBodyContainsf asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  a.HTTPBodyContainsf(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  a.HTTPBodyContainsf(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPBodyContainsf(a.t, handler, method, url, values, str, msg, args...)\n }\n \n // HTTPBodyNotContains asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  a.HTTPBodyNotContains(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  a.HTTPBodyNotContains(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyNotContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPBodyNotContains(a.t, handler, method, url, values, str, msgAndArgs...)\n }\n \n // HTTPBodyNotContainsf asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  a.HTTPBodyNotContainsf(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  a.HTTPBodyNotContainsf(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyNotContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPBodyNotContainsf(a.t, handler, method, url, values, str, msg, args...)\n }\n \n@@ -265,6 +361,9 @@ func (a *Assertions) HTTPBodyNotContainsf(handler http.HandlerFunc, method strin\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPError(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPError(a.t, handler, method, url, values, msgAndArgs...)\n }\n \n@@ -274,6 +373,9 @@ func (a *Assertions) HTTPError(handler http.HandlerFunc, method string, url stri\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func (a *Assertions) HTTPErrorf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPErrorf(a.t, handler, method, url, values, msg, args...)\n }\n \n@@ -283,6 +385,9 @@ func (a *Assertions) HTTPErrorf(handler http.HandlerFunc, method string, url str\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPRedirect(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPRedirect(a.t, handler, method, url, values, msgAndArgs...)\n }\n \n@@ -292,6 +397,9 @@ func (a *Assertions) HTTPRedirect(handler http.HandlerFunc, method string, url s\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func (a *Assertions) HTTPRedirectf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPRedirectf(a.t, handler, method, url, values, msg, args...)\n }\n \n@@ -301,6 +409,9 @@ func (a *Assertions) HTTPRedirectf(handler http.HandlerFunc, method string, url\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPSuccess(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPSuccess(a.t, handler, method, url, values, msgAndArgs...)\n }\n \n@@ -310,98 +421,149 @@ func (a *Assertions) HTTPSuccess(handler http.HandlerFunc, method string, url st\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPSuccessf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn HTTPSuccessf(a.t, handler, method, url, values, msg, args...)\n }\n \n // Implements asserts that an object is implemented by the specified interface.\n //\n //    a.Implements((*MyInterface)(nil), new(MyObject))\n func (a *Assertions) Implements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Implements(a.t, interfaceObject, object, msgAndArgs...)\n }\n \n // Implementsf asserts that an object is implemented by the specified interface.\n //\n //    a.Implementsf((*MyInterface, \"error message %s\", \"formatted\")(nil), new(MyObject))\n func (a *Assertions) Implementsf(interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Implementsf(a.t, interfaceObject, object, msg, args...)\n }\n \n // InDelta asserts that the two numerals are within delta of each other.\n //\n // \t a.InDelta(math.Pi, (22 / 7.0), 0.01)\n func (a *Assertions) InDelta(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDelta(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func (a *Assertions) InDeltaMapValues(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDeltaMapValues(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func (a *Assertions) InDeltaMapValuesf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDeltaMapValuesf(a.t, expected, actual, delta, msg, args...)\n }\n \n // InDeltaSlice is the same as InDelta, except it compares two slices.\n func (a *Assertions) InDeltaSlice(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDeltaSlice(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // InDeltaSlicef is the same as InDelta, except it compares two slices.\n func (a *Assertions) InDeltaSlicef(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDeltaSlicef(a.t, expected, actual, delta, msg, args...)\n }\n \n // InDeltaf asserts that the two numerals are within delta of each other.\n //\n // \t a.InDeltaf(math.Pi, (22 / 7.0, \"error message %s\", \"formatted\"), 0.01)\n func (a *Assertions) InDeltaf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InDeltaf(a.t, expected, actual, delta, msg, args...)\n }\n \n // InEpsilon asserts that expected and actual have a relative error less than epsilon\n func (a *Assertions) InEpsilon(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InEpsilon(a.t, expected, actual, epsilon, msgAndArgs...)\n }\n \n // InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.\n func (a *Assertions) InEpsilonSlice(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InEpsilonSlice(a.t, expected, actual, epsilon, msgAndArgs...)\n }\n \n // InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.\n func (a *Assertions) InEpsilonSlicef(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InEpsilonSlicef(a.t, expected, actual, epsilon, msg, args...)\n }\n \n // InEpsilonf asserts that expected and actual have a relative error less than epsilon\n func (a *Assertions) InEpsilonf(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn InEpsilonf(a.t, expected, actual, epsilon, msg, args...)\n }\n \n // IsType asserts that the specified objects are of the same type.\n func (a *Assertions) IsType(expectedType interface{}, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn IsType(a.t, expectedType, object, msgAndArgs...)\n }\n \n // IsTypef asserts that the specified objects are of the same type.\n func (a *Assertions) IsTypef(expectedType interface{}, object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn IsTypef(a.t, expectedType, object, msg, args...)\n }\n \n // JSONEq asserts that two JSON strings are equivalent.\n //\n //  a.JSONEq(`{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`)\n func (a *Assertions) JSONEq(expected string, actual string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn JSONEq(a.t, expected, actual, msgAndArgs...)\n }\n \n // JSONEqf asserts that two JSON strings are equivalent.\n //\n //  a.JSONEqf(`{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`, \"error message %s\", \"formatted\")\n func (a *Assertions) JSONEqf(expected string, actual string, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn JSONEqf(a.t, expected, actual, msg, args...)\n }\n \n@@ -410,6 +572,9 @@ func (a *Assertions) JSONEqf(expected string, actual string, msg string, args ..\n //\n //    a.Len(mySlice, 3)\n func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Len(a.t, object, length, msgAndArgs...)\n }\n \n@@ -418,20 +583,29 @@ func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface\n //\n //    a.Lenf(mySlice, 3, \"error message %s\", \"formatted\")\n func (a *Assertions) Lenf(object interface{}, length int, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Lenf(a.t, object, length, msg, args...)\n }\n \n // Nil asserts that the specified object is nil.\n //\n //    a.Nil(err)\n func (a *Assertions) Nil(object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Nil(a.t, object, msgAndArgs...)\n }\n \n // Nilf asserts that the specified object is nil.\n //\n //    a.Nilf(err, \"error message %s\", \"formatted\")\n func (a *Assertions) Nilf(object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Nilf(a.t, object, msg, args...)\n }\n \n@@ -442,6 +616,9 @@ func (a *Assertions) Nilf(object interface{}, msg string, args ...interface{}) b\n // \t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func (a *Assertions) NoError(err error, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NoError(a.t, err, msgAndArgs...)\n }\n \n@@ -452,6 +629,9 @@ func (a *Assertions) NoError(err error, msgAndArgs ...interface{}) bool {\n // \t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func (a *Assertions) NoErrorf(err error, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NoErrorf(a.t, err, msg, args...)\n }\n \n@@ -462,6 +642,9 @@ func (a *Assertions) NoErrorf(err error, msg string, args ...interface{}) bool {\n //    a.NotContains([\"Hello\", \"World\"], \"Earth\")\n //    a.NotContains({\"Hello\": \"World\"}, \"Earth\")\n func (a *Assertions) NotContains(s interface{}, contains interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotContains(a.t, s, contains, msgAndArgs...)\n }\n \n@@ -472,6 +655,9 @@ func (a *Assertions) NotContains(s interface{}, contains interface{}, msgAndArgs\n //    a.NotContainsf([\"Hello\", \"World\"], \"Earth\", \"error message %s\", \"formatted\")\n //    a.NotContainsf({\"Hello\": \"World\"}, \"Earth\", \"error message %s\", \"formatted\")\n func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotContainsf(a.t, s, contains, msg, args...)\n }\n \n@@ -482,6 +668,9 @@ func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg strin\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotEmpty(a.t, object, msgAndArgs...)\n }\n \n@@ -492,6 +681,9 @@ func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) boo\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func (a *Assertions) NotEmptyf(object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotEmptyf(a.t, object, msg, args...)\n }\n \n@@ -502,6 +694,9 @@ func (a *Assertions) NotEmptyf(object interface{}, msg string, args ...interface\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func (a *Assertions) NotEqual(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotEqual(a.t, expected, actual, msgAndArgs...)\n }\n \n@@ -512,34 +707,49 @@ func (a *Assertions) NotEqual(expected interface{}, actual interface{}, msgAndAr\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func (a *Assertions) NotEqualf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotEqualf(a.t, expected, actual, msg, args...)\n }\n \n // NotNil asserts that the specified object is not nil.\n //\n //    a.NotNil(err)\n func (a *Assertions) NotNil(object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotNil(a.t, object, msgAndArgs...)\n }\n \n // NotNilf asserts that the specified object is not nil.\n //\n //    a.NotNilf(err, \"error message %s\", \"formatted\")\n func (a *Assertions) NotNilf(object interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotNilf(a.t, object, msg, args...)\n }\n \n // NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.\n //\n //   a.NotPanics(func(){ RemainCalm() })\n func (a *Assertions) NotPanics(f PanicTestFunc, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotPanics(a.t, f, msgAndArgs...)\n }\n \n // NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.\n //\n //   a.NotPanicsf(func(){ RemainCalm() }, \"error message %s\", \"formatted\")\n func (a *Assertions) NotPanicsf(f PanicTestFunc, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotPanicsf(a.t, f, msg, args...)\n }\n \n@@ -548,6 +758,9 @@ func (a *Assertions) NotPanicsf(f PanicTestFunc, msg string, args ...interface{}\n //  a.NotRegexp(regexp.MustCompile(\"starts\"), \"it's starting\")\n //  a.NotRegexp(\"^start\", \"it's not starting\")\n func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotRegexp(a.t, rx, str, msgAndArgs...)\n }\n \n@@ -556,6 +769,9 @@ func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...in\n //  a.NotRegexpf(regexp.MustCompile(\"starts\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  a.NotRegexpf(\"^start\", \"it's not starting\", \"error message %s\", \"formatted\")\n func (a *Assertions) NotRegexpf(rx interface{}, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotRegexpf(a.t, rx, str, msg, args...)\n }\n \n@@ -564,6 +780,9 @@ func (a *Assertions) NotRegexpf(rx interface{}, str interface{}, msg string, arg\n //\n //    a.NotSubset([1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\")\n func (a *Assertions) NotSubset(list interface{}, subset interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotSubset(a.t, list, subset, msgAndArgs...)\n }\n \n@@ -572,23 +791,35 @@ func (a *Assertions) NotSubset(list interface{}, subset interface{}, msgAndArgs\n //\n //    a.NotSubsetf([1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\", \"error message %s\", \"formatted\")\n func (a *Assertions) NotSubsetf(list interface{}, subset interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotSubsetf(a.t, list, subset, msg, args...)\n }\n \n // NotZero asserts that i is not the zero value for its type.\n func (a *Assertions) NotZero(i interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotZero(a.t, i, msgAndArgs...)\n }\n \n // NotZerof asserts that i is not the zero value for its type.\n func (a *Assertions) NotZerof(i interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn NotZerof(a.t, i, msg, args...)\n }\n \n // Panics asserts that the code inside the specified PanicTestFunc panics.\n //\n //   a.Panics(func(){ GoCrazy() })\n func (a *Assertions) Panics(f PanicTestFunc, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Panics(a.t, f, msgAndArgs...)\n }\n \n@@ -597,6 +828,9 @@ func (a *Assertions) Panics(f PanicTestFunc, msgAndArgs ...interface{}) bool {\n //\n //   a.PanicsWithValue(\"crazy error\", func(){ GoCrazy() })\n func (a *Assertions) PanicsWithValue(expected interface{}, f PanicTestFunc, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn PanicsWithValue(a.t, expected, f, msgAndArgs...)\n }\n \n@@ -605,13 +839,19 @@ func (a *Assertions) PanicsWithValue(expected interface{}, f PanicTestFunc, msgA\n //\n //   a.PanicsWithValuef(\"crazy error\", func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func (a *Assertions) PanicsWithValuef(expected interface{}, f PanicTestFunc, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn PanicsWithValuef(a.t, expected, f, msg, args...)\n }\n \n // Panicsf asserts that the code inside the specified PanicTestFunc panics.\n //\n //   a.Panicsf(func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func (a *Assertions) Panicsf(f PanicTestFunc, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Panicsf(a.t, f, msg, args...)\n }\n \n@@ -620,6 +860,9 @@ func (a *Assertions) Panicsf(f PanicTestFunc, msg string, args ...interface{}) b\n //  a.Regexp(regexp.MustCompile(\"start\"), \"it's starting\")\n //  a.Regexp(\"start...$\", \"it's not starting\")\n func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Regexp(a.t, rx, str, msgAndArgs...)\n }\n \n@@ -628,6 +871,9 @@ func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...inter\n //  a.Regexpf(regexp.MustCompile(\"start\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  a.Regexpf(\"start...$\", \"it's not starting\", \"error message %s\", \"formatted\")\n func (a *Assertions) Regexpf(rx interface{}, str interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Regexpf(a.t, rx, str, msg, args...)\n }\n \n@@ -636,6 +882,9 @@ func (a *Assertions) Regexpf(rx interface{}, str interface{}, msg string, args .\n //\n //    a.Subset([1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\")\n func (a *Assertions) Subset(list interface{}, subset interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Subset(a.t, list, subset, msgAndArgs...)\n }\n \n@@ -644,43 +893,64 @@ func (a *Assertions) Subset(list interface{}, subset interface{}, msgAndArgs ...\n //\n //    a.Subsetf([1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\", \"error message %s\", \"formatted\")\n func (a *Assertions) Subsetf(list interface{}, subset interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Subsetf(a.t, list, subset, msg, args...)\n }\n \n // True asserts that the specified value is true.\n //\n //    a.True(myBool)\n func (a *Assertions) True(value bool, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn True(a.t, value, msgAndArgs...)\n }\n \n // Truef asserts that the specified value is true.\n //\n //    a.Truef(myBool, \"error message %s\", \"formatted\")\n func (a *Assertions) Truef(value bool, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Truef(a.t, value, msg, args...)\n }\n \n // WithinDuration asserts that the two times are within duration delta of each other.\n //\n //   a.WithinDuration(time.Now(), time.Now(), 10*time.Second)\n func (a *Assertions) WithinDuration(expected time.Time, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn WithinDuration(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // WithinDurationf asserts that the two times are within duration delta of each other.\n //\n //   a.WithinDurationf(time.Now(), time.Now(), 10*time.Second, \"error message %s\", \"formatted\")\n func (a *Assertions) WithinDurationf(expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn WithinDurationf(a.t, expected, actual, delta, msg, args...)\n }\n \n // Zero asserts that i is the zero value for its type.\n func (a *Assertions) Zero(i interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Zero(a.t, i, msgAndArgs...)\n }\n \n // Zerof asserts that i is the zero value for its type.\n func (a *Assertions) Zerof(i interface{}, msg string, args ...interface{}) bool {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \treturn Zerof(a.t, i, msg, args...)\n }"
    },
    {
      "sha": "188bb9e174397295062da708cc9f5207e2331768",
      "filename": "backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go.tmpl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go.tmpl",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go.tmpl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/assert/assertion_forward.go.tmpl?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,4 +1,5 @@\n {{.CommentWithoutT \"a\"}}\n func (a *Assertions) {{.DocInfo.Name}}({{.Params}}) bool {\n+\tif h, ok := a.t.(tHelper); ok { h.Helper() }\n \treturn {{.DocInfo.Name}}(a.t, {{.ForwardedParams}})\n }"
    },
    {
      "sha": "9bd4a80e4847c014478d6e36e15c3c9bdf93a194",
      "filename": "backend/vendor/github.com/stretchr/testify/assert/assertions.go",
      "status": "modified",
      "additions": 201,
      "deletions": 41,
      "changes": 242,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertions.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/assertions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/assert/assertions.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -27,6 +27,22 @@ type TestingT interface {\n \tErrorf(format string, args ...interface{})\n }\n \n+// ComparisonAssertionFunc is a common function prototype when comparing two values.  Can be useful\n+// for table driven tests.\n+type ComparisonAssertionFunc func(TestingT, interface{}, interface{}, ...interface{}) bool\n+\n+// ValueAssertionFunc is a common function prototype when validating a single value.  Can be useful\n+// for table driven tests.\n+type ValueAssertionFunc func(TestingT, interface{}, ...interface{}) bool\n+\n+// BoolAssertionFunc is a common function prototype when validating a bool value.  Can be useful\n+// for table driven tests.\n+type BoolAssertionFunc func(TestingT, bool, ...interface{}) bool\n+\n+// ErrorAssertionFunc is a common function prototype when validating an error value.  Can be useful\n+// for table driven tests.\n+type ErrorAssertionFunc func(TestingT, error, ...interface{}) bool\n+\n // Comparison a custom function that returns true on success and false on failure\n type Comparison func() (success bool)\n \n@@ -38,21 +54,23 @@ type Comparison func() (success bool)\n //\n // This function does no assertion of any kind.\n func ObjectsAreEqual(expected, actual interface{}) bool {\n-\n \tif expected == nil || actual == nil {\n \t\treturn expected == actual\n \t}\n-\tif exp, ok := expected.([]byte); ok {\n-\t\tact, ok := actual.([]byte)\n-\t\tif !ok {\n-\t\t\treturn false\n-\t\t} else if exp == nil || act == nil {\n-\t\t\treturn exp == nil && act == nil\n-\t\t}\n-\t\treturn bytes.Equal(exp, act)\n+\n+\texp, ok := expected.([]byte)\n+\tif !ok {\n+\t\treturn reflect.DeepEqual(expected, actual)\n \t}\n-\treturn reflect.DeepEqual(expected, actual)\n \n+\tact, ok := actual.([]byte)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\tif exp == nil || act == nil {\n+\t\treturn exp == nil && act == nil\n+\t}\n+\treturn bytes.Equal(exp, act)\n }\n \n // ObjectsAreEqualValues gets whether two objects are equal, or if their\n@@ -156,27 +174,16 @@ func isTest(name, prefix string) bool {\n \treturn !unicode.IsLower(rune)\n }\n \n-// getWhitespaceString returns a string that is long enough to overwrite the default\n-// output from the go testing framework.\n-func getWhitespaceString() string {\n-\n-\t_, file, line, ok := runtime.Caller(1)\n-\tif !ok {\n-\t\treturn \"\"\n-\t}\n-\tparts := strings.Split(file, \"/\")\n-\tfile = parts[len(parts)-1]\n-\n-\treturn strings.Repeat(\" \", len(fmt.Sprintf(\"%s:%d:        \", file, line)))\n-\n-}\n-\n func messageFromMsgAndArgs(msgAndArgs ...interface{}) string {\n \tif len(msgAndArgs) == 0 || msgAndArgs == nil {\n \t\treturn \"\"\n \t}\n \tif len(msgAndArgs) == 1 {\n-\t\treturn msgAndArgs[0].(string)\n+\t\tmsg := msgAndArgs[0]\n+\t\tif msgAsStr, ok := msg.(string); ok {\n+\t\t\treturn msgAsStr\n+\t\t}\n+\t\treturn fmt.Sprintf(\"%+v\", msg)\n \t}\n \tif len(msgAndArgs) > 1 {\n \t\treturn fmt.Sprintf(msgAndArgs[0].(string), msgAndArgs[1:]...)\n@@ -195,7 +202,7 @@ func indentMessageLines(message string, longestLabelLen int) string {\n \t\t// no need to align first line because it starts at the correct location (after the label)\n \t\tif i != 0 {\n \t\t\t// append alignLen+1 spaces to align with \"{{longestLabel}}:\" before adding tab\n-\t\t\toutBuf.WriteString(\"\\n\\r\\t\" + strings.Repeat(\" \", longestLabelLen+1) + \"\\t\")\n+\t\t\toutBuf.WriteString(\"\\n\\t\" + strings.Repeat(\" \", longestLabelLen+1) + \"\\t\")\n \t\t}\n \t\toutBuf.WriteString(scanner.Text())\n \t}\n@@ -209,6 +216,9 @@ type failNower interface {\n \n // FailNow fails test\n func FailNow(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFail(t, failureMessage, msgAndArgs...)\n \n \t// We cannot extend TestingT with FailNow() and\n@@ -227,8 +237,11 @@ func FailNow(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool\n \n // Fail reports a failure through\n func Fail(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tcontent := []labeledContent{\n-\t\t{\"Error Trace\", strings.Join(CallerInfo(), \"\\n\\r\\t\\t\\t\")},\n+\t\t{\"Error Trace\", strings.Join(CallerInfo(), \"\\n\\t\\t\\t\")},\n \t\t{\"Error\", failureMessage},\n \t}\n \n@@ -244,7 +257,7 @@ func Fail(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool {\n \t\tcontent = append(content, labeledContent{\"Messages\", message})\n \t}\n \n-\tt.Errorf(\"%s\", \"\\r\"+getWhitespaceString()+labeledOutput(content...))\n+\tt.Errorf(\"\\n%s\", \"\"+labeledOutput(content...))\n \n \treturn false\n }\n@@ -256,7 +269,7 @@ type labeledContent struct {\n \n // labeledOutput returns a string consisting of the provided labeledContent. Each labeled output is appended in the following manner:\n //\n-//   \\r\\t{{label}}:{{align_spaces}}\\t{{content}}\\n\n+//   \\t{{label}}:{{align_spaces}}\\t{{content}}\\n\n //\n // The initial carriage return is required to undo/erase any padding added by testing.T.Errorf. The \"\\t{{label}}:\" is for the label.\n // If a label is shorter than the longest label provided, padding spaces are added to make all the labels match in length. Once this\n@@ -272,7 +285,7 @@ func labeledOutput(content ...labeledContent) string {\n \t}\n \tvar output string\n \tfor _, v := range content {\n-\t\toutput += \"\\r\\t\" + v.label + \":\" + strings.Repeat(\" \", longestLabel-len(v.label)) + \"\\t\" + indentMessageLines(v.content, longestLabel) + \"\\n\"\n+\t\toutput += \"\\t\" + v.label + \":\" + strings.Repeat(\" \", longestLabel-len(v.label)) + \"\\t\" + indentMessageLines(v.content, longestLabel) + \"\\n\"\n \t}\n \treturn output\n }\n@@ -281,6 +294,9 @@ func labeledOutput(content ...labeledContent) string {\n //\n //    assert.Implements(t, (*MyInterface)(nil), new(MyObject))\n func Implements(t TestingT, interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tinterfaceType := reflect.TypeOf(interfaceObject).Elem()\n \n \tif object == nil {\n@@ -295,6 +311,9 @@ func Implements(t TestingT, interfaceObject interface{}, object interface{}, msg\n \n // IsType asserts that the specified objects are of the same type.\n func IsType(t TestingT, expectedType interface{}, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tif !ObjectsAreEqual(reflect.TypeOf(object), reflect.TypeOf(expectedType)) {\n \t\treturn Fail(t, fmt.Sprintf(\"Object expected to be of type %v, but was %v\", reflect.TypeOf(expectedType), reflect.TypeOf(object)), msgAndArgs...)\n@@ -311,6 +330,9 @@ func IsType(t TestingT, expectedType interface{}, object interface{}, msgAndArgs\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func Equal(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif err := validateEqualArgs(expected, actual); err != nil {\n \t\treturn Fail(t, fmt.Sprintf(\"Invalid operation: %#v == %#v (%s)\",\n \t\t\texpected, actual, err), msgAndArgs...)\n@@ -349,6 +371,9 @@ func formatUnequalValues(expected, actual interface{}) (e string, a string) {\n //\n //    assert.EqualValues(t, uint32(123), int32(123))\n func EqualValues(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tif !ObjectsAreEqualValues(expected, actual) {\n \t\tdiff := diff(expected, actual)\n@@ -366,12 +391,15 @@ func EqualValues(t TestingT, expected, actual interface{}, msgAndArgs ...interfa\n //\n //    assert.Exactly(t, int32(123), int64(123))\n func Exactly(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \taType := reflect.TypeOf(expected)\n \tbType := reflect.TypeOf(actual)\n \n \tif aType != bType {\n-\t\treturn Fail(t, fmt.Sprintf(\"Types expected to match exactly\\n\\r\\t%v != %v\", aType, bType), msgAndArgs...)\n+\t\treturn Fail(t, fmt.Sprintf(\"Types expected to match exactly\\n\\t%v != %v\", aType, bType), msgAndArgs...)\n \t}\n \n \treturn Equal(t, expected, actual, msgAndArgs...)\n@@ -382,12 +410,26 @@ func Exactly(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}\n //\n //    assert.NotNil(t, err)\n func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif !isNil(object) {\n \t\treturn true\n \t}\n \treturn Fail(t, \"Expected value not to be nil.\", msgAndArgs...)\n }\n \n+// containsKind checks if a specified kind in the slice of kinds.\n+func containsKind(kinds []reflect.Kind, kind reflect.Kind) bool {\n+\tfor i := 0; i < len(kinds); i++ {\n+\t\tif kind == kinds[i] {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}\n+\n // isNil checks if a specified object is nil or not, without Failing.\n func isNil(object interface{}) bool {\n \tif object == nil {\n@@ -396,7 +438,14 @@ func isNil(object interface{}) bool {\n \n \tvalue := reflect.ValueOf(object)\n \tkind := value.Kind()\n-\tif kind >= reflect.Chan && kind <= reflect.Slice && value.IsNil() {\n+\tisNilableKind := containsKind(\n+\t\t[]reflect.Kind{\n+\t\t\treflect.Chan, reflect.Func,\n+\t\t\treflect.Interface, reflect.Map,\n+\t\t\treflect.Ptr, reflect.Slice},\n+\t\tkind)\n+\n+\tif isNilableKind && value.IsNil() {\n \t\treturn true\n \t}\n \n@@ -407,6 +456,9 @@ func isNil(object interface{}) bool {\n //\n //    assert.Nil(t, err)\n func Nil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif isNil(object) {\n \t\treturn true\n \t}\n@@ -446,6 +498,9 @@ func isEmpty(object interface{}) bool {\n //\n //  assert.Empty(t, obj)\n func Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tpass := isEmpty(object)\n \tif !pass {\n@@ -463,6 +518,9 @@ func Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tpass := !isEmpty(object)\n \tif !pass {\n@@ -490,6 +548,9 @@ func getLen(x interface{}) (ok bool, length int) {\n //\n //    assert.Len(t, mySlice, 3)\n func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tok, l := getLen(object)\n \tif !ok {\n \t\treturn Fail(t, fmt.Sprintf(\"\\\"%s\\\" could not be applied builtin len()\", object), msgAndArgs...)\n@@ -505,6 +566,14 @@ func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{})\n //\n //    assert.True(t, myBool)\n func True(t TestingT, value bool, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tif h, ok := t.(interface {\n+\t\tHelper()\n+\t}); ok {\n+\t\th.Helper()\n+\t}\n \n \tif value != true {\n \t\treturn Fail(t, \"Should be true\", msgAndArgs...)\n@@ -518,6 +587,9 @@ func True(t TestingT, value bool, msgAndArgs ...interface{}) bool {\n //\n //    assert.False(t, myBool)\n func False(t TestingT, value bool, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tif value != false {\n \t\treturn Fail(t, \"Should be false\", msgAndArgs...)\n@@ -534,6 +606,9 @@ func False(t TestingT, value bool, msgAndArgs ...interface{}) bool {\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func NotEqual(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif err := validateEqualArgs(expected, actual); err != nil {\n \t\treturn Fail(t, fmt.Sprintf(\"Invalid operation: %#v != %#v (%s)\",\n \t\t\texpected, actual, err), msgAndArgs...)\n@@ -592,6 +667,9 @@ func includeElement(list interface{}, element interface{}) (ok, found bool) {\n //    assert.Contains(t, [\"Hello\", \"World\"], \"World\")\n //    assert.Contains(t, {\"Hello\": \"World\"}, \"Hello\")\n func Contains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tok, found := includeElement(s, contains)\n \tif !ok {\n@@ -612,6 +690,9 @@ func Contains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bo\n //    assert.NotContains(t, [\"Hello\", \"World\"], \"Earth\")\n //    assert.NotContains(t, {\"Hello\": \"World\"}, \"Earth\")\n func NotContains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tok, found := includeElement(s, contains)\n \tif !ok {\n@@ -630,6 +711,9 @@ func NotContains(t TestingT, s, contains interface{}, msgAndArgs ...interface{})\n //\n //    assert.Subset(t, [1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\")\n func Subset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool) {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif subset == nil {\n \t\treturn true // we consider nil to be equal to the nil set\n \t}\n@@ -671,6 +755,9 @@ func Subset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok\n //\n //    assert.NotSubset(t, [1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\")\n func NotSubset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool) {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif subset == nil {\n \t\treturn Fail(t, fmt.Sprintf(\"nil is the empty set which is a subset of every set\"), msgAndArgs...)\n \t}\n@@ -713,6 +800,9 @@ func NotSubset(t TestingT, list, subset interface{}, msgAndArgs ...interface{})\n //\n // assert.ElementsMatch(t, [1, 3, 2, 3], [1, 3, 3, 2])\n func ElementsMatch(t TestingT, listA, listB interface{}, msgAndArgs ...interface{}) (ok bool) {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif isEmpty(listA) && isEmpty(listB) {\n \t\treturn true\n \t}\n@@ -763,6 +853,9 @@ func ElementsMatch(t TestingT, listA, listB interface{}, msgAndArgs ...interface\n \n // Condition uses a Comparison to assert a complex condition.\n func Condition(t TestingT, comp Comparison, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tresult := comp()\n \tif !result {\n \t\tFail(t, \"Condition failed!\", msgAndArgs...)\n@@ -800,9 +893,12 @@ func didPanic(f PanicTestFunc) (bool, interface{}) {\n //\n //   assert.Panics(t, func(){ GoCrazy() })\n func Panics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tif funcDidPanic, panicValue := didPanic(f); !funcDidPanic {\n-\t\treturn Fail(t, fmt.Sprintf(\"func %#v should panic\\n\\r\\tPanic value:\\t%v\", f, panicValue), msgAndArgs...)\n+\t\treturn Fail(t, fmt.Sprintf(\"func %#v should panic\\n\\tPanic value:\\t%#v\", f, panicValue), msgAndArgs...)\n \t}\n \n \treturn true\n@@ -813,13 +909,16 @@ func Panics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool {\n //\n //   assert.PanicsWithValue(t, \"crazy error\", func(){ GoCrazy() })\n func PanicsWithValue(t TestingT, expected interface{}, f PanicTestFunc, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tfuncDidPanic, panicValue := didPanic(f)\n \tif !funcDidPanic {\n-\t\treturn Fail(t, fmt.Sprintf(\"func %#v should panic\\n\\r\\tPanic value:\\t%v\", f, panicValue), msgAndArgs...)\n+\t\treturn Fail(t, fmt.Sprintf(\"func %#v should panic\\n\\tPanic value:\\t%#v\", f, panicValue), msgAndArgs...)\n \t}\n \tif panicValue != expected {\n-\t\treturn Fail(t, fmt.Sprintf(\"func %#v should panic with value:\\t%v\\n\\r\\tPanic value:\\t%v\", f, expected, panicValue), msgAndArgs...)\n+\t\treturn Fail(t, fmt.Sprintf(\"func %#v should panic with value:\\t%#v\\n\\tPanic value:\\t%#v\", f, expected, panicValue), msgAndArgs...)\n \t}\n \n \treturn true\n@@ -829,9 +928,12 @@ func PanicsWithValue(t TestingT, expected interface{}, f PanicTestFunc, msgAndAr\n //\n //   assert.NotPanics(t, func(){ RemainCalm() })\n func NotPanics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tif funcDidPanic, panicValue := didPanic(f); funcDidPanic {\n-\t\treturn Fail(t, fmt.Sprintf(\"func %#v should not panic\\n\\r\\tPanic value:\\t%v\", f, panicValue), msgAndArgs...)\n+\t\treturn Fail(t, fmt.Sprintf(\"func %#v should not panic\\n\\tPanic value:\\t%v\", f, panicValue), msgAndArgs...)\n \t}\n \n \treturn true\n@@ -841,6 +943,9 @@ func NotPanics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool {\n //\n //   assert.WithinDuration(t, time.Now(), time.Now(), 10*time.Second)\n func WithinDuration(t TestingT, expected, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tdt := expected.Sub(actual)\n \tif dt < -delta || dt > delta {\n@@ -890,6 +995,9 @@ func toFloat(x interface{}) (float64, bool) {\n //\n // \t assert.InDelta(t, math.Pi, (22 / 7.0), 0.01)\n func InDelta(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \taf, aok := toFloat(expected)\n \tbf, bok := toFloat(actual)\n@@ -916,6 +1024,9 @@ func InDelta(t TestingT, expected, actual interface{}, delta float64, msgAndArgs\n \n // InDeltaSlice is the same as InDelta, except it compares two slices.\n func InDeltaSlice(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif expected == nil || actual == nil ||\n \t\treflect.TypeOf(actual).Kind() != reflect.Slice ||\n \t\treflect.TypeOf(expected).Kind() != reflect.Slice {\n@@ -937,6 +1048,9 @@ func InDeltaSlice(t TestingT, expected, actual interface{}, delta float64, msgAn\n \n // InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func InDeltaMapValues(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif expected == nil || actual == nil ||\n \t\treflect.TypeOf(actual).Kind() != reflect.Map ||\n \t\treflect.TypeOf(expected).Kind() != reflect.Map {\n@@ -994,6 +1108,9 @@ func calcRelativeError(expected, actual interface{}) (float64, error) {\n \n // InEpsilon asserts that expected and actual have a relative error less than epsilon\n func InEpsilon(t TestingT, expected, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tactualEpsilon, err := calcRelativeError(expected, actual)\n \tif err != nil {\n \t\treturn Fail(t, err.Error(), msgAndArgs...)\n@@ -1008,6 +1125,9 @@ func InEpsilon(t TestingT, expected, actual interface{}, epsilon float64, msgAnd\n \n // InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.\n func InEpsilonSlice(t TestingT, expected, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif expected == nil || actual == nil ||\n \t\treflect.TypeOf(actual).Kind() != reflect.Slice ||\n \t\treflect.TypeOf(expected).Kind() != reflect.Slice {\n@@ -1038,6 +1158,9 @@ func InEpsilonSlice(t TestingT, expected, actual interface{}, epsilon float64, m\n //\t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func NoError(t TestingT, err error, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif err != nil {\n \t\treturn Fail(t, fmt.Sprintf(\"Received unexpected error:\\n%+v\", err), msgAndArgs...)\n \t}\n@@ -1052,6 +1175,9 @@ func NoError(t TestingT, err error, msgAndArgs ...interface{}) bool {\n //\t   assert.Equal(t, expectedError, err)\n //   }\n func Error(t TestingT, err error, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tif err == nil {\n \t\treturn Fail(t, \"An error is expected but got nil.\", msgAndArgs...)\n@@ -1066,6 +1192,9 @@ func Error(t TestingT, err error, msgAndArgs ...interface{}) bool {\n //   actualObj, err := SomeFunction()\n //   assert.EqualError(t, err,  expectedErrorString)\n func EqualError(t TestingT, theError error, errString string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif !Error(t, theError, msgAndArgs...) {\n \t\treturn false\n \t}\n@@ -1099,6 +1228,9 @@ func matchRegexp(rx interface{}, str interface{}) bool {\n //  assert.Regexp(t, regexp.MustCompile(\"start\"), \"it's starting\")\n //  assert.Regexp(t, \"start...$\", \"it's not starting\")\n func Regexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \n \tmatch := matchRegexp(rx, str)\n \n@@ -1114,6 +1246,9 @@ func Regexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface\n //  assert.NotRegexp(t, regexp.MustCompile(\"starts\"), \"it's starting\")\n //  assert.NotRegexp(t, \"^start\", \"it's not starting\")\n func NotRegexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tmatch := matchRegexp(rx, str)\n \n \tif match {\n@@ -1126,6 +1261,9 @@ func NotRegexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interf\n \n // Zero asserts that i is the zero value for its type.\n func Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif i != nil && !reflect.DeepEqual(i, reflect.Zero(reflect.TypeOf(i)).Interface()) {\n \t\treturn Fail(t, fmt.Sprintf(\"Should be zero, but was %v\", i), msgAndArgs...)\n \t}\n@@ -1134,6 +1272,9 @@ func Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool {\n \n // NotZero asserts that i is not the zero value for its type.\n func NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tif i == nil || reflect.DeepEqual(i, reflect.Zero(reflect.TypeOf(i)).Interface()) {\n \t\treturn Fail(t, fmt.Sprintf(\"Should not be zero, but was %v\", i), msgAndArgs...)\n \t}\n@@ -1142,6 +1283,9 @@ func NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool {\n \n // FileExists checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func FileExists(t TestingT, path string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tinfo, err := os.Lstat(path)\n \tif err != nil {\n \t\tif os.IsNotExist(err) {\n@@ -1157,6 +1301,9 @@ func FileExists(t TestingT, path string, msgAndArgs ...interface{}) bool {\n \n // DirExists checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func DirExists(t TestingT, path string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tinfo, err := os.Lstat(path)\n \tif err != nil {\n \t\tif os.IsNotExist(err) {\n@@ -1174,6 +1321,9 @@ func DirExists(t TestingT, path string, msgAndArgs ...interface{}) bool {\n //\n //  assert.JSONEq(t, `{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`)\n func JSONEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tvar expectedJSONAsInterface, actualJSONAsInterface interface{}\n \n \tif err := json.Unmarshal([]byte(expected), &expectedJSONAsInterface); err != nil {\n@@ -1199,7 +1349,7 @@ func typeAndKind(v interface{}) (reflect.Type, reflect.Kind) {\n }\n \n // diff returns a diff of both values as long as both are of the same type and\n-// are a struct, map, slice or array. Otherwise it returns an empty string.\n+// are a struct, map, slice, array or string. Otherwise it returns an empty string.\n func diff(expected interface{}, actual interface{}) string {\n \tif expected == nil || actual == nil {\n \t\treturn \"\"\n@@ -1212,12 +1362,18 @@ func diff(expected interface{}, actual interface{}) string {\n \t\treturn \"\"\n \t}\n \n-\tif ek != reflect.Struct && ek != reflect.Map && ek != reflect.Slice && ek != reflect.Array {\n+\tif ek != reflect.Struct && ek != reflect.Map && ek != reflect.Slice && ek != reflect.Array && ek != reflect.String {\n \t\treturn \"\"\n \t}\n \n-\te := spewConfig.Sdump(expected)\n-\ta := spewConfig.Sdump(actual)\n+\tvar e, a string\n+\tif et != reflect.TypeOf(\"\") {\n+\t\te = spewConfig.Sdump(expected)\n+\t\ta = spewConfig.Sdump(actual)\n+\t} else {\n+\t\te = expected.(string)\n+\t\ta = actual.(string)\n+\t}\n \n \tdiff, _ := difflib.GetUnifiedDiffString(difflib.UnifiedDiff{\n \t\tA:        difflib.SplitLines(e),\n@@ -1254,3 +1410,7 @@ var spewConfig = spew.ConfigState{\n \tDisableCapacities:       true,\n \tSortKeys:                true,\n }\n+\n+type tHelper interface {\n+\tHelper()\n+}"
    },
    {
      "sha": "df46fa777acb3b8bc6c58371d8c48375a6a623de",
      "filename": "backend/vendor/github.com/stretchr/testify/assert/http_assertions.go",
      "status": "modified",
      "additions": 19,
      "deletions": 3,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/http_assertions.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/assert/http_assertions.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/assert/http_assertions.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -12,10 +12,11 @@ import (\n // an error if building a new request fails.\n func httpCode(handler http.HandlerFunc, method, url string, values url.Values) (int, error) {\n \tw := httptest.NewRecorder()\n-\treq, err := http.NewRequest(method, url+\"?\"+values.Encode(), nil)\n+\treq, err := http.NewRequest(method, url, nil)\n \tif err != nil {\n \t\treturn -1, err\n \t}\n+\treq.URL.RawQuery = values.Encode()\n \thandler(w, req)\n \treturn w.Code, nil\n }\n@@ -26,6 +27,9 @@ func httpCode(handler http.HandlerFunc, method, url string, values url.Values) (\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPSuccess(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tcode, err := httpCode(handler, method, url, values)\n \tif err != nil {\n \t\tFail(t, fmt.Sprintf(\"Failed to build test request, got error: %s\", err))\n@@ -46,6 +50,9 @@ func HTTPSuccess(t TestingT, handler http.HandlerFunc, method, url string, value\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPRedirect(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tcode, err := httpCode(handler, method, url, values)\n \tif err != nil {\n \t\tFail(t, fmt.Sprintf(\"Failed to build test request, got error: %s\", err))\n@@ -66,6 +73,9 @@ func HTTPRedirect(t TestingT, handler http.HandlerFunc, method, url string, valu\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPError(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tcode, err := httpCode(handler, method, url, values)\n \tif err != nil {\n \t\tFail(t, fmt.Sprintf(\"Failed to build test request, got error: %s\", err))\n@@ -95,10 +105,13 @@ func HTTPBody(handler http.HandlerFunc, method, url string, values url.Values) s\n // HTTPBodyContains asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  assert.HTTPBodyContains(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  assert.HTTPBodyContains(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyContains(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tbody := HTTPBody(handler, method, url, values)\n \n \tcontains := strings.Contains(body, fmt.Sprint(str))\n@@ -112,10 +125,13 @@ func HTTPBodyContains(t TestingT, handler http.HandlerFunc, method, url string,\n // HTTPBodyNotContains asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  assert.HTTPBodyNotContains(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  assert.HTTPBodyNotContains(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyNotContains(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tbody := HTTPBody(handler, method, url, values)\n \n \tcontains := strings.Contains(body, fmt.Sprint(str))"
    },
    {
      "sha": "535f293490ce97e9ee271793c00ff56935e07e24",
      "filename": "backend/vendor/github.com/stretchr/testify/require/require.go",
      "status": "modified",
      "additions": 544,
      "deletions": 184,
      "changes": 728,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/require/require.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -14,16 +14,24 @@ import (\n \n // Condition uses a Comparison to assert a complex condition.\n func Condition(t TestingT, comp assert.Comparison, msgAndArgs ...interface{}) {\n-\tif !assert.Condition(t, comp, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Condition(t, comp, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Conditionf uses a Comparison to assert a complex condition.\n func Conditionf(t TestingT, comp assert.Comparison, msg string, args ...interface{}) {\n-\tif !assert.Conditionf(t, comp, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Conditionf(t, comp, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Contains asserts that the specified string, list(array, slice...) or map contains the\n@@ -33,9 +41,13 @@ func Conditionf(t TestingT, comp assert.Comparison, msg string, args ...interfac\n //    assert.Contains(t, [\"Hello\", \"World\"], \"World\")\n //    assert.Contains(t, {\"Hello\": \"World\"}, \"Hello\")\n func Contains(t TestingT, s interface{}, contains interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Contains(t, s, contains, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Contains(t, s, contains, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Containsf asserts that the specified string, list(array, slice...) or map contains the\n@@ -45,23 +57,35 @@ func Contains(t TestingT, s interface{}, contains interface{}, msgAndArgs ...int\n //    assert.Containsf(t, [\"Hello\", \"World\"], \"World\", \"error message %s\", \"formatted\")\n //    assert.Containsf(t, {\"Hello\": \"World\"}, \"Hello\", \"error message %s\", \"formatted\")\n func Containsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) {\n-\tif !assert.Containsf(t, s, contains, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Containsf(t, s, contains, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // DirExists checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func DirExists(t TestingT, path string, msgAndArgs ...interface{}) {\n-\tif !assert.DirExists(t, path, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.DirExists(t, path, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // DirExistsf checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func DirExistsf(t TestingT, path string, msg string, args ...interface{}) {\n-\tif !assert.DirExistsf(t, path, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.DirExistsf(t, path, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // ElementsMatch asserts that the specified listA(array, slice...) is equal to specified\n@@ -70,9 +94,13 @@ func DirExistsf(t TestingT, path string, msg string, args ...interface{}) {\n //\n // assert.ElementsMatch(t, [1, 3, 2, 3], [1, 3, 3, 2])\n func ElementsMatch(t TestingT, listA interface{}, listB interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.ElementsMatch(t, listA, listB, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.ElementsMatch(t, listA, listB, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified\n@@ -81,29 +109,41 @@ func ElementsMatch(t TestingT, listA interface{}, listB interface{}, msgAndArgs\n //\n // assert.ElementsMatchf(t, [1, 3, 2, 3], [1, 3, 3, 2], \"error message %s\", \"formatted\")\n func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) {\n-\tif !assert.ElementsMatchf(t, listA, listB, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.ElementsMatchf(t, listA, listB, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Empty asserts that the specified object is empty.  I.e. nil, \"\", false, 0 or either\n // a slice or a channel with len == 0.\n //\n //  assert.Empty(t, obj)\n func Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Empty(t, object, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Empty(t, object, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Emptyf asserts that the specified object is empty.  I.e. nil, \"\", false, 0 or either\n // a slice or a channel with len == 0.\n //\n //  assert.Emptyf(t, obj, \"error message %s\", \"formatted\")\n func Emptyf(t TestingT, object interface{}, msg string, args ...interface{}) {\n-\tif !assert.Emptyf(t, object, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Emptyf(t, object, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Equal asserts that two objects are equal.\n@@ -114,9 +154,13 @@ func Emptyf(t TestingT, object interface{}, msg string, args ...interface{}) {\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func Equal(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Equal(t, expected, actual, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Equal(t, expected, actual, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // EqualError asserts that a function returned an error (i.e. not `nil`)\n@@ -125,9 +169,13 @@ func Equal(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...i\n //   actualObj, err := SomeFunction()\n //   assert.EqualError(t, err,  expectedErrorString)\n func EqualError(t TestingT, theError error, errString string, msgAndArgs ...interface{}) {\n-\tif !assert.EqualError(t, theError, errString, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.EqualError(t, theError, errString, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // EqualErrorf asserts that a function returned an error (i.e. not `nil`)\n@@ -136,29 +184,41 @@ func EqualError(t TestingT, theError error, errString string, msgAndArgs ...inte\n //   actualObj, err := SomeFunction()\n //   assert.EqualErrorf(t, err,  expectedErrorString, \"error message %s\", \"formatted\")\n func EqualErrorf(t TestingT, theError error, errString string, msg string, args ...interface{}) {\n-\tif !assert.EqualErrorf(t, theError, errString, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.EqualErrorf(t, theError, errString, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // EqualValues asserts that two objects are equal or convertable to the same types\n // and equal.\n //\n //    assert.EqualValues(t, uint32(123), int32(123))\n func EqualValues(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.EqualValues(t, expected, actual, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.EqualValues(t, expected, actual, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // EqualValuesf asserts that two objects are equal or convertable to the same types\n // and equal.\n //\n //    assert.EqualValuesf(t, uint32(123, \"error message %s\", \"formatted\"), int32(123))\n func EqualValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) {\n-\tif !assert.EqualValuesf(t, expected, actual, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.EqualValuesf(t, expected, actual, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Equalf asserts that two objects are equal.\n@@ -169,9 +229,13 @@ func EqualValuesf(t TestingT, expected interface{}, actual interface{}, msg stri\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func Equalf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) {\n-\tif !assert.Equalf(t, expected, actual, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Equalf(t, expected, actual, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Error asserts that a function returned an error (i.e. not `nil`).\n@@ -181,9 +245,13 @@ func Equalf(t TestingT, expected interface{}, actual interface{}, msg string, ar\n // \t   assert.Equal(t, expectedError, err)\n //   }\n func Error(t TestingT, err error, msgAndArgs ...interface{}) {\n-\tif !assert.Error(t, err, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Error(t, err, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Errorf asserts that a function returned an error (i.e. not `nil`).\n@@ -193,135 +261,195 @@ func Error(t TestingT, err error, msgAndArgs ...interface{}) {\n // \t   assert.Equal(t, expectedErrorf, err)\n //   }\n func Errorf(t TestingT, err error, msg string, args ...interface{}) {\n-\tif !assert.Errorf(t, err, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Errorf(t, err, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Exactly asserts that two objects are equal in value and type.\n //\n //    assert.Exactly(t, int32(123), int64(123))\n func Exactly(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Exactly(t, expected, actual, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Exactly(t, expected, actual, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Exactlyf asserts that two objects are equal in value and type.\n //\n //    assert.Exactlyf(t, int32(123, \"error message %s\", \"formatted\"), int64(123))\n func Exactlyf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) {\n-\tif !assert.Exactlyf(t, expected, actual, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Exactlyf(t, expected, actual, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Fail reports a failure through\n func Fail(t TestingT, failureMessage string, msgAndArgs ...interface{}) {\n-\tif !assert.Fail(t, failureMessage, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Fail(t, failureMessage, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // FailNow fails test\n func FailNow(t TestingT, failureMessage string, msgAndArgs ...interface{}) {\n-\tif !assert.FailNow(t, failureMessage, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.FailNow(t, failureMessage, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // FailNowf fails test\n func FailNowf(t TestingT, failureMessage string, msg string, args ...interface{}) {\n-\tif !assert.FailNowf(t, failureMessage, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.FailNowf(t, failureMessage, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Failf reports a failure through\n func Failf(t TestingT, failureMessage string, msg string, args ...interface{}) {\n-\tif !assert.Failf(t, failureMessage, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Failf(t, failureMessage, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // False asserts that the specified value is false.\n //\n //    assert.False(t, myBool)\n func False(t TestingT, value bool, msgAndArgs ...interface{}) {\n-\tif !assert.False(t, value, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.False(t, value, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Falsef asserts that the specified value is false.\n //\n //    assert.Falsef(t, myBool, \"error message %s\", \"formatted\")\n func Falsef(t TestingT, value bool, msg string, args ...interface{}) {\n-\tif !assert.Falsef(t, value, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Falsef(t, value, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // FileExists checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func FileExists(t TestingT, path string, msgAndArgs ...interface{}) {\n-\tif !assert.FileExists(t, path, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.FileExists(t, path, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // FileExistsf checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func FileExistsf(t TestingT, path string, msg string, args ...interface{}) {\n-\tif !assert.FileExistsf(t, path, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.FileExistsf(t, path, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // HTTPBodyContains asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  assert.HTTPBodyContains(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  assert.HTTPBodyContains(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyContains(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.HTTPBodyContains(t, handler, method, url, values, str, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPBodyContains(t, handler, method, url, values, str, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // HTTPBodyContainsf asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  assert.HTTPBodyContainsf(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  assert.HTTPBodyContainsf(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) {\n-\tif !assert.HTTPBodyContainsf(t, handler, method, url, values, str, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPBodyContainsf(t, handler, method, url, values, str, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // HTTPBodyNotContains asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  assert.HTTPBodyNotContains(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  assert.HTTPBodyNotContains(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyNotContains(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.HTTPBodyNotContains(t, handler, method, url, values, str, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPBodyNotContains(t, handler, method, url, values, str, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // HTTPBodyNotContainsf asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  assert.HTTPBodyNotContainsf(t, myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  assert.HTTPBodyNotContainsf(t, myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPBodyNotContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) {\n-\tif !assert.HTTPBodyNotContainsf(t, handler, method, url, values, str, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPBodyNotContainsf(t, handler, method, url, values, str, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // HTTPError asserts that a specified handler returns an error status code.\n@@ -330,9 +458,13 @@ func HTTPBodyNotContainsf(t TestingT, handler http.HandlerFunc, method string, u\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPError(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) {\n-\tif !assert.HTTPError(t, handler, method, url, values, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPError(t, handler, method, url, values, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // HTTPErrorf asserts that a specified handler returns an error status code.\n@@ -341,9 +473,13 @@ func HTTPError(t TestingT, handler http.HandlerFunc, method string, url string,\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func HTTPErrorf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) {\n-\tif !assert.HTTPErrorf(t, handler, method, url, values, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPErrorf(t, handler, method, url, values, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // HTTPRedirect asserts that a specified handler returns a redirect status code.\n@@ -352,9 +488,13 @@ func HTTPErrorf(t TestingT, handler http.HandlerFunc, method string, url string,\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPRedirect(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) {\n-\tif !assert.HTTPRedirect(t, handler, method, url, values, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPRedirect(t, handler, method, url, values, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // HTTPRedirectf asserts that a specified handler returns a redirect status code.\n@@ -363,9 +503,13 @@ func HTTPRedirect(t TestingT, handler http.HandlerFunc, method string, url strin\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func HTTPRedirectf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) {\n-\tif !assert.HTTPRedirectf(t, handler, method, url, values, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPRedirectf(t, handler, method, url, values, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // HTTPSuccess asserts that a specified handler returns a success status code.\n@@ -374,9 +518,13 @@ func HTTPRedirectf(t TestingT, handler http.HandlerFunc, method string, url stri\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPSuccess(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) {\n-\tif !assert.HTTPSuccess(t, handler, method, url, values, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPSuccess(t, handler, method, url, values, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // HTTPSuccessf asserts that a specified handler returns a success status code.\n@@ -385,171 +533,255 @@ func HTTPSuccess(t TestingT, handler http.HandlerFunc, method string, url string\n //\n // Returns whether the assertion was successful (true) or not (false).\n func HTTPSuccessf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) {\n-\tif !assert.HTTPSuccessf(t, handler, method, url, values, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.HTTPSuccessf(t, handler, method, url, values, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Implements asserts that an object is implemented by the specified interface.\n //\n //    assert.Implements(t, (*MyInterface)(nil), new(MyObject))\n func Implements(t TestingT, interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Implements(t, interfaceObject, object, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Implements(t, interfaceObject, object, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Implementsf asserts that an object is implemented by the specified interface.\n //\n //    assert.Implementsf(t, (*MyInterface, \"error message %s\", \"formatted\")(nil), new(MyObject))\n func Implementsf(t TestingT, interfaceObject interface{}, object interface{}, msg string, args ...interface{}) {\n-\tif !assert.Implementsf(t, interfaceObject, object, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Implementsf(t, interfaceObject, object, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // InDelta asserts that the two numerals are within delta of each other.\n //\n // \t assert.InDelta(t, math.Pi, (22 / 7.0), 0.01)\n func InDelta(t TestingT, expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) {\n-\tif !assert.InDelta(t, expected, actual, delta, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.InDelta(t, expected, actual, delta, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func InDeltaMapValues(t TestingT, expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) {\n-\tif !assert.InDeltaMapValues(t, expected, actual, delta, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.InDeltaMapValues(t, expected, actual, delta, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func InDeltaMapValuesf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) {\n-\tif !assert.InDeltaMapValuesf(t, expected, actual, delta, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.InDeltaMapValuesf(t, expected, actual, delta, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // InDeltaSlice is the same as InDelta, except it compares two slices.\n func InDeltaSlice(t TestingT, expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) {\n-\tif !assert.InDeltaSlice(t, expected, actual, delta, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.InDeltaSlice(t, expected, actual, delta, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // InDeltaSlicef is the same as InDelta, except it compares two slices.\n func InDeltaSlicef(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) {\n-\tif !assert.InDeltaSlicef(t, expected, actual, delta, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.InDeltaSlicef(t, expected, actual, delta, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // InDeltaf asserts that the two numerals are within delta of each other.\n //\n // \t assert.InDeltaf(t, math.Pi, (22 / 7.0, \"error message %s\", \"formatted\"), 0.01)\n func InDeltaf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) {\n-\tif !assert.InDeltaf(t, expected, actual, delta, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.InDeltaf(t, expected, actual, delta, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // InEpsilon asserts that expected and actual have a relative error less than epsilon\n func InEpsilon(t TestingT, expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) {\n-\tif !assert.InEpsilon(t, expected, actual, epsilon, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.InEpsilon(t, expected, actual, epsilon, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.\n func InEpsilonSlice(t TestingT, expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) {\n-\tif !assert.InEpsilonSlice(t, expected, actual, epsilon, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.InEpsilonSlice(t, expected, actual, epsilon, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.\n func InEpsilonSlicef(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) {\n-\tif !assert.InEpsilonSlicef(t, expected, actual, epsilon, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.InEpsilonSlicef(t, expected, actual, epsilon, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // InEpsilonf asserts that expected and actual have a relative error less than epsilon\n func InEpsilonf(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) {\n-\tif !assert.InEpsilonf(t, expected, actual, epsilon, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.InEpsilonf(t, expected, actual, epsilon, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // IsType asserts that the specified objects are of the same type.\n func IsType(t TestingT, expectedType interface{}, object interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.IsType(t, expectedType, object, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.IsType(t, expectedType, object, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // IsTypef asserts that the specified objects are of the same type.\n func IsTypef(t TestingT, expectedType interface{}, object interface{}, msg string, args ...interface{}) {\n-\tif !assert.IsTypef(t, expectedType, object, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.IsTypef(t, expectedType, object, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // JSONEq asserts that two JSON strings are equivalent.\n //\n //  assert.JSONEq(t, `{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`)\n func JSONEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) {\n-\tif !assert.JSONEq(t, expected, actual, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.JSONEq(t, expected, actual, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // JSONEqf asserts that two JSON strings are equivalent.\n //\n //  assert.JSONEqf(t, `{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`, \"error message %s\", \"formatted\")\n func JSONEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) {\n-\tif !assert.JSONEqf(t, expected, actual, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.JSONEqf(t, expected, actual, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Len asserts that the specified object has specific length.\n // Len also fails if the object has a type that len() not accept.\n //\n //    assert.Len(t, mySlice, 3)\n func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{}) {\n-\tif !assert.Len(t, object, length, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Len(t, object, length, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Lenf asserts that the specified object has specific length.\n // Lenf also fails if the object has a type that len() not accept.\n //\n //    assert.Lenf(t, mySlice, 3, \"error message %s\", \"formatted\")\n func Lenf(t TestingT, object interface{}, length int, msg string, args ...interface{}) {\n-\tif !assert.Lenf(t, object, length, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Lenf(t, object, length, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Nil asserts that the specified object is nil.\n //\n //    assert.Nil(t, err)\n func Nil(t TestingT, object interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Nil(t, object, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Nil(t, object, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Nilf asserts that the specified object is nil.\n //\n //    assert.Nilf(t, err, \"error message %s\", \"formatted\")\n func Nilf(t TestingT, object interface{}, msg string, args ...interface{}) {\n-\tif !assert.Nilf(t, object, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Nilf(t, object, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // NoError asserts that a function returned no error (i.e. `nil`).\n@@ -559,9 +791,13 @@ func Nilf(t TestingT, object interface{}, msg string, args ...interface{}) {\n // \t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func NoError(t TestingT, err error, msgAndArgs ...interface{}) {\n-\tif !assert.NoError(t, err, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NoError(t, err, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NoErrorf asserts that a function returned no error (i.e. `nil`).\n@@ -571,9 +807,13 @@ func NoError(t TestingT, err error, msgAndArgs ...interface{}) {\n // \t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func NoErrorf(t TestingT, err error, msg string, args ...interface{}) {\n-\tif !assert.NoErrorf(t, err, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NoErrorf(t, err, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the\n@@ -583,9 +823,13 @@ func NoErrorf(t TestingT, err error, msg string, args ...interface{}) {\n //    assert.NotContains(t, [\"Hello\", \"World\"], \"Earth\")\n //    assert.NotContains(t, {\"Hello\": \"World\"}, \"Earth\")\n func NotContains(t TestingT, s interface{}, contains interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.NotContains(t, s, contains, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotContains(t, s, contains, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // NotContainsf asserts that the specified string, list(array, slice...) or map does NOT contain the\n@@ -595,9 +839,13 @@ func NotContains(t TestingT, s interface{}, contains interface{}, msgAndArgs ...\n //    assert.NotContainsf(t, [\"Hello\", \"World\"], \"Earth\", \"error message %s\", \"formatted\")\n //    assert.NotContainsf(t, {\"Hello\": \"World\"}, \"Earth\", \"error message %s\", \"formatted\")\n func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) {\n-\tif !assert.NotContainsf(t, s, contains, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotContainsf(t, s, contains, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, \"\", false, 0 or either\n@@ -607,9 +855,13 @@ func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, a\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.NotEmpty(t, object, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotEmpty(t, object, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, \"\", false, 0 or either\n@@ -619,9 +871,13 @@ func NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) {\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func NotEmptyf(t TestingT, object interface{}, msg string, args ...interface{}) {\n-\tif !assert.NotEmptyf(t, object, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotEmptyf(t, object, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // NotEqual asserts that the specified values are NOT equal.\n@@ -631,9 +887,13 @@ func NotEmptyf(t TestingT, object interface{}, msg string, args ...interface{})\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func NotEqual(t TestingT, expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.NotEqual(t, expected, actual, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotEqual(t, expected, actual, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotEqualf asserts that the specified values are NOT equal.\n@@ -643,225 +903,325 @@ func NotEqual(t TestingT, expected interface{}, actual interface{}, msgAndArgs .\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func NotEqualf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) {\n-\tif !assert.NotEqualf(t, expected, actual, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotEqualf(t, expected, actual, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotNil asserts that the specified object is not nil.\n //\n //    assert.NotNil(t, err)\n func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.NotNil(t, object, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotNil(t, object, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // NotNilf asserts that the specified object is not nil.\n //\n //    assert.NotNilf(t, err, \"error message %s\", \"formatted\")\n func NotNilf(t TestingT, object interface{}, msg string, args ...interface{}) {\n-\tif !assert.NotNilf(t, object, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotNilf(t, object, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.\n //\n //   assert.NotPanics(t, func(){ RemainCalm() })\n func NotPanics(t TestingT, f assert.PanicTestFunc, msgAndArgs ...interface{}) {\n-\tif !assert.NotPanics(t, f, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotPanics(t, f, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.\n //\n //   assert.NotPanicsf(t, func(){ RemainCalm() }, \"error message %s\", \"formatted\")\n func NotPanicsf(t TestingT, f assert.PanicTestFunc, msg string, args ...interface{}) {\n-\tif !assert.NotPanicsf(t, f, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotPanicsf(t, f, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotRegexp asserts that a specified regexp does not match a string.\n //\n //  assert.NotRegexp(t, regexp.MustCompile(\"starts\"), \"it's starting\")\n //  assert.NotRegexp(t, \"^start\", \"it's not starting\")\n func NotRegexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.NotRegexp(t, rx, str, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotRegexp(t, rx, str, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotRegexpf asserts that a specified regexp does not match a string.\n //\n //  assert.NotRegexpf(t, regexp.MustCompile(\"starts\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  assert.NotRegexpf(t, \"^start\", \"it's not starting\", \"error message %s\", \"formatted\")\n func NotRegexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) {\n-\tif !assert.NotRegexpf(t, rx, str, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotRegexpf(t, rx, str, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // NotSubset asserts that the specified list(array, slice...) contains not all\n // elements given in the specified subset(array, slice...).\n //\n //    assert.NotSubset(t, [1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\")\n func NotSubset(t TestingT, list interface{}, subset interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.NotSubset(t, list, subset, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotSubset(t, list, subset, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotSubsetf asserts that the specified list(array, slice...) contains not all\n // elements given in the specified subset(array, slice...).\n //\n //    assert.NotSubsetf(t, [1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\", \"error message %s\", \"formatted\")\n func NotSubsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) {\n-\tif !assert.NotSubsetf(t, list, subset, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotSubsetf(t, list, subset, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // NotZero asserts that i is not the zero value for its type.\n func NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.NotZero(t, i, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.NotZero(t, i, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // NotZerof asserts that i is not the zero value for its type.\n func NotZerof(t TestingT, i interface{}, msg string, args ...interface{}) {\n-\tif !assert.NotZerof(t, i, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.NotZerof(t, i, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Panics asserts that the code inside the specified PanicTestFunc panics.\n //\n //   assert.Panics(t, func(){ GoCrazy() })\n func Panics(t TestingT, f assert.PanicTestFunc, msgAndArgs ...interface{}) {\n-\tif !assert.Panics(t, f, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Panics(t, f, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that\n // the recovered panic value equals the expected panic value.\n //\n //   assert.PanicsWithValue(t, \"crazy error\", func(){ GoCrazy() })\n func PanicsWithValue(t TestingT, expected interface{}, f assert.PanicTestFunc, msgAndArgs ...interface{}) {\n-\tif !assert.PanicsWithValue(t, expected, f, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.PanicsWithValue(t, expected, f, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that\n // the recovered panic value equals the expected panic value.\n //\n //   assert.PanicsWithValuef(t, \"crazy error\", func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func PanicsWithValuef(t TestingT, expected interface{}, f assert.PanicTestFunc, msg string, args ...interface{}) {\n-\tif !assert.PanicsWithValuef(t, expected, f, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.PanicsWithValuef(t, expected, f, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Panicsf asserts that the code inside the specified PanicTestFunc panics.\n //\n //   assert.Panicsf(t, func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func Panicsf(t TestingT, f assert.PanicTestFunc, msg string, args ...interface{}) {\n-\tif !assert.Panicsf(t, f, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Panicsf(t, f, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Regexp asserts that a specified regexp matches a string.\n //\n //  assert.Regexp(t, regexp.MustCompile(\"start\"), \"it's starting\")\n //  assert.Regexp(t, \"start...$\", \"it's not starting\")\n func Regexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Regexp(t, rx, str, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Regexp(t, rx, str, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Regexpf asserts that a specified regexp matches a string.\n //\n //  assert.Regexpf(t, regexp.MustCompile(\"start\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  assert.Regexpf(t, \"start...$\", \"it's not starting\", \"error message %s\", \"formatted\")\n func Regexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) {\n-\tif !assert.Regexpf(t, rx, str, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Regexpf(t, rx, str, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Subset asserts that the specified list(array, slice...) contains all\n // elements given in the specified subset(array, slice...).\n //\n //    assert.Subset(t, [1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\")\n func Subset(t TestingT, list interface{}, subset interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Subset(t, list, subset, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Subset(t, list, subset, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Subsetf asserts that the specified list(array, slice...) contains all\n // elements given in the specified subset(array, slice...).\n //\n //    assert.Subsetf(t, [1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\", \"error message %s\", \"formatted\")\n func Subsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) {\n-\tif !assert.Subsetf(t, list, subset, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Subsetf(t, list, subset, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // True asserts that the specified value is true.\n //\n //    assert.True(t, myBool)\n func True(t TestingT, value bool, msgAndArgs ...interface{}) {\n-\tif !assert.True(t, value, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.True(t, value, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Truef asserts that the specified value is true.\n //\n //    assert.Truef(t, myBool, \"error message %s\", \"formatted\")\n func Truef(t TestingT, value bool, msg string, args ...interface{}) {\n-\tif !assert.Truef(t, value, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Truef(t, value, msg, args...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // WithinDuration asserts that the two times are within duration delta of each other.\n //\n //   assert.WithinDuration(t, time.Now(), time.Now(), 10*time.Second)\n func WithinDuration(t TestingT, expected time.Time, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) {\n-\tif !assert.WithinDuration(t, expected, actual, delta, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.WithinDuration(t, expected, actual, delta, msgAndArgs...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // WithinDurationf asserts that the two times are within duration delta of each other.\n //\n //   assert.WithinDurationf(t, time.Now(), time.Now(), 10*time.Second, \"error message %s\", \"formatted\")\n func WithinDurationf(t TestingT, expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) {\n-\tif !assert.WithinDurationf(t, expected, actual, delta, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.WithinDurationf(t, expected, actual, delta, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }\n \n // Zero asserts that i is the zero value for its type.\n func Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) {\n-\tif !assert.Zero(t, i, msgAndArgs...) {\n-\t\tt.FailNow()\n+\tif assert.Zero(t, i, msgAndArgs...) {\n+\t\treturn\n \t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n+\tt.FailNow()\n }\n \n // Zerof asserts that i is the zero value for its type.\n func Zerof(t TestingT, i interface{}, msg string, args ...interface{}) {\n-\tif !assert.Zerof(t, i, msg, args...) {\n-\t\tt.FailNow()\n+\tif assert.Zerof(t, i, msg, args...) {\n+\t\treturn\n+\t}\n+\tif h, ok := t.(tHelper); ok {\n+\t\th.Helper()\n \t}\n+\tt.FailNow()\n }"
    },
    {
      "sha": "6ffc751b5e507bf3d8b07447bfac4d63230fa1e2",
      "filename": "backend/vendor/github.com/stretchr/testify/require/require.go.tmpl",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require.go.tmpl",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require.go.tmpl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/require/require.go.tmpl?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,6 +1,6 @@\n {{.Comment}}\n func {{.DocInfo.Name}}(t TestingT, {{.Params}}) {\n-\tif !assert.{{.DocInfo.Name}}(t, {{.ForwardedParams}}) {\n-\t\tt.FailNow()\n-\t}\n+\tif assert.{{.DocInfo.Name}}(t, {{.ForwardedParams}}) { return }\n+\tif h, ok := t.(tHelper); ok { h.Helper() }\n+\tt.FailNow()\n }"
    },
    {
      "sha": "9fe41dbdc0cb15506d682bea563da92e5cc08f60",
      "filename": "backend/vendor/github.com/stretchr/testify/require/require_forward.go",
      "status": "modified",
      "additions": 274,
      "deletions": 4,
      "changes": 278,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require_forward.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require_forward.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/require/require_forward.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -14,11 +14,17 @@ import (\n \n // Condition uses a Comparison to assert a complex condition.\n func (a *Assertions) Condition(comp assert.Comparison, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tCondition(a.t, comp, msgAndArgs...)\n }\n \n // Conditionf uses a Comparison to assert a complex condition.\n func (a *Assertions) Conditionf(comp assert.Comparison, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tConditionf(a.t, comp, msg, args...)\n }\n \n@@ -29,6 +35,9 @@ func (a *Assertions) Conditionf(comp assert.Comparison, msg string, args ...inte\n //    a.Contains([\"Hello\", \"World\"], \"World\")\n //    a.Contains({\"Hello\": \"World\"}, \"Hello\")\n func (a *Assertions) Contains(s interface{}, contains interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tContains(a.t, s, contains, msgAndArgs...)\n }\n \n@@ -39,16 +48,25 @@ func (a *Assertions) Contains(s interface{}, contains interface{}, msgAndArgs ..\n //    a.Containsf([\"Hello\", \"World\"], \"World\", \"error message %s\", \"formatted\")\n //    a.Containsf({\"Hello\": \"World\"}, \"Hello\", \"error message %s\", \"formatted\")\n func (a *Assertions) Containsf(s interface{}, contains interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tContainsf(a.t, s, contains, msg, args...)\n }\n \n // DirExists checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func (a *Assertions) DirExists(path string, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tDirExists(a.t, path, msgAndArgs...)\n }\n \n // DirExistsf checks whether a directory exists in the given path. It also fails if the path is a file rather a directory or there is an error checking whether it exists.\n func (a *Assertions) DirExistsf(path string, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tDirExistsf(a.t, path, msg, args...)\n }\n \n@@ -58,6 +76,9 @@ func (a *Assertions) DirExistsf(path string, msg string, args ...interface{}) {\n //\n // a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])\n func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tElementsMatch(a.t, listA, listB, msgAndArgs...)\n }\n \n@@ -67,6 +88,9 @@ func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndA\n //\n // a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], \"error message %s\", \"formatted\")\n func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tElementsMatchf(a.t, listA, listB, msg, args...)\n }\n \n@@ -75,6 +99,9 @@ func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg st\n //\n //  a.Empty(obj)\n func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEmpty(a.t, object, msgAndArgs...)\n }\n \n@@ -83,6 +110,9 @@ func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) {\n //\n //  a.Emptyf(obj, \"error message %s\", \"formatted\")\n func (a *Assertions) Emptyf(object interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEmptyf(a.t, object, msg, args...)\n }\n \n@@ -94,6 +124,9 @@ func (a *Assertions) Emptyf(object interface{}, msg string, args ...interface{})\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func (a *Assertions) Equal(expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEqual(a.t, expected, actual, msgAndArgs...)\n }\n \n@@ -103,6 +136,9 @@ func (a *Assertions) Equal(expected interface{}, actual interface{}, msgAndArgs\n //   actualObj, err := SomeFunction()\n //   a.EqualError(err,  expectedErrorString)\n func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEqualError(a.t, theError, errString, msgAndArgs...)\n }\n \n@@ -112,6 +148,9 @@ func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...\n //   actualObj, err := SomeFunction()\n //   a.EqualErrorf(err,  expectedErrorString, \"error message %s\", \"formatted\")\n func (a *Assertions) EqualErrorf(theError error, errString string, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEqualErrorf(a.t, theError, errString, msg, args...)\n }\n \n@@ -120,6 +159,9 @@ func (a *Assertions) EqualErrorf(theError error, errString string, msg string, a\n //\n //    a.EqualValues(uint32(123), int32(123))\n func (a *Assertions) EqualValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEqualValues(a.t, expected, actual, msgAndArgs...)\n }\n \n@@ -128,6 +170,9 @@ func (a *Assertions) EqualValues(expected interface{}, actual interface{}, msgAn\n //\n //    a.EqualValuesf(uint32(123, \"error message %s\", \"formatted\"), int32(123))\n func (a *Assertions) EqualValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEqualValuesf(a.t, expected, actual, msg, args...)\n }\n \n@@ -139,6 +184,9 @@ func (a *Assertions) EqualValuesf(expected interface{}, actual interface{}, msg\n // referenced values (as opposed to the memory addresses). Function equality\n // cannot be determined and will always fail.\n func (a *Assertions) Equalf(expected interface{}, actual interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tEqualf(a.t, expected, actual, msg, args...)\n }\n \n@@ -149,6 +197,9 @@ func (a *Assertions) Equalf(expected interface{}, actual interface{}, msg string\n // \t   assert.Equal(t, expectedError, err)\n //   }\n func (a *Assertions) Error(err error, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tError(a.t, err, msgAndArgs...)\n }\n \n@@ -159,104 +210,149 @@ func (a *Assertions) Error(err error, msgAndArgs ...interface{}) {\n // \t   assert.Equal(t, expectedErrorf, err)\n //   }\n func (a *Assertions) Errorf(err error, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tErrorf(a.t, err, msg, args...)\n }\n \n // Exactly asserts that two objects are equal in value and type.\n //\n //    a.Exactly(int32(123), int64(123))\n func (a *Assertions) Exactly(expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tExactly(a.t, expected, actual, msgAndArgs...)\n }\n \n // Exactlyf asserts that two objects are equal in value and type.\n //\n //    a.Exactlyf(int32(123, \"error message %s\", \"formatted\"), int64(123))\n func (a *Assertions) Exactlyf(expected interface{}, actual interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tExactlyf(a.t, expected, actual, msg, args...)\n }\n \n // Fail reports a failure through\n func (a *Assertions) Fail(failureMessage string, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFail(a.t, failureMessage, msgAndArgs...)\n }\n \n // FailNow fails test\n func (a *Assertions) FailNow(failureMessage string, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFailNow(a.t, failureMessage, msgAndArgs...)\n }\n \n // FailNowf fails test\n func (a *Assertions) FailNowf(failureMessage string, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFailNowf(a.t, failureMessage, msg, args...)\n }\n \n // Failf reports a failure through\n func (a *Assertions) Failf(failureMessage string, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFailf(a.t, failureMessage, msg, args...)\n }\n \n // False asserts that the specified value is false.\n //\n //    a.False(myBool)\n func (a *Assertions) False(value bool, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFalse(a.t, value, msgAndArgs...)\n }\n \n // Falsef asserts that the specified value is false.\n //\n //    a.Falsef(myBool, \"error message %s\", \"formatted\")\n func (a *Assertions) Falsef(value bool, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFalsef(a.t, value, msg, args...)\n }\n \n // FileExists checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func (a *Assertions) FileExists(path string, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFileExists(a.t, path, msgAndArgs...)\n }\n \n // FileExistsf checks whether a file exists in the given path. It also fails if the path points to a directory or there is an error when trying to check the file.\n func (a *Assertions) FileExistsf(path string, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tFileExistsf(a.t, path, msg, args...)\n }\n \n // HTTPBodyContains asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  a.HTTPBodyContains(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  a.HTTPBodyContains(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPBodyContains(a.t, handler, method, url, values, str, msgAndArgs...)\n }\n \n // HTTPBodyContainsf asserts that a specified handler returns a\n // body that contains a string.\n //\n-//  a.HTTPBodyContainsf(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  a.HTTPBodyContainsf(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPBodyContainsf(a.t, handler, method, url, values, str, msg, args...)\n }\n \n // HTTPBodyNotContains asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  a.HTTPBodyNotContains(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\")\n+//  a.HTTPBodyNotContains(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyNotContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPBodyNotContains(a.t, handler, method, url, values, str, msgAndArgs...)\n }\n \n // HTTPBodyNotContainsf asserts that a specified handler returns a\n // body that does not contain a string.\n //\n-//  a.HTTPBodyNotContainsf(myHandler, \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n+//  a.HTTPBodyNotContainsf(myHandler, \"GET\", \"www.google.com\", nil, \"I'm Feeling Lucky\", \"error message %s\", \"formatted\")\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPBodyNotContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPBodyNotContainsf(a.t, handler, method, url, values, str, msg, args...)\n }\n \n@@ -266,6 +362,9 @@ func (a *Assertions) HTTPBodyNotContainsf(handler http.HandlerFunc, method strin\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPError(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPError(a.t, handler, method, url, values, msgAndArgs...)\n }\n \n@@ -275,6 +374,9 @@ func (a *Assertions) HTTPError(handler http.HandlerFunc, method string, url stri\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func (a *Assertions) HTTPErrorf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPErrorf(a.t, handler, method, url, values, msg, args...)\n }\n \n@@ -284,6 +386,9 @@ func (a *Assertions) HTTPErrorf(handler http.HandlerFunc, method string, url str\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPRedirect(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPRedirect(a.t, handler, method, url, values, msgAndArgs...)\n }\n \n@@ -293,6 +398,9 @@ func (a *Assertions) HTTPRedirect(handler http.HandlerFunc, method string, url s\n //\n // Returns whether the assertion was successful (true, \"error message %s\", \"formatted\") or not (false).\n func (a *Assertions) HTTPRedirectf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPRedirectf(a.t, handler, method, url, values, msg, args...)\n }\n \n@@ -302,6 +410,9 @@ func (a *Assertions) HTTPRedirectf(handler http.HandlerFunc, method string, url\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPSuccess(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPSuccess(a.t, handler, method, url, values, msgAndArgs...)\n }\n \n@@ -311,98 +422,149 @@ func (a *Assertions) HTTPSuccess(handler http.HandlerFunc, method string, url st\n //\n // Returns whether the assertion was successful (true) or not (false).\n func (a *Assertions) HTTPSuccessf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tHTTPSuccessf(a.t, handler, method, url, values, msg, args...)\n }\n \n // Implements asserts that an object is implemented by the specified interface.\n //\n //    a.Implements((*MyInterface)(nil), new(MyObject))\n func (a *Assertions) Implements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tImplements(a.t, interfaceObject, object, msgAndArgs...)\n }\n \n // Implementsf asserts that an object is implemented by the specified interface.\n //\n //    a.Implementsf((*MyInterface, \"error message %s\", \"formatted\")(nil), new(MyObject))\n func (a *Assertions) Implementsf(interfaceObject interface{}, object interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tImplementsf(a.t, interfaceObject, object, msg, args...)\n }\n \n // InDelta asserts that the two numerals are within delta of each other.\n //\n // \t a.InDelta(math.Pi, (22 / 7.0), 0.01)\n func (a *Assertions) InDelta(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInDelta(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func (a *Assertions) InDeltaMapValues(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInDeltaMapValues(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.\n func (a *Assertions) InDeltaMapValuesf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInDeltaMapValuesf(a.t, expected, actual, delta, msg, args...)\n }\n \n // InDeltaSlice is the same as InDelta, except it compares two slices.\n func (a *Assertions) InDeltaSlice(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInDeltaSlice(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // InDeltaSlicef is the same as InDelta, except it compares two slices.\n func (a *Assertions) InDeltaSlicef(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInDeltaSlicef(a.t, expected, actual, delta, msg, args...)\n }\n \n // InDeltaf asserts that the two numerals are within delta of each other.\n //\n // \t a.InDeltaf(math.Pi, (22 / 7.0, \"error message %s\", \"formatted\"), 0.01)\n func (a *Assertions) InDeltaf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInDeltaf(a.t, expected, actual, delta, msg, args...)\n }\n \n // InEpsilon asserts that expected and actual have a relative error less than epsilon\n func (a *Assertions) InEpsilon(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInEpsilon(a.t, expected, actual, epsilon, msgAndArgs...)\n }\n \n // InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.\n func (a *Assertions) InEpsilonSlice(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInEpsilonSlice(a.t, expected, actual, epsilon, msgAndArgs...)\n }\n \n // InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.\n func (a *Assertions) InEpsilonSlicef(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInEpsilonSlicef(a.t, expected, actual, epsilon, msg, args...)\n }\n \n // InEpsilonf asserts that expected and actual have a relative error less than epsilon\n func (a *Assertions) InEpsilonf(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tInEpsilonf(a.t, expected, actual, epsilon, msg, args...)\n }\n \n // IsType asserts that the specified objects are of the same type.\n func (a *Assertions) IsType(expectedType interface{}, object interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tIsType(a.t, expectedType, object, msgAndArgs...)\n }\n \n // IsTypef asserts that the specified objects are of the same type.\n func (a *Assertions) IsTypef(expectedType interface{}, object interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tIsTypef(a.t, expectedType, object, msg, args...)\n }\n \n // JSONEq asserts that two JSON strings are equivalent.\n //\n //  a.JSONEq(`{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`)\n func (a *Assertions) JSONEq(expected string, actual string, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tJSONEq(a.t, expected, actual, msgAndArgs...)\n }\n \n // JSONEqf asserts that two JSON strings are equivalent.\n //\n //  a.JSONEqf(`{\"hello\": \"world\", \"foo\": \"bar\"}`, `{\"foo\": \"bar\", \"hello\": \"world\"}`, \"error message %s\", \"formatted\")\n func (a *Assertions) JSONEqf(expected string, actual string, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tJSONEqf(a.t, expected, actual, msg, args...)\n }\n \n@@ -411,6 +573,9 @@ func (a *Assertions) JSONEqf(expected string, actual string, msg string, args ..\n //\n //    a.Len(mySlice, 3)\n func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tLen(a.t, object, length, msgAndArgs...)\n }\n \n@@ -419,20 +584,29 @@ func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface\n //\n //    a.Lenf(mySlice, 3, \"error message %s\", \"formatted\")\n func (a *Assertions) Lenf(object interface{}, length int, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tLenf(a.t, object, length, msg, args...)\n }\n \n // Nil asserts that the specified object is nil.\n //\n //    a.Nil(err)\n func (a *Assertions) Nil(object interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNil(a.t, object, msgAndArgs...)\n }\n \n // Nilf asserts that the specified object is nil.\n //\n //    a.Nilf(err, \"error message %s\", \"formatted\")\n func (a *Assertions) Nilf(object interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNilf(a.t, object, msg, args...)\n }\n \n@@ -443,6 +617,9 @@ func (a *Assertions) Nilf(object interface{}, msg string, args ...interface{}) {\n // \t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func (a *Assertions) NoError(err error, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNoError(a.t, err, msgAndArgs...)\n }\n \n@@ -453,6 +630,9 @@ func (a *Assertions) NoError(err error, msgAndArgs ...interface{}) {\n // \t   assert.Equal(t, expectedObj, actualObj)\n //   }\n func (a *Assertions) NoErrorf(err error, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNoErrorf(a.t, err, msg, args...)\n }\n \n@@ -463,6 +643,9 @@ func (a *Assertions) NoErrorf(err error, msg string, args ...interface{}) {\n //    a.NotContains([\"Hello\", \"World\"], \"Earth\")\n //    a.NotContains({\"Hello\": \"World\"}, \"Earth\")\n func (a *Assertions) NotContains(s interface{}, contains interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotContains(a.t, s, contains, msgAndArgs...)\n }\n \n@@ -473,6 +656,9 @@ func (a *Assertions) NotContains(s interface{}, contains interface{}, msgAndArgs\n //    a.NotContainsf([\"Hello\", \"World\"], \"Earth\", \"error message %s\", \"formatted\")\n //    a.NotContainsf({\"Hello\": \"World\"}, \"Earth\", \"error message %s\", \"formatted\")\n func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotContainsf(a.t, s, contains, msg, args...)\n }\n \n@@ -483,6 +669,9 @@ func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg strin\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotEmpty(a.t, object, msgAndArgs...)\n }\n \n@@ -493,6 +682,9 @@ func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) {\n //    assert.Equal(t, \"two\", obj[1])\n //  }\n func (a *Assertions) NotEmptyf(object interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotEmptyf(a.t, object, msg, args...)\n }\n \n@@ -503,6 +695,9 @@ func (a *Assertions) NotEmptyf(object interface{}, msg string, args ...interface\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func (a *Assertions) NotEqual(expected interface{}, actual interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotEqual(a.t, expected, actual, msgAndArgs...)\n }\n \n@@ -513,34 +708,49 @@ func (a *Assertions) NotEqual(expected interface{}, actual interface{}, msgAndAr\n // Pointer variable equality is determined based on the equality of the\n // referenced values (as opposed to the memory addresses).\n func (a *Assertions) NotEqualf(expected interface{}, actual interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotEqualf(a.t, expected, actual, msg, args...)\n }\n \n // NotNil asserts that the specified object is not nil.\n //\n //    a.NotNil(err)\n func (a *Assertions) NotNil(object interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotNil(a.t, object, msgAndArgs...)\n }\n \n // NotNilf asserts that the specified object is not nil.\n //\n //    a.NotNilf(err, \"error message %s\", \"formatted\")\n func (a *Assertions) NotNilf(object interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotNilf(a.t, object, msg, args...)\n }\n \n // NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.\n //\n //   a.NotPanics(func(){ RemainCalm() })\n func (a *Assertions) NotPanics(f assert.PanicTestFunc, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotPanics(a.t, f, msgAndArgs...)\n }\n \n // NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.\n //\n //   a.NotPanicsf(func(){ RemainCalm() }, \"error message %s\", \"formatted\")\n func (a *Assertions) NotPanicsf(f assert.PanicTestFunc, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotPanicsf(a.t, f, msg, args...)\n }\n \n@@ -549,6 +759,9 @@ func (a *Assertions) NotPanicsf(f assert.PanicTestFunc, msg string, args ...inte\n //  a.NotRegexp(regexp.MustCompile(\"starts\"), \"it's starting\")\n //  a.NotRegexp(\"^start\", \"it's not starting\")\n func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotRegexp(a.t, rx, str, msgAndArgs...)\n }\n \n@@ -557,6 +770,9 @@ func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...in\n //  a.NotRegexpf(regexp.MustCompile(\"starts\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  a.NotRegexpf(\"^start\", \"it's not starting\", \"error message %s\", \"formatted\")\n func (a *Assertions) NotRegexpf(rx interface{}, str interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotRegexpf(a.t, rx, str, msg, args...)\n }\n \n@@ -565,6 +781,9 @@ func (a *Assertions) NotRegexpf(rx interface{}, str interface{}, msg string, arg\n //\n //    a.NotSubset([1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\")\n func (a *Assertions) NotSubset(list interface{}, subset interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotSubset(a.t, list, subset, msgAndArgs...)\n }\n \n@@ -573,23 +792,35 @@ func (a *Assertions) NotSubset(list interface{}, subset interface{}, msgAndArgs\n //\n //    a.NotSubsetf([1, 3, 4], [1, 2], \"But [1, 3, 4] does not contain [1, 2]\", \"error message %s\", \"formatted\")\n func (a *Assertions) NotSubsetf(list interface{}, subset interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotSubsetf(a.t, list, subset, msg, args...)\n }\n \n // NotZero asserts that i is not the zero value for its type.\n func (a *Assertions) NotZero(i interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotZero(a.t, i, msgAndArgs...)\n }\n \n // NotZerof asserts that i is not the zero value for its type.\n func (a *Assertions) NotZerof(i interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tNotZerof(a.t, i, msg, args...)\n }\n \n // Panics asserts that the code inside the specified PanicTestFunc panics.\n //\n //   a.Panics(func(){ GoCrazy() })\n func (a *Assertions) Panics(f assert.PanicTestFunc, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tPanics(a.t, f, msgAndArgs...)\n }\n \n@@ -598,6 +829,9 @@ func (a *Assertions) Panics(f assert.PanicTestFunc, msgAndArgs ...interface{}) {\n //\n //   a.PanicsWithValue(\"crazy error\", func(){ GoCrazy() })\n func (a *Assertions) PanicsWithValue(expected interface{}, f assert.PanicTestFunc, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tPanicsWithValue(a.t, expected, f, msgAndArgs...)\n }\n \n@@ -606,13 +840,19 @@ func (a *Assertions) PanicsWithValue(expected interface{}, f assert.PanicTestFun\n //\n //   a.PanicsWithValuef(\"crazy error\", func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func (a *Assertions) PanicsWithValuef(expected interface{}, f assert.PanicTestFunc, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tPanicsWithValuef(a.t, expected, f, msg, args...)\n }\n \n // Panicsf asserts that the code inside the specified PanicTestFunc panics.\n //\n //   a.Panicsf(func(){ GoCrazy() }, \"error message %s\", \"formatted\")\n func (a *Assertions) Panicsf(f assert.PanicTestFunc, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tPanicsf(a.t, f, msg, args...)\n }\n \n@@ -621,6 +861,9 @@ func (a *Assertions) Panicsf(f assert.PanicTestFunc, msg string, args ...interfa\n //  a.Regexp(regexp.MustCompile(\"start\"), \"it's starting\")\n //  a.Regexp(\"start...$\", \"it's not starting\")\n func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tRegexp(a.t, rx, str, msgAndArgs...)\n }\n \n@@ -629,6 +872,9 @@ func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...inter\n //  a.Regexpf(regexp.MustCompile(\"start\", \"error message %s\", \"formatted\"), \"it's starting\")\n //  a.Regexpf(\"start...$\", \"it's not starting\", \"error message %s\", \"formatted\")\n func (a *Assertions) Regexpf(rx interface{}, str interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tRegexpf(a.t, rx, str, msg, args...)\n }\n \n@@ -637,6 +883,9 @@ func (a *Assertions) Regexpf(rx interface{}, str interface{}, msg string, args .\n //\n //    a.Subset([1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\")\n func (a *Assertions) Subset(list interface{}, subset interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tSubset(a.t, list, subset, msgAndArgs...)\n }\n \n@@ -645,43 +894,64 @@ func (a *Assertions) Subset(list interface{}, subset interface{}, msgAndArgs ...\n //\n //    a.Subsetf([1, 2, 3], [1, 2], \"But [1, 2, 3] does contain [1, 2]\", \"error message %s\", \"formatted\")\n func (a *Assertions) Subsetf(list interface{}, subset interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tSubsetf(a.t, list, subset, msg, args...)\n }\n \n // True asserts that the specified value is true.\n //\n //    a.True(myBool)\n func (a *Assertions) True(value bool, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tTrue(a.t, value, msgAndArgs...)\n }\n \n // Truef asserts that the specified value is true.\n //\n //    a.Truef(myBool, \"error message %s\", \"formatted\")\n func (a *Assertions) Truef(value bool, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tTruef(a.t, value, msg, args...)\n }\n \n // WithinDuration asserts that the two times are within duration delta of each other.\n //\n //   a.WithinDuration(time.Now(), time.Now(), 10*time.Second)\n func (a *Assertions) WithinDuration(expected time.Time, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tWithinDuration(a.t, expected, actual, delta, msgAndArgs...)\n }\n \n // WithinDurationf asserts that the two times are within duration delta of each other.\n //\n //   a.WithinDurationf(time.Now(), time.Now(), 10*time.Second, \"error message %s\", \"formatted\")\n func (a *Assertions) WithinDurationf(expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tWithinDurationf(a.t, expected, actual, delta, msg, args...)\n }\n \n // Zero asserts that i is the zero value for its type.\n func (a *Assertions) Zero(i interface{}, msgAndArgs ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tZero(a.t, i, msgAndArgs...)\n }\n \n // Zerof asserts that i is the zero value for its type.\n func (a *Assertions) Zerof(i interface{}, msg string, args ...interface{}) {\n+\tif h, ok := a.t.(tHelper); ok {\n+\t\th.Helper()\n+\t}\n \tZerof(a.t, i, msg, args...)\n }"
    },
    {
      "sha": "54124df1d3bbed65addd5df5f9c57c4ea07d4253",
      "filename": "backend/vendor/github.com/stretchr/testify/require/require_forward.go.tmpl",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require_forward.go.tmpl",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/require_forward.go.tmpl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/require/require_forward.go.tmpl?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -1,4 +1,5 @@\n {{.CommentWithoutT \"a\"}}\n func (a *Assertions) {{.DocInfo.Name}}({{.Params}}) {\n+\tif h, ok := a.t.(tHelper); ok { h.Helper() }\n \t{{.DocInfo.Name}}(a.t, {{.ForwardedParams}})\n }"
    },
    {
      "sha": "6b85c5ecef251782251b12e74772d0825c56acc0",
      "filename": "backend/vendor/github.com/stretchr/testify/require/requirements.go",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/requirements.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/github.com/stretchr/testify/require/requirements.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/stretchr/testify/require/requirements.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -6,4 +6,24 @@ type TestingT interface {\n \tFailNow()\n }\n \n+type tHelper interface {\n+\tHelper()\n+}\n+\n+// ComparisonAssertionFunc is a common function prototype when comparing two values.  Can be useful\n+// for table driven tests.\n+type ComparisonAssertionFunc func(TestingT, interface{}, interface{}, ...interface{})\n+\n+// ValueAssertionFunc is a common function prototype when validating a single value.  Can be useful\n+// for table driven tests.\n+type ValueAssertionFunc func(TestingT, interface{}, ...interface{})\n+\n+// BoolAssertionFunc is a common function prototype when validating a bool value.  Can be useful\n+// for table driven tests.\n+type BoolAssertionFunc func(TestingT, bool, ...interface{})\n+\n+// ErrorAssertionFunc is a common function prototype when validating an error value.  Can be useful\n+// for table driven tests.\n+type ErrorAssertionFunc func(TestingT, error, ...interface{})\n+\n //go:generate go run ../_codegen/main.go -output-package=require -template=require.go.tmpl -include-format-funcs"
    },
    {
      "sha": "cd5aaba6478f5f1e6e3e09463227cea843517c01",
      "filename": "backend/vendor/golang.org/x/image/draw/draw.go",
      "status": "modified",
      "additions": 21,
      "deletions": 3,
      "changes": 24,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/image/draw/draw.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/image/draw/draw.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/image/draw/draw.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -11,9 +11,8 @@\n // package in the standard library.\n package draw\n \n-// This file, and the go1_*.go files, just contains the API exported by the\n-// image/draw package in the standard library. Other files in this package\n-// provide additional features.\n+// This file just contains the API exported by the image/draw package in the\n+// standard library. Other files in this package provide additional features.\n \n import (\n \t\"image\"\n@@ -32,6 +31,9 @@ func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mas\n \tdraw.DrawMask(dst, r, src, sp, mask, mp, draw.Op(op))\n }\n \n+// Drawer contains the Draw method.\n+type Drawer = draw.Drawer\n+\n // FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error\n // diffusion.\n var FloydSteinberg Drawer = floydSteinberg{}\n@@ -41,3 +43,19 @@ type floydSteinberg struct{}\n func (floydSteinberg) Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point) {\n \tdraw.FloydSteinberg.Draw(dst, r, src, sp)\n }\n+\n+// Image is an image.Image with a Set method to change a single pixel.\n+type Image = draw.Image\n+\n+// Op is a Porter-Duff compositing operator.\n+type Op = draw.Op\n+\n+const (\n+\t// Over specifies ``(src in mask) over dst''.\n+\tOver Op = draw.Over\n+\t// Src specifies ``src in mask''.\n+\tSrc Op = draw.Src\n+)\n+\n+// Quantizer produces a palette for an image.\n+type Quantizer = draw.Quantizer"
    },
    {
      "sha": "ec192b717348f4542f02cee1f3584aba5037d4ac",
      "filename": "backend/vendor/golang.org/x/image/draw/go1_8.go",
      "status": "removed",
      "additions": 0,
      "deletions": 49,
      "changes": 49,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/image/draw/go1_8.go",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/image/draw/go1_8.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/image/draw/go1_8.go?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !go1.9,!go1.8.typealias\n-\n-package draw\n-\n-import (\n-\t\"image\"\n-\t\"image/color\"\n-\t\"image/draw\"\n-)\n-\n-// Drawer contains the Draw method.\n-type Drawer interface {\n-\t// Draw aligns r.Min in dst with sp in src and then replaces the\n-\t// rectangle r in dst with the result of drawing src on dst.\n-\tDraw(dst Image, r image.Rectangle, src image.Image, sp image.Point)\n-}\n-\n-// Image is an image.Image with a Set method to change a single pixel.\n-type Image interface {\n-\timage.Image\n-\tSet(x, y int, c color.Color)\n-}\n-\n-// Op is a Porter-Duff compositing operator.\n-type Op int\n-\n-const (\n-\t// Over specifies ``(src in mask) over dst''.\n-\tOver Op = Op(draw.Over)\n-\t// Src specifies ``src in mask''.\n-\tSrc Op = Op(draw.Src)\n-)\n-\n-// Draw implements the Drawer interface by calling the Draw function with\n-// this Op.\n-func (op Op) Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point) {\n-\t(draw.Op(op)).Draw(dst, r, src, sp)\n-}\n-\n-// Quantizer produces a palette for an image.\n-type Quantizer interface {\n-\t// Quantize appends up to cap(p) - len(p) colors to p and returns the\n-\t// updated palette suitable for converting m to a paletted image.\n-\tQuantize(p color.Palette, m image.Image) color.Palette\n-}"
    },
    {
      "sha": "fc548e94703125e1286717713a32411adedac999",
      "filename": "backend/vendor/golang.org/x/image/draw/go1_9.go",
      "status": "removed",
      "additions": 0,
      "deletions": 57,
      "changes": 57,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/image/draw/go1_9.go",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/image/draw/go1_9.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/image/draw/go1_9.go?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build go1.9 go1.8.typealias\n-\n-package draw\n-\n-import (\n-\t\"image/draw\"\n-)\n-\n-// We use type aliases (new in Go 1.9) for the exported names from the standard\n-// library's image/draw package. This is not merely syntactic sugar for\n-//\n-//\ttype Drawer draw.Drawer\n-//\n-// as aliasing means that the types in this package, such as draw.Image and\n-// draw.Op, are identical to the corresponding draw.Image and draw.Op types in\n-// the standard library. In comparison, prior to Go 1.9, the code in go1_8.go\n-// defines new types that mimic the old but are different types.\n-//\n-// The package documentation, in draw.go, explicitly gives the intent of this\n-// package:\n-//\n-//\tThis package is a superset of and a drop-in replacement for the\n-//\timage/draw package in the standard library.\n-//\n-// Drop-in replacement means that I can replace all of my \"image/draw\" imports\n-// with \"golang.org/x/image/draw\", to access additional features in this\n-// package, and no further changes are required. That's mostly true, but not\n-// completely true unless we use type aliases.\n-//\n-// Without type aliases, users might need to import both \"image/draw\" and\n-// \"golang.org/x/image/draw\" in order to convert from two conceptually\n-// equivalent but different (from the compiler's point of view) types, such as\n-// from one draw.Op type to another draw.Op type, to satisfy some other\n-// interface or function signature.\n-\n-// Drawer contains the Draw method.\n-type Drawer = draw.Drawer\n-\n-// Image is an image.Image with a Set method to change a single pixel.\n-type Image = draw.Image\n-\n-// Op is a Porter-Duff compositing operator.\n-type Op = draw.Op\n-\n-const (\n-\t// Over specifies ``(src in mask) over dst''.\n-\tOver Op = draw.Over\n-\t// Src specifies ``src in mask''.\n-\tSrc Op = draw.Src\n-)\n-\n-// Quantizer produces a palette for an image.\n-type Quantizer = draw.Quantizer"
    },
    {
      "sha": "00121a129def3d80a55398856fbd44f0e4732e9c",
      "filename": "backend/vendor/golang.org/x/image/draw/scale.go",
      "status": "modified",
      "additions": 6,
      "deletions": 8,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/image/draw/scale.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/image/draw/scale.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/image/draw/scale.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -46,8 +46,8 @@ type Scaler interface {\n //\n // For example, if m is the matrix\n //\n-// m00 m01 m02\n-// m10 m11 m12\n+// \tm00 m01 m02\n+// \tm10 m11 m12\n //\n // then the src-space point (sx, sy) maps to the dst-space point\n // (m00*sx + m01*sy + m02, m10*sx + m11*sy + m12).\n@@ -65,7 +65,7 @@ type Options struct {\n \t// the src image are drawn from.\n \t//\n \t// A dst or src mask image having a zero alpha (transparent) pixel value in\n-\t// the respective coordinate space means that that dst pixel is entirely\n+\t// the respective coordinate space means that dst pixel is entirely\n \t// unaffected or that src pixel is considered transparent black. A full\n \t// alpha (opaque) value means that the dst pixel is maximally affected or\n \t// the src pixel contributes maximally. The default values, nil, are\n@@ -408,11 +408,9 @@ func clipAffectedDestRect(adr image.Rectangle, dstMask image.Image, dstMaskP ima\n \tif dstMask == nil {\n \t\treturn adr, nil\n \t}\n-\t// TODO: enable this fast path once Go 1.5 is released, where an\n-\t// image.Rectangle implements image.Image.\n-\t// if r, ok := dstMask.(image.Rectangle); ok {\n-\t// \treturn adr.Intersect(r.Sub(dstMaskP)), nil\n-\t// }\n+\tif r, ok := dstMask.(image.Rectangle); ok {\n+\t\treturn adr.Intersect(r.Sub(dstMaskP)), nil\n+\t}\n \t// TODO: clip to dstMask.Bounds() if the color model implies that out-of-bounds means 0 alpha?\n \treturn adr, dstMask\n }"
    },
    {
      "sha": "37dc0cfdb5b0dbb48f26c922050421bf5c757d05",
      "filename": "backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -2,18 +2,15 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build go1.7\n-\n // Package ctxhttp provides helper functions for performing context-aware HTTP requests.\n package ctxhttp // import \"golang.org/x/net/context/ctxhttp\"\n \n import (\n+\t\"context\"\n \t\"io\"\n \t\"net/http\"\n \t\"net/url\"\n \t\"strings\"\n-\n-\t\"golang.org/x/net/context\"\n )\n \n // Do sends an HTTP request with the provided http.Client and returns"
    },
    {
      "sha": "926870cc23fd642e319cabce8438750e0c6df677",
      "filename": "backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17.go",
      "status": "removed",
      "additions": 0,
      "deletions": 147,
      "changes": 147,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17.go",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/context/ctxhttp/ctxhttp_pre17.go?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930",
      "patch": "@@ -1,147 +0,0 @@\n-// Copyright 2015 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !go1.7\n-\n-package ctxhttp // import \"golang.org/x/net/context/ctxhttp\"\n-\n-import (\n-\t\"io\"\n-\t\"net/http\"\n-\t\"net/url\"\n-\t\"strings\"\n-\n-\t\"golang.org/x/net/context\"\n-)\n-\n-func nop() {}\n-\n-var (\n-\ttestHookContextDoneBeforeHeaders = nop\n-\ttestHookDoReturned               = nop\n-\ttestHookDidBodyClose             = nop\n-)\n-\n-// Do sends an HTTP request with the provided http.Client and returns an HTTP response.\n-// If the client is nil, http.DefaultClient is used.\n-// If the context is canceled or times out, ctx.Err() will be returned.\n-func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) {\n-\tif client == nil {\n-\t\tclient = http.DefaultClient\n-\t}\n-\n-\t// TODO(djd): Respect any existing value of req.Cancel.\n-\tcancel := make(chan struct{})\n-\treq.Cancel = cancel\n-\n-\ttype responseAndError struct {\n-\t\tresp *http.Response\n-\t\terr  error\n-\t}\n-\tresult := make(chan responseAndError, 1)\n-\n-\t// Make local copies of test hooks closed over by goroutines below.\n-\t// Prevents data races in tests.\n-\ttestHookDoReturned := testHookDoReturned\n-\ttestHookDidBodyClose := testHookDidBodyClose\n-\n-\tgo func() {\n-\t\tresp, err := client.Do(req)\n-\t\ttestHookDoReturned()\n-\t\tresult <- responseAndError{resp, err}\n-\t}()\n-\n-\tvar resp *http.Response\n-\n-\tselect {\n-\tcase <-ctx.Done():\n-\t\ttestHookContextDoneBeforeHeaders()\n-\t\tclose(cancel)\n-\t\t// Clean up after the goroutine calling client.Do:\n-\t\tgo func() {\n-\t\t\tif r := <-result; r.resp != nil {\n-\t\t\t\ttestHookDidBodyClose()\n-\t\t\t\tr.resp.Body.Close()\n-\t\t\t}\n-\t\t}()\n-\t\treturn nil, ctx.Err()\n-\tcase r := <-result:\n-\t\tvar err error\n-\t\tresp, err = r.resp, r.err\n-\t\tif err != nil {\n-\t\t\treturn resp, err\n-\t\t}\n-\t}\n-\n-\tc := make(chan struct{})\n-\tgo func() {\n-\t\tselect {\n-\t\tcase <-ctx.Done():\n-\t\t\tclose(cancel)\n-\t\tcase <-c:\n-\t\t\t// The response's Body is closed.\n-\t\t}\n-\t}()\n-\tresp.Body = &notifyingReader{resp.Body, c}\n-\n-\treturn resp, nil\n-}\n-\n-// Get issues a GET request via the Do function.\n-func Get(ctx context.Context, client *http.Client, url string) (*http.Response, error) {\n-\treq, err := http.NewRequest(\"GET\", url, nil)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn Do(ctx, client, req)\n-}\n-\n-// Head issues a HEAD request via the Do function.\n-func Head(ctx context.Context, client *http.Client, url string) (*http.Response, error) {\n-\treq, err := http.NewRequest(\"HEAD\", url, nil)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn Do(ctx, client, req)\n-}\n-\n-// Post issues a POST request via the Do function.\n-func Post(ctx context.Context, client *http.Client, url string, bodyType string, body io.Reader) (*http.Response, error) {\n-\treq, err := http.NewRequest(\"POST\", url, body)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treq.Header.Set(\"Content-Type\", bodyType)\n-\treturn Do(ctx, client, req)\n-}\n-\n-// PostForm issues a POST request via the Do function.\n-func PostForm(ctx context.Context, client *http.Client, url string, data url.Values) (*http.Response, error) {\n-\treturn Post(ctx, client, url, \"application/x-www-form-urlencoded\", strings.NewReader(data.Encode()))\n-}\n-\n-// notifyingReader is an io.ReadCloser that closes the notify channel after\n-// Close is called or a Read fails on the underlying ReadCloser.\n-type notifyingReader struct {\n-\tio.ReadCloser\n-\tnotify chan<- struct{}\n-}\n-\n-func (r *notifyingReader) Read(p []byte) (int, error) {\n-\tn, err := r.ReadCloser.Read(p)\n-\tif err != nil && r.notify != nil {\n-\t\tclose(r.notify)\n-\t\tr.notify = nil\n-\t}\n-\treturn n, err\n-}\n-\n-func (r *notifyingReader) Close() error {\n-\terr := r.ReadCloser.Close()\n-\tif r.notify != nil {\n-\t\tclose(r.notify)\n-\t\tr.notify = nil\n-\t}\n-\treturn err\n-}"
    },
    {
      "sha": "5d052781bceaf8504923cff6da7d4a5f22044169",
      "filename": "backend/vendor/golang.org/x/net/html/atom/gen.go",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/atom/gen.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/atom/gen.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/atom/gen.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -306,7 +306,7 @@ func (t *table) push(i uint32, depth int) bool {\n \n // The lists of element names and attribute keys were taken from\n // https://html.spec.whatwg.org/multipage/indices.html#index\n-// as of the \"HTML Living Standard - Last Updated 18 September 2017\" version.\n+// as of the \"HTML Living Standard - Last Updated 16 April 2018\" version.\n \n // \"command\", \"keygen\" and \"menuitem\" have been removed from the spec,\n // but are kept here for backwards compatibility.\n@@ -701,6 +701,8 @@ var extra = []string{\n \t\"plaintext\",\n \t\"prompt\",\n \t\"public\",\n+\t\"rb\",\n+\t\"rtc\",\n \t\"spacer\",\n \t\"strike\",\n \t\"svg\","
    },
    {
      "sha": "2a938864cb9d3e88b3259c4856412517a39dce5f",
      "filename": "backend/vendor/golang.org/x/net/html/atom/table.go",
      "status": "modified",
      "additions": 552,
      "deletions": 548,
      "changes": 1100,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/atom/table.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/atom/table.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/atom/table.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -10,30 +10,30 @@ const (\n \tAccept                    Atom = 0x1a06\n \tAcceptCharset             Atom = 0x1a0e\n \tAccesskey                 Atom = 0x2c09\n-\tAcronym                   Atom = 0x6907\n-\tAction                    Atom = 0x26a06\n+\tAcronym                   Atom = 0xaa07\n+\tAction                    Atom = 0x27206\n \tAddress                   Atom = 0x6f307\n-\tAlign                     Atom = 0x7005\n-\tAllowfullscreen           Atom = 0x2000f\n-\tAllowpaymentrequest       Atom = 0x8013\n-\tAllowusermedia            Atom = 0x9c0e\n-\tAlt                       Atom = 0xc703\n+\tAlign                     Atom = 0xb105\n+\tAllowfullscreen           Atom = 0x2080f\n+\tAllowpaymentrequest       Atom = 0xc113\n+\tAllowusermedia            Atom = 0xdd0e\n+\tAlt                       Atom = 0xf303\n \tAnnotation                Atom = 0x1c90a\n \tAnnotationXml             Atom = 0x1c90e\n-\tApplet                    Atom = 0x31106\n-\tArea                      Atom = 0x34e04\n-\tArticle                   Atom = 0x3f407\n-\tAs                        Atom = 0xd002\n-\tAside                     Atom = 0xd805\n-\tAsync                     Atom = 0xd005\n-\tAudio                     Atom = 0xe605\n-\tAutocomplete              Atom = 0x2700c\n-\tAutofocus                 Atom = 0x10209\n-\tAutoplay                  Atom = 0x11d08\n+\tApplet                    Atom = 0x31906\n+\tArea                      Atom = 0x35604\n+\tArticle                   Atom = 0x3fc07\n+\tAs                        Atom = 0x3c02\n+\tAside                     Atom = 0x10705\n+\tAsync                     Atom = 0xff05\n+\tAudio                     Atom = 0x11505\n+\tAutocomplete              Atom = 0x2780c\n+\tAutofocus                 Atom = 0x12109\n+\tAutoplay                  Atom = 0x13c08\n \tB                         Atom = 0x101\n-\tBase                      Atom = 0x12c04\n-\tBasefont                  Atom = 0x12c08\n-\tBdi                       Atom = 0x7903\n+\tBase                      Atom = 0x3b04\n+\tBasefont                  Atom = 0x3b08\n+\tBdi                       Atom = 0xba03\n \tBdo                       Atom = 0x14b03\n \tBgsound                   Atom = 0x15e07\n \tBig                       Atom = 0x17003\n@@ -42,217 +42,217 @@ const (\n \tBody                      Atom = 0x2804\n \tBr                        Atom = 0x202\n \tButton                    Atom = 0x19106\n-\tCanvas                    Atom = 0xd406\n-\tCaption                   Atom = 0x22907\n-\tCenter                    Atom = 0x21806\n-\tChallenge                 Atom = 0x29309\n+\tCanvas                    Atom = 0x10306\n+\tCaption                   Atom = 0x23107\n+\tCenter                    Atom = 0x22006\n+\tChallenge                 Atom = 0x29b09\n \tCharset                   Atom = 0x2107\n-\tChecked                   Atom = 0x47107\n-\tCite                      Atom = 0x55c04\n-\tClass                     Atom = 0x5bd05\n-\tCode                      Atom = 0x1a004\n-\tCol                       Atom = 0x1a703\n-\tColgroup                  Atom = 0x1a708\n+\tChecked                   Atom = 0x47907\n+\tCite                      Atom = 0x19c04\n+\tClass                     Atom = 0x56405\n+\tCode                      Atom = 0x5c504\n+\tCol                       Atom = 0x1ab03\n+\tColgroup                  Atom = 0x1ab08\n \tColor                     Atom = 0x1bf05\n \tCols                      Atom = 0x1c404\n \tColspan                   Atom = 0x1c407\n \tCommand                   Atom = 0x1d707\n-\tContent                   Atom = 0x58307\n-\tContenteditable           Atom = 0x5830f\n-\tContextmenu               Atom = 0x3780b\n+\tContent                   Atom = 0x58b07\n+\tContenteditable           Atom = 0x58b0f\n+\tContextmenu               Atom = 0x3800b\n \tControls                  Atom = 0x1de08\n \tCoords                    Atom = 0x1ea06\n-\tCrossorigin               Atom = 0x1f30b\n-\tData                      Atom = 0x49d04\n-\tDatalist                  Atom = 0x49d08\n-\tDatetime                  Atom = 0x2b008\n-\tDd                        Atom = 0x2cf02\n-\tDefault                   Atom = 0xdb07\n-\tDefer                     Atom = 0x1a205\n-\tDel                       Atom = 0x44a03\n-\tDesc                      Atom = 0x55904\n-\tDetails                   Atom = 0x4607\n-\tDfn                       Atom = 0x5f03\n-\tDialog                    Atom = 0x7a06\n-\tDir                       Atom = 0xba03\n-\tDirname                   Atom = 0xba07\n+\tCrossorigin               Atom = 0x1fb0b\n+\tData                      Atom = 0x4a504\n+\tDatalist                  Atom = 0x4a508\n+\tDatetime                  Atom = 0x2b808\n+\tDd                        Atom = 0x2d702\n+\tDefault                   Atom = 0x10a07\n+\tDefer                     Atom = 0x5c705\n+\tDel                       Atom = 0x45203\n+\tDesc                      Atom = 0x56104\n+\tDetails                   Atom = 0x7207\n+\tDfn                       Atom = 0x8703\n+\tDialog                    Atom = 0xbb06\n+\tDir                       Atom = 0x9303\n+\tDirname                   Atom = 0x9307\n \tDisabled                  Atom = 0x16408\n \tDiv                       Atom = 0x16b03\n \tDl                        Atom = 0x5e602\n-\tDownload                  Atom = 0x45b08\n+\tDownload                  Atom = 0x46308\n \tDraggable                 Atom = 0x17a09\n-\tDropzone                  Atom = 0x3fd08\n+\tDropzone                  Atom = 0x40508\n \tDt                        Atom = 0x64b02\n-\tEm                        Atom = 0x4202\n-\tEmbed                     Atom = 0x4205\n-\tEnctype                   Atom = 0x28507\n-\tFace                      Atom = 0x21604\n-\tFieldset                  Atom = 0x21e08\n-\tFigcaption                Atom = 0x2260a\n-\tFigure                    Atom = 0x24006\n-\tFont                      Atom = 0x13004\n-\tFooter                    Atom = 0xca06\n-\tFor                       Atom = 0x24c03\n-\tForeignObject             Atom = 0x24c0d\n-\tForeignobject             Atom = 0x2590d\n-\tForm                      Atom = 0x26604\n-\tFormaction                Atom = 0x2660a\n-\tFormenctype               Atom = 0x2810b\n-\tFormmethod                Atom = 0x29c0a\n-\tFormnovalidate            Atom = 0x2a60e\n-\tFormtarget                Atom = 0x2b80a\n-\tFrame                     Atom = 0x5705\n-\tFrameset                  Atom = 0x5708\n+\tEm                        Atom = 0x6e02\n+\tEmbed                     Atom = 0x6e05\n+\tEnctype                   Atom = 0x28d07\n+\tFace                      Atom = 0x21e04\n+\tFieldset                  Atom = 0x22608\n+\tFigcaption                Atom = 0x22e0a\n+\tFigure                    Atom = 0x24806\n+\tFont                      Atom = 0x3f04\n+\tFooter                    Atom = 0xf606\n+\tFor                       Atom = 0x25403\n+\tForeignObject             Atom = 0x2540d\n+\tForeignobject             Atom = 0x2610d\n+\tForm                      Atom = 0x26e04\n+\tFormaction                Atom = 0x26e0a\n+\tFormenctype               Atom = 0x2890b\n+\tFormmethod                Atom = 0x2a40a\n+\tFormnovalidate            Atom = 0x2ae0e\n+\tFormtarget                Atom = 0x2c00a\n+\tFrame                     Atom = 0x8b05\n+\tFrameset                  Atom = 0x8b08\n \tH1                        Atom = 0x15c02\n-\tH2                        Atom = 0x2d602\n-\tH3                        Atom = 0x30502\n-\tH4                        Atom = 0x33d02\n-\tH5                        Atom = 0x34702\n+\tH2                        Atom = 0x2de02\n+\tH3                        Atom = 0x30d02\n+\tH4                        Atom = 0x34502\n+\tH5                        Atom = 0x34f02\n \tH6                        Atom = 0x64d02\n-\tHead                      Atom = 0x32904\n-\tHeader                    Atom = 0x32906\n-\tHeaders                   Atom = 0x32907\n-\tHeight                    Atom = 0x14306\n-\tHgroup                    Atom = 0x2c206\n-\tHidden                    Atom = 0x2cd06\n-\tHigh                      Atom = 0x2d304\n+\tHead                      Atom = 0x33104\n+\tHeader                    Atom = 0x33106\n+\tHeaders                   Atom = 0x33107\n+\tHeight                    Atom = 0x5206\n+\tHgroup                    Atom = 0x2ca06\n+\tHidden                    Atom = 0x2d506\n+\tHigh                      Atom = 0x2db04\n \tHr                        Atom = 0x15702\n-\tHref                      Atom = 0x2d804\n-\tHreflang                  Atom = 0x2d808\n-\tHtml                      Atom = 0x14704\n-\tHttpEquiv                 Atom = 0x2e00a\n+\tHref                      Atom = 0x2e004\n+\tHreflang                  Atom = 0x2e008\n+\tHtml                      Atom = 0x5604\n+\tHttpEquiv                 Atom = 0x2e80a\n \tI                         Atom = 0x601\n-\tIcon                      Atom = 0x58204\n-\tId                        Atom = 0xda02\n-\tIframe                    Atom = 0x2f406\n-\tImage                     Atom = 0x2fa05\n-\tImg                       Atom = 0x2ff03\n-\tInput                     Atom = 0x44305\n-\tInputmode                 Atom = 0x44309\n-\tIns                       Atom = 0x1fc03\n-\tIntegrity                 Atom = 0x23709\n+\tIcon                      Atom = 0x58a04\n+\tId                        Atom = 0x10902\n+\tIframe                    Atom = 0x2fc06\n+\tImage                     Atom = 0x30205\n+\tImg                       Atom = 0x30703\n+\tInput                     Atom = 0x44b05\n+\tInputmode                 Atom = 0x44b09\n+\tIns                       Atom = 0x20403\n+\tIntegrity                 Atom = 0x23f09\n \tIs                        Atom = 0x16502\n-\tIsindex                   Atom = 0x30707\n-\tIsmap                     Atom = 0x30e05\n-\tItemid                    Atom = 0x38306\n-\tItemprop                  Atom = 0x55d08\n-\tItemref                   Atom = 0x3c507\n+\tIsindex                   Atom = 0x30f07\n+\tIsmap                     Atom = 0x31605\n+\tItemid                    Atom = 0x38b06\n+\tItemprop                  Atom = 0x19d08\n+\tItemref                   Atom = 0x3cd07\n \tItemscope                 Atom = 0x67109\n-\tItemtype                  Atom = 0x31708\n-\tKbd                       Atom = 0x7803\n+\tItemtype                  Atom = 0x31f08\n+\tKbd                       Atom = 0xb903\n \tKeygen                    Atom = 0x3206\n-\tKeytype                   Atom = 0x9507\n+\tKeytype                   Atom = 0xd607\n \tKind                      Atom = 0x17704\n-\tLabel                     Atom = 0xf105\n-\tLang                      Atom = 0x2dc04\n+\tLabel                     Atom = 0x5905\n+\tLang                      Atom = 0x2e404\n \tLegend                    Atom = 0x18106\n-\tLi                        Atom = 0x7102\n+\tLi                        Atom = 0xb202\n \tLink                      Atom = 0x17404\n-\tList                      Atom = 0x4a104\n-\tListing                   Atom = 0x4a107\n-\tLoop                      Atom = 0xf504\n-\tLow                       Atom = 0x8203\n+\tList                      Atom = 0x4a904\n+\tListing                   Atom = 0x4a907\n+\tLoop                      Atom = 0x5d04\n+\tLow                       Atom = 0xc303\n \tMain                      Atom = 0x1004\n-\tMalignmark                Atom = 0x6f0a\n+\tMalignmark                Atom = 0xb00a\n \tManifest                  Atom = 0x6d708\n-\tMap                       Atom = 0x31003\n-\tMark                      Atom = 0x7504\n-\tMarquee                   Atom = 0x31f07\n-\tMath                      Atom = 0x32604\n-\tMax                       Atom = 0x33503\n-\tMaxlength                 Atom = 0x33509\n-\tMedia                     Atom = 0xa505\n-\tMediagroup                Atom = 0xa50a\n-\tMenu                      Atom = 0x37f04\n-\tMenuitem                  Atom = 0x37f08\n-\tMeta                      Atom = 0x4b004\n-\tMeter                     Atom = 0xbf05\n-\tMethod                    Atom = 0x2a006\n-\tMglyph                    Atom = 0x30006\n-\tMi                        Atom = 0x33f02\n-\tMin                       Atom = 0x33f03\n-\tMinlength                 Atom = 0x33f09\n-\tMn                        Atom = 0x2a902\n-\tMo                        Atom = 0x6302\n+\tMap                       Atom = 0x31803\n+\tMark                      Atom = 0xb604\n+\tMarquee                   Atom = 0x32707\n+\tMath                      Atom = 0x32e04\n+\tMax                       Atom = 0x33d03\n+\tMaxlength                 Atom = 0x33d09\n+\tMedia                     Atom = 0xe605\n+\tMediagroup                Atom = 0xe60a\n+\tMenu                      Atom = 0x38704\n+\tMenuitem                  Atom = 0x38708\n+\tMeta                      Atom = 0x4b804\n+\tMeter                     Atom = 0x9805\n+\tMethod                    Atom = 0x2a806\n+\tMglyph                    Atom = 0x30806\n+\tMi                        Atom = 0x34702\n+\tMin                       Atom = 0x34703\n+\tMinlength                 Atom = 0x34709\n+\tMn                        Atom = 0x2b102\n+\tMo                        Atom = 0xa402\n \tMs                        Atom = 0x67402\n-\tMtext                     Atom = 0x34905\n-\tMultiple                  Atom = 0x35708\n-\tMuted                     Atom = 0x35f05\n-\tName                      Atom = 0xbd04\n+\tMtext                     Atom = 0x35105\n+\tMultiple                  Atom = 0x35f08\n+\tMuted                     Atom = 0x36705\n+\tName                      Atom = 0x9604\n \tNav                       Atom = 0x1303\n \tNobr                      Atom = 0x3704\n-\tNoembed                   Atom = 0x4007\n-\tNoframes                  Atom = 0x5508\n-\tNomodule                  Atom = 0x6108\n-\tNonce                     Atom = 0x56605\n-\tNoscript                  Atom = 0x20e08\n-\tNovalidate                Atom = 0x2aa0a\n-\tObject                    Atom = 0x26006\n-\tOl                        Atom = 0x11802\n+\tNoembed                   Atom = 0x6c07\n+\tNoframes                  Atom = 0x8908\n+\tNomodule                  Atom = 0xa208\n+\tNonce                     Atom = 0x1a605\n+\tNoscript                  Atom = 0x21608\n+\tNovalidate                Atom = 0x2b20a\n+\tObject                    Atom = 0x26806\n+\tOl                        Atom = 0x13702\n \tOnabort                   Atom = 0x19507\n-\tOnafterprint              Atom = 0x22e0c\n-\tOnautocomplete            Atom = 0x26e0e\n-\tOnautocompleteerror       Atom = 0x26e13\n+\tOnafterprint              Atom = 0x2360c\n+\tOnautocomplete            Atom = 0x2760e\n+\tOnautocompleteerror       Atom = 0x27613\n \tOnauxclick                Atom = 0x61f0a\n \tOnbeforeprint             Atom = 0x69e0d\n \tOnbeforeunload            Atom = 0x6e70e\n-\tOnblur                    Atom = 0x5c606\n-\tOncancel                  Atom = 0xea08\n+\tOnblur                    Atom = 0x56d06\n+\tOncancel                  Atom = 0x11908\n \tOncanplay                 Atom = 0x14d09\n \tOncanplaythrough          Atom = 0x14d10\n-\tOnchange                  Atom = 0x41308\n-\tOnclick                   Atom = 0x2ed07\n-\tOnclose                   Atom = 0x36407\n-\tOncontextmenu             Atom = 0x3760d\n-\tOncopy                    Atom = 0x38906\n-\tOncuechange               Atom = 0x38f0b\n-\tOncut                     Atom = 0x39a05\n-\tOndblclick                Atom = 0x39f0a\n-\tOndrag                    Atom = 0x3a906\n-\tOndragend                 Atom = 0x3a909\n-\tOndragenter               Atom = 0x3b20b\n-\tOndragexit                Atom = 0x3bd0a\n-\tOndragleave               Atom = 0x3d70b\n-\tOndragover                Atom = 0x3e20a\n-\tOndragstart               Atom = 0x3ec0b\n-\tOndrop                    Atom = 0x3fb06\n-\tOndurationchange          Atom = 0x40b10\n-\tOnemptied                 Atom = 0x40209\n-\tOnended                   Atom = 0x41b07\n-\tOnerror                   Atom = 0x42207\n-\tOnfocus                   Atom = 0x42907\n-\tOnhashchange              Atom = 0x4350c\n-\tOninput                   Atom = 0x44107\n-\tOninvalid                 Atom = 0x44d09\n-\tOnkeydown                 Atom = 0x45609\n-\tOnkeypress                Atom = 0x4630a\n-\tOnkeyup                   Atom = 0x47807\n-\tOnlanguagechange          Atom = 0x48510\n-\tOnload                    Atom = 0x49506\n-\tOnloadeddata              Atom = 0x4950c\n-\tOnloadedmetadata          Atom = 0x4a810\n-\tOnloadend                 Atom = 0x4be09\n-\tOnloadstart               Atom = 0x4c70b\n-\tOnmessage                 Atom = 0x4d209\n-\tOnmessageerror            Atom = 0x4d20e\n-\tOnmousedown               Atom = 0x4e00b\n-\tOnmouseenter              Atom = 0x4eb0c\n-\tOnmouseleave              Atom = 0x4f70c\n-\tOnmousemove               Atom = 0x5030b\n-\tOnmouseout                Atom = 0x50e0a\n-\tOnmouseover               Atom = 0x51b0b\n-\tOnmouseup                 Atom = 0x52609\n-\tOnmousewheel              Atom = 0x5340c\n-\tOnoffline                 Atom = 0x54009\n-\tOnonline                  Atom = 0x54908\n-\tOnpagehide                Atom = 0x5510a\n-\tOnpageshow                Atom = 0x56b0a\n-\tOnpaste                   Atom = 0x57707\n-\tOnpause                   Atom = 0x59207\n-\tOnplay                    Atom = 0x59c06\n-\tOnplaying                 Atom = 0x59c09\n-\tOnpopstate                Atom = 0x5a50a\n-\tOnprogress                Atom = 0x5af0a\n+\tOnchange                  Atom = 0x41b08\n+\tOnclick                   Atom = 0x2f507\n+\tOnclose                   Atom = 0x36c07\n+\tOncontextmenu             Atom = 0x37e0d\n+\tOncopy                    Atom = 0x39106\n+\tOncuechange               Atom = 0x3970b\n+\tOncut                     Atom = 0x3a205\n+\tOndblclick                Atom = 0x3a70a\n+\tOndrag                    Atom = 0x3b106\n+\tOndragend                 Atom = 0x3b109\n+\tOndragenter               Atom = 0x3ba0b\n+\tOndragexit                Atom = 0x3c50a\n+\tOndragleave               Atom = 0x3df0b\n+\tOndragover                Atom = 0x3ea0a\n+\tOndragstart               Atom = 0x3f40b\n+\tOndrop                    Atom = 0x40306\n+\tOndurationchange          Atom = 0x41310\n+\tOnemptied                 Atom = 0x40a09\n+\tOnended                   Atom = 0x42307\n+\tOnerror                   Atom = 0x42a07\n+\tOnfocus                   Atom = 0x43107\n+\tOnhashchange              Atom = 0x43d0c\n+\tOninput                   Atom = 0x44907\n+\tOninvalid                 Atom = 0x45509\n+\tOnkeydown                 Atom = 0x45e09\n+\tOnkeypress                Atom = 0x46b0a\n+\tOnkeyup                   Atom = 0x48007\n+\tOnlanguagechange          Atom = 0x48d10\n+\tOnload                    Atom = 0x49d06\n+\tOnloadeddata              Atom = 0x49d0c\n+\tOnloadedmetadata          Atom = 0x4b010\n+\tOnloadend                 Atom = 0x4c609\n+\tOnloadstart               Atom = 0x4cf0b\n+\tOnmessage                 Atom = 0x4da09\n+\tOnmessageerror            Atom = 0x4da0e\n+\tOnmousedown               Atom = 0x4e80b\n+\tOnmouseenter              Atom = 0x4f30c\n+\tOnmouseleave              Atom = 0x4ff0c\n+\tOnmousemove               Atom = 0x50b0b\n+\tOnmouseout                Atom = 0x5160a\n+\tOnmouseover               Atom = 0x5230b\n+\tOnmouseup                 Atom = 0x52e09\n+\tOnmousewheel              Atom = 0x53c0c\n+\tOnoffline                 Atom = 0x54809\n+\tOnonline                  Atom = 0x55108\n+\tOnpagehide                Atom = 0x5590a\n+\tOnpageshow                Atom = 0x5730a\n+\tOnpaste                   Atom = 0x57f07\n+\tOnpause                   Atom = 0x59a07\n+\tOnplay                    Atom = 0x5a406\n+\tOnplaying                 Atom = 0x5a409\n+\tOnpopstate                Atom = 0x5ad0a\n+\tOnprogress                Atom = 0x5b70a\n \tOnratechange              Atom = 0x5cc0c\n \tOnrejectionhandled        Atom = 0x5d812\n \tOnreset                   Atom = 0x5ea07\n@@ -268,509 +268,513 @@ const (\n \tOnstorage                 Atom = 0x66209\n \tOnsubmit                  Atom = 0x66b08\n \tOnsuspend                 Atom = 0x67b09\n-\tOntimeupdate              Atom = 0x1310c\n+\tOntimeupdate              Atom = 0x400c\n \tOntoggle                  Atom = 0x68408\n \tOnunhandledrejection      Atom = 0x68c14\n \tOnunload                  Atom = 0x6ab08\n \tOnvolumechange            Atom = 0x6b30e\n \tOnwaiting                 Atom = 0x6c109\n \tOnwheel                   Atom = 0x6ca07\n-\tOpen                      Atom = 0x56304\n-\tOptgroup                  Atom = 0xf708\n+\tOpen                      Atom = 0x1a304\n+\tOptgroup                  Atom = 0x5f08\n \tOptimum                   Atom = 0x6d107\n \tOption                    Atom = 0x6e306\n-\tOutput                    Atom = 0x51506\n+\tOutput                    Atom = 0x51d06\n \tP                         Atom = 0xc01\n \tParam                     Atom = 0xc05\n-\tPattern                   Atom = 0x4f07\n-\tPicture                   Atom = 0xae07\n-\tPing                      Atom = 0xfe04\n-\tPlaceholder               Atom = 0x1120b\n-\tPlaintext                 Atom = 0x1ae09\n-\tPlaysinline               Atom = 0x1210b\n-\tPoster                    Atom = 0x2c706\n-\tPre                       Atom = 0x46803\n-\tPreload                   Atom = 0x47e07\n-\tProgress                  Atom = 0x5b108\n-\tPrompt                    Atom = 0x52e06\n-\tPublic                    Atom = 0x57e06\n-\tQ                         Atom = 0x8e01\n+\tPattern                   Atom = 0x6607\n+\tPicture                   Atom = 0x7b07\n+\tPing                      Atom = 0xef04\n+\tPlaceholder               Atom = 0x1310b\n+\tPlaintext                 Atom = 0x1b209\n+\tPlaysinline               Atom = 0x1400b\n+\tPoster                    Atom = 0x2cf06\n+\tPre                       Atom = 0x47003\n+\tPreload                   Atom = 0x48607\n+\tProgress                  Atom = 0x5b908\n+\tPrompt                    Atom = 0x53606\n+\tPublic                    Atom = 0x58606\n+\tQ                         Atom = 0xcf01\n \tRadiogroup                Atom = 0x30a\n-\tReadonly                  Atom = 0x34f08\n-\tReferrerpolicy            Atom = 0x3c90e\n-\tRel                       Atom = 0x47f03\n-\tRequired                  Atom = 0x24408\n-\tReversed                  Atom = 0xb308\n-\tRows                      Atom = 0x3a04\n-\tRowspan                   Atom = 0x3a07\n-\tRp                        Atom = 0x23402\n+\tRb                        Atom = 0x3a02\n+\tReadonly                  Atom = 0x35708\n+\tReferrerpolicy            Atom = 0x3d10e\n+\tRel                       Atom = 0x48703\n+\tRequired                  Atom = 0x24c08\n+\tReversed                  Atom = 0x8008\n+\tRows                      Atom = 0x9c04\n+\tRowspan                   Atom = 0x9c07\n+\tRp                        Atom = 0x23c02\n \tRt                        Atom = 0x19a02\n-\tRuby                      Atom = 0xc304\n+\tRtc                       Atom = 0x19a03\n+\tRuby                      Atom = 0xfb04\n \tS                         Atom = 0x2501\n-\tSamp                      Atom = 0x4c04\n-\tSandbox                   Atom = 0x10a07\n+\tSamp                      Atom = 0x7804\n+\tSandbox                   Atom = 0x12907\n \tScope                     Atom = 0x67505\n \tScoped                    Atom = 0x67506\n-\tScript                    Atom = 0x21006\n-\tSeamless                  Atom = 0x36908\n-\tSection                   Atom = 0x5c107\n+\tScript                    Atom = 0x21806\n+\tSeamless                  Atom = 0x37108\n+\tSection                   Atom = 0x56807\n \tSelect                    Atom = 0x63c06\n \tSelected                  Atom = 0x63c08\n \tShape                     Atom = 0x1e505\n \tSize                      Atom = 0x5f504\n \tSizes                     Atom = 0x5f505\n \tSlot                      Atom = 0x1ef04\n-\tSmall                     Atom = 0x1fe05\n+\tSmall                     Atom = 0x20605\n \tSortable                  Atom = 0x65108\n-\tSorted                    Atom = 0x32f06\n-\tSource                    Atom = 0x37006\n-\tSpacer                    Atom = 0x42f06\n-\tSpan                      Atom = 0x3d04\n-\tSpellcheck                Atom = 0x46c0a\n-\tSrc                       Atom = 0x5b803\n-\tSrcdoc                    Atom = 0x5b806\n+\tSorted                    Atom = 0x33706\n+\tSource                    Atom = 0x37806\n+\tSpacer                    Atom = 0x43706\n+\tSpan                      Atom = 0x9f04\n+\tSpellcheck                Atom = 0x4740a\n+\tSrc                       Atom = 0x5c003\n+\tSrcdoc                    Atom = 0x5c006\n \tSrclang                   Atom = 0x5f907\n \tSrcset                    Atom = 0x6f906\n-\tStart                     Atom = 0x3f205\n-\tStep                      Atom = 0x57b04\n-\tStrike                    Atom = 0x9106\n+\tStart                     Atom = 0x3fa05\n+\tStep                      Atom = 0x58304\n+\tStrike                    Atom = 0xd206\n \tStrong                    Atom = 0x6dd06\n \tStyle                     Atom = 0x6ff05\n \tSub                       Atom = 0x66d03\n \tSummary                   Atom = 0x70407\n \tSup                       Atom = 0x70b03\n \tSvg                       Atom = 0x70e03\n \tSystem                    Atom = 0x71106\n-\tTabindex                  Atom = 0x4b608\n-\tTable                     Atom = 0x58d05\n-\tTarget                    Atom = 0x2bc06\n+\tTabindex                  Atom = 0x4be08\n+\tTable                     Atom = 0x59505\n+\tTarget                    Atom = 0x2c406\n \tTbody                     Atom = 0x2705\n-\tTd                        Atom = 0x5e02\n+\tTd                        Atom = 0x9202\n \tTemplate                  Atom = 0x71408\n-\tTextarea                  Atom = 0x34a08\n-\tTfoot                     Atom = 0xc905\n+\tTextarea                  Atom = 0x35208\n+\tTfoot                     Atom = 0xf505\n \tTh                        Atom = 0x15602\n-\tThead                     Atom = 0x32805\n-\tTime                      Atom = 0x13304\n-\tTitle                     Atom = 0xe105\n-\tTr                        Atom = 0x8b02\n-\tTrack                     Atom = 0x19b05\n-\tTranslate                 Atom = 0x1b609\n-\tTt                        Atom = 0x5102\n-\tType                      Atom = 0x9804\n-\tTypemustmatch             Atom = 0x2880d\n+\tThead                     Atom = 0x33005\n+\tTime                      Atom = 0x4204\n+\tTitle                     Atom = 0x11005\n+\tTr                        Atom = 0xcc02\n+\tTrack                     Atom = 0x1ba05\n+\tTranslate                 Atom = 0x1f209\n+\tTt                        Atom = 0x6802\n+\tType                      Atom = 0xd904\n+\tTypemustmatch             Atom = 0x2900d\n \tU                         Atom = 0xb01\n-\tUl                        Atom = 0x6602\n-\tUpdateviacache            Atom = 0x1370e\n-\tUsemap                    Atom = 0x59606\n+\tUl                        Atom = 0xa702\n+\tUpdateviacache            Atom = 0x460e\n+\tUsemap                    Atom = 0x59e06\n \tValue                     Atom = 0x1505\n \tVar                       Atom = 0x16d03\n-\tVideo                     Atom = 0x2e905\n-\tWbr                       Atom = 0x57403\n+\tVideo                     Atom = 0x2f105\n+\tWbr                       Atom = 0x57c03\n \tWidth                     Atom = 0x64905\n \tWorkertype                Atom = 0x71c0a\n \tWrap                      Atom = 0x72604\n-\tXmp                       Atom = 0x11003\n+\tXmp                       Atom = 0x12f03\n )\n \n const hash0 = 0x81cdf10e\n \n const maxAtomLen = 25\n \n var table = [1 << 9]Atom{\n-\t0x1:   0xa50a,  // mediagroup\n-\t0x2:   0x2dc04, // lang\n+\t0x1:   0xe60a,  // mediagroup\n+\t0x2:   0x2e404, // lang\n \t0x4:   0x2c09,  // accesskey\n-\t0x5:   0x5708,  // frameset\n+\t0x5:   0x8b08,  // frameset\n \t0x7:   0x63a08, // onselect\n \t0x8:   0x71106, // system\n \t0xa:   0x64905, // width\n-\t0xc:   0x2810b, // formenctype\n-\t0xd:   0x11802, // ol\n-\t0xe:   0x38f0b, // oncuechange\n+\t0xc:   0x2890b, // formenctype\n+\t0xd:   0x13702, // ol\n+\t0xe:   0x3970b, // oncuechange\n \t0x10:  0x14b03, // bdo\n-\t0x11:  0xe605,  // audio\n+\t0x11:  0x11505, // audio\n \t0x12:  0x17a09, // draggable\n-\t0x14:  0x2e905, // video\n-\t0x15:  0x2a902, // mn\n-\t0x16:  0x37f04, // menu\n-\t0x17:  0x2c706, // poster\n-\t0x19:  0xca06,  // footer\n-\t0x1a:  0x2a006, // method\n-\t0x1b:  0x2b008, // datetime\n+\t0x14:  0x2f105, // video\n+\t0x15:  0x2b102, // mn\n+\t0x16:  0x38704, // menu\n+\t0x17:  0x2cf06, // poster\n+\t0x19:  0xf606,  // footer\n+\t0x1a:  0x2a806, // method\n+\t0x1b:  0x2b808, // datetime\n \t0x1c:  0x19507, // onabort\n-\t0x1d:  0x1370e, // updateviacache\n-\t0x1e:  0xd005,  // async\n-\t0x1f:  0x49506, // onload\n-\t0x21:  0xea08,  // oncancel\n+\t0x1d:  0x460e,  // updateviacache\n+\t0x1e:  0xff05,  // async\n+\t0x1f:  0x49d06, // onload\n+\t0x21:  0x11908, // oncancel\n \t0x22:  0x62908, // onseeked\n-\t0x23:  0x2fa05, // image\n+\t0x23:  0x30205, // image\n \t0x24:  0x5d812, // onrejectionhandled\n \t0x26:  0x17404, // link\n-\t0x27:  0x51506, // output\n-\t0x28:  0x32904, // head\n-\t0x29:  0x4f70c, // onmouseleave\n-\t0x2a:  0x57707, // onpaste\n-\t0x2b:  0x59c09, // onplaying\n+\t0x27:  0x51d06, // output\n+\t0x28:  0x33104, // head\n+\t0x29:  0x4ff0c, // onmouseleave\n+\t0x2a:  0x57f07, // onpaste\n+\t0x2b:  0x5a409, // onplaying\n \t0x2c:  0x1c407, // colspan\n \t0x2f:  0x1bf05, // color\n \t0x30:  0x5f504, // size\n-\t0x31:  0x2e00a, // http-equiv\n+\t0x31:  0x2e80a, // http-equiv\n \t0x33:  0x601,   // i\n-\t0x34:  0x5510a, // onpagehide\n+\t0x34:  0x5590a, // onpagehide\n \t0x35:  0x68c14, // onunhandledrejection\n-\t0x37:  0x42207, // onerror\n-\t0x3a:  0x12c08, // basefont\n+\t0x37:  0x42a07, // onerror\n+\t0x3a:  0x3b08,  // basefont\n \t0x3f:  0x1303,  // nav\n \t0x40:  0x17704, // kind\n-\t0x41:  0x34f08, // readonly\n-\t0x42:  0x30006, // mglyph\n-\t0x44:  0x7102,  // li\n-\t0x46:  0x2cd06, // hidden\n+\t0x41:  0x35708, // readonly\n+\t0x42:  0x30806, // mglyph\n+\t0x44:  0xb202,  // li\n+\t0x46:  0x2d506, // hidden\n \t0x47:  0x70e03, // svg\n-\t0x48:  0x57b04, // step\n-\t0x49:  0x23709, // integrity\n-\t0x4a:  0x57e06, // public\n-\t0x4c:  0x1a703, // col\n+\t0x48:  0x58304, // step\n+\t0x49:  0x23f09, // integrity\n+\t0x4a:  0x58606, // public\n+\t0x4c:  0x1ab03, // col\n \t0x4d:  0x1870a, // blockquote\n-\t0x4e:  0x34702, // h5\n-\t0x50:  0x5b108, // progress\n+\t0x4e:  0x34f02, // h5\n+\t0x50:  0x5b908, // progress\n \t0x51:  0x5f505, // sizes\n-\t0x52:  0x33d02, // h4\n-\t0x56:  0x32805, // thead\n-\t0x57:  0x9507,  // keytype\n-\t0x58:  0x5af0a, // onprogress\n-\t0x59:  0x44309, // inputmode\n-\t0x5a:  0x3a909, // ondragend\n-\t0x5d:  0x39a05, // oncut\n-\t0x5e:  0x42f06, // spacer\n-\t0x5f:  0x1a708, // colgroup\n+\t0x52:  0x34502, // h4\n+\t0x56:  0x33005, // thead\n+\t0x57:  0xd607,  // keytype\n+\t0x58:  0x5b70a, // onprogress\n+\t0x59:  0x44b09, // inputmode\n+\t0x5a:  0x3b109, // ondragend\n+\t0x5d:  0x3a205, // oncut\n+\t0x5e:  0x43706, // spacer\n+\t0x5f:  0x1ab08, // colgroup\n \t0x62:  0x16502, // is\n-\t0x65:  0xd002,  // as\n-\t0x66:  0x54009, // onoffline\n-\t0x67:  0x32f06, // sorted\n-\t0x69:  0x48510, // onlanguagechange\n-\t0x6c:  0x4350c, // onhashchange\n-\t0x6d:  0xbd04,  // name\n-\t0x6e:  0xc905,  // tfoot\n-\t0x6f:  0x55904, // desc\n-\t0x70:  0x33503, // max\n+\t0x65:  0x3c02,  // as\n+\t0x66:  0x54809, // onoffline\n+\t0x67:  0x33706, // sorted\n+\t0x69:  0x48d10, // onlanguagechange\n+\t0x6c:  0x43d0c, // onhashchange\n+\t0x6d:  0x9604,  // name\n+\t0x6e:  0xf505,  // tfoot\n+\t0x6f:  0x56104, // desc\n+\t0x70:  0x33d03, // max\n \t0x72:  0x1ea06, // coords\n-\t0x73:  0x30502, // h3\n+\t0x73:  0x30d02, // h3\n \t0x74:  0x6e70e, // onbeforeunload\n-\t0x75:  0x3a04,  // rows\n+\t0x75:  0x9c04,  // rows\n \t0x76:  0x63c06, // select\n-\t0x77:  0xbf05,  // meter\n-\t0x78:  0x38306, // itemid\n-\t0x79:  0x5340c, // onmousewheel\n-\t0x7a:  0x5b806, // srcdoc\n-\t0x7d:  0x19b05, // track\n-\t0x7f:  0x31708, // itemtype\n-\t0x82:  0x6302,  // mo\n-\t0x83:  0x41308, // onchange\n-\t0x84:  0x32907, // headers\n+\t0x77:  0x9805,  // meter\n+\t0x78:  0x38b06, // itemid\n+\t0x79:  0x53c0c, // onmousewheel\n+\t0x7a:  0x5c006, // srcdoc\n+\t0x7d:  0x1ba05, // track\n+\t0x7f:  0x31f08, // itemtype\n+\t0x82:  0xa402,  // mo\n+\t0x83:  0x41b08, // onchange\n+\t0x84:  0x33107, // headers\n \t0x85:  0x5cc0c, // onratechange\n \t0x86:  0x60819, // onsecuritypolicyviolation\n-\t0x88:  0x49d08, // datalist\n-\t0x89:  0x4e00b, // onmousedown\n+\t0x88:  0x4a508, // datalist\n+\t0x89:  0x4e80b, // onmousedown\n \t0x8a:  0x1ef04, // slot\n-\t0x8b:  0x4a810, // onloadedmetadata\n+\t0x8b:  0x4b010, // onloadedmetadata\n \t0x8c:  0x1a06,  // accept\n-\t0x8d:  0x26006, // object\n+\t0x8d:  0x26806, // object\n \t0x91:  0x6b30e, // onvolumechange\n \t0x92:  0x2107,  // charset\n-\t0x93:  0x26e13, // onautocompleteerror\n-\t0x94:  0x8013,  // allowpaymentrequest\n+\t0x93:  0x27613, // onautocompleteerror\n+\t0x94:  0xc113,  // allowpaymentrequest\n \t0x95:  0x2804,  // body\n-\t0x96:  0xdb07,  // default\n+\t0x96:  0x10a07, // default\n \t0x97:  0x63c08, // selected\n-\t0x98:  0x21604, // face\n+\t0x98:  0x21e04, // face\n \t0x99:  0x1e505, // shape\n \t0x9b:  0x68408, // ontoggle\n \t0x9e:  0x64b02, // dt\n-\t0x9f:  0x7504,  // mark\n+\t0x9f:  0xb604,  // mark\n \t0xa1:  0xb01,   // u\n \t0xa4:  0x6ab08, // onunload\n-\t0xa5:  0xf504,  // loop\n+\t0xa5:  0x5d04,  // loop\n \t0xa6:  0x16408, // disabled\n-\t0xaa:  0x41b07, // onended\n-\t0xab:  0x6f0a,  // malignmark\n+\t0xaa:  0x42307, // onended\n+\t0xab:  0xb00a,  // malignmark\n \t0xad:  0x67b09, // onsuspend\n-\t0xae:  0x34905, // mtext\n+\t0xae:  0x35105, // mtext\n \t0xaf:  0x64f06, // onsort\n-\t0xb0:  0x55d08, // itemprop\n+\t0xb0:  0x19d08, // itemprop\n \t0xb3:  0x67109, // itemscope\n \t0xb4:  0x17305, // blink\n-\t0xb6:  0x3a906, // ondrag\n-\t0xb7:  0x6602,  // ul\n-\t0xb8:  0x26604, // form\n-\t0xb9:  0x10a07, // sandbox\n-\t0xba:  0x5705,  // frame\n+\t0xb6:  0x3b106, // ondrag\n+\t0xb7:  0xa702,  // ul\n+\t0xb8:  0x26e04, // form\n+\t0xb9:  0x12907, // sandbox\n+\t0xba:  0x8b05,  // frame\n \t0xbb:  0x1505,  // value\n \t0xbc:  0x66209, // onstorage\n-\t0xbf:  0x6907,  // acronym\n+\t0xbf:  0xaa07,  // acronym\n \t0xc0:  0x19a02, // rt\n \t0xc2:  0x202,   // br\n-\t0xc3:  0x21e08, // fieldset\n-\t0xc4:  0x2880d, // typemustmatch\n-\t0xc5:  0x6108,  // nomodule\n-\t0xc6:  0x4007,  // noembed\n+\t0xc3:  0x22608, // fieldset\n+\t0xc4:  0x2900d, // typemustmatch\n+\t0xc5:  0xa208,  // nomodule\n+\t0xc6:  0x6c07,  // noembed\n \t0xc7:  0x69e0d, // onbeforeprint\n \t0xc8:  0x19106, // button\n-\t0xc9:  0x2ed07, // onclick\n+\t0xc9:  0x2f507, // onclick\n \t0xca:  0x70407, // summary\n-\t0xcd:  0xc304,  // ruby\n-\t0xce:  0x5bd05, // class\n-\t0xcf:  0x3ec0b, // ondragstart\n-\t0xd0:  0x22907, // caption\n-\t0xd4:  0x9c0e,  // allowusermedia\n-\t0xd5:  0x4c70b, // onloadstart\n+\t0xcd:  0xfb04,  // ruby\n+\t0xce:  0x56405, // class\n+\t0xcf:  0x3f40b, // ondragstart\n+\t0xd0:  0x23107, // caption\n+\t0xd4:  0xdd0e,  // allowusermedia\n+\t0xd5:  0x4cf0b, // onloadstart\n \t0xd9:  0x16b03, // div\n-\t0xda:  0x4a104, // list\n-\t0xdb:  0x32604, // math\n-\t0xdc:  0x44305, // input\n-\t0xdf:  0x3e20a, // ondragover\n-\t0xe0:  0x2d602, // h2\n-\t0xe2:  0x1ae09, // plaintext\n-\t0xe4:  0x4eb0c, // onmouseenter\n-\t0xe7:  0x47107, // checked\n-\t0xe8:  0x46803, // pre\n-\t0xea:  0x35708, // multiple\n-\t0xeb:  0x7903,  // bdi\n-\t0xec:  0x33509, // maxlength\n-\t0xed:  0x8e01,  // q\n+\t0xda:  0x4a904, // list\n+\t0xdb:  0x32e04, // math\n+\t0xdc:  0x44b05, // input\n+\t0xdf:  0x3ea0a, // ondragover\n+\t0xe0:  0x2de02, // h2\n+\t0xe2:  0x1b209, // plaintext\n+\t0xe4:  0x4f30c, // onmouseenter\n+\t0xe7:  0x47907, // checked\n+\t0xe8:  0x47003, // pre\n+\t0xea:  0x35f08, // multiple\n+\t0xeb:  0xba03,  // bdi\n+\t0xec:  0x33d09, // maxlength\n+\t0xed:  0xcf01,  // q\n \t0xee:  0x61f0a, // onauxclick\n-\t0xf0:  0x57403, // wbr\n-\t0xf2:  0x12c04, // base\n+\t0xf0:  0x57c03, // wbr\n+\t0xf2:  0x3b04,  // base\n \t0xf3:  0x6e306, // option\n-\t0xf5:  0x40b10, // ondurationchange\n-\t0xf7:  0x5508,  // noframes\n-\t0xf9:  0x3fd08, // dropzone\n+\t0xf5:  0x41310, // ondurationchange\n+\t0xf7:  0x8908,  // noframes\n+\t0xf9:  0x40508, // dropzone\n \t0xfb:  0x67505, // scope\n-\t0xfc:  0xb308,  // reversed\n-\t0xfd:  0x3b20b, // ondragenter\n-\t0xfe:  0x3f205, // start\n-\t0xff:  0x11003, // xmp\n+\t0xfc:  0x8008,  // reversed\n+\t0xfd:  0x3ba0b, // ondragenter\n+\t0xfe:  0x3fa05, // start\n+\t0xff:  0x12f03, // xmp\n \t0x100: 0x5f907, // srclang\n-\t0x101: 0x2ff03, // img\n+\t0x101: 0x30703, // img\n \t0x104: 0x101,   // b\n-\t0x105: 0x24c03, // for\n-\t0x106: 0xd805,  // aside\n-\t0x107: 0x44107, // oninput\n-\t0x108: 0x34e04, // area\n-\t0x109: 0x29c0a, // formmethod\n+\t0x105: 0x25403, // for\n+\t0x106: 0x10705, // aside\n+\t0x107: 0x44907, // oninput\n+\t0x108: 0x35604, // area\n+\t0x109: 0x2a40a, // formmethod\n \t0x10a: 0x72604, // wrap\n-\t0x10c: 0x23402, // rp\n-\t0x10d: 0x4630a, // onkeypress\n-\t0x10e: 0x5102,  // tt\n-\t0x110: 0x33f02, // mi\n-\t0x111: 0x35f05, // muted\n-\t0x112: 0xc703,  // alt\n-\t0x113: 0x1a004, // code\n-\t0x114: 0x4202,  // em\n-\t0x115: 0x3bd0a, // ondragexit\n-\t0x117: 0x3d04,  // span\n+\t0x10c: 0x23c02, // rp\n+\t0x10d: 0x46b0a, // onkeypress\n+\t0x10e: 0x6802,  // tt\n+\t0x110: 0x34702, // mi\n+\t0x111: 0x36705, // muted\n+\t0x112: 0xf303,  // alt\n+\t0x113: 0x5c504, // code\n+\t0x114: 0x6e02,  // em\n+\t0x115: 0x3c50a, // ondragexit\n+\t0x117: 0x9f04,  // span\n \t0x119: 0x6d708, // manifest\n-\t0x11a: 0x37f08, // menuitem\n-\t0x11b: 0x58307, // content\n+\t0x11a: 0x38708, // menuitem\n+\t0x11b: 0x58b07, // content\n \t0x11d: 0x6c109, // onwaiting\n-\t0x11f: 0x4be09, // onloadend\n-\t0x121: 0x3760d, // oncontextmenu\n-\t0x123: 0x5c606, // onblur\n-\t0x124: 0x3f407, // article\n-\t0x125: 0xba03,  // dir\n-\t0x126: 0xfe04,  // ping\n-\t0x127: 0x24408, // required\n-\t0x128: 0x44d09, // oninvalid\n-\t0x129: 0x7005,  // align\n-\t0x12b: 0x58204, // icon\n+\t0x11f: 0x4c609, // onloadend\n+\t0x121: 0x37e0d, // oncontextmenu\n+\t0x123: 0x56d06, // onblur\n+\t0x124: 0x3fc07, // article\n+\t0x125: 0x9303,  // dir\n+\t0x126: 0xef04,  // ping\n+\t0x127: 0x24c08, // required\n+\t0x128: 0x45509, // oninvalid\n+\t0x129: 0xb105,  // align\n+\t0x12b: 0x58a04, // icon\n \t0x12c: 0x64d02, // h6\n \t0x12d: 0x1c404, // cols\n-\t0x12e: 0x2260a, // figcaption\n-\t0x12f: 0x45609, // onkeydown\n+\t0x12e: 0x22e0a, // figcaption\n+\t0x12f: 0x45e09, // onkeydown\n \t0x130: 0x66b08, // onsubmit\n \t0x131: 0x14d09, // oncanplay\n \t0x132: 0x70b03, // sup\n \t0x133: 0xc01,   // p\n-\t0x135: 0x40209, // onemptied\n-\t0x136: 0x38906, // oncopy\n-\t0x137: 0x55c04, // cite\n-\t0x138: 0x39f0a, // ondblclick\n-\t0x13a: 0x5030b, // onmousemove\n+\t0x135: 0x40a09, // onemptied\n+\t0x136: 0x39106, // oncopy\n+\t0x137: 0x19c04, // cite\n+\t0x138: 0x3a70a, // ondblclick\n+\t0x13a: 0x50b0b, // onmousemove\n \t0x13c: 0x66d03, // sub\n-\t0x13d: 0x47f03, // rel\n-\t0x13e: 0xf708,  // optgroup\n-\t0x142: 0x3a07,  // rowspan\n-\t0x143: 0x37006, // source\n-\t0x144: 0x20e08, // noscript\n-\t0x145: 0x56304, // open\n-\t0x146: 0x1fc03, // ins\n-\t0x147: 0x24c0d, // foreignObject\n-\t0x148: 0x5a50a, // onpopstate\n-\t0x14a: 0x28507, // enctype\n-\t0x14b: 0x26e0e, // onautocomplete\n-\t0x14c: 0x34a08, // textarea\n-\t0x14e: 0x2700c, // autocomplete\n+\t0x13d: 0x48703, // rel\n+\t0x13e: 0x5f08,  // optgroup\n+\t0x142: 0x9c07,  // rowspan\n+\t0x143: 0x37806, // source\n+\t0x144: 0x21608, // noscript\n+\t0x145: 0x1a304, // open\n+\t0x146: 0x20403, // ins\n+\t0x147: 0x2540d, // foreignObject\n+\t0x148: 0x5ad0a, // onpopstate\n+\t0x14a: 0x28d07, // enctype\n+\t0x14b: 0x2760e, // onautocomplete\n+\t0x14c: 0x35208, // textarea\n+\t0x14e: 0x2780c, // autocomplete\n \t0x14f: 0x15702, // hr\n \t0x150: 0x1de08, // controls\n-\t0x151: 0xda02,  // id\n-\t0x153: 0x22e0c, // onafterprint\n-\t0x155: 0x2590d, // foreignobject\n-\t0x156: 0x31f07, // marquee\n-\t0x157: 0x59207, // onpause\n+\t0x151: 0x10902, // id\n+\t0x153: 0x2360c, // onafterprint\n+\t0x155: 0x2610d, // foreignobject\n+\t0x156: 0x32707, // marquee\n+\t0x157: 0x59a07, // onpause\n \t0x158: 0x5e602, // dl\n-\t0x159: 0x14306, // height\n-\t0x15a: 0x33f03, // min\n-\t0x15b: 0xba07,  // dirname\n-\t0x15c: 0x1b609, // translate\n-\t0x15d: 0x14704, // html\n-\t0x15e: 0x33f09, // minlength\n-\t0x15f: 0x47e07, // preload\n+\t0x159: 0x5206,  // height\n+\t0x15a: 0x34703, // min\n+\t0x15b: 0x9307,  // dirname\n+\t0x15c: 0x1f209, // translate\n+\t0x15d: 0x5604,  // html\n+\t0x15e: 0x34709, // minlength\n+\t0x15f: 0x48607, // preload\n \t0x160: 0x71408, // template\n-\t0x161: 0x3d70b, // ondragleave\n-\t0x164: 0x5b803, // src\n+\t0x161: 0x3df0b, // ondragleave\n+\t0x162: 0x3a02,  // rb\n+\t0x164: 0x5c003, // src\n \t0x165: 0x6dd06, // strong\n-\t0x167: 0x4c04,  // samp\n+\t0x167: 0x7804,  // samp\n \t0x168: 0x6f307, // address\n-\t0x169: 0x54908, // ononline\n-\t0x16b: 0x1120b, // placeholder\n-\t0x16c: 0x2bc06, // target\n-\t0x16d: 0x1fe05, // small\n+\t0x169: 0x55108, // ononline\n+\t0x16b: 0x1310b, // placeholder\n+\t0x16c: 0x2c406, // target\n+\t0x16d: 0x20605, // small\n \t0x16e: 0x6ca07, // onwheel\n \t0x16f: 0x1c90a, // annotation\n-\t0x170: 0x46c0a, // spellcheck\n-\t0x171: 0x4607,  // details\n-\t0x172: 0xd406,  // canvas\n-\t0x173: 0x10209, // autofocus\n+\t0x170: 0x4740a, // spellcheck\n+\t0x171: 0x7207,  // details\n+\t0x172: 0x10306, // canvas\n+\t0x173: 0x12109, // autofocus\n \t0x174: 0xc05,   // param\n-\t0x176: 0x45b08, // download\n-\t0x177: 0x44a03, // del\n-\t0x178: 0x36407, // onclose\n-\t0x179: 0x7803,  // kbd\n-\t0x17a: 0x31106, // applet\n-\t0x17b: 0x2d804, // href\n+\t0x176: 0x46308, // download\n+\t0x177: 0x45203, // del\n+\t0x178: 0x36c07, // onclose\n+\t0x179: 0xb903,  // kbd\n+\t0x17a: 0x31906, // applet\n+\t0x17b: 0x2e004, // href\n \t0x17c: 0x5f108, // onresize\n-\t0x17e: 0x4950c, // onloadeddata\n-\t0x180: 0x8b02,  // tr\n-\t0x181: 0x2b80a, // formtarget\n-\t0x182: 0xe105,  // title\n+\t0x17e: 0x49d0c, // onloadeddata\n+\t0x180: 0xcc02,  // tr\n+\t0x181: 0x2c00a, // formtarget\n+\t0x182: 0x11005, // title\n \t0x183: 0x6ff05, // style\n-\t0x184: 0x9106,  // strike\n-\t0x185: 0x59606, // usemap\n-\t0x186: 0x2f406, // iframe\n+\t0x184: 0xd206,  // strike\n+\t0x185: 0x59e06, // usemap\n+\t0x186: 0x2fc06, // iframe\n \t0x187: 0x1004,  // main\n-\t0x189: 0xae07,  // picture\n-\t0x18c: 0x30e05, // ismap\n-\t0x18e: 0x49d04, // data\n-\t0x18f: 0xf105,  // label\n-\t0x191: 0x3c90e, // referrerpolicy\n+\t0x189: 0x7b07,  // picture\n+\t0x18c: 0x31605, // ismap\n+\t0x18e: 0x4a504, // data\n+\t0x18f: 0x5905,  // label\n+\t0x191: 0x3d10e, // referrerpolicy\n \t0x192: 0x15602, // th\n-\t0x194: 0x52e06, // prompt\n-\t0x195: 0x5c107, // section\n+\t0x194: 0x53606, // prompt\n+\t0x195: 0x56807, // section\n \t0x197: 0x6d107, // optimum\n-\t0x198: 0x2d304, // high\n+\t0x198: 0x2db04, // high\n \t0x199: 0x15c02, // h1\n \t0x19a: 0x65909, // onstalled\n \t0x19b: 0x16d03, // var\n-\t0x19c: 0x13304, // time\n+\t0x19c: 0x4204,  // time\n \t0x19e: 0x67402, // ms\n-\t0x19f: 0x32906, // header\n-\t0x1a0: 0x4d209, // onmessage\n-\t0x1a1: 0x56605, // nonce\n-\t0x1a2: 0x2660a, // formaction\n-\t0x1a3: 0x21806, // center\n+\t0x19f: 0x33106, // header\n+\t0x1a0: 0x4da09, // onmessage\n+\t0x1a1: 0x1a605, // nonce\n+\t0x1a2: 0x26e0a, // formaction\n+\t0x1a3: 0x22006, // center\n \t0x1a4: 0x3704,  // nobr\n-\t0x1a5: 0x58d05, // table\n-\t0x1a6: 0x4a107, // listing\n+\t0x1a5: 0x59505, // table\n+\t0x1a6: 0x4a907, // listing\n \t0x1a7: 0x18106, // legend\n-\t0x1a9: 0x29309, // challenge\n-\t0x1aa: 0x24006, // figure\n-\t0x1ab: 0xa505,  // media\n-\t0x1ae: 0x9804,  // type\n-\t0x1af: 0x13004, // font\n-\t0x1b0: 0x4d20e, // onmessageerror\n-\t0x1b1: 0x36908, // seamless\n-\t0x1b2: 0x5f03,  // dfn\n-\t0x1b3: 0x1a205, // defer\n-\t0x1b4: 0x8203,  // low\n-\t0x1b5: 0x63109, // onseeking\n-\t0x1b6: 0x51b0b, // onmouseover\n-\t0x1b7: 0x2aa0a, // novalidate\n+\t0x1a9: 0x29b09, // challenge\n+\t0x1aa: 0x24806, // figure\n+\t0x1ab: 0xe605,  // media\n+\t0x1ae: 0xd904,  // type\n+\t0x1af: 0x3f04,  // font\n+\t0x1b0: 0x4da0e, // onmessageerror\n+\t0x1b1: 0x37108, // seamless\n+\t0x1b2: 0x8703,  // dfn\n+\t0x1b3: 0x5c705, // defer\n+\t0x1b4: 0xc303,  // low\n+\t0x1b5: 0x19a03, // rtc\n+\t0x1b6: 0x5230b, // onmouseover\n+\t0x1b7: 0x2b20a, // novalidate\n \t0x1b8: 0x71c0a, // workertype\n-\t0x1ba: 0x3c507, // itemref\n+\t0x1ba: 0x3cd07, // itemref\n \t0x1bd: 0x1,     // a\n-\t0x1be: 0x31003, // map\n-\t0x1bf: 0x1310c, // ontimeupdate\n+\t0x1be: 0x31803, // map\n+\t0x1bf: 0x400c,  // ontimeupdate\n \t0x1c0: 0x15e07, // bgsound\n \t0x1c1: 0x3206,  // keygen\n \t0x1c2: 0x2705,  // tbody\n \t0x1c5: 0x64406, // onshow\n \t0x1c7: 0x2501,  // s\n-\t0x1c8: 0x4f07,  // pattern\n+\t0x1c8: 0x6607,  // pattern\n \t0x1cc: 0x14d10, // oncanplaythrough\n-\t0x1ce: 0x2cf02, // dd\n+\t0x1ce: 0x2d702, // dd\n \t0x1cf: 0x6f906, // srcset\n \t0x1d0: 0x17003, // big\n \t0x1d2: 0x65108, // sortable\n-\t0x1d3: 0x47807, // onkeyup\n-\t0x1d5: 0x59c06, // onplay\n-\t0x1d7: 0x4b004, // meta\n-\t0x1d8: 0x3fb06, // ondrop\n+\t0x1d3: 0x48007, // onkeyup\n+\t0x1d5: 0x5a406, // onplay\n+\t0x1d7: 0x4b804, // meta\n+\t0x1d8: 0x40306, // ondrop\n \t0x1da: 0x60008, // onscroll\n-\t0x1db: 0x1f30b, // crossorigin\n-\t0x1dc: 0x56b0a, // onpageshow\n+\t0x1db: 0x1fb0b, // crossorigin\n+\t0x1dc: 0x5730a, // onpageshow\n \t0x1dd: 0x4,     // abbr\n-\t0x1de: 0x5e02,  // td\n-\t0x1df: 0x5830f, // contenteditable\n-\t0x1e0: 0x26a06, // action\n-\t0x1e1: 0x1210b, // playsinline\n-\t0x1e2: 0x42907, // onfocus\n-\t0x1e3: 0x2d808, // hreflang\n-\t0x1e5: 0x50e0a, // onmouseout\n+\t0x1de: 0x9202,  // td\n+\t0x1df: 0x58b0f, // contenteditable\n+\t0x1e0: 0x27206, // action\n+\t0x1e1: 0x1400b, // playsinline\n+\t0x1e2: 0x43107, // onfocus\n+\t0x1e3: 0x2e008, // hreflang\n+\t0x1e5: 0x5160a, // onmouseout\n \t0x1e6: 0x5ea07, // onreset\n-\t0x1e7: 0x11d08, // autoplay\n+\t0x1e7: 0x13c08, // autoplay\n+\t0x1e8: 0x63109, // onseeking\n \t0x1ea: 0x67506, // scoped\n \t0x1ec: 0x30a,   // radiogroup\n-\t0x1ee: 0x3780b, // contextmenu\n-\t0x1ef: 0x52609, // onmouseup\n-\t0x1f1: 0x2c206, // hgroup\n-\t0x1f2: 0x2000f, // allowfullscreen\n-\t0x1f3: 0x4b608, // tabindex\n-\t0x1f6: 0x30707, // isindex\n+\t0x1ee: 0x3800b, // contextmenu\n+\t0x1ef: 0x52e09, // onmouseup\n+\t0x1f1: 0x2ca06, // hgroup\n+\t0x1f2: 0x2080f, // allowfullscreen\n+\t0x1f3: 0x4be08, // tabindex\n+\t0x1f6: 0x30f07, // isindex\n \t0x1f7: 0x1a0e,  // accept-charset\n-\t0x1f8: 0x2a60e, // formnovalidate\n+\t0x1f8: 0x2ae0e, // formnovalidate\n \t0x1fb: 0x1c90e, // annotation-xml\n-\t0x1fc: 0x4205,  // embed\n-\t0x1fd: 0x21006, // script\n-\t0x1fe: 0x7a06,  // dialog\n+\t0x1fc: 0x6e05,  // embed\n+\t0x1fd: 0x21806, // script\n+\t0x1fe: 0xbb06,  // dialog\n \t0x1ff: 0x1d707, // command\n }\n \n-const atomText = \"abbradiogrouparamainavalueaccept-charsetbodyaccesskeygenobro\" +\n-\t\"wspanoembedetailsampatternoframesetdfnomoduleacronymalignmar\" +\n-\t\"kbdialogallowpaymentrequestrikeytypeallowusermediagroupictur\" +\n-\t\"eversedirnameterubyaltfooterasyncanvasidefaultitleaudioncanc\" +\n-\t\"elabelooptgroupingautofocusandboxmplaceholderautoplaysinline\" +\n-\t\"basefontimeupdateviacacheightmlbdoncanplaythrough1bgsoundisa\" +\n-\t\"bledivarbigblinkindraggablegendblockquotebuttonabortrackcode\" +\n-\t\"fercolgrouplaintextranslatecolorcolspannotation-xmlcommandco\" +\n-\t\"ntrolshapecoordslotcrossoriginsmallowfullscreenoscriptfacent\" +\n-\t\"erfieldsetfigcaptionafterprintegrityfigurequiredforeignObjec\" +\n-\t\"tforeignobjectformactionautocompleteerrorformenctypemustmatc\" +\n-\t\"hallengeformmethodformnovalidatetimeformtargethgrouposterhid\" +\n-\t\"denhigh2hreflanghttp-equivideonclickiframeimageimglyph3isind\" +\n-\t\"exismappletitemtypemarqueematheadersortedmaxlength4minlength\" +\n-\t\"5mtextareadonlymultiplemutedoncloseamlessourceoncontextmenui\" +\n-\t\"temidoncopyoncuechangeoncutondblclickondragendondragenterond\" +\n-\t\"ragexitemreferrerpolicyondragleaveondragoverondragstarticleo\" +\n-\t\"ndropzonemptiedondurationchangeonendedonerroronfocuspaceronh\" +\n-\t\"ashchangeoninputmodeloninvalidonkeydownloadonkeypresspellche\" +\n-\t\"ckedonkeyupreloadonlanguagechangeonloadeddatalistingonloaded\" +\n-\t\"metadatabindexonloadendonloadstartonmessageerroronmousedowno\" +\n-\t\"nmouseenteronmouseleaveonmousemoveonmouseoutputonmouseoveron\" +\n-\t\"mouseupromptonmousewheelonofflineononlineonpagehidescitempro\" +\n-\t\"penonceonpageshowbronpastepublicontenteditableonpausemaponpl\" +\n-\t\"ayingonpopstateonprogressrcdoclassectionbluronratechangeonre\" +\n+const atomText = \"abbradiogrouparamainavalueaccept-charsetbodyaccesskeygenobrb\" +\n+\t\"asefontimeupdateviacacheightmlabelooptgroupatternoembedetail\" +\n+\t\"sampictureversedfnoframesetdirnameterowspanomoduleacronymali\" +\n+\t\"gnmarkbdialogallowpaymentrequestrikeytypeallowusermediagroup\" +\n+\t\"ingaltfooterubyasyncanvasidefaultitleaudioncancelautofocusan\" +\n+\t\"dboxmplaceholderautoplaysinlinebdoncanplaythrough1bgsoundisa\" +\n+\t\"bledivarbigblinkindraggablegendblockquotebuttonabortcitempro\" +\n+\t\"penoncecolgrouplaintextrackcolorcolspannotation-xmlcommandco\" +\n+\t\"ntrolshapecoordslotranslatecrossoriginsmallowfullscreenoscri\" +\n+\t\"ptfacenterfieldsetfigcaptionafterprintegrityfigurequiredfore\" +\n+\t\"ignObjectforeignobjectformactionautocompleteerrorformenctype\" +\n+\t\"mustmatchallengeformmethodformnovalidatetimeformtargethgroup\" +\n+\t\"osterhiddenhigh2hreflanghttp-equivideonclickiframeimageimgly\" +\n+\t\"ph3isindexismappletitemtypemarqueematheadersortedmaxlength4m\" +\n+\t\"inlength5mtextareadonlymultiplemutedoncloseamlessourceoncont\" +\n+\t\"extmenuitemidoncopyoncuechangeoncutondblclickondragendondrag\" +\n+\t\"enterondragexitemreferrerpolicyondragleaveondragoverondragst\" +\n+\t\"articleondropzonemptiedondurationchangeonendedonerroronfocus\" +\n+\t\"paceronhashchangeoninputmodeloninvalidonkeydownloadonkeypres\" +\n+\t\"spellcheckedonkeyupreloadonlanguagechangeonloadeddatalisting\" +\n+\t\"onloadedmetadatabindexonloadendonloadstartonmessageerroronmo\" +\n+\t\"usedownonmouseenteronmouseleaveonmousemoveonmouseoutputonmou\" +\n+\t\"seoveronmouseupromptonmousewheelonofflineononlineonpagehides\" +\n+\t\"classectionbluronpageshowbronpastepublicontenteditableonpaus\" +\n+\t\"emaponplayingonpopstateonprogressrcdocodeferonratechangeonre\" +\n \t\"jectionhandledonresetonresizesrclangonscrollonsecuritypolicy\" +\n \t\"violationauxclickonseekedonseekingonselectedonshowidth6onsor\" +\n \t\"tableonstalledonstorageonsubmitemscopedonsuspendontoggleonun\" +"
    },
    {
      "sha": "a3a918f0b381d2663037373b487e1d7f776c5c35",
      "filename": "backend/vendor/golang.org/x/net/html/const.go",
      "status": "modified",
      "additions": 10,
      "deletions": 2,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/const.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/const.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/const.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "patch": "@@ -4,7 +4,7 @@\n \n package html\n \n-// Section 12.2.3.2 of the HTML5 specification says \"The following elements\n+// Section 12.2.4.2 of the HTML5 specification says \"The following elements\n // have varying levels of special parsing rules\".\n // https://html.spec.whatwg.org/multipage/syntax.html#the-stack-of-open-elements\n var isSpecialElementMap = map[string]bool{\n@@ -97,8 +97,16 @@ func isSpecialElement(element *Node) bool {\n \tswitch element.Namespace {\n \tcase \"\", \"html\":\n \t\treturn isSpecialElementMap[element.Data]\n+\tcase \"math\":\n+\t\tswitch element.Data {\n+\t\tcase \"mi\", \"mo\", \"mn\", \"ms\", \"mtext\", \"annotation-xml\":\n+\t\t\treturn true\n+\t\t}\n \tcase \"svg\":\n-\t\treturn element.Data == \"foreignObject\"\n+\t\tswitch element.Data {\n+\t\tcase \"foreignObject\", \"desc\", \"title\":\n+\t\t\treturn true\n+\t\t}\n \t}\n \treturn false\n }"
    },
    {
      "sha": "b628880a014d865f22c5b2c15a2aaf63aa340ed7",
      "filename": "backend/vendor/golang.org/x/net/html/entity.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/entity.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/entity.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/entity.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "01477a96397c971333726e0f248d54ae05206cdb",
      "filename": "backend/vendor/golang.org/x/net/html/foreign.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/foreign.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/foreign.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/foreign.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2c1cade6070d3609b8a6fe064ff0b1950389b658",
      "filename": "backend/vendor/golang.org/x/net/html/node.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/node.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/node.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/node.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "64a5793725b9e975497030cd7ef1d06555dd120f",
      "filename": "backend/vendor/golang.org/x/net/html/parse.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/parse.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/net/html/parse.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/net/html/parse.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "dfbed62cf546d1a3cdef7bf31f965f8a1c6bc4ff",
      "filename": "backend/vendor/golang.org/x/oauth2/CONTRIBUTING.md",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/CONTRIBUTING.md",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/CONTRIBUTING.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/CONTRIBUTING.md?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "68f436ed9524e767145b1346b4d6f1ca77c4bb77",
      "filename": "backend/vendor/golang.org/x/oauth2/README.md",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/README.md?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "21c49e7f2d3803efd1cea3a1f38c959aa3c51fac",
      "filename": "backend/vendor/golang.org/x/oauth2/facebook/facebook.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/facebook/facebook.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/facebook/facebook.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/facebook/facebook.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "feb1157b15b45665c9fd91c502bae148846eda05",
      "filename": "backend/vendor/golang.org/x/oauth2/google/appengine.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/appengine.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/appengine.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/appengine.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "83dacac320a98a201e86608104a1f7be29f1f2a8",
      "filename": "backend/vendor/golang.org/x/oauth2/google/appengine_gen1.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/appengine_gen1.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/appengine_gen1.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/appengine_gen1.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "04c2c2216af56ba601a4ba9257adbb6d82b3cc35",
      "filename": "backend/vendor/golang.org/x/oauth2/google/appengine_gen2_flex.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/appengine_gen2_flex.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/appengine_gen2_flex.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/appengine_gen2_flex.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "56669eaa98d2f25467069f88a5fbfffaefd791aa",
      "filename": "backend/vendor/golang.org/x/oauth2/google/appengine_hook.go",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/oauth2/google/appengine_hook.go",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/oauth2/google/appengine_hook.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/appengine_hook.go?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "5d0231af2dd1c9c3889a2d79e39df9e3051b2e9e",
      "filename": "backend/vendor/golang.org/x/oauth2/google/appengineflex_hook.go",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/oauth2/google/appengineflex_hook.go",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/oauth2/google/appengineflex_hook.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/appengineflex_hook.go?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "5087d845fe14aa00eaaee0e61f7c7dd4a8f1fadf",
      "filename": "backend/vendor/golang.org/x/oauth2/google/default.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/default.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/default.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/default.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "73be629033d35f2826d589b7c2e5f71e37e73d58",
      "filename": "backend/vendor/golang.org/x/oauth2/google/doc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/doc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/doc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/doc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ca7d208d7736a3d325e6d3760b884c4544aa6e0f",
      "filename": "backend/vendor/golang.org/x/oauth2/google/google.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/google.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/google.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/google.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "456224bc789636061c872848856e7518ffca5456",
      "filename": "backend/vendor/golang.org/x/oauth2/google/sdk.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/sdk.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/google/sdk.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/google/sdk.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "c0ab196cf461cf3eb159d732e29f41a880d5a125",
      "filename": "backend/vendor/golang.org/x/oauth2/internal/oauth2.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/internal/oauth2.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/internal/oauth2.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/internal/oauth2.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "a831b77465451578d1dfb52bc2b42eb8425ff45b",
      "filename": "backend/vendor/golang.org/x/oauth2/internal/token.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/internal/token.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/internal/token.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/internal/token.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "572074a637dd6fbf13571900bac00289871d9dcc",
      "filename": "backend/vendor/golang.org/x/oauth2/internal/transport.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/internal/transport.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/internal/transport.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/internal/transport.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "0783a94c4847364eeeb6f966cc892ce191e6d2cd",
      "filename": "backend/vendor/golang.org/x/oauth2/jwt/jwt.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/jwt/jwt.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/jwt/jwt.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/jwt/jwt.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "1e8e1b741a81463b8200bbb0a46704ca624f01ac",
      "filename": "backend/vendor/golang.org/x/oauth2/oauth2.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/oauth2.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/oauth2.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/oauth2.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "9be1ae537376ed3c6333781070864ac6164ff64e",
      "filename": "backend/vendor/golang.org/x/oauth2/token.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/token.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/token.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/token.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "aa0d34f1e0eaf5b4ab9f35244ebe3503bd34e689",
      "filename": "backend/vendor/golang.org/x/oauth2/transport.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/transport.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/oauth2/transport.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/oauth2/transport.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2bf415fb1cff3b2446f0ede07147f0439b8e8f5c",
      "filename": "backend/vendor/golang.org/x/sys/unix/README.md",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/README.md?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "951fce4d0d93f9b3ea3796465070bb78ab5717f9",
      "filename": "backend/vendor/golang.org/x/sys/unix/aliases.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/aliases.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/aliases.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/aliases.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "06f84b8555800d8a55973d4b255cb5fa74cd954c",
      "filename": "backend/vendor/golang.org/x/sys/unix/asm_aix_ppc64.s",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_aix_ppc64.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_aix_ppc64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/asm_aix_ppc64.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "603dd5728c4a4b41f26ae34834f250d516de5b04",
      "filename": "backend/vendor/golang.org/x/sys/unix/asm_dragonfly_amd64.s",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_dragonfly_amd64.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_dragonfly_amd64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/asm_dragonfly_amd64.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d9318cbf034d8dbc238bf0b546311db97fbef0c3",
      "filename": "backend/vendor/golang.org/x/sys/unix/asm_freebsd_arm64.s",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_freebsd_arm64.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_freebsd_arm64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/asm_freebsd_arm64.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "88f712557810a1a5e07ab1b847216ba24cd8d528",
      "filename": "backend/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/asm_linux_ppc64x.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "df5204877378c349252b53d796dd3cd9547daeef",
      "filename": "backend/vendor/golang.org/x/sys/unix/cap_freebsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/cap_freebsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/cap_freebsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/cap_freebsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "3a6ac648dd5965584abf4afcc97c417b4bc8792f",
      "filename": "backend/vendor/golang.org/x/sys/unix/constants.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/constants.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/constants.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/constants.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "5e5fb451044aaba62809c8e3c4e1d45894b05b8f",
      "filename": "backend/vendor/golang.org/x/sys/unix/dev_aix_ppc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/dev_aix_ppc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/dev_aix_ppc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/dev_aix_ppc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8b401244c419c3e77c0164cced93dba0fa910818",
      "filename": "backend/vendor/golang.org/x/sys/unix/dev_aix_ppc64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/dev_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/dev_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/dev_aix_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4407c505a369c83e8ef95c21b2607dd32badfa6a",
      "filename": "backend/vendor/golang.org/x/sys/unix/dirent.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/dirent.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/dirent.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/dirent.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "84178b0a134a9d425f7aa7c0c55c9fada0b86614",
      "filename": "backend/vendor/golang.org/x/sys/unix/env_unix.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/env_unix.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/env_unix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/env_unix.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "39c03f1ef135bb93ce282209be0b0ace0beb15bc",
      "filename": "backend/vendor/golang.org/x/sys/unix/fcntl.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/fcntl.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/fcntl.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/fcntl.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "previous_filename": "backend/vendor/golang.org/x/sys/unix/flock.go"
    },
    {
      "sha": "5868a4a47b4561805c1813b122a8dc052d698280",
      "filename": "backend/vendor/golang.org/x/sys/unix/fcntl_darwin.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/fcntl_darwin.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/fcntl_darwin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/fcntl_darwin.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "fc0e50e037214c3c264076f85ea8548e8add9dd0",
      "filename": "backend/vendor/golang.org/x/sys/unix/fcntl_linux_32bit.go",
      "status": "renamed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/fcntl_linux_32bit.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/fcntl_linux_32bit.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/fcntl_linux_32bit.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c",
      "previous_filename": "backend/vendor/golang.org/x/sys/unix/flock_linux_32bit.go"
    },
    {
      "sha": "cd6f5a6133fe86c796b7458953ebe868edf3070c",
      "filename": "backend/vendor/golang.org/x/sys/unix/gccgo.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/gccgo.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/gccgo.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/gccgo.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "c44730c5e99ff103d47bc8fa186fca401c560fda",
      "filename": "backend/vendor/golang.org/x/sys/unix/gccgo_c.c",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/gccgo_c.c",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/gccgo_c.c",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/gccgo_c.c?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "f121a8d64b8c8dad3982f5233ff6605e6c705441",
      "filename": "backend/vendor/golang.org/x/sys/unix/ioctl.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ioctl.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ioctl.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ioctl.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "76f9cdd701718a183372decaa41789f1ebdfeb0e",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkall.sh",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkall.sh",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkall.sh",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkall.sh?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4548b993dbcc52a83ba7e944a6d7d8dd9de3b049",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkasm_darwin.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "178077f47b46ff78622ab8210b5c49515a818305",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkerrors.sh",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkerrors.sh",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkerrors.sh",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkerrors.sh?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "9feddd00c4b4d018e68fed15380c2a3be4bcd17d",
      "filename": "backend/vendor/golang.org/x/sys/unix/mkpost.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkpost.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mkpost.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mkpost.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "890652ca836a8ba3875ddd9531796a3f9191d34e",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "1f6b926f8c64cb0fbfa417e78c5fa8fee650410a",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksyscall.pl",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksyscall.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall.pl?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "f2c58fb7cc7f6957484c6ddae9026f42d58b0c3d",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "53df26bb93acbd6b9841e36ac47ef73f4654b7ad",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_aix_ppc64.pl?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "a354df5a6bfd678cb722ccd7ed0795f7c94ac4c2",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksyscall_solaris.pl?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "20632e14608e37ba2ff7c5b3f467009cf315b51a",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "07f8960ff38c50eadfe01ae55ba442247f6b9a88",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysnum.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksysnum.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/mksysnum.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysnum.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "5453c53b192319c95d47c672a40d7a73f626105f",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysnum_darwin.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_darwin.pl",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_darwin.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysnum_darwin.pl?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "6804f41216e732851470c89cb2ae1c552e5515cd",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "a0a22bf560e7fe5ac447ac6f0c6d5b05adedeb8a",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "85988b140b9d843c104fe6a2a9f921eab6abcb03",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "84edf60ca12d90b0a6a080947b1a08fb7b6c3b20",
      "filename": "backend/vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl",
      "status": "removed",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl",
      "raw_url": "https://github.com/umputun/remark/raw/d37ce1a91218f86b05d9641dd17e6ec29bc67930/backend/vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl?ref=d37ce1a91218f86b05d9641dd17e6ec29bc67930"
    },
    {
      "sha": "230a36d2490a3c02cb287b1905cd86f3589df8fc",
      "filename": "backend/vendor/golang.org/x/sys/unix/openbsd_pledge.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/openbsd_pledge.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/openbsd_pledge.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/openbsd_pledge.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "aebc2dc5768f449b6edf39d8d4f6e07557b50cee",
      "filename": "backend/vendor/golang.org/x/sys/unix/openbsd_unveil.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/openbsd_unveil.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/openbsd_unveil.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/openbsd_unveil.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "bc2f3629a7a95c223ac63e8df1f611660d8327e8",
      "filename": "backend/vendor/golang.org/x/sys/unix/pagesize_unix.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/pagesize_unix.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/pagesize_unix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/pagesize_unix.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ad026678c7ca9d13c30922211d9ac1c1c5394d5f",
      "filename": "backend/vendor/golang.org/x/sys/unix/race0.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/race0.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/race0.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/race0.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "5f9ae233a7a62af88a77d9d0142aa78f546394e2",
      "filename": "backend/vendor/golang.org/x/sys/unix/sockcmsg_unix.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/sockcmsg_unix.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/sockcmsg_unix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/sockcmsg_unix.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "17fb698683132287d9f81b1d81462dc61df6be73",
      "filename": "backend/vendor/golang.org/x/sys/unix/str.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/str.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/str.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/str.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "0d4b1d7a20e6ade73e85a11088cf63e37ea8391a",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "1351a228b841832aa0dfaf8f031e35d282504d76",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_aix.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_aix.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_aix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_aix.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "c28af1f86eb4f59b14751a132cae23e26925dbaf",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "881cacc6cc5665a448256e997a4d43f5b62e013c",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_aix_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "33c8b5f0db728bc684b99f5bdb765b58a5f2b087",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_bsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_bsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_bsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_bsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "04042e44b4a3bef28499b47661b45f684feb8431",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_darwin.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_darwin.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "489726fa9bdbce0e3cc76580735ae1d06b861c47",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_darwin_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_darwin_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "914b89bde5aae69bd8fdf9cad72e2361b08b949e",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4a284cf5025f28c8f8a8841c5ae9a161149b28c0",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "52dcd88f6bf98c8906502a3152af66eb42bb2966",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4b4ae460f2ff94631580e1bbb5f81c1d82acd577",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_darwin_libSystem.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_libSystem.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_darwin_libSystem.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_darwin_libSystem.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "891c94d7e26b661fd7e9cc10dd18c75e58388e9b",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_dragonfly.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "a7ca1ebea315ee091b3a6b9924bb02cd7c5ec1db",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_freebsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_freebsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_freebsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_freebsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "a318054878a9e4bd12e55d363223bd302a20d4ce",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_freebsd_arm64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_freebsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_freebsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_freebsd_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "77604023335b637f475e3f4bf485ccb225897d54",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "74bc098ce192ecc6507778098e04b8211e553b57",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "615f2918adac3d2684a5af3ca1fe78df32cb9ac1",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ad2bd2582f3bbe1365ad1406f70320161392cbe7",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "fa5a9a6f64987d8c50d49c6a73afc57edaf1f128",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "070bd38994ecf57719777ea49d01b3331dbeed0f",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_gc_386.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_gc_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_gc_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_gc_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "308eb7aecfa876129ee13fd1ab032cf033ee8692",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_386.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "aa7fc9e19975d204fb7d082279d03a41bd26cd73",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_arm.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_gccgo_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "18541dc5730bc797f8838e1e76d9a9c5e46479d7",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "99e0e999a1af5c63ddb8154e1e97fca82a352732",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "41451854bc01ebbdd8a05c8bdff5d6836400ee4f",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "44aa1227a6c2cbad1c8b4ee0f26b43ba8d8ea053",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "f52f148f9ff3594a4cfe1c721f4d8bbdb96723c1",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_s390x.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "72e64187debf0e96d0d9ad914e4d2cdc4b45a772",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "5240e16e4b34f1117723b833c330d4227d2fbdfb",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_netbsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_netbsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_netbsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_netbsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "687999549c80048ce621bf1043a92cef8cdeac5d",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_openbsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_openbsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d62da60d1ff52320c4761bab9a4441fcecb09fe9",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_openbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "9a35334cba436894b6337750c4449d48ed3e2768",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "5d812aaea53e3d66842ff5acb0b5a9f475c566cd",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "e4780127537d829dca99e4cbc4dda939fc701a4e",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_solaris.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_solaris.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_solaris.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_solaris.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "91c32ddf02a25bb67f114ce94a738eb8c5fd3222",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "33583a22b67c42b478ed31295c8715285dfbf44e",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_unix.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_unix.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_unix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_unix.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "1c70d1b6902b1f6b6a778cff3e14288c58ee0b3d",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_unix_gc.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_unix_gc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_unix_gc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_unix_gc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "86dc765aba3e683d2a15d524e540c447527a5076",
      "filename": "backend/vendor/golang.org/x/sys/unix/syscall_unix_gc_ppc64x.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_unix_gc_ppc64x.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/syscall_unix_gc_ppc64x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/syscall_unix_gc_ppc64x.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4a672f56942abd067302123f5da066b038d79807",
      "filename": "backend/vendor/golang.org/x/sys/unix/timestruct.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/timestruct.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/timestruct.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/timestruct.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "25e834940d712121730d25922e7841f22ed71969",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_aix.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_aix.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_aix.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_aix.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "9fd2aaa6a224decf7f702e07574cee0ac30527e4",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_darwin.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_darwin.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_darwin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_darwin.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "3365dd79d082c232ec189b6d1dbcf0eb21ea8364",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_dragonfly.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_dragonfly.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_dragonfly.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_dragonfly.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "74707989512514f57373d407b71d697413888bf6",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_freebsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_freebsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_freebsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_freebsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2dd4f9542c9cba0cb663a21a538f00df904edce6",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_netbsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_netbsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_netbsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_netbsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4e5e57f9a61a09dce8bd3ea7501038aefc870bab",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_openbsd.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_openbsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_openbsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_openbsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2b716f93481d8bdb024efc7972a7d1b1de8391ba",
      "filename": "backend/vendor/golang.org/x/sys/unix/types_solaris.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_solaris.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/types_solaris.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/types_solaris.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "30c1d71f4eddb192e9360af673306a66a62a1d41",
      "filename": "backend/vendor/golang.org/x/sys/unix/xattr_bsd.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/xattr_bsd.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/xattr_bsd.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/xattr_bsd.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4b7b965027da3d51bf50817f9be7e993fecb4409",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ed04fd1b77db90de9cb95d6dea68a28811215bc8",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_aix_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "3b39d7408ad84bd494918a9ca70a766ac65d2e7e",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_darwin_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8fe5547775b2ced15c43edfa5082d6882a1ce0d7",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "7a977770d0ade59dc3e1cfdc0b5d4c2f704c0e62",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "6d56d8a059d17f30478a85ec7ca785391e464d39",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "bbe6089bb7ecb74ec01a825d7573a069ff8ae059",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d2bbaabc87faa2cbac459e605204bb63a575bbcc",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4f8db783d3cc0f892d2d3104fd6e533bbd535438",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "53e5de605184ab6636eebf3b32aa9a222307fd64",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d4a192fefeeef30e33102d59d7af36725dbefe3e",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_freebsd_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "c62bb94902863217483e3e06c4ef757e541ef040",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "93f65d7d1a762e2af367174909d9bd161ef0da9d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ccc57676fdd7c4fee49341db61478fbb53031e17",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "9c57337c62597eef12b1d354c6d79fa4aecc987b",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "66cdbfd58680821a4aa471f159bc20f7f278bbce",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "038cfeb7db6b5140cd300a5f24f5dacdd47bef4d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2b9af2f5ef321663f8e4ed0a7240976b16c06d46",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d117b636726276cdf3acd5800ffbbbb51932f564",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ed12556bf46a09f6dab5698e8ae17c65ce00b40d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "4aa4fa9c993b475601b10fece1af18ee5a3d5926",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "cfe9ef8b1b2e0f80c9955929f085c08967fdd37b",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "11496611094b00a1fb5718fe266a042dbc663d11",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "036f3247c71d116392d3d073761d3c5a8991c187",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "78cc04ea6df16d26064c318dfdc81490e50bf4c1",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "92185e693ff01e4bce473605976d4b904043d242",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "373ad4543d831fc7582499f57acdc5032bc5cda5",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d8be045189b3457ab01793c60838c5879ec5274e",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "1f9e8a29ea9e9f887f6e1c6cfdb4434b702cf9d8",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "79d5695c376fb73c60a81d1633d6b804ee006881",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "22569db31d3cee8118632273ca349620d3271126",
      "filename": "backend/vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "79f6e0566e316b72a8ffa9ac62a52272e1b8d112",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "3e929e520e080e900b05263bc084886e97ee5950",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "a185ee842412a3cb63cbc539805440d57fc5f984",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "aef7c0e78465868ee4d0095a45096358e78a345f",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64_gccgo.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "c4ec7ff87cf77e3029ede755a63bb51f50f22cc9",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.1_11.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.1_11.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.1_11.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.1_11.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "23346dc68ff39efabe0fc85f408aebf1a90c74b2",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "37b85b4f6127a76e84f45ea66e2170831c759e8a",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.s",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_386.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2581e8960fd5a2b5bd2930b14366ccfdfbd93a33",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_11.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_11.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_11.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.1_11.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b50178d67922468b1cae984a8f854823611d40ef",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "da9b900a8c61c5fbe083e9ffcfd803be16680c3c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "f8caecef02e29431b4f749b9129e2a68373bb7a6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.1_11.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.1_11.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.1_11.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.1_11.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "01cffbf46ccf9ae6582047df1bb36bf65020514d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "994056f35969c34b4c4b5a95502a14ff035781eb",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.s",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "3fd0f3c854d108c459c47bcc5c995961995fedc5",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.1_11.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.1_11.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.1_11.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.1_11.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8f2691deea9305e936f3eab309960a1018e9ea7c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "61dc0d4c12959eab7f605c04f45a5eac273994f8",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.s",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.s",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.s",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.s?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "da9986dd213c410a3ca49b142c6209c7e5395e0d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "80903e47b65c2fcfaaf41deacb397d1c6bce1d12",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "cd250ff0e240e8e8a83c1b0eec76e688dc674d3d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "290a9c2cb06c31d189441c9740c8be592bef6503",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "c6df9d2e8f62be506d0151d8b22318ce8df93c45",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "5356a517594d22c79a30a18c765c85908913d012",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "0f6d265d8b070ca1ca9359e6e24f1a0852ad96fe",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "012261ad549f5fe31d3dbb2c1d4fe059864e4eca",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b890cb03c6e15eb7a1066ca83d8d95efb80fd828",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "cc17b43d35564b9b273d558124b888aaf4196101",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "25026415ddc11b025fe2db4eb114fff2ab4a2ec6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "83d8bb8af8c1fbb77d7b5c7872865dacb3e2971e",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b16b3e102989fc57aeaf99597e560698ae7e79af",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "27b6a6bf0e39564d194a8fafa00d83f2d60d0148",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "f7ecc9afda5714156c2306d92c20034adaa02cd9",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "e3cd4e53f99490d4a6250dac62ca9e6cffe91693",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "3001d3798198ad22c33678fbef5a240b8a4e30af",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "aafe3660fa28e23fef2bd34fa97acce39163a8e6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "642db7670a20977a4499f655febb4daa889b0c7b",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "59585fee3541f704409c0b210cdbd76567f0cf3d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "6ec31434b214b1f65fbe421391ce02e8d730d4b8",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "6a489fac0a69e7f6cd1f2f7c8cfff6ebe1411248",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "30cba4347c12167f53b886f5076a8a23bdcef23b",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "fa1beda33e38d18310bb4475c0f3d8d38b27b1f6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "97b22a499ed3be305c1d5250f3439bfa90fc369c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b005031abed3c3e5259d2eff3cd4c36c8ee905da",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "d014451c9d8e9ccc431190bc80d2d8ee2fb5ad5c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b005031abed3c3e5259d2eff3cd4c36c8ee905da",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "f33614532f999d2ea26f0aea0a98c8c4aecb36c2",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "9e2837e0e326fc56ff252dd5407bca326c745202",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "103a72ed1c0ebea77cfc1f12390a961df4bbd9cc",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "7ab2130b967b1d046ba5be7d649e25345ff3b4cd",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_darwin_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "464c9a9832dc48b475196964669b72c01eb94f14",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_dragonfly_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_dragonfly_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_dragonfly_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_dragonfly_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "55c3a32945d35d88487032f20e7e562540f37a95",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b39be6cb8f4a07c0dc147b0e139457f0b8f5feac",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "44ffd4ce5e9804b8f56c9cb932e33c627b780379",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8c1e16ca516d262598bb59fb1e5fa03a4504c7bb",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8d17873de0fe06120d14fbf2d5962f0c05552deb",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b3d8ad79d425bb1fab13173cac0abee80f0c2dda",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "e092822fbadd111dd9d510acf6cc33c46be77756",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "3206967896afd8c389adba90acb09d3f243fbc6d",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "6893a5bd055b135f0feb33f6c2d39d1cc482414b",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "40164cacdf5c309782d558e9b5a7d15786b86f37",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8a909738bc0ef206ee6c0e75eeb15848931be73c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mips64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8d78184224586f88449d637ab3f1a83e7e2d9a2a",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mipsle.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mipsle.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mipsle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_mipsle.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ec5bde3d5634539ff0f2418a6f0e702cfd5c8f59",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "bdbabdbcdb1791c61fd4827d90aa7c72a90477e5",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "473c74613f64fed3a550a7a068ba2128ab90b8f9",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_riscv64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_riscv64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_riscv64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_riscv64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "6eb7c257f8cafd49c3a19c7f3c1bd3506fa388db",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_s390x.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_s390x.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_s390x.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_s390x.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "93480fcb168386765fc0d60e4331912d76f244be",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_linux_sparc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_sparc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_sparc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_linux_sparc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "e66a8c9d39eae528646aa6d252ae4cc73137f20c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "42c788f2490c255ed602affa083fe7ad8c4638aa",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "0a0757179ba418a9596a5cab2f56f92e1d5443b6",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "b0207d1c9bbca388729d1661c199d0ac2aa1af7c",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "f0dec6f0b43cc1fc1c1079f55bfe39bf177a1103",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "33d1dc5404e403b9199fa1062158ef8656309b04",
      "filename": "backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/zsysnum_openbsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "cedc9b0f26d7369314ae390273217f2f139314ea",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "f46482d272e62915c8b02394502d3c78d6a49059",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_aix_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2aeb52a886decc2988fe602f599012cdd689b6f1",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_darwin_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "0d0d9f2ccb7abd5e6f15af9bd3a205629a5a7733",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "04e344b78d88329dcbf0f15b0c2dd3050549bde7",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "9fec185c180f0b51b0b59f26ea00084412f3e16b",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "7b34e2e2c686813c6ef44b4afa9c3a9a98e74406",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "c146c1ad35441365ac62067789fa9b6ce8212f0c",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ac33a8dd4a6c206c5b91e6fb74e86e3a984646c3",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "e27511a642f116368b393c13bf48398930442a44",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2aadc1a4d8ffd539e4940312be0a1f196d489e35",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go",
      "status": "added",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_freebsd_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "ebf10d48d364c824f4f3886a60ceee9506ea7158",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_386.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "99a6900d21156570b5ff56258ee56e35189d1882",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "5ccc4b5414a03e1b48b7dbd0605114294a413ad5",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "be375d9bb2e5d95975ffd48adaaaa67cfae71916",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "195f7e1f85b354c61ac4102e0490d85eb99003b2",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "77acf56985d685f8757924be4fc5a2e9b4921bc5",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "2fb7498da65dc80f2d0f23217308be654e1cd86f",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "41cb14863c8cdb6bb69538d6089996f180c92b30",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "8e6b5fa68e8decd15c3a0695faac7400c5860a86",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    },
    {
      "sha": "019d2d6a9d94d0e93c7acb1a8832f2200bf71df4",
      "filename": "backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/umputun/remark/blob/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go",
      "raw_url": "https://github.com/umputun/remark/raw/034101fb648ea7d731fe37f3fce452e5c202fa2c/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go?ref=034101fb648ea7d731fe37f3fce452e5c202fa2c"
    }
  ]
}
