{
  "sha": "7b8bc80468703afa421c6330712d5aa964c82c8d",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOjdiOGJjODA0Njg3MDNhZmE0MjFjNjMzMDcxMmQ1YWE5NjRjODJjOGQ=",
  "commit": {
    "author": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-05-17T07:50:32Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2019-05-17T07:50:32Z"
    },
    "message": "Merge pull request #331 from umputun/alter\n\nAlter",
    "tree": {
      "sha": "4f0d79341c5ffc10a816547176cfe6d6585beebc",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/4f0d79341c5ffc10a816547176cfe6d6585beebc"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/7b8bc80468703afa421c6330712d5aa964c82c8d",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc3mfICRBK7hj4Ov3rIwAAdHIIAFbnb6MNffpsYRv/2HMj6L+W\naO/7KeYpqlivlngSiiLE3PjXNEHJQNkGUoz9Vg8LqdpnEqhdV6bLu3idYNU0zhEg\njNXuUVnly3olSHD4QkoRSFOsCqsEQmeoP/HCTuD9n+rPDfmfwwNyD/qW15pgdAZj\noSMmAi4hQRQHUhexN3Q3TWpzkVIqgLW4fWaRJujlx2ehF8n0tuveKS3vVN+812qG\nZ+QfOUa9p8Ud7VzkXjR77ZMzKx9oRe9PocZQvCPoe6U8Q6fXMWECp4Ebu5kU5CYy\n4rJFJC6DKHS3fBf5+jC73LZw/6utNOWfSPTjsF64cUKdizZe5TDiAhDqCPwWke0=\n=jJZB\n-----END PGP SIGNATURE-----\n",
      "payload": "tree 4f0d79341c5ffc10a816547176cfe6d6585beebc\nparent 5218f3f37c6334c8a84cabaff51c4cac52340b00\nparent 00166fe57c812835e1fb52cbe6a061ec9d594e63\nauthor Umputun <umputun@gmail.com> 1558079432 -0500\ncommitter GitHub <noreply@github.com> 1558079432 -0500\n\nMerge pull request #331 from umputun/alter\n\nAlter"
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/7b8bc80468703afa421c6330712d5aa964c82c8d",
  "html_url": "https://github.com/umputun/remark/commit/7b8bc80468703afa421c6330712d5aa964c82c8d",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/7b8bc80468703afa421c6330712d5aa964c82c8d/comments",
  "author": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5218f3f37c6334c8a84cabaff51c4cac52340b00",
      "url": "https://api.github.com/repos/umputun/remark/commits/5218f3f37c6334c8a84cabaff51c4cac52340b00",
      "html_url": "https://github.com/umputun/remark/commit/5218f3f37c6334c8a84cabaff51c4cac52340b00"
    },
    {
      "sha": "00166fe57c812835e1fb52cbe6a061ec9d594e63",
      "url": "https://api.github.com/repos/umputun/remark/commits/00166fe57c812835e1fb52cbe6a061ec9d594e63",
      "html_url": "https://github.com/umputun/remark/commit/00166fe57c812835e1fb52cbe6a061ec9d594e63"
    }
  ],
  "stats": {
    "total": 1295,
    "additions": 927,
    "deletions": 368
  },
  "files": [
    {
      "sha": "5388f9b37f4183b93b0a93d78687c5afa69b8c6f",
      "filename": "backend/app/migrator/disqus_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/disqus_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/disqus_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/migrator/disqus_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -26,7 +26,7 @@ func TestDisqus_Import(t *testing.T) {\n \tassert.Nil(t, err)\n \tassert.Equal(t, 4, size)\n \n-\tlast, err := dataStore.Last(\"test\", 10, time.Time{})\n+\tlast, err := dataStore.Last(\"test\", 10, time.Time{}, adminUser)\n \tassert.Nil(t, err)\n \tassert.Equal(t, 4, len(last), \"4 comments imported\")\n "
    },
    {
      "sha": "93ba4b53afd28368aff3d6cfcc83776e87a7833e",
      "filename": "backend/app/migrator/migrator.go",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/migrator.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/migrator.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/migrator/migrator.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -27,7 +27,7 @@ type Exporter interface {\n // Store defines minimal interface needed to export and import comments\n type Store interface {\n \tCreate(comment store.Comment) (commentID string, err error)\n-\tFind(locator store.Locator, sort string) ([]store.Comment, error)\n+\tFind(locator store.Locator, sort string, user store.User) ([]store.Comment, error)\n \tList(siteID string, limit int, skip int) ([]store.PostInfo, error)\n \tDeleteAll(siteID string) error\n \tMetas(siteID string) (umetas []service.UserMetaData, pmetas []service.PostMetaData, err error)\n@@ -42,6 +42,8 @@ type ImportParams struct {\n \tSiteID    string\n }\n \n+var adminUser = store.User{Admin: true}\n+\n // ImportComments imports from given provider format and saves to store\n func ImportComments(p ImportParams) (int, error) {\n \tlog.Printf(\"[INFO] import from %s (%s) to %s\", p.InputFile, p.Provider, p.SiteID)"
    },
    {
      "sha": "4b1dae2e4fa0c7d141defbe57ee6eb3d5fd27d1a",
      "filename": "backend/app/migrator/migrator_test.go",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/migrator_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/migrator_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/migrator/migrator_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -10,6 +10,7 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n \n+\t\"github.com/umputun/remark/backend/app/store\"\n \t\"github.com/umputun/remark/backend/app/store/admin\"\n \t\"github.com/umputun/remark/backend/app/store/engine\"\n \t\"github.com/umputun/remark/backend/app/store/service\"\n@@ -36,7 +37,7 @@ func TestMigrator_ImportDisqus(t *testing.T) {\n \tassert.Nil(t, err)\n \tassert.Equal(t, 4, size)\n \n-\tlast, err := dataStore.Last(\"test\", 10, time.Time{})\n+\tlast, err := dataStore.Last(\"test\", 10, time.Time{}, store.User{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 4, len(last), \"4 comments imported\")\n }\n@@ -62,7 +63,7 @@ func TestMigrator_ImportWordPress(t *testing.T) {\n \tassert.Nil(t, err)\n \tassert.Equal(t, 3, size)\n \n-\tlast, err := dataStore.Last(\"test\", 10, time.Time{})\n+\tlast, err := dataStore.Last(\"test\", 10, time.Time{}, store.User{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 3, len(last), \"3 comments imported\")\n }\n@@ -92,7 +93,7 @@ func TestMigrator_ImportNative(t *testing.T) {\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, size)\n \n-\tlast, err := dataStore.Last(\"radio-t\", 10, time.Time{})\n+\tlast, err := dataStore.Last(\"radio-t\", 10, time.Time{}, store.User{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, len(last), \"2 comments imported\")\n }"
    },
    {
      "sha": "6084dd2422b3e03b9f8132459e4b5b455ab48b26",
      "filename": "backend/app/migrator/native.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/native.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/native.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/migrator/native.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -49,7 +49,7 @@ func (n *Native) Export(w io.Writer, siteID string) (size int, err error) {\n \tcommentsCount := 0\n \tfor i := len(topics) - 1; i >= 0; i-- { // topics from List sorted in opposite direction\n \t\ttopic := topics[i]\n-\t\tcomments, e := n.DataStore.Find(store.Locator{SiteID: siteID, URL: topic.URL}, \"time\")\n+\t\tcomments, e := n.DataStore.Find(store.Locator{SiteID: siteID, URL: topic.URL}, \"time\", adminUser)\n \t\tif e != nil {\n \t\t\treturn commentsCount, e\n \t\t}"
    },
    {
      "sha": "ed0b0c97389f13753d2dbe292302b0ab14270663",
      "filename": "backend/app/migrator/native_test.go",
      "status": "modified",
      "additions": 8,
      "deletions": 5,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/native_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/native_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/migrator/native_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -77,12 +77,13 @@ func TestNative_Import(t *testing.T) {\n \t{\"id\":\"f863bd79-fec6-4a75-b308-61fe5dd02aa1\",\"pid\":\"1234\",\"text\":\"some text2\",\"user\":{\"name\":\"user name\",\"id\":\"user2\",\"picture\":\"\",\"ip\":\"293ec5b0cf154855258824ec7fac5dc63d176915\",\"admin\":false},\"locator\":{\"site\":\"radio-t\",\"url\":\"https://radio-t.com/2\"},\"score\":0,\"votes\":{},\"time\":\"2017-12-20T15:18:23-06:00\"}`\n \n \tb := prep(t) // write some recs\n-\tr := Native{DataStore: &service.DataStore{Interface: b, AdminStore: admin.NewStaticStore(\"12345\", []string{}, \"\")}}\n+\tb.AdminStore = admin.NewStaticStore(\"12345\", []string{}, \"\")\n+\tr := Native{DataStore: b}\n \tsize, err := r.Import(strings.NewReader(inp), \"radio-t\")\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, size)\n \n-\tcomments, err := b.Last(\"radio-t\", 10, time.Time{})\n+\tcomments, err := b.Last(\"radio-t\", 10, time.Time{}, store.User{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, len(comments))\n \tassert.Equal(t, \"f863bd79-fec6-4a75-b308-61fe5dd02aa1\", comments[0].ID)\n@@ -106,7 +107,8 @@ func TestNative_ImportWrongVersion(t *testing.T) {\n \t{\"id\":\"f863bd79-fec6-4a75-b308-61fe5dd02aa1\",\"pid\":\"1234\",\"text\":\"some text2\",\"user\":{\"name\":\"user name\",\"id\":\"user2\",\"picture\":\"\",\"ip\":\"293ec5b0cf154855258824ec7fac5dc63d176915\",\"admin\":false},\"locator\":{\"site\":\"radio-t\",\"url\":\"https://radio-t.com/2\"},\"score\":0,\"votes\":{},\"time\":\"2017-12-20T15:18:23-06:00\"}`\n \n \tb := prep(t) // write some recs\n-\tr := Native{DataStore: &service.DataStore{Interface: b, AdminStore: admin.NewStaticStore(\"12345\", []string{}, \"\")}}\n+\tb.AdminStore = admin.NewStaticStore(\"12345\", []string{}, \"\")\n+\tr := Native{DataStore: b}\n \tsize, err := r.Import(strings.NewReader(inp), \"radio-t\")\n \tassert.EqualError(t, err, \"unexpected import file version 2\")\n \tassert.Equal(t, 0, size)\n@@ -126,11 +128,12 @@ func TestNative_ImportManyWithError(t *testing.T) {\n \tbuf.WriteString(\"{}\\n\")\n \n \tb := prep(t) // write some recs\n-\tr := Native{DataStore: &service.DataStore{Interface: b, AdminStore: admin.NewStaticStore(\"12345\", []string{}, \"\")}}\n+\tb.AdminStore = admin.NewStaticStore(\"12345\", []string{}, \"\")\n+\tr := Native{DataStore: b}\n \tn, err := r.Import(buf, \"radio-t\")\n \tassert.EqualError(t, err, \"failed to save 2 comments\")\n \tassert.Equal(t, 1200, n)\n-\tcomments, err := b.Find(store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com\"}, \"time\")\n+\tcomments, err := b.Find(store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com\"}, \"time\", store.User{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 1200, len(comments))\n }"
    },
    {
      "sha": "86a99b9305b9ce80857c1e371a906802f16681d0",
      "filename": "backend/app/migrator/wordpress_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/wordpress_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/migrator/wordpress_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/migrator/wordpress_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -27,7 +27,7 @@ func TestWordPress_Import(t *testing.T) {\n \tassert.Nil(t, err)\n \tassert.Equal(t, 3, size)\n \n-\tlast, err := dataStore.Last(siteID, 10, time.Time{})\n+\tlast, err := dataStore.Last(siteID, 10, time.Time{}, adminUser)\n \tassert.Nil(t, err)\n \tassert.Equal(t, 3, len(last), \"3 comments imported\")\n "
    },
    {
      "sha": "7157bdb6e60cda13c2c301815a2f91a15bfc5a69",
      "filename": "backend/app/notify/notify.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/notify/notify.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/notify/notify.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/notify.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -31,7 +31,7 @@ type Destination interface {\n \n // Store defines the minimal interface accessing stored comments used by notifier\n type Store interface {\n-\tGet(locator store.Locator, id string) (store.Comment, error)\n+\tGet(locator store.Locator, id string, user store.User) (store.Comment, error)\n }\n \n type request struct {\n@@ -69,7 +69,7 @@ func (s *Service) Submit(comment store.Comment) {\n \t}\n \tparentComment := store.Comment{}\n \tif s.dataService != nil {\n-\t\tif p, err := s.dataService.Get(comment.Locator, comment.ParentID); err == nil {\n+\t\tif p, err := s.dataService.Get(comment.Locator, comment.ParentID, store.User{}); err == nil {\n \t\t\tparentComment = p\n \t\t}\n \t}"
    },
    {
      "sha": "2dfbc63256e118315306cc686b7372a0b9b9bf0a",
      "filename": "backend/app/notify/notify_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/notify/notify_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/notify/notify_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/notify_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -146,7 +146,7 @@ func (m *mockDest) String() string { return fmt.Sprintf(\"mock id=%d, closed=%v\",\n \n type mockStore struct{ data map[string]store.Comment }\n \n-func (m *mockStore) Get(_ store.Locator, id string) (store.Comment, error) {\n+func (m *mockStore) Get(_ store.Locator, id string, user store.User) (store.Comment, error) {\n \tres, ok := m.data[id]\n \tif !ok {\n \t\treturn store.Comment{}, errors.New(\"no such id\")"
    },
    {
      "sha": "dec80e925092984682a1f73597401ab9190f1cee",
      "filename": "backend/app/rest/api/admin.go",
      "status": "modified",
      "additions": 16,
      "deletions": 42,
      "changes": 58,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/admin.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/admin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/admin.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -15,18 +15,31 @@ import (\n \n \t\"github.com/umputun/remark/backend/app/rest\"\n \t\"github.com/umputun/remark/backend/app/store\"\n-\t\"github.com/umputun/remark/backend/app/store/service\"\n )\n \n // admin provides router for all requests available for admin users only\n type admin struct {\n-\tdataService   *service.DataStore\n+\tdataService   adminStore\n \tcache         cache.LoadingCache\n \tauthenticator *auth.Service\n \treadOnlyAge   int\n \tmigrator      *Migrator\n }\n \n+type adminStore interface {\n+\tDelete(locator store.Locator, commentID string, mode store.DeleteMode) error\n+\tDeleteUser(siteID string, userID string) error\n+\tUser(siteID, userID string, limit, skip int, user store.User) ([]store.Comment, error)\n+\tIsBlocked(siteID string, userID string) bool\n+\tSetBlock(siteID string, userID string, status bool, ttl time.Duration) error\n+\tBlocked(siteID string) ([]store.BlockedUser, error)\n+\tInfo(locator store.Locator, readonlyAge int) (store.PostInfo, error)\n+\tSetTitle(locator store.Locator, commentID string) (comment store.Comment, err error)\n+\tSetVerified(siteID string, userID string, status bool) error\n+\tSetReadOnly(locator store.Locator, status bool) error\n+\tSetPin(locator store.Locator, commentID string, status bool) error\n+}\n+\n // DELETE /comment/{id}?site=siteID&url=post-url - removes comment\n func (a *admin) deleteCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \n@@ -67,7 +80,7 @@ func (a *admin) getUserInfoCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n \tlog.Printf(\"[INFO] get user info for %s, site %s\", userID, siteID)\n \n-\tucomments, err := a.dataService.User(siteID, userID, 1, 0)\n+\tucomments, err := a.dataService.User(siteID, userID, 1, 0, rest.GetUserOrEmpty(r))\n \tif err != nil || len(ucomments) == 0 {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't get user info\", rest.ErrInternal)\n \t\treturn\n@@ -218,42 +231,3 @@ func (a *admin) setPinCtrl(w http.ResponseWriter, r *http.Request) {\n \ta.cache.Flush(cache.Flusher(locator.SiteID).Scopes(locator.URL))\n \trender.JSON(w, r, R.JSON{\"id\": commentID, \"locator\": locator, \"pin\": pinStatus})\n }\n-\n-func (a *admin) checkBlocked(siteID string, user store.User) bool {\n-\treturn a.dataService.IsBlocked(siteID, user.ID)\n-}\n-\n-// post-processes comments, hides text of all comments for blocked users,\n-// resets score and votes too. Also hides sensitive info for non-admin users\n-func (a *admin) alterComments(comments []store.Comment, r *http.Request) (res []store.Comment) {\n-\tres = make([]store.Comment, len(comments))\n-\n-\tuser, err := rest.GetUserInfo(r)\n-\tisAdmin := err == nil && user.Admin\n-\n-\tfor i, c := range comments {\n-\n-\t\tblocked := a.dataService.IsBlocked(c.Locator.SiteID, c.User.ID)\n-\t\t// process blocked users\n-\t\tif blocked {\n-\t\t\tif !isAdmin { // reset comment to deleted for non-admins\n-\t\t\t\tc.SetDeleted(store.SoftDelete)\n-\t\t\t}\n-\t\t\tc.User.Blocked = true\n-\t\t\tc.Deleted = true\n-\t\t}\n-\n-\t\t// set verified status retroactively\n-\t\tif !blocked {\n-\t\t\tc.User.Verified = a.dataService.IsVerified(c.Locator.SiteID, c.User.ID)\n-\t\t}\n-\n-\t\t// hide info from non-admins\n-\t\tif !isAdmin {\n-\t\t\tc.User.IP = \"\"\n-\t\t}\n-\n-\t\tres[i] = c\n-\t}\n-\treturn res\n-}"
    },
    {
      "sha": "541a6c77ee416e4fef7e80976770165110c174fd",
      "filename": "backend/app/rest/api/admin_test.go",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/admin_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/admin_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/admin_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -313,7 +313,7 @@ func TestAdmin_Block(t *testing.T) {\n \tassert.Equal(t, \"\", comments.Comments[0].Text)\n \tassert.True(t, comments.Comments[0].Deleted)\n \n-\tsrv.Cache = &cache.Nop{} // TODO: with lru cache it won't be refreshed and invalidated for long time\n+\tsrv.pubRest.cache = &cache.Nop{} // TODO: with lru cache it won't be refreshed and invalidated for long time\n \ttime.Sleep(50 * time.Millisecond)\n \tres, code = get(t, ts.URL+\"/api/v1/find?site=radio-t&url=https://radio-t.com/blah&sort=+time\")\n \tassert.Equal(t, 200, code)\n@@ -618,7 +618,7 @@ func TestAdmin_DeleteMeRequest(t *testing.T) {\n \t_, err = srv.DataService.Create(c2)\n \tassert.Nil(t, err)\n \n-\tcomments, err := srv.DataService.User(\"radio-t\", \"user1\", 0, 0)\n+\tcomments, err := srv.DataService.User(\"radio-t\", \"user1\", 0, 0, store.User{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 1, len(comments), \"a comment for user1\")\n \n@@ -655,7 +655,7 @@ func TestAdmin_DeleteMeRequest(t *testing.T) {\n \trequire.NoError(t, err)\n \tassert.Equal(t, 200, resp.StatusCode)\n \n-\t_, err = srv.DataService.User(\"radio-t\", \"user1\", 0, 0)\n+\t_, err = srv.DataService.User(\"radio-t\", \"user1\", 0, 0, store.User{})\n \tassert.EqualError(t, err, \"no comments for user user1 in store\")\n }\n "
    },
    {
      "sha": "16d6bccd73450bf78d678f77a7dd214a7967b7f5",
      "filename": "backend/app/rest/api/rest.go",
      "status": "modified",
      "additions": 110,
      "deletions": 71,
      "changes": 181,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -59,7 +59,9 @@ type Rest struct {\n \thttpServer  *http.Server\n \tlock        sync.Mutex\n \n-\tadminService admin\n+\tpubRest   public\n+\tprivRest  private\n+\tadminRest admin\n }\n \n const hardBodyLimit = 1024 * 64 // limit size of body\n@@ -167,7 +169,28 @@ func (s *Rest) routes() chi.Router {\n \trouter.Use(middleware.Throttle(1000), middleware.Timeout(60*time.Second))\n \trouter.Use(R.AppInfo(\"remark42\", \"umputun\", s.Version), R.Ping)\n \n-\ts.adminService = admin{\n+\ts.pubRest = public{\n+\t\tdataService:      s.DataService,\n+\t\tcache:            s.Cache,\n+\t\timageService:     s.ImageService,\n+\t\tcommentFormatter: s.CommentFormatter,\n+\t\treadOnlyAge:      s.ReadOnlyAge,\n+\t\tconfFn:           s.config,\n+\t\twebRoot:          s.WebRoot,\n+\t}\n+\n+\ts.privRest = private{\n+\t\tdataService:      s.DataService,\n+\t\tcache:            s.Cache,\n+\t\timageService:     s.ImageService,\n+\t\tcommentFormatter: s.CommentFormatter,\n+\t\treadOnlyAge:      s.ReadOnlyAge,\n+\t\tauthenticator:    s.Authenticator,\n+\t\tnotifyService:    s.NotifyService,\n+\t\tremarkURL:        s.RemarkURL,\n+\t}\n+\n+\ts.adminRest = admin{\n \t\tdataService:   s.DataService,\n \t\tmigrator:      s.Migrator,\n \t\tcache:         s.Cache,\n@@ -215,16 +238,16 @@ func (s *Rest) routes() chi.Router {\n \t\trapi.Group(func(ropen chi.Router) {\n \t\t\tropen.Use(tollbooth_chi.LimitHandler(tollbooth.NewLimiter(10, nil)))\n \t\t\tropen.Use(authMiddleware.Trace, middleware.NoCache, logInfoWithBody)\n-\t\t\tropen.Get(\"/find\", s.findCommentsCtrl)\n-\t\t\tropen.Get(\"/id/{id}\", s.commentByIDCtrl)\n-\t\t\tropen.Get(\"/comments\", s.findUserCommentsCtrl)\n-\t\t\tropen.Get(\"/last/{limit}\", s.lastCommentsCtrl)\n-\t\t\tropen.Get(\"/count\", s.countCtrl)\n-\t\t\tropen.Post(\"/counts\", s.countMultiCtrl)\n-\t\t\tropen.Get(\"/list\", s.listCtrl)\n-\t\t\tropen.Get(\"/config\", s.configCtrl)\n-\t\t\tropen.Post(\"/preview\", s.previewCommentCtrl)\n-\t\t\tropen.Get(\"/info\", s.infoCtrl)\n+\t\t\tropen.Get(\"/find\", s.pubRest.findCommentsCtrl)\n+\t\t\tropen.Get(\"/id/{id}\", s.pubRest.commentByIDCtrl)\n+\t\t\tropen.Get(\"/comments\", s.pubRest.findUserCommentsCtrl)\n+\t\t\tropen.Get(\"/last/{limit}\", s.pubRest.lastCommentsCtrl)\n+\t\t\tropen.Get(\"/count\", s.pubRest.countCtrl)\n+\t\t\tropen.Post(\"/counts\", s.pubRest.countMultiCtrl)\n+\t\t\tropen.Get(\"/list\", s.pubRest.listCtrl)\n+\t\t\tropen.Get(\"/config\", s.pubRest.configCtrl)\n+\t\t\tropen.Post(\"/preview\", s.pubRest.previewCommentCtrl)\n+\t\t\tropen.Get(\"/info\", s.pubRest.infoCtrl)\n \t\t\tropen.Get(\"/img\", s.ImageProxy.Handler)\n \n \t\t\tropen.Route(\"/rss\", func(rrss chi.Router) {\n@@ -238,15 +261,15 @@ func (s *Rest) routes() chi.Router {\n \t\trapi.Group(func(ropen chi.Router) {\n \t\t\tropen.Use(tollbooth_chi.LimitHandler(tollbooth.NewLimiter(10, nil)))\n \t\t\tropen.Use(authMiddleware.Trace, logInfoWithBody)\n-\t\t\tropen.Get(\"/picture/{user}/{id}\", s.loadPictureCtrl)\n+\t\t\tropen.Get(\"/picture/{user}/{id}\", s.pubRest.loadPictureCtrl)\n \t\t})\n \n \t\t// protected routes, require auth\n \t\trapi.Group(func(rauth chi.Router) {\n \t\t\trauth.Use(tollbooth_chi.LimitHandler(tollbooth.NewLimiter(10, nil)))\n \t\t\trauth.Use(authMiddleware.Auth, middleware.NoCache, logInfoWithBody)\n-\t\t\trauth.Get(\"/user\", s.userInfoCtrl)\n-\t\t\trauth.Get(\"/userdata\", s.userAllDataCtrl)\n+\t\t\trauth.Get(\"/user\", s.privRest.userInfoCtrl)\n+\t\t\trauth.Get(\"/userdata\", s.privRest.userAllDataCtrl)\n \t\t})\n \n \t\t// admin routes, require auth and admin users only\n@@ -255,22 +278,22 @@ func (s *Rest) routes() chi.Router {\n \t\t\tradmin.Use(authMiddleware.Auth, authMiddleware.AdminOnly)\n \t\t\tradmin.Use(middleware.NoCache, logInfoWithBody)\n \n-\t\t\tradmin.Delete(\"/comment/{id}\", s.adminService.deleteCommentCtrl)\n-\t\t\tradmin.Put(\"/user/{userid}\", s.adminService.setBlockCtrl)\n-\t\t\tradmin.Delete(\"/user/{userid}\", s.adminService.deleteUserCtrl)\n-\t\t\tradmin.Get(\"/user/{userid}\", s.adminService.getUserInfoCtrl)\n-\t\t\tradmin.Get(\"/deleteme\", s.adminService.deleteMeRequestCtrl)\n-\t\t\tradmin.Put(\"/verify/{userid}\", s.adminService.setVerifyCtrl)\n-\t\t\tradmin.Put(\"/pin/{id}\", s.adminService.setPinCtrl)\n-\t\t\tradmin.Get(\"/blocked\", s.adminService.blockedUsersCtrl)\n-\t\t\tradmin.Put(\"/readonly\", s.adminService.setReadOnlyCtrl)\n-\t\t\tradmin.Put(\"/title/{id}\", s.adminService.setTitleCtrl)\n+\t\t\tradmin.Delete(\"/comment/{id}\", s.adminRest.deleteCommentCtrl)\n+\t\t\tradmin.Put(\"/user/{userid}\", s.adminRest.setBlockCtrl)\n+\t\t\tradmin.Delete(\"/user/{userid}\", s.adminRest.deleteUserCtrl)\n+\t\t\tradmin.Get(\"/user/{userid}\", s.adminRest.getUserInfoCtrl)\n+\t\t\tradmin.Get(\"/deleteme\", s.adminRest.deleteMeRequestCtrl)\n+\t\t\tradmin.Put(\"/verify/{userid}\", s.adminRest.setVerifyCtrl)\n+\t\t\tradmin.Put(\"/pin/{id}\", s.adminRest.setPinCtrl)\n+\t\t\tradmin.Get(\"/blocked\", s.adminRest.blockedUsersCtrl)\n+\t\t\tradmin.Put(\"/readonly\", s.adminRest.setReadOnlyCtrl)\n+\t\t\tradmin.Put(\"/title/{id}\", s.adminRest.setTitleCtrl)\n \n \t\t\t// migrator\n-\t\t\tradmin.Get(\"/export\", s.adminService.migrator.exportCtrl)\n-\t\t\tradmin.Post(\"/import\", s.adminService.migrator.importCtrl)\n-\t\t\tradmin.Post(\"/import/form\", s.adminService.migrator.importFormCtrl)\n-\t\t\tradmin.Get(\"/import/wait\", s.adminService.migrator.importWaitCtrl)\n+\t\t\tradmin.Get(\"/export\", s.adminRest.migrator.exportCtrl)\n+\t\t\tradmin.Post(\"/import\", s.adminRest.migrator.importCtrl)\n+\t\t\tradmin.Post(\"/import/form\", s.adminRest.migrator.importFormCtrl)\n+\t\t\tradmin.Get(\"/import/wait\", s.adminRest.migrator.importWaitCtrl)\n \t\t})\n \n \t\t// protected routes, throttled to 10/s by default, controlled by external UpdateLimiter param\n@@ -280,68 +303,33 @@ func (s *Rest) routes() chi.Router {\n \t\t\trauth.Use(middleware.NoCache)\n \t\t\trauth.Use(logger.New(logger.Log(log.Default()), logger.WithBody, logger.Prefix(\"[DEBUG]\"), logger.IPfn(ipFn)).Handler)\n \n-\t\t\trauth.Put(\"/comment/{id}\", s.updateCommentCtrl)\n-\t\t\trauth.Post(\"/comment\", s.createCommentCtrl)\n-\t\t\trauth.With(rejectAnonUser).Put(\"/vote/{id}\", s.voteCtrl)\n-\t\t\trauth.With(rejectAnonUser).Post(\"/deleteme\", s.deleteMeCtrl)\n+\t\t\trauth.Put(\"/comment/{id}\", s.privRest.updateCommentCtrl)\n+\t\t\trauth.Post(\"/comment\", s.privRest.createCommentCtrl)\n+\t\t\trauth.With(rejectAnonUser).Put(\"/vote/{id}\", s.privRest.voteCtrl)\n+\t\t\trauth.With(rejectAnonUser).Post(\"/deleteme\", s.privRest.deleteMeCtrl)\n \t\t})\n \n \t\trapi.Group(func(rauth chi.Router) {\n \t\t\trauth.Use(tollbooth_chi.LimitHandler(tollbooth.NewLimiter(s.updateLimiter(), nil)))\n \t\t\trauth.Use(authMiddleware.Auth, rejectAnonUser)\n \t\t\trauth.Use(logger.New(logger.Log(log.Default()), logger.Prefix(\"[DEBUG]\"), logger.IPfn(ipFn)).Handler)\n-\t\t\trauth.Post(\"/picture\", s.savePictureCtrl)\n+\t\t\trauth.Post(\"/picture\", s.privRest.savePictureCtrl)\n \t\t})\n \n \t})\n \n \t// open routes on root level\n \trouter.Group(func(rroot chi.Router) {\n \t\ttollbooth_chi.LimitHandler(tollbooth.NewLimiter(50, nil))\n-\t\trroot.Get(\"/index.html\", s.getStartedCtrl)\n-\t\trroot.Get(\"/robots.txt\", s.getRobotsCtrl)\n+\t\trroot.Get(\"/index.html\", s.pubRest.getStartedCtrl)\n+\t\trroot.Get(\"/robots.txt\", s.pubRest.getRobotsCtrl)\n \t})\n \n \t// file server for static content from /web\n \taddFileServer(router, \"/web\", http.Dir(s.WebRoot))\n \treturn router\n }\n \n-func (s *Rest) alterComments(comments []store.Comment, r *http.Request) (res []store.Comment) {\n-\n-\tres = s.adminService.alterComments(comments, r) // apply admin's alteration\n-\n-\t// prepare vote info for client view\n-\tvote := func(c store.Comment, r *http.Request) store.Comment {\n-\n-\t\tc.Vote = 0 // default is \"none\" (not voted)\n-\n-\t\tuser, err := rest.GetUserInfo(r)\n-\t\tif err != nil {\n-\t\t\tc.Votes = nil // hide voters list and don't set Vote for non-authed user\n-\t\t\treturn c\n-\t\t}\n-\n-\t\tif v, ok := c.Votes[user.ID]; ok {\n-\t\t\tif v {\n-\t\t\t\tc.Vote = 1\n-\t\t\t} else {\n-\t\t\t\tc.Vote = -1\n-\t\t\t}\n-\t\t}\n-\n-\t\tc.Votes = nil // hide voters list\n-\t\treturn c\n-\t}\n-\n-\tfor i, c := range res {\n-\t\tc = vote(c, r)\n-\t\tres[i] = c\n-\t}\n-\n-\treturn res\n-}\n-\n // updateLimiter returns UpdateLimiter if set, or 10 if not\n func (s *Rest) updateLimiter() float64 {\n \tlmt := 10.0\n@@ -448,3 +436,54 @@ func rejectAnonUser(next http.Handler) http.Handler {\n \t}\n \treturn http.HandlerFunc(fn)\n }\n+\n+func (s *Rest) config(siteID string) config {\n+\n+\tcnf := config{\n+\t\tVersion:        s.Version,\n+\t\tEditDuration:   int(s.DataService.EditDuration.Seconds()),\n+\t\tMaxCommentSize: s.DataService.MaxCommentSize,\n+\t\tAdmins:         s.DataService.AdminStore.Admins(siteID),\n+\t\tAdminEmail:     s.DataService.AdminStore.Email(siteID),\n+\t\tLowScore:       s.ScoreThresholds.Low,\n+\t\tCriticalScore:  s.ScoreThresholds.Critical,\n+\t\tPositiveScore:  s.DataService.PositiveScore,\n+\t\tReadOnlyAge:    s.ReadOnlyAge,\n+\t\tMaxImageSize:   s.ImageService.Store.SizeLimit(),\n+\t}\n+\n+\tcnf.Auth = []string{}\n+\tfor _, ap := range s.Authenticator.Providers() {\n+\t\tcnf.Auth = append(cnf.Auth, ap.Name())\n+\t}\n+\n+\tif cnf.Admins == nil { // prevent json serialization to nil\n+\t\tcnf.Admins = []string{}\n+\t}\n+\treturn cnf\n+}\n+\n+func parseError(err error, defaultCode int) (code int) {\n+\tcode = defaultCode\n+\n+\tswitch {\n+\t// voting errors\n+\tcase strings.Contains(err.Error(), \"can not vote for his own comment\"):\n+\t\tcode = rest.ErrVoteSelf\n+\tcase strings.Contains(err.Error(), \"already voted for\"):\n+\t\tcode = rest.ErrVoteDbl\n+\tcase strings.Contains(err.Error(), \"maximum number of votes exceeded for comment\"):\n+\t\tcode = rest.ErrVoteMax\n+\tcase strings.Contains(err.Error(), \"minimal score reached for comment\"):\n+\t\tcode = rest.ErrVoteMinScore\n+\n+\t// edit errors\n+\tcase strings.HasPrefix(err.Error(), \"too late to edit\"):\n+\t\tcode = rest.ErrCommentEditExpired\n+\tcase strings.HasPrefix(err.Error(), \"parent comment with reply can't be edited\"):\n+\t\tcode = rest.ErrCommentEditChanged\n+\n+\t}\n+\n+\treturn code\n+}"
    },
    {
      "sha": "c66a3d33a3371e54f0e542075e5dea7d70fdb688",
      "filename": "backend/app/rest/api/rest_private.go",
      "status": "modified",
      "additions": 61,
      "deletions": 59,
      "changes": 120,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_private.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_private.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest_private.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -12,19 +12,46 @@ import (\n \t\"github.com/dgrijalva/jwt-go\"\n \t\"github.com/go-chi/chi\"\n \t\"github.com/go-chi/render\"\n+\t\"github.com/go-pkgz/auth\"\n \t\"github.com/go-pkgz/auth/token\"\n \tlog \"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n \t\"github.com/go-pkgz/rest/cache\"\n \t\"github.com/hashicorp/go-multierror\"\n \n+\t\"github.com/umputun/remark/backend/app/notify\"\n \t\"github.com/umputun/remark/backend/app/rest\"\n \t\"github.com/umputun/remark/backend/app/store\"\n+\t\"github.com/umputun/remark/backend/app/store/image\"\n \t\"github.com/umputun/remark/backend/app/store/service\"\n )\n \n+type private struct {\n+\tdataService      privStore\n+\tcache            cache.LoadingCache\n+\treadOnlyAge      int\n+\tcommentFormatter *store.CommentFormatter\n+\timageService     *image.Service\n+\tnotifyService    *notify.Service\n+\tauthenticator    *auth.Service\n+\tremarkURL        string\n+}\n+\n+type privStore interface {\n+\tCreate(comment store.Comment) (commentID string, err error)\n+\tEditComment(locator store.Locator, commentID string, req service.EditRequest) (comment store.Comment, err error)\n+\tVote(locator store.Locator, commentID string, userID string, val bool) (comment store.Comment, err error)\n+\tGet(locator store.Locator, commentID string, user store.User) (store.Comment, error)\n+\tUser(siteID, userID string, limit, skip int, user store.User) ([]store.Comment, error)\n+\tValidateComment(c *store.Comment) error\n+\tIsVerified(siteID string, userID string) bool\n+\tIsReadOnly(locator store.Locator) bool\n+\tIsBlocked(siteID string, userID string) bool\n+\tInfo(locator store.Locator, readonlyAge int) (store.PostInfo, error)\n+}\n+\n // POST /comment - adds comment, resets all immutable fields\n-func (s *Rest) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *private) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tcomment := store.Comment{}\n \tif err := render.DecodeJSON(http.MaxBytesReader(w, r.Body, hardBodyLimit), &comment); err != nil {\n@@ -39,14 +66,14 @@ func (s *Rest) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \tcomment.User.IP = strings.Split(r.RemoteAddr, \":\")[0]\n \n \tcomment.Orig = comment.Text // original comment text, prior to md render\n-\tif err := s.DataService.ValidateComment(&comment); err != nil {\n+\tif err := s.dataService.ValidateComment(&comment); err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"invalid comment\", rest.ErrCommentValidation)\n \t\treturn\n \t}\n-\tcomment = s.CommentFormatter.Format(comment)\n+\tcomment = s.commentFormatter.Format(comment)\n \n \t// check if user blocked\n-\tif s.adminService.checkBlocked(comment.Locator.SiteID, comment.User) {\n+\tif s.dataService.IsBlocked(comment.Locator.SiteID, comment.User.ID) {\n \t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"), \"user blocked\", rest.ErrUserBlocked)\n \t\treturn\n \t}\n@@ -56,7 +83,7 @@ func (s *Rest) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n-\tid, err := s.DataService.Create(comment)\n+\tid, err := s.dataService.Create(comment)\n \tif err == service.ErrRestrictedWordsFound {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"invalid comment\", rest.ErrCommentValidation)\n \t\treturn\n@@ -66,17 +93,17 @@ func (s *Rest) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \n-\t// DataService modifies comment\n-\tfinalComment, err := s.DataService.Get(comment.Locator, id)\n+\t// dataService modifies comment\n+\tfinalComment, err := s.dataService.Get(comment.Locator, id, rest.GetUserOrEmpty(r))\n \tif err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusInternalServerError, err, \"can't load created comment\", rest.ErrInternal)\n \t\treturn\n \t}\n-\ts.Cache.Flush(cache.Flusher(comment.Locator.SiteID).\n+\ts.cache.Flush(cache.Flusher(comment.Locator.SiteID).\n \t\tScopes(comment.Locator.URL, lastCommentsScope, comment.User.ID, comment.Locator.SiteID))\n \n-\tif s.NotifyService != nil {\n-\t\ts.NotifyService.Submit(finalComment)\n+\tif s.notifyService != nil {\n+\t\ts.notifyService.Submit(finalComment)\n \t}\n \n \tlog.Printf(\"[DEBUG] created commend %+v\", finalComment)\n@@ -86,7 +113,7 @@ func (s *Rest) createCommentCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // PUT /comment/{id}?site=siteID&url=post-url - update comment\n-func (s *Rest) updateCommentCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *private) updateCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tedit := struct {\n \t\tText    string\n@@ -107,7 +134,7 @@ func (s *Rest) updateCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tvar currComment store.Comment\n \tvar err error\n-\tif currComment, err = s.DataService.Get(locator, id); err != nil {\n+\tif currComment, err = s.dataService.Get(locator, id, rest.GetUserOrEmpty(r)); err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't find comment\", rest.ErrCommentNotFound)\n \t\treturn\n \t}\n@@ -119,40 +146,40 @@ func (s *Rest) updateCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \teditReq := service.EditRequest{\n-\t\tText:    s.CommentFormatter.FormatText(edit.Text),\n+\t\tText:    s.commentFormatter.FormatText(edit.Text),\n \t\tOrig:    edit.Text,\n \t\tSummary: edit.Summary,\n \t\tDelete:  edit.Delete,\n \t}\n \n-\tres, err := s.DataService.EditComment(locator, id, editReq)\n+\tres, err := s.dataService.EditComment(locator, id, editReq)\n \tif err == service.ErrRestrictedWordsFound {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"invalid comment\", rest.ErrCommentValidation)\n \t\treturn\n \t}\n \n \tif err != nil {\n-\t\tcode := s.parseError(err, rest.ErrCommentRejected)\n+\t\tcode := parseError(err, rest.ErrCommentRejected)\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't update comment\", code)\n \t\treturn\n \t}\n \n-\ts.Cache.Flush(cache.Flusher(locator.SiteID).Scopes(locator.SiteID, locator.URL, lastCommentsScope, user.ID))\n+\ts.cache.Flush(cache.Flusher(locator.SiteID).Scopes(locator.SiteID, locator.URL, lastCommentsScope, user.ID))\n \trender.JSON(w, r, res)\n }\n \n // GET /user?site=siteID - returns user info\n-func (s *Rest) userInfoCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *private) userInfoCtrl(w http.ResponseWriter, r *http.Request) {\n \tuser := rest.MustGetUserInfo(r)\n \tif siteID := r.URL.Query().Get(\"site\"); siteID != \"\" {\n-\t\tuser.Verified = s.DataService.IsVerified(siteID, user.ID)\n+\t\tuser.Verified = s.dataService.IsVerified(siteID, user.ID)\n \t}\n \n \trender.JSON(w, r, user)\n }\n \n // PUT /vote/{id}?site=siteID&url=post-url&vote=1 - vote for/against comment\n-func (s *Rest) voteCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *private) voteCtrl(w http.ResponseWriter, r *http.Request) {\n \tuser := rest.MustGetUserInfo(r)\n \tlocator := store.Locator{SiteID: r.URL.Query().Get(\"site\"), URL: r.URL.Query().Get(\"url\")}\n \tid := chi.URLParam(r, \"id\")\n@@ -166,23 +193,23 @@ func (s *Rest) voteCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \t// check if user blocked\n-\tif s.adminService.checkBlocked(locator.SiteID, user) {\n+\tif s.dataService.IsBlocked(locator.SiteID, user.ID) {\n \t\trest.SendErrorJSON(w, r, http.StatusForbidden, errors.New(\"rejected\"), \"user blocked\", rest.ErrUserBlocked)\n \t\treturn\n \t}\n \n-\tcomment, err := s.DataService.Vote(locator, id, user.ID, vote)\n+\tcomment, err := s.dataService.Vote(locator, id, user.ID, vote)\n \tif err != nil {\n-\t\tcode := s.parseError(err, rest.ErrVoteRejected)\n+\t\tcode := parseError(err, rest.ErrVoteRejected)\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't vote for comment\", code)\n \t\treturn\n \t}\n-\ts.Cache.Flush(cache.Flusher(locator.SiteID).Scopes(locator.URL, comment.User.ID))\n+\ts.cache.Flush(cache.Flusher(locator.SiteID).Scopes(locator.URL, comment.User.ID))\n \trender.JSON(w, r, R.JSON{\"id\": comment.ID, \"score\": comment.Score})\n }\n \n // GET /userdata?site=siteID - exports all data about the user as a json with user info and list of all comments\n-func (s *Rest) userAllDataCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *private) userAllDataCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n \tuser := rest.MustGetUserInfo(r)\n \tuserB, err := json.Marshal(&user)\n@@ -213,7 +240,7 @@ func (s *Rest) userAllDataCtrl(w http.ResponseWriter, r *http.Request) {\n \n \t// get comments in 100 in each paginated request\n \tfor i := 0; i < 100; i++ {\n-\t\tcomments, errUser := s.DataService.User(siteID, user.ID, 100, i*100)\n+\t\tcomments, errUser := s.dataService.User(siteID, user.ID, 100, i*100, rest.GetUserOrEmpty(r))\n \t\tif errUser != nil {\n \t\t\trest.SendErrorJSON(w, r, http.StatusInternalServerError, errUser, \"can't get user comments\", rest.ErrInternal)\n \t\t\treturn\n@@ -240,7 +267,7 @@ func (s *Rest) userAllDataCtrl(w http.ResponseWriter, r *http.Request) {\n \n // POST /deleteme?site_id=site - requesting delete of all user info\n // makes jwt with user info and sends it back as a part of json response\n-func (s *Rest) deleteMeCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *private) deleteMeCtrl(w http.ResponseWriter, r *http.Request) {\n \tuser := rest.MustGetUserInfo(r)\n \tsiteID := r.URL.Query().Get(\"site\")\n \n@@ -260,18 +287,18 @@ func (s *Rest) deleteMeCtrl(w http.ResponseWriter, r *http.Request) {\n \t\t},\n \t}\n \n-\ttokenStr, err := s.Authenticator.TokenService().Token(claims)\n+\ttokenStr, err := s.authenticator.TokenService().Token(claims)\n \tif err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusInternalServerError, err, \"can't make token\", rest.ErrInternal)\n \t\treturn\n \t}\n \n-\tlink := fmt.Sprintf(\"%s/web/deleteme.html?token=%s\", s.RemarkURL, tokenStr)\n+\tlink := fmt.Sprintf(\"%s/web/deleteme.html?token=%s\", s.remarkURL, tokenStr)\n \trender.JSON(w, r, R.JSON{\"site\": siteID, \"user_id\": user.ID, \"token\": tokenStr, \"link\": link})\n }\n \n // POST /image - save image with form request\n-func (s *Rest) savePictureCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *private) savePictureCtrl(w http.ResponseWriter, r *http.Request) {\n \tuser := rest.MustGetUserInfo(r)\n \n \tif err := r.ParseMultipartForm(5 * 1024 * 1024); err != nil { // 5M max memory, if bigger will make a file\n@@ -286,7 +313,7 @@ func (s *Rest) savePictureCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \tdefer func() { _ = file.Close() }()\n \n-\tid, err := s.ImageService.Save(header.Filename, user.ID, file)\n+\tid, err := s.imageService.Save(header.Filename, user.ID, file)\n \tif err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't save image\", rest.ErrInternal)\n \t\treturn\n@@ -295,37 +322,12 @@ func (s *Rest) savePictureCtrl(w http.ResponseWriter, r *http.Request) {\n \trender.JSON(w, r, R.JSON{\"id\": id})\n }\n \n-func (s *Rest) isReadOnly(locator store.Locator) bool {\n-\tif s.ReadOnlyAge > 0 {\n+func (s *private) isReadOnly(locator store.Locator) bool {\n+\tif s.readOnlyAge > 0 {\n \t\t// check RO by age\n-\t\tif info, e := s.DataService.Info(locator, s.ReadOnlyAge); e == nil && info.ReadOnly {\n+\t\tif info, e := s.dataService.Info(locator, s.readOnlyAge); e == nil && info.ReadOnly {\n \t\t\treturn true\n \t\t}\n \t}\n-\treturn s.DataService.IsReadOnly(locator) // ro manually\n-}\n-\n-func (s *Rest) parseError(err error, defaultCode int) (code int) {\n-\tcode = defaultCode\n-\n-\tswitch {\n-\t// voting errors\n-\tcase strings.Contains(err.Error(), \"can not vote for his own comment\"):\n-\t\tcode = rest.ErrVoteSelf\n-\tcase strings.Contains(err.Error(), \"already voted for\"):\n-\t\tcode = rest.ErrVoteDbl\n-\tcase strings.Contains(err.Error(), \"maximum number of votes exceeded for comment\"):\n-\t\tcode = rest.ErrVoteMax\n-\tcase strings.Contains(err.Error(), \"minimal score reached for comment\"):\n-\t\tcode = rest.ErrVoteMinScore\n-\n-\t// edit errors\n-\tcase strings.HasPrefix(err.Error(), \"too late to edit\"):\n-\t\tcode = rest.ErrCommentEditExpired\n-\tcase strings.HasPrefix(err.Error(), \"parent comment with reply can't be edited\"):\n-\t\tcode = rest.ErrCommentEditChanged\n-\n-\t}\n-\n-\treturn code\n+\treturn s.dataService.IsReadOnly(locator) // ro manually\n }"
    },
    {
      "sha": "7059bdb3f812e18014c34a9d9bf965267233ad33",
      "filename": "backend/app/rest/api/rest_private_test.go",
      "status": "modified",
      "additions": 15,
      "deletions": 36,
      "changes": 51,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_private_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_private_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest_private_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -11,17 +11,14 @@ import (\n \t\"mime/multipart\"\n \t\"net/http\"\n \t\"os\"\n-\t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n \t\"github.com/go-pkgz/lgr\"\n \tR \"github.com/go-pkgz/rest\"\n-\t\"github.com/pkg/errors\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n-\t\"github.com/umputun/remark/backend/app/rest\"\n \n \t\"github.com/umputun/remark/backend/app/store\"\n \t\"github.com/umputun/remark/backend/app/store/image\"\n@@ -63,7 +60,7 @@ func TestRest_CreateOldPost(t *testing.T) {\n \t_, err := srv.DataService.Create(old)\n \tassert.Nil(t, err)\n \n-\tcomments, err := srv.DataService.Find(store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com/blah1\"}, \"time\")\n+\tcomments, err := srv.DataService.Find(store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com/blah1\"}, \"time\", store.User{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 1, len(comments))\n \n@@ -620,16 +617,21 @@ func TestRest_CreateWithPictures(t *testing.T) {\n \t}()\n \tlgr.Setup(lgr.Debug, lgr.CallerFile, lgr.CallerFunc)\n \n-\tsvc.ImageService = &image.Service{\n-\t\tStore: &image.FileSystem{\n-\t\t\tStaging:  \"/tmp/remark42/images.staging\",\n-\t\t\tLocation: \"/tmp/remark42/images\",\n-\t\t\tMaxSize:  2000,\n-\t\t},\n-\t\tTTL: time.Millisecond * 100,\n+\timageService := svc.ImageService\n+\timageService.Store = &image.FileSystem{\n+\t\tStaging:  \"/tmp/remark42/images.staging\",\n+\t\tLocation: \"/tmp/remark42/images\",\n+\t\tMaxSize:  2000,\n \t}\n-\tsvc.DataService.EditDuration = time.Millisecond * 100\n-\tsvc.DataService.ImageService = svc.ImageService\n+\timageService.TTL = 100 * time.Millisecond\n+\n+\tsvc.privRest.imageService = imageService\n+\tsvc.ImageService = imageService\n+\n+\tdataService := svc.DataService\n+\tdataService.EditDuration = time.Millisecond * 100\n+\tdataService.ImageService = svc.ImageService\n+\tsvc.privRest.dataService = dataService\n \n \tuploadPicture := func(file string) (id string) {\n \t\tbodyBuf := &bytes.Buffer{}\n@@ -683,26 +685,3 @@ func TestRest_CreateWithPictures(t *testing.T) {\n \t_, err = os.Stat(\"/tmp/remark42/images/\" + id3)\n \tassert.NoError(t, err, \"moved from staging\")\n }\n-\n-func TestRest_parseError(t *testing.T) {\n-\ttbl := []struct {\n-\t\terr error\n-\t\tres int\n-\t}{\n-\t\t{errors.New(\"can not vote for his own comment\"), rest.ErrVoteSelf},\n-\t\t{errors.New(\"already voted for\"), rest.ErrVoteDbl},\n-\t\t{errors.New(\"maximum number of votes exceeded for comment\"), rest.ErrVoteMax},\n-\t\t{errors.New(\"minimal score reached for comment\"), rest.ErrVoteMinScore},\n-\t\t{errors.New(\"too late to edit\"), rest.ErrCommentEditExpired},\n-\t\t{errors.New(\"parent comment with reply can't be edited\"), rest.ErrCommentEditChanged},\n-\t\t{errors.New(\"blah blah\"), rest.ErrInternal},\n-\t}\n-\n-\tsvc := Rest{}\n-\tfor n, tt := range tbl {\n-\t\tt.Run(strconv.Itoa(n), func(t *testing.T) {\n-\t\t\tres := svc.parseError(tt.err, rest.ErrInternal)\n-\t\t\tassert.Equal(t, tt.res, res)\n-\t\t})\n-\t}\n-}"
    },
    {
      "sha": "f9c280b6b3feb8822c87789425a3a6616d4b5322",
      "filename": "backend/app/rest/api/rest_public.go",
      "status": "modified",
      "additions": 81,
      "deletions": 79,
      "changes": 160,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_public.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_public.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest_public.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -19,12 +19,53 @@ import (\n \n \t\"github.com/umputun/remark/backend/app/rest\"\n \t\"github.com/umputun/remark/backend/app/store\"\n+\t\"github.com/umputun/remark/backend/app/store/image\"\n \t\"github.com/umputun/remark/backend/app/store/service\"\n )\n \n+type public struct {\n+\tdataService      pubStore\n+\tcache            cache.LoadingCache\n+\treadOnlyAge      int\n+\tcommentFormatter *store.CommentFormatter\n+\timageService     *image.Service\n+\twebRoot          string\n+\tconfFn           func(siteID string) config\n+}\n+\n+type pubStore interface {\n+\tCreate(comment store.Comment) (commentID string, err error)\n+\tGet(locator store.Locator, commentID string, user store.User) (store.Comment, error)\n+\tFind(locator store.Locator, sort string, user store.User) ([]store.Comment, error)\n+\tLast(siteID string, limit int, since time.Time, user store.User) ([]store.Comment, error)\n+\tUser(siteID, userID string, limit, skip int, user store.User) ([]store.Comment, error)\n+\tUserCount(siteID, userID string) (int, error)\n+\tCount(locator store.Locator) (int, error)\n+\tList(siteID string, limit int, skip int) ([]store.PostInfo, error)\n+\tInfo(locator store.Locator, readonlyAge int) (store.PostInfo, error)\n+\n+\tValidateComment(c *store.Comment) error\n+\tIsReadOnly(locator store.Locator) bool\n+\tCounts(siteID string, postIDs []string) ([]store.PostInfo, error)\n+}\n+\n+type config struct {\n+\tVersion        string   `json:\"version\"`\n+\tEditDuration   int      `json:\"edit_duration\"`\n+\tMaxCommentSize int      `json:\"max_comment_size\"`\n+\tAdmins         []string `json:\"admins\"`\n+\tAdminEmail     string   `json:\"admin_email\"`\n+\tAuth           []string `json:\"auth_providers\"`\n+\tLowScore       int      `json:\"low_score\"`\n+\tCriticalScore  int      `json:\"critical_score\"`\n+\tPositiveScore  bool     `json:\"positive_score\"`\n+\tReadOnlyAge    int      `json:\"readonly_age\"`\n+\tMaxImageSize   int      `json:\"max_image_size\"`\n+}\n+\n // GET /find?site=siteID&url=post-url&format=[tree|plain]&sort=[+/-time|+/-score|+/-controversy ]\n // find comments for given post. Returns in tree or plain formats, sorted\n-func (s *Rest) findCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) findCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \tlocator := store.Locator{SiteID: r.URL.Query().Get(\"site\"), URL: r.URL.Query().Get(\"url\")}\n \tsort := r.URL.Query().Get(\"sort\")\n \tif strings.HasPrefix(sort, \" \") { // restore + replaced by \" \"\n@@ -33,26 +74,25 @@ func (s *Rest) findCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \tlog.Printf(\"[DEBUG] get comments for %+v, sort %s, format %s\", locator, sort, r.URL.Query().Get(\"format\"))\n \n \tkey := cache.NewKey(locator.SiteID).ID(URLKeyWithUser(r)).Scopes(locator.SiteID, locator.URL)\n-\tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tcomments, e := s.DataService.Find(locator, sort)\n+\tdata, err := s.cache.Get(key, func() ([]byte, error) {\n+\t\tcomments, e := s.dataService.Find(locator, sort, rest.GetUserOrEmpty(r))\n \t\tif e != nil {\n \t\t\tcomments = []store.Comment{} // error should clear comments and continue for post info\n \t\t}\n-\t\tmaskedComments := s.alterComments(comments, r)\n \t\tvar b []byte\n \t\tswitch r.URL.Query().Get(\"format\") {\n \t\tcase \"tree\":\n-\t\t\ttree := service.MakeTree(maskedComments, sort, s.ReadOnlyAge)\n+\t\t\ttree := service.MakeTree(comments, sort, s.readOnlyAge)\n \t\t\tif tree.Nodes == nil { // eliminate json nil serialization\n \t\t\t\ttree.Nodes = []*service.Node{}\n \t\t\t}\n-\t\t\tif s.DataService.IsReadOnly(locator) {\n+\t\t\tif s.dataService.IsReadOnly(locator) {\n \t\t\t\ttree.Info.ReadOnly = true\n \t\t\t}\n \t\t\tb, e = encodeJSONWithHTML(tree)\n \t\tdefault:\n-\t\t\twithInfo := commentsWithInfo{Comments: maskedComments}\n-\t\t\tif info, ee := s.DataService.Info(locator, s.ReadOnlyAge); ee == nil {\n+\t\t\twithInfo := commentsWithInfo{Comments: comments}\n+\t\t\tif info, ee := s.dataService.Info(locator, s.readOnlyAge); ee == nil {\n \t\t\t\twithInfo.Info = info\n \t\t\t}\n \t\t\tb, e = encodeJSONWithHTML(withInfo)\n@@ -71,7 +111,7 @@ func (s *Rest) findCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // POST /preview, body is a comment, returns rendered html\n-func (s *Rest) previewCommentCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) previewCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \tcomment := store.Comment{}\n \tif err := render.DecodeJSON(http.MaxBytesReader(w, r.Body, hardBodyLimit), &comment); err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't bind comment\", rest.ErrDecode)\n@@ -85,23 +125,23 @@ func (s *Rest) previewCommentCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \tcomment.User = user\n \tcomment.Orig = comment.Text\n-\tif err = s.DataService.ValidateComment(&comment); err != nil {\n+\tif err = s.dataService.ValidateComment(&comment); err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"invalid comment\", rest.ErrCommentValidation)\n \t\treturn\n \t}\n \n-\tcomment = s.CommentFormatter.Format(comment)\n+\tcomment = s.commentFormatter.Format(comment)\n \tcomment.Sanitize()\n \trender.HTML(w, r, comment.Text)\n }\n \n // GET /info?site=siteID&url=post-url - get info about the post\n-func (s *Rest) infoCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) infoCtrl(w http.ResponseWriter, r *http.Request) {\n \tlocator := store.Locator{SiteID: r.URL.Query().Get(\"site\"), URL: r.URL.Query().Get(\"url\")}\n \n \tkey := cache.NewKey(locator.SiteID).ID(URLKey(r)).Scopes(locator.SiteID, locator.URL)\n-\tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tinfo, e := s.DataService.Info(locator, s.ReadOnlyAge)\n+\tdata, err := s.cache.Get(key, func() ([]byte, error) {\n+\t\tinfo, e := s.dataService.Info(locator, s.readOnlyAge)\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n@@ -120,7 +160,7 @@ func (s *Rest) infoCtrl(w http.ResponseWriter, r *http.Request) {\n \n // GET /last/{limit}?site=siteID&since=unix_ts_msec - last comments for the siteID, across all posts, sorted by time, optionally\n // limited with \"since\" param\n-func (s *Rest) lastCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) lastCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n \tlog.Printf(\"[DEBUG] get last comments for %s\", siteID)\n \n@@ -132,21 +172,20 @@ func (s *Rest) lastCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \tsinceTime := time.Time{}\n \tsince := r.URL.Query().Get(\"since\")\n \tif since != \"\" {\n-\t\tunixTS, err := strconv.ParseInt(since, 10, 64)\n-\t\tif err != nil {\n-\t\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't translate since parameter\", rest.ErrDecode)\n+\t\tunixTS, e := strconv.ParseInt(since, 10, 64)\n+\t\tif e != nil {\n+\t\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, e, \"can't translate since parameter\", rest.ErrDecode)\n \t\t\treturn\n \t\t}\n \t\tsinceTime = time.Unix(unixTS/1000, 1000000*(unixTS%1000)) // since param in msec timestamp\n \t}\n \n \tkey := cache.NewKey(siteID).ID(URLKey(r)).Scopes(lastCommentsScope)\n-\tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tcomments, e := s.DataService.Last(siteID, limit, sinceTime)\n+\tdata, err := s.cache.Get(key, func() ([]byte, error) {\n+\t\tcomments, e := s.dataService.Last(siteID, limit, sinceTime, rest.GetUserOrEmpty(r))\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n-\t\tcomments = s.alterComments(comments, r)\n \t\t// filter deleted from last comments view. Blocked marked as deleted and will sneak in without\n \t\tfilterDeleted := filterComments(comments, func(c store.Comment) bool { return !c.Deleted })\n \t\treturn encodeJSONWithHTML(filterDeleted)\n@@ -163,20 +202,19 @@ func (s *Rest) lastCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // GET /id/{id}?site=siteID&url=post-url - gets a comment by id\n-func (s *Rest) commentByIDCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) commentByIDCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tid := chi.URLParam(r, \"id\")\n \tsiteID := r.URL.Query().Get(\"site\")\n \turl := r.URL.Query().Get(\"url\")\n \n \tlog.Printf(\"[DEBUG] get comments by id %s, %s %s\", id, siteID, url)\n \n-\tcomment, err := s.DataService.Get(store.Locator{SiteID: siteID, URL: url}, id)\n+\tcomment, err := s.dataService.Get(store.Locator{SiteID: siteID, URL: url}, id, rest.GetUserOrEmpty(r))\n \tif err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't get comment by id\", rest.ErrCommentNotFound)\n \t\treturn\n \t}\n-\tcomment = s.alterComments([]store.Comment{comment}, r)[0]\n \trender.Status(r, http.StatusOK)\n \n \tif err = R.RenderJSONWithHTML(w, r, comment); err != nil {\n@@ -185,7 +223,7 @@ func (s *Rest) commentByIDCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // GET /comments?site=siteID&user=id - returns comments for given userID\n-func (s *Rest) findUserCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) findUserCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tuserID := r.URL.Query().Get(\"user\")\n \tsiteID := r.URL.Query().Get(\"site\")\n@@ -203,14 +241,13 @@ func (s *Rest) findUserCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \tlog.Printf(\"[DEBUG] get comments for userID %s, %s\", userID, siteID)\n \n \tkey := cache.NewKey(siteID).ID(URLKeyWithUser(r)).Scopes(userID, siteID)\n-\tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tcomments, e := s.DataService.User(siteID, userID, limit, 0)\n+\tdata, err := s.cache.Get(key, func() ([]byte, error) {\n+\t\tcomments, e := s.dataService.User(siteID, userID, limit, 0, rest.GetUserOrEmpty(r))\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n-\t\tcomments = s.alterComments(comments, r)\n \t\tcomments = filterComments(comments, func(c store.Comment) bool { return !c.Deleted })\n-\t\tcount, e := s.DataService.UserCount(siteID, userID)\n+\t\tcount, e := s.dataService.UserCount(siteID, userID)\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n@@ -229,52 +266,17 @@ func (s *Rest) findUserCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // GET /config?site=siteID - returns configuration\n-func (s *Rest) configCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) configCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n-\n-\ttype config struct {\n-\t\tVersion        string   `json:\"version\"`\n-\t\tEditDuration   int      `json:\"edit_duration\"`\n-\t\tMaxCommentSize int      `json:\"max_comment_size\"`\n-\t\tAdmins         []string `json:\"admins\"`\n-\t\tAdminEmail     string   `json:\"admin_email\"`\n-\t\tAuth           []string `json:\"auth_providers\"`\n-\t\tLowScore       int      `json:\"low_score\"`\n-\t\tCriticalScore  int      `json:\"critical_score\"`\n-\t\tPositiveScore  bool     `json:\"positive_score\"`\n-\t\tReadOnlyAge    int      `json:\"readonly_age\"`\n-\t\tMaxImageSize   int      `json:\"max_image_size\"`\n-\t}\n-\n-\tcnf := config{\n-\t\tVersion:        s.Version,\n-\t\tEditDuration:   int(s.DataService.EditDuration.Seconds()),\n-\t\tMaxCommentSize: s.DataService.MaxCommentSize,\n-\t\tAdmins:         s.DataService.AdminStore.Admins(siteID),\n-\t\tAdminEmail:     s.DataService.AdminStore.Email(siteID),\n-\t\tLowScore:       s.ScoreThresholds.Low,\n-\t\tCriticalScore:  s.ScoreThresholds.Critical,\n-\t\tPositiveScore:  s.DataService.PositiveScore,\n-\t\tReadOnlyAge:    s.ReadOnlyAge,\n-\t\tMaxImageSize:   s.ImageService.Store.SizeLimit(),\n-\t}\n-\n-\tcnf.Auth = []string{}\n-\tfor _, ap := range s.Authenticator.Providers() {\n-\t\tcnf.Auth = append(cnf.Auth, ap.Name())\n-\t}\n-\n-\tif cnf.Admins == nil { // prevent json serialization to nil\n-\t\tcnf.Admins = []string{}\n-\t}\n+\tcnf := s.confFn(siteID)\n \trender.Status(r, http.StatusOK)\n \trender.JSON(w, r, cnf)\n }\n \n // GET /count?site=siteID&url=post-url - get number of comments for given post\n-func (s *Rest) countCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) countCtrl(w http.ResponseWriter, r *http.Request) {\n \tlocator := store.Locator{SiteID: r.URL.Query().Get(\"site\"), URL: r.URL.Query().Get(\"url\")}\n-\tcount, err := s.DataService.Count(locator)\n+\tcount, err := s.dataService.Count(locator)\n \tif err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't get count\", rest.ErrPostNotFound)\n \t\treturn\n@@ -283,7 +285,7 @@ func (s *Rest) countCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // POST /counts?site=siteID - get number of comments for posts from post body\n-func (s *Rest) countMultiCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) countMultiCtrl(w http.ResponseWriter, r *http.Request) {\n \tsiteID := r.URL.Query().Get(\"site\")\n \tposts := []string{}\n \tif err := render.DecodeJSON(http.MaxBytesReader(w, r.Body, hardBodyLimit), &posts); err != nil {\n@@ -297,8 +299,8 @@ func (s *Rest) countMultiCtrl(w http.ResponseWriter, r *http.Request) {\n \tsha := base64.URLEncoding.EncodeToString(h[:])\n \n \tkey := cache.NewKey(siteID).ID(sha).Scopes(siteID)\n-\tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tcounts, e := s.DataService.Counts(siteID, posts)\n+\tdata, err := s.cache.Get(key, func() ([]byte, error) {\n+\t\tcounts, e := s.dataService.Counts(siteID, posts)\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n@@ -316,7 +318,7 @@ func (s *Rest) countMultiCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // GET /list?site=siteID&limit=50&skip=10 - list posts with comments\n-func (s *Rest) listCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) listCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tsiteID := r.URL.Query().Get(\"site\")\n \tlimit, skip := 0, 0\n@@ -329,8 +331,8 @@ func (s *Rest) listCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \tkey := cache.NewKey(siteID).ID(URLKey(r)).Scopes(siteID)\n-\tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tposts, e := s.DataService.List(siteID, limit, skip)\n+\tdata, err := s.cache.Get(key, func() ([]byte, error) {\n+\t\tposts, e := s.dataService.List(siteID, limit, skip)\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n@@ -348,7 +350,7 @@ func (s *Rest) listCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // GET /picture/{user}/{id} - get picture\n-func (s *Rest) loadPictureCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) loadPictureCtrl(w http.ResponseWriter, r *http.Request) {\n \n \timgContentType := func(img string) string {\n \t\timg = strings.ToLower(img)\n@@ -364,7 +366,7 @@ func (s *Rest) loadPictureCtrl(w http.ResponseWriter, r *http.Request) {\n \t}\n \n \tid := chi.URLParam(r, \"user\") + \"/\" + chi.URLParam(r, \"id\")\n-\timgRdr, size, err := s.ImageService.Load(id)\n+\timgRdr, size, err := s.imageService.Load(id)\n \tif err != nil {\n \t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, \"can't get image \"+id, rest.ErrAssetNotFound)\n \t\treturn\n@@ -395,8 +397,8 @@ func (s *Rest) loadPictureCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // GET /index.html - respond to /index.html with the content of getstarted.html under /web root\n-func (s *Rest) getStartedCtrl(w http.ResponseWriter, r *http.Request) {\n-\tdata, err := ioutil.ReadFile(path.Join(s.WebRoot, \"getstarted.html\"))\n+func (s *public) getStartedCtrl(w http.ResponseWriter, r *http.Request) {\n+\tdata, err := ioutil.ReadFile(path.Join(s.webRoot, \"getstarted.html\"))\n \tif err != nil {\n \t\tw.WriteHeader(http.StatusNotFound)\n \t\treturn\n@@ -405,7 +407,7 @@ func (s *Rest) getStartedCtrl(w http.ResponseWriter, r *http.Request) {\n }\n \n // GET /robots.txt\n-func (s *Rest) getRobotsCtrl(w http.ResponseWriter, r *http.Request) {\n+func (s *public) getRobotsCtrl(w http.ResponseWriter, r *http.Request) {\n \tallowed := []string{\"/find\", \"/last\", \"/id\", \"/count\", \"/counts\", \"/list\", \"/config\",\n \t\t\"/img\", \"/avatar\", \"/picture\"}\n \tfor i := range allowed {"
    },
    {
      "sha": "91a54313f1281f5554f52b566c6e69f39004f459",
      "filename": "backend/app/rest/api/rest_public_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_public_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_public_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest_public_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -453,7 +453,7 @@ func TestRest_Info(t *testing.T) {\n \tts, srv, teardown := startupT(t)\n \tdefer teardown()\n \n-\tsrv.ReadOnlyAge = 10000000 // make sure we don't hit read-only\n+\tsrv.pubRest.readOnlyAge = 10000000 // make sure we don't hit read-only\n \n \tuser := store.User{ID: \"user1\", Name: \"user name 1\"}\n \tc1 := store.Comment{User: user, Text: \"test test #1\", Locator: store.Locator{SiteID: \"radio-t\","
    },
    {
      "sha": "e0af2b0a656203e7c3d9d2c8066da8560f657213",
      "filename": "backend/app/rest/api/rest_test.go",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rest_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rest_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -4,6 +4,7 @@ import (\n \t\"bytes\"\n \t\"crypto/tls\"\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"math/rand\"\n@@ -249,6 +250,29 @@ func Test_URLKeyWithUser(t *testing.T) {\n \t}\n \n }\n+\n+func TestRest_parseError(t *testing.T) {\n+\ttbl := []struct {\n+\t\terr error\n+\t\tres int\n+\t}{\n+\t\t{errors.New(\"can not vote for his own comment\"), rest.ErrVoteSelf},\n+\t\t{errors.New(\"already voted for\"), rest.ErrVoteDbl},\n+\t\t{errors.New(\"maximum number of votes exceeded for comment\"), rest.ErrVoteMax},\n+\t\t{errors.New(\"minimal score reached for comment\"), rest.ErrVoteMinScore},\n+\t\t{errors.New(\"too late to edit\"), rest.ErrCommentEditExpired},\n+\t\t{errors.New(\"parent comment with reply can't be edited\"), rest.ErrCommentEditChanged},\n+\t\t{errors.New(\"blah blah\"), rest.ErrInternal},\n+\t}\n+\n+\tfor n, tt := range tbl {\n+\t\tt.Run(strconv.Itoa(n), func(t *testing.T) {\n+\t\t\tres := parseError(tt.err, rest.ErrInternal)\n+\t\t\tassert.Equal(t, tt.res, res)\n+\t\t})\n+\t}\n+}\n+\n func startupT(t *testing.T) (ts *httptest.Server, srv *Rest, teardown func()) {\n \n \ttestDb := fmt.Sprintf(\"/tmp/test-remark-%d.db\", rand.Int31())"
    },
    {
      "sha": "47ec8edfeb0c3e5fa72c2367e47a56b11d252167",
      "filename": "backend/app/rest/api/rss.go",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rss.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/api/rss.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/rss.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -28,11 +28,10 @@ func (s *Rest) rssPostCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tkey := cache.NewKey(locator.SiteID).ID(URLKey(r)).Scopes(locator.SiteID, locator.URL)\n \tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tcomments, e := s.DataService.Find(locator, \"-time\")\n+\t\tcomments, e := s.DataService.Find(locator, \"-time\", rest.GetUserOrEmpty(r))\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n-\t\tcomments = s.alterComments(comments, r)\n \t\trss, e := s.toRssFeed(locator.URL, comments, \"post comments for \"+r.URL.Query().Get(\"url\"))\n \t\tif e != nil {\n \t\t\treturn nil, e\n@@ -60,11 +59,10 @@ func (s *Rest) rssSiteCommentsCtrl(w http.ResponseWriter, r *http.Request) {\n \n \tkey := cache.NewKey(siteID).ID(URLKey(r)).Scopes(siteID, lastCommentsScope)\n \tdata, err := s.Cache.Get(key, func() ([]byte, error) {\n-\t\tcomments, e := s.DataService.Last(siteID, maxRssItems, time.Time{})\n+\t\tcomments, e := s.DataService.Last(siteID, maxRssItems, time.Time{}, rest.GetUserOrEmpty(r))\n \t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n-\t\tcomments = s.alterComments(comments, r)\n \n \t\trss, e := s.toRssFeed(r.URL.Query().Get(\"site\"), comments, \"site comment for \"+siteID)\n \t\tif e != nil {\n@@ -94,11 +92,10 @@ func (s *Rest) rssRepliesCtrl(w http.ResponseWriter, r *http.Request) {\n \tuserName := \"\"\n \tkey := cache.NewKey(siteID).ID(URLKey(r)).Scopes(siteID, lastCommentsScope)\n \tdata, err := s.Cache.Get(key, func() (res []byte, e error) {\n-\t\tcomments, e := s.DataService.Last(siteID, maxLastCommentsReply, time.Time{})\n+\t\tcomments, e := s.DataService.Last(siteID, maxLastCommentsReply, time.Time{}, rest.GetUserOrEmpty(r))\n \t\tif e != nil {\n \t\t\treturn nil, errors.Wrap(e, \"can't get last comments\")\n \t\t}\n-\t\tcomments = s.alterComments(comments, r)\n \t\treplies := []store.Comment{}\n \t\tfor _, c := range comments {\n \t\t\tif len(replies) > maxRssItems || c.Timestamp.Add(maxReplyDuration).Before(time.Now()) {\n@@ -109,7 +106,7 @@ func (s *Rest) rssRepliesCtrl(w http.ResponseWriter, r *http.Request) {\n \t\t\t}\n \t\t\tif c.ParentID != \"\" && !c.Deleted && c.User.ID != userID { // not interested in replies to yourself\n \t\t\t\tvar pc store.Comment\n-\t\t\t\tif pc, e = s.DataService.Get(c.Locator, c.ParentID); e != nil {\n+\t\t\t\tif pc, e = s.DataService.Get(c.Locator, c.ParentID, rest.GetUserOrEmpty(r)); e != nil {\n \t\t\t\t\treturn nil, errors.Wrap(e, \"can't get parent comment\")\n \t\t\t\t}\n \t\t\t\tif pc.User.ID == userID {\n@@ -166,7 +163,7 @@ func (s *Rest) toRssFeed(url string, comments []store.Comment, description strin\n \t\t}\n \t\tif c.ParentID != \"\" {\n \t\t\t// add indication to parent comment\n-\t\t\tparentComment, err := s.DataService.Get(c.Locator, c.ParentID)\n+\t\t\tparentComment, err := s.DataService.Get(c.Locator, c.ParentID, store.User{})\n \t\t\tif err == nil {\n \t\t\t\tf.Title = fmt.Sprintf(\"%s > %s\", c.User.Name, parentComment.User.Name)\n \t\t\t} else {"
    },
    {
      "sha": "6ae05fd0b036aed85890b220e6ab9169eabe0bb8",
      "filename": "backend/app/rest/user.go",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/user.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/rest/user.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/user.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -36,7 +36,15 @@ func GetUserInfo(r *http.Request) (user store.User, err error) {\n \t\tVerified: u.BoolAttr(\"verified\"),\n \t\tBlocked:  u.BoolAttr(\"blocked\"),\n \t}, nil\n+}\n \n+// GetUserOrEmpty attempts to get user info from request and returns empty object if failed\n+func GetUserOrEmpty(r *http.Request) store.User {\n+\tuser, err := GetUserInfo(r)\n+\tif err != nil {\n+\t\treturn store.User{}\n+\t}\n+\treturn user\n }\n \n // SetUserInfo sets user into request context"
    },
    {
      "sha": "9eccce65d1dfe7bfabcfac3028164abbec21ece6",
      "filename": "backend/app/store/engine/engine.go",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/engine/engine.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/engine/engine.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/engine.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -10,7 +10,8 @@ import (\n \t\"github.com/umputun/remark/backend/app/store\"\n )\n \n-//go:generate sh -c \"mockery -inpkg -name Interface -print > file.tmp && mv file.tmp engine_mock.go\"\n+// NOTE: mockery works from linked to go-path and with GOFLAGS='-mod=vendor' go generate\n+//go:generate sh -c \"mockery -inpkg -name Interface -print > /tmp/engine-mock.tmp && mv /tmp/engine-mock.tmp engine_mock.go\"\n \n // Interface combines all store interfaces\n type Interface interface {"
    },
    {
      "sha": "e274d538586cbaf86b0088019b568521b6efa8b3",
      "filename": "backend/app/store/engine/engine_mock.go",
      "status": "added",
      "additions": 408,
      "deletions": 0,
      "changes": 408,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/engine/engine_mock.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/engine/engine_mock.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/engine_mock.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -0,0 +1,408 @@\n+// Code generated by mockery v1.0.0. DO NOT EDIT.\n+package engine\n+\n+import mock \"github.com/stretchr/testify/mock\"\n+import store \"github.com/umputun/remark/backend/app/store\"\n+import time \"time\"\n+\n+// MockInterface is an autogenerated mock type for the Interface type\n+type MockInterface struct {\n+\tmock.Mock\n+}\n+\n+// Blocked provides a mock function with given fields: siteID\n+func (_m *MockInterface) Blocked(siteID string) ([]store.BlockedUser, error) {\n+\tret := _m.Called(siteID)\n+\n+\tvar r0 []store.BlockedUser\n+\tif rf, ok := ret.Get(0).(func(string) []store.BlockedUser); ok {\n+\t\tr0 = rf(siteID)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).([]store.BlockedUser)\n+\t\t}\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(string) error); ok {\n+\t\tr1 = rf(siteID)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// Close provides a mock function with given fields:\n+func (_m *MockInterface) Close() error {\n+\tret := _m.Called()\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func() error); ok {\n+\t\tr0 = rf()\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// Count provides a mock function with given fields: locator\n+func (_m *MockInterface) Count(locator store.Locator) (int, error) {\n+\tret := _m.Called(locator)\n+\n+\tvar r0 int\n+\tif rf, ok := ret.Get(0).(func(store.Locator) int); ok {\n+\t\tr0 = rf(locator)\n+\t} else {\n+\t\tr0 = ret.Get(0).(int)\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(store.Locator) error); ok {\n+\t\tr1 = rf(locator)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// Create provides a mock function with given fields: comment\n+func (_m *MockInterface) Create(comment store.Comment) (string, error) {\n+\tret := _m.Called(comment)\n+\n+\tvar r0 string\n+\tif rf, ok := ret.Get(0).(func(store.Comment) string); ok {\n+\t\tr0 = rf(comment)\n+\t} else {\n+\t\tr0 = ret.Get(0).(string)\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(store.Comment) error); ok {\n+\t\tr1 = rf(comment)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// Delete provides a mock function with given fields: locator, commentID, mode\n+func (_m *MockInterface) Delete(locator store.Locator, commentID string, mode store.DeleteMode) error {\n+\tret := _m.Called(locator, commentID, mode)\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(store.Locator, string, store.DeleteMode) error); ok {\n+\t\tr0 = rf(locator, commentID, mode)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// DeleteAll provides a mock function with given fields: siteID\n+func (_m *MockInterface) DeleteAll(siteID string) error {\n+\tret := _m.Called(siteID)\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(string) error); ok {\n+\t\tr0 = rf(siteID)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// DeleteUser provides a mock function with given fields: siteID, userID\n+func (_m *MockInterface) DeleteUser(siteID string, userID string) error {\n+\tret := _m.Called(siteID, userID)\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(string, string) error); ok {\n+\t\tr0 = rf(siteID, userID)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// Find provides a mock function with given fields: locator, sort\n+func (_m *MockInterface) Find(locator store.Locator, sort string) ([]store.Comment, error) {\n+\tret := _m.Called(locator, sort)\n+\n+\tvar r0 []store.Comment\n+\tif rf, ok := ret.Get(0).(func(store.Locator, string) []store.Comment); ok {\n+\t\tr0 = rf(locator, sort)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).([]store.Comment)\n+\t\t}\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(store.Locator, string) error); ok {\n+\t\tr1 = rf(locator, sort)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// Get provides a mock function with given fields: locator, commentID\n+func (_m *MockInterface) Get(locator store.Locator, commentID string) (store.Comment, error) {\n+\tret := _m.Called(locator, commentID)\n+\n+\tvar r0 store.Comment\n+\tif rf, ok := ret.Get(0).(func(store.Locator, string) store.Comment); ok {\n+\t\tr0 = rf(locator, commentID)\n+\t} else {\n+\t\tr0 = ret.Get(0).(store.Comment)\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(store.Locator, string) error); ok {\n+\t\tr1 = rf(locator, commentID)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// Info provides a mock function with given fields: locator, readonlyAge\n+func (_m *MockInterface) Info(locator store.Locator, readonlyAge int) (store.PostInfo, error) {\n+\tret := _m.Called(locator, readonlyAge)\n+\n+\tvar r0 store.PostInfo\n+\tif rf, ok := ret.Get(0).(func(store.Locator, int) store.PostInfo); ok {\n+\t\tr0 = rf(locator, readonlyAge)\n+\t} else {\n+\t\tr0 = ret.Get(0).(store.PostInfo)\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(store.Locator, int) error); ok {\n+\t\tr1 = rf(locator, readonlyAge)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// IsBlocked provides a mock function with given fields: siteID, userID\n+func (_m *MockInterface) IsBlocked(siteID string, userID string) bool {\n+\tret := _m.Called(siteID, userID)\n+\n+\tvar r0 bool\n+\tif rf, ok := ret.Get(0).(func(string, string) bool); ok {\n+\t\tr0 = rf(siteID, userID)\n+\t} else {\n+\t\tr0 = ret.Get(0).(bool)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// IsReadOnly provides a mock function with given fields: locator\n+func (_m *MockInterface) IsReadOnly(locator store.Locator) bool {\n+\tret := _m.Called(locator)\n+\n+\tvar r0 bool\n+\tif rf, ok := ret.Get(0).(func(store.Locator) bool); ok {\n+\t\tr0 = rf(locator)\n+\t} else {\n+\t\tr0 = ret.Get(0).(bool)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// IsVerified provides a mock function with given fields: siteID, userID\n+func (_m *MockInterface) IsVerified(siteID string, userID string) bool {\n+\tret := _m.Called(siteID, userID)\n+\n+\tvar r0 bool\n+\tif rf, ok := ret.Get(0).(func(string, string) bool); ok {\n+\t\tr0 = rf(siteID, userID)\n+\t} else {\n+\t\tr0 = ret.Get(0).(bool)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// Last provides a mock function with given fields: siteID, limit, since\n+func (_m *MockInterface) Last(siteID string, limit int, since time.Time) ([]store.Comment, error) {\n+\tret := _m.Called(siteID, limit, since)\n+\n+\tvar r0 []store.Comment\n+\tif rf, ok := ret.Get(0).(func(string, int, time.Time) []store.Comment); ok {\n+\t\tr0 = rf(siteID, limit, since)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).([]store.Comment)\n+\t\t}\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(string, int, time.Time) error); ok {\n+\t\tr1 = rf(siteID, limit, since)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// List provides a mock function with given fields: siteID, limit, skip\n+func (_m *MockInterface) List(siteID string, limit int, skip int) ([]store.PostInfo, error) {\n+\tret := _m.Called(siteID, limit, skip)\n+\n+\tvar r0 []store.PostInfo\n+\tif rf, ok := ret.Get(0).(func(string, int, int) []store.PostInfo); ok {\n+\t\tr0 = rf(siteID, limit, skip)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).([]store.PostInfo)\n+\t\t}\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(string, int, int) error); ok {\n+\t\tr1 = rf(siteID, limit, skip)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// Put provides a mock function with given fields: locator, comment\n+func (_m *MockInterface) Put(locator store.Locator, comment store.Comment) error {\n+\tret := _m.Called(locator, comment)\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(store.Locator, store.Comment) error); ok {\n+\t\tr0 = rf(locator, comment)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// SetBlock provides a mock function with given fields: siteID, userID, status, ttl\n+func (_m *MockInterface) SetBlock(siteID string, userID string, status bool, ttl time.Duration) error {\n+\tret := _m.Called(siteID, userID, status, ttl)\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(string, string, bool, time.Duration) error); ok {\n+\t\tr0 = rf(siteID, userID, status, ttl)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// SetReadOnly provides a mock function with given fields: locator, status\n+func (_m *MockInterface) SetReadOnly(locator store.Locator, status bool) error {\n+\tret := _m.Called(locator, status)\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(store.Locator, bool) error); ok {\n+\t\tr0 = rf(locator, status)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// SetVerified provides a mock function with given fields: siteID, userID, status\n+func (_m *MockInterface) SetVerified(siteID string, userID string, status bool) error {\n+\tret := _m.Called(siteID, userID, status)\n+\n+\tvar r0 error\n+\tif rf, ok := ret.Get(0).(func(string, string, bool) error); ok {\n+\t\tr0 = rf(siteID, userID, status)\n+\t} else {\n+\t\tr0 = ret.Error(0)\n+\t}\n+\n+\treturn r0\n+}\n+\n+// User provides a mock function with given fields: siteID, userID, limit, skip\n+func (_m *MockInterface) User(siteID string, userID string, limit int, skip int) ([]store.Comment, error) {\n+\tret := _m.Called(siteID, userID, limit, skip)\n+\n+\tvar r0 []store.Comment\n+\tif rf, ok := ret.Get(0).(func(string, string, int, int) []store.Comment); ok {\n+\t\tr0 = rf(siteID, userID, limit, skip)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).([]store.Comment)\n+\t\t}\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(string, string, int, int) error); ok {\n+\t\tr1 = rf(siteID, userID, limit, skip)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// UserCount provides a mock function with given fields: siteID, userID\n+func (_m *MockInterface) UserCount(siteID string, userID string) (int, error) {\n+\tret := _m.Called(siteID, userID)\n+\n+\tvar r0 int\n+\tif rf, ok := ret.Get(0).(func(string, string) int); ok {\n+\t\tr0 = rf(siteID, userID)\n+\t} else {\n+\t\tr0 = ret.Get(0).(int)\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(string, string) error); ok {\n+\t\tr1 = rf(siteID, userID)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}\n+\n+// Verified provides a mock function with given fields: siteID\n+func (_m *MockInterface) Verified(siteID string) ([]string, error) {\n+\tret := _m.Called(siteID)\n+\n+\tvar r0 []string\n+\tif rf, ok := ret.Get(0).(func(string) []string); ok {\n+\t\tr0 = rf(siteID)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).([]string)\n+\t\t}\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(string) error); ok {\n+\t\tr1 = rf(siteID)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}"
    },
    {
      "sha": "9999ffd8f55fb3f26f95340d2013c5f32f1ad9ed",
      "filename": "backend/app/store/service/service.go",
      "status": "modified",
      "additions": 107,
      "deletions": 25,
      "changes": 132,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/service/service.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/service/service.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/service/service.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -1,3 +1,6 @@\n+// Package service wraps engine interfaces with common logic unrelated to any particular engine implementation.\n+// All consumers should be using service.DataStore and not the naked engine!\n+\n package service\n \n import (\n@@ -96,12 +99,48 @@ func (s *DataStore) Create(comment store.Comment) (commentID string, err error)\n \treturn s.Interface.Create(comment)\n }\n \n+// Find wraps engine's Find call and alter results if needed\n+func (s *DataStore) Find(locator store.Locator, sort string, user store.User) ([]store.Comment, error) {\n+\tcomments, err := s.Interface.Find(locator, sort)\n+\tif err != nil {\n+\t\treturn comments, err\n+\t}\n+\n+\tchangedSort := false\n+\t// set votes controversy for comments added prior to #274\n+\tfor i, c := range comments {\n+\t\tif c.Controversy == 0 && len(c.Votes) > 0 {\n+\t\t\tc.Controversy = s.controversy(s.upsAndDowns(c))\n+\t\t\tif !changedSort && strings.Contains(sort, \"controversy\") { // trigger sort change\n+\t\t\t\tchangedSort = true\n+\t\t\t}\n+\t\t}\n+\t\tcomments[i] = s.alterComment(c, user)\n+\t}\n+\n+\t// resort commits if altered\n+\tif changedSort {\n+\t\tcomments = engine.SortComments(comments, sort)\n+\t}\n+\n+\treturn comments, nil\n+}\n+\n+// Get comment by ID\n+func (s *DataStore) Get(locator store.Locator, commentID string, user store.User) (store.Comment, error) {\n+\tc, err := s.Interface.Get(locator, commentID)\n+\tif err != nil {\n+\t\treturn store.Comment{}, err\n+\t}\n+\treturn s.alterComment(c, user), nil\n+}\n+\n // submitImages initiated delayed commit of all images from the comment uploaded to remark42\n func (s *DataStore) submitImages(comment store.Comment) {\n \n \ts.ImageService.Submit(func() []string {\n \t\tc := comment\n-\t\tcc, err := s.Get(c.Locator, c.ID) // this can be called after last edit, we have to retrieve fresh comment\n+\t\tcc, err := s.Interface.Get(c.Locator, c.ID) // this can be called after last edit, we have to retrieve fresh comment\n \t\tif err != nil {\n \t\t\tlog.Printf(\"[WARN] can't get comment's %s text for image extraction, %v\", c.ID, err)\n \t\t\treturn nil\n@@ -143,7 +182,7 @@ func (s *DataStore) prepareNewComment(comment store.Comment) (store.Comment, err\n \n // SetPin pin/un-pin comment as special\n func (s *DataStore) SetPin(locator store.Locator, commentID string, status bool) error {\n-\tcomment, err := s.Get(locator, commentID)\n+\tcomment, err := s.Interface.Get(locator, commentID)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -158,7 +197,7 @@ func (s *DataStore) Vote(locator store.Locator, commentID string, userID string,\n \tcLock.Lock()                           // prevents race on voting\n \tdefer cLock.Unlock()\n \n-\tcomment, err = s.Get(locator, commentID)\n+\tcomment, err = s.Interface.Get(locator, commentID)\n \tif err != nil {\n \t\treturn comment, err\n \t}\n@@ -246,7 +285,7 @@ type EditRequest struct {\n \n // EditComment to edit text and update Edit info\n func (s *DataStore) EditComment(locator store.Locator, commentID string, req EditRequest) (comment store.Comment, err error) {\n-\tcomment, err = s.Get(locator, commentID)\n+\tcomment, err = s.Interface.Get(locator, commentID)\n \tif err != nil {\n \t\treturn comment, err\n \t}\n@@ -295,7 +334,7 @@ func (s *DataStore) HasReplies(comment store.Comment) bool {\n \t\treturn true\n \t}\n \n-\tcomments, err := s.Last(comment.Locator.SiteID, maxLastCommentsReply, time.Time{})\n+\tcomments, err := s.Interface.Last(comment.Locator.SiteID, maxLastCommentsReply, time.Time{})\n \tif err != nil {\n \t\tlog.Printf(\"[WARN] can't get last comments for reply check, %v\", err)\n \t\treturn false\n@@ -318,7 +357,7 @@ func (s *DataStore) SetTitle(locator store.Locator, commentID string) (comment s\n \t\treturn comment, errors.New(\"no title extractor\")\n \t}\n \n-\tcomment, err = s.Get(locator, commentID)\n+\tcomment, err = s.Interface.Get(locator, commentID)\n \tif err != nil {\n \t\treturn comment, err\n \t}\n@@ -452,30 +491,22 @@ func (s *DataStore) SetMetas(siteID string, umetas []UserMetaData, pmetas []Post\n \treturn errs.ErrorOrNil()\n }\n \n-// Find wraps engine's Find call and alter results if needed\n-func (s *DataStore) Find(locator store.Locator, sort string) ([]store.Comment, error) {\n-\tcomments, err := s.Interface.Find(locator, sort)\n+// User gets comment for given userID on siteID\n+func (s *DataStore) User(siteID, userID string, limit, skip int, user store.User) ([]store.Comment, error) {\n+\tcomments, err := s.Interface.User(siteID, userID, limit, skip)\n \tif err != nil {\n \t\treturn comments, err\n \t}\n+\treturn s.alterComments(comments, user), nil\n+}\n \n-\tchangedSort := false\n-\t// set votes controversy for comments added prior to #274\n-\tfor i, c := range comments {\n-\t\tif c.Controversy == 0 && len(c.Votes) > 0 {\n-\t\t\tcomments[i].Controversy = s.controversy(s.upsAndDowns(c))\n-\t\t\tif !changedSort && strings.Contains(sort, \"controversy\") { // trigger sort change\n-\t\t\t\tchangedSort = true\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// resort commits if altered\n-\tif changedSort {\n-\t\tcomments = engine.SortComments(comments, sort)\n+// Last gets last comments for site, cross-post. Limited by count and optional since ts\n+func (s *DataStore) Last(siteID string, limit int, since time.Time, user store.User) ([]store.Comment, error) {\n+\tcomments, err := s.Interface.Last(siteID, limit, since)\n+\tif err != nil {\n+\t\treturn comments, err\n \t}\n-\n-\treturn comments, nil\n+\treturn s.alterComments(comments, user), nil\n }\n \n func (s *DataStore) upsAndDowns(c store.Comment) (ups, downs int) {\n@@ -503,3 +534,54 @@ func (s *DataStore) getScopedLocks(id string) (lock sync.Locker) {\n \n \treturn lock\n }\n+\n+func (s *DataStore) alterComments(cc []store.Comment, user store.User) (res []store.Comment) {\n+\tres = make([]store.Comment, len(cc))\n+\tfor i, c := range cc {\n+\t\tres[i] = s.alterComment(c, user)\n+\t}\n+\treturn res\n+}\n+\n+func (s *DataStore) alterComment(c store.Comment, user store.User) (res store.Comment) {\n+\n+\tblocked := s.IsBlocked(c.Locator.SiteID, c.User.ID)\n+\t// process blocked users\n+\tif blocked {\n+\t\tif !user.Admin { // reset comment to deleted for non-admins\n+\t\t\tc.SetDeleted(store.SoftDelete)\n+\t\t}\n+\t\tc.User.Blocked = true\n+\t\tc.Deleted = true\n+\t}\n+\n+\t// set verified status retroactively\n+\tif !blocked {\n+\t\tc.User.Verified = s.IsVerified(c.Locator.SiteID, c.User.ID)\n+\t}\n+\n+\t// hide info from non-admins\n+\tif !user.Admin {\n+\t\tc.User.IP = \"\"\n+\t}\n+\n+\tc = s.prepVotes(c, user)\n+\treturn c\n+}\n+\n+// prepare vote info for client view\n+func (s *DataStore) prepVotes(c store.Comment, user store.User) store.Comment {\n+\n+\tc.Vote = 0 // default is \"none\" (not voted)\n+\n+\tif v, ok := c.Votes[user.ID]; ok {\n+\t\tif v {\n+\t\t\tc.Vote = 1\n+\t\t} else {\n+\t\t\tc.Vote = -1\n+\t\t}\n+\t}\n+\n+\tc.Votes = nil // hide voters list\n+\treturn c\n+}"
    },
    {
      "sha": "01cd7031f3de573003eafae3868cda7eed7d9301",
      "filename": "backend/app/store/service/service_test.go",
      "status": "modified",
      "additions": 58,
      "deletions": 26,
      "changes": 84,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/service/service_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/app/store/service/service_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/service/service_test.go?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -18,11 +18,11 @@ import (\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/mock\"\n \t\"github.com/stretchr/testify/require\"\n-\t\"github.com/umputun/remark/backend/app/store/image\"\n \n \t\"github.com/umputun/remark/backend/app/store\"\n \t\"github.com/umputun/remark/backend/app/store/admin\"\n \t\"github.com/umputun/remark/backend/app/store/engine\"\n+\t\"github.com/umputun/remark/backend/app/store/image\"\n )\n \n var testDb = \"/tmp/test-remark.db\"\n@@ -40,7 +40,7 @@ func TestService_CreateFromEmpty(t *testing.T) {\n \tassert.NoError(t, err)\n \tassert.True(t, id != \"\", id)\n \n-\tres, err := b.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, id)\n+\tres, err := b.Interface.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, id)\n \tassert.NoError(t, err)\n \tt.Logf(\"%+v\", res)\n \tassert.Equal(t, \"text\", res.Text)\n@@ -66,7 +66,7 @@ func TestService_CreateFromPartial(t *testing.T) {\n \tassert.NoError(t, err)\n \tassert.True(t, id != \"\", id)\n \n-\tres, err := b.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, id)\n+\tres, err := b.Interface.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, id)\n \tassert.NoError(t, err)\n \tt.Logf(\"%+v\", res)\n \tassert.Equal(t, \"text\", res.Text)\n@@ -94,15 +94,15 @@ func TestService_CreateFromPartialWithTitle(t *testing.T) {\n \tassert.NoError(t, err)\n \tassert.True(t, id != \"\", id)\n \n-\tres, err := b.Get(store.Locator{URL: \"https://radio-t.com/p/2018/12/29/podcast-630/\", SiteID: \"radio-t\"}, id)\n+\tres, err := b.Interface.Get(store.Locator{URL: \"https://radio-t.com/p/2018/12/29/podcast-630/\", SiteID: \"radio-t\"}, id)\n \tassert.NoError(t, err)\n \tt.Logf(\"%+v\", res)\n \tassert.Equal(t, \"Радио-Т 630 — Радио-Т Подкаст\", res.PostTitle)\n \n \tcomment.PostTitle = \"post blah\"\n \tid, err = b.Create(comment)\n \tassert.NoError(t, err)\n-\tres, err = b.Get(store.Locator{URL: \"https://radio-t.com/p/2018/12/29/podcast-630/\", SiteID: \"radio-t\"}, id)\n+\tres, err = b.Interface.Get(store.Locator{URL: \"https://radio-t.com/p/2018/12/29/podcast-630/\", SiteID: \"radio-t\"}, id)\n \tassert.NoError(t, err)\n \tt.Logf(\"%+v\", res)\n \tassert.Equal(t, \"post blah\", res.PostTitle, \"keep comment title\")\n@@ -145,7 +145,7 @@ func TestService_SetTitle(t *testing.T) {\n \tassert.NoError(t, err)\n \tassert.True(t, id != \"\", id)\n \n-\tres, err := b.Get(store.Locator{URL: tss.URL + \"/post1\", SiteID: \"radio-t\"}, id)\n+\tres, err := b.Interface.Get(store.Locator{URL: tss.URL + \"/post1\", SiteID: \"radio-t\"}, id)\n \tassert.NoError(t, err)\n \tt.Logf(\"%+v\", res)\n \tassert.Equal(t, \"\", res.PostTitle)\n@@ -174,7 +174,7 @@ func TestService_Vote(t *testing.T) {\n \t_, err := b.Create(comment)\n \tassert.NoError(t, err)\n \n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tt.Logf(\"%+v\", res[0])\n \tassert.Nil(t, err)\n \tassert.Equal(t, 3, len(res))\n@@ -195,7 +195,7 @@ func TestService_Vote(t *testing.T) {\n \tassert.NotNil(t, err, \"double-voting rejected\")\n \tassert.True(t, strings.HasPrefix(err.Error(), \"user user1 already voted\"))\n \n-\tres, err = b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err = b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 3, len(res))\n \tassert.Equal(t, 1, res[0].Score)\n@@ -204,7 +204,7 @@ func TestService_Vote(t *testing.T) {\n \n \t_, err = b.Vote(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID, \"user1\", false)\n \tassert.Nil(t, err, \"vote reset\")\n-\tres, err = b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err = b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tassert.Nil(t, err)\n \tassert.Equal(t, 3, len(res))\n \tassert.Equal(t, 0, res[0].Score)\n@@ -250,7 +250,7 @@ func TestService_VoteAggressive(t *testing.T) {\n \t_, err := b.Create(comment)\n \tassert.NoError(t, err)\n \n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \trequire.Nil(t, err)\n \tt.Logf(\"%+v\", res[0])\n \tassert.Equal(t, 3, len(res))\n@@ -271,7 +271,7 @@ func TestService_VoteAggressive(t *testing.T) {\n \t\t}()\n \t}\n \twg.Wait()\n-\tres, err = b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err = b.Interface.Last(\"radio-t\", 0, time.Time{})\n \trequire.NoError(t, err)\n \n \tt.Logf(\"%+v\", res[0])\n@@ -290,7 +290,7 @@ func TestService_VoteAggressive(t *testing.T) {\n \t\t}()\n \t}\n \twg.Wait()\n-\tres, err = b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err = b.Interface.Last(\"radio-t\", 0, time.Time{})\n \trequire.NoError(t, err)\n \tassert.Equal(t, 3, len(res))\n \tt.Logf(\"%+v %d\", res[0], res[0].Score)\n@@ -309,7 +309,7 @@ func TestService_VoteConcurrent(t *testing.T) {\n \t}\n \t_, err := b.Create(comment)\n \tassert.NoError(t, err)\n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \trequire.Nil(t, err)\n \n \t// concurrent vote +1 as multiple users for the same comment\n@@ -324,7 +324,7 @@ func TestService_VoteConcurrent(t *testing.T) {\n \t\t}()\n \t}\n \twg.Wait()\n-\tres, err = b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err = b.Interface.Last(\"radio-t\", 0, time.Time{})\n \trequire.NoError(t, err)\n \tassert.Equal(t, 100, res[0].Score, \"should have 100 score\")\n \tassert.Equal(t, 100, len(res[0].Votes), \"should have 100 votes\")\n@@ -370,7 +370,7 @@ func TestService_VoteControversy(t *testing.T) {\n \tassert.InDelta(t, 1.73, c.Controversy, 0.01)\n \n \t// check if stored\n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \trequire.NoError(t, err)\n \tassert.Equal(t, 1, res[0].Score, \"should have 1 score\")\n \tassert.InDelta(t, 1.73, res[0].Controversy, 0.01)\n@@ -404,7 +404,7 @@ func TestService_Pin(t *testing.T) {\n \tdefer teardown(t)\n \tb := DataStore{Interface: prepStoreEngine(t), AdminStore: admin.NewStaticKeyStore(\"secret 123\")}\n \n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tt.Logf(\"%+v\", res[0])\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, len(res))\n@@ -413,13 +413,13 @@ func TestService_Pin(t *testing.T) {\n \terr = b.SetPin(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID, true)\n \tassert.Nil(t, err)\n \n-\tc, err := b.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n+\tc, err := b.Interface.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n \tassert.Nil(t, err)\n \tassert.Equal(t, true, c.Pin)\n \n \terr = b.SetPin(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID, false)\n \tassert.Nil(t, err)\n-\tc, err = b.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n+\tc, err = b.Interface.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n \tassert.Nil(t, err)\n \tassert.Equal(t, false, c.Pin)\n }\n@@ -428,7 +428,7 @@ func TestService_EditComment(t *testing.T) {\n \tdefer teardown(t)\n \tb := DataStore{Interface: prepStoreEngine(t), AdminStore: admin.NewStaticKeyStore(\"secret 123\")}\n \n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tt.Logf(\"%+v\", res[0])\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, len(res))\n@@ -441,7 +441,7 @@ func TestService_EditComment(t *testing.T) {\n \tassert.Equal(t, \"xxx\", comment.Text)\n \tassert.Equal(t, \"yyy\", comment.Orig)\n \n-\tc, err := b.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n+\tc, err := b.Interface.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n \tassert.Nil(t, err)\n \tassert.Equal(t, \"my edit\", c.Edit.Summary)\n \tassert.Equal(t, \"xxx\", c.Text)\n@@ -455,7 +455,7 @@ func TestService_DeleteComment(t *testing.T) {\n \tdefer teardown(t)\n \tb := DataStore{Interface: prepStoreEngine(t), AdminStore: admin.NewStaticKeyStore(\"secret 123\")}\n \n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tt.Logf(\"%+v\", res[0])\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, len(res))\n@@ -464,7 +464,7 @@ func TestService_DeleteComment(t *testing.T) {\n \t_, err = b.EditComment(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID, EditRequest{Delete: true})\n \tassert.Nil(t, err)\n \n-\tc, err := b.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n+\tc, err := b.Interface.Get(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID)\n \tassert.Nil(t, err)\n \tassert.True(t, c.Deleted)\n \tt.Logf(\"%+v\", c)\n@@ -474,7 +474,7 @@ func TestService_EditCommentDurationFailed(t *testing.T) {\n \tdefer teardown(t)\n \tb := DataStore{Interface: prepStoreEngine(t), EditDuration: 100 * time.Millisecond, AdminStore: admin.NewStaticKeyStore(\"secret 123\")}\n \n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tt.Logf(\"%+v\", res[0])\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, len(res))\n@@ -491,7 +491,7 @@ func TestService_EditCommentReplyFailed(t *testing.T) {\n \tdefer teardown(t)\n \tb := DataStore{Interface: prepStoreEngine(t), AdminStore: admin.NewStaticKeyStore(\"secret 123\")}\n \n-\tres, err := b.Last(\"radio-t\", 0, time.Time{})\n+\tres, err := b.Interface.Last(\"radio-t\", 0, time.Time{})\n \tt.Logf(\"%+v\", res[1])\n \tassert.Nil(t, err)\n \tassert.Equal(t, 2, len(res))\n@@ -534,6 +534,7 @@ func TestService_ValidateComment(t *testing.T) {\n \t\t\tassert.Nil(t, e, \"check #%d\", n)\n \t\t\tcontinue\n \t\t}\n+\t\trequire.NotNil(t, e)\n \t\tassert.EqualError(t, tt.err, e.Error(), \"check #%d\", n)\n \t}\n }\n@@ -669,7 +670,7 @@ func TestService_Find(t *testing.T) {\n \tb := DataStore{Interface: prepStoreEngine(t), EditDuration: 100 * time.Millisecond,\n \t\tAdminStore: admin.NewStaticStore(\"secret 123\", []string{\"user2\"}, \"user@email.com\")}\n \n-\tres, err := b.Find(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, \"time\")\n+\tres, err := b.Find(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, \"time\", store.User{})\n \trequire.NoError(t, err)\n \tassert.Equal(t, 2, len(res))\n \n@@ -687,7 +688,7 @@ func TestService_Find(t *testing.T) {\n \tassert.Nil(t, err)\n \n \t// make sure Controversy altered\n-\tres, err = b.Find(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, \"-controversy\")\n+\tres, err = b.Find(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, \"-controversy\", store.User{})\n \trequire.NoError(t, err)\n \tassert.Equal(t, 3, len(res))\n \tassert.Equal(t, \"123456\", res[0].ID)\n@@ -722,6 +723,37 @@ func TestService_submitImages(t *testing.T) {\n \ttime.Sleep(250 * time.Millisecond)\n }\n \n+func TestService_alterComment(t *testing.T) {\n+\tdefer teardown(t)\n+\n+\tengineMock := engine.MockInterface{}\n+\tengineMock.On(\"IsBlocked\", mock.Anything, mock.Anything).Return(false)\n+\tengineMock.On(\"IsVerified\", mock.Anything, mock.Anything).Return(false)\n+\tsvc := DataStore{Interface: &engineMock}\n+\n+\tr := svc.alterComment(store.Comment{ID: \"123\", User: store.User{IP: \"127.0.0.1\"}}, store.User{Name: \"dev\", Admin: false})\n+\tassert.Equal(t, store.Comment{ID: \"123\", User: store.User{IP: \"\"}}, r, \"ip cleaned\")\n+\tr = svc.alterComment(store.Comment{ID: \"123\", User: store.User{IP: \"127.0.0.1\"}}, store.User{Name: \"dev\", Admin: true})\n+\tassert.Equal(t, store.Comment{ID: \"123\", User: store.User{IP: \"127.0.0.1\"}}, r, \"ip not cleaned\")\n+\n+\tengineMock = engine.MockInterface{}\n+\tengineMock.On(\"IsBlocked\", mock.Anything, mock.Anything).Return(false)\n+\tengineMock.On(\"IsVerified\", mock.Anything, mock.Anything).Return(true)\n+\tsvc = DataStore{Interface: &engineMock}\n+\tr = svc.alterComment(store.Comment{ID: \"123\", User: store.User{IP: \"127.0.0.1\", Verified: true}},\n+\t\tstore.User{Name: \"dev\", Admin: false})\n+\tassert.Equal(t, store.Comment{ID: \"123\", User: store.User{IP: \"\", Verified: true}}, r, \"verified set\")\n+\n+\tengineMock = engine.MockInterface{}\n+\tengineMock.On(\"IsBlocked\", mock.Anything, mock.Anything).Return(true)\n+\tengineMock.On(\"IsVerified\", mock.Anything, mock.Anything).Return(false)\n+\tsvc = DataStore{Interface: &engineMock}\n+\tr = svc.alterComment(store.Comment{ID: \"123\", User: store.User{IP: \"127.0.0.1\", Verified: true}},\n+\t\tstore.User{Name: \"dev\", Admin: false})\n+\tassert.Equal(t, store.Comment{ID: \"123\", User: store.User{IP: \"\", Verified: true, Blocked: true}, Deleted: true}, r,\n+\t\t\"blocked\")\n+}\n+\n // makes new boltdb, put two records\n func prepStoreEngine(t *testing.T) engine.Interface {\n \t_ = os.Remove(testDb)"
    },
    {
      "sha": "5d3d8cbc5e20c6461252da77898f08f9ec46de2d",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.mod?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -24,8 +24,7 @@ require (\n \tgithub.com/golang/protobuf v1.3.1 // indirect\n \tgithub.com/google/uuid v0.0.0-20161128191214-064e2069ce9c\n \tgithub.com/gorilla/feeds v1.1.0\n-\tgithub.com/hashicorp/errwrap v1.0.0 // indirect\n-\tgithub.com/hashicorp/go-multierror v0.0.0-20171204182908-b7773ae21874\n+\tgithub.com/hashicorp/go-multierror v1.0.0\n \tgithub.com/hashicorp/golang-lru v0.5.1 // indirect\n \tgithub.com/jessevdk/go-flags v0.0.0-20180331124232-1c38ed7ad0cc\n \tgithub.com/microcosm-cc/bluemonday v0.0.0-20171222152607-542fd4642604"
    },
    {
      "sha": "20045e075217811f00332e5c4adc7e178ae18737",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.sum?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -71,6 +71,8 @@ github.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/U\n github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\n github.com/hashicorp/go-multierror v0.0.0-20171204182908-b7773ae21874 h1:em+tTnzgU7N22woTBMcSJAOW7tRHAkK597W+MD/CpK8=\n github.com/hashicorp/go-multierror v0.0.0-20171204182908-b7773ae21874/go.mod h1:JMRHfdO9jKNzS/+BTlxCjKNQHg/jZAft8U7LloJvN7I=\n+github.com/hashicorp/go-multierror v1.0.0 h1:iVjPR7a6H0tWELX5NxNe7bYopibicUzc7uPribsnS6o=\n+github.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=\n github.com/hashicorp/golang-lru v0.5.0 h1:CL2msUPvZTLb5O648aiLNJw3hnBxN2+1Jq8rCOH9wdo=\n github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n github.com/hashicorp/golang-lru v0.5.1 h1:0hERBMJE1eitiLkihrMvRVBYAkpHzc/J3QdDN+dAcgU=\n@@ -107,6 +109,7 @@ github.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=\n github.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=\n github.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\n github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\n+github.com/umputun/remark v1.3.2 h1:m0PvvY7GEWSIjfQeqddvglJVswxUoSBPi4RrsI3sJz8=\n go.etcd.io/bbolt v1.3.2 h1:Z/90sZLPOeCy2PwprqkFa25PdkusRzaj9P8zm/KNyvk=\n go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\n go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU="
    },
    {
      "sha": "21efc324cb26a6a1d9f2bdec03a4b94b44107134",
      "filename": "backend/vendor/github.com/go-pkgz/mongo/go.sum",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/vendor/github.com/go-pkgz/mongo/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/vendor/github.com/go-pkgz/mongo/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/mongo/go.sum?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -1,5 +1,6 @@\n github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\n github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\n github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n github.com/globalsign/mgo v0.0.0-20180615134936-113d3961e731 h1:y7wyeiA6T+TT+HGC9DYypvLkUeg99N4rqHMzn2MmjYk=\n github.com/globalsign/mgo v0.0.0-20180615134936-113d3961e731/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q="
    },
    {
      "sha": "8ad8826b368df47e99ef561a0e6c69aa7ec88392",
      "filename": "backend/vendor/github.com/hashicorp/golang-lru/go.mod",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/vendor/github.com/hashicorp/golang-lru/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/7b8bc80468703afa421c6330712d5aa964c82c8d/backend/vendor/github.com/hashicorp/golang-lru/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/hashicorp/golang-lru/go.mod?ref=7b8bc80468703afa421c6330712d5aa964c82c8d",
      "patch": "@@ -1 +1,3 @@\n module github.com/hashicorp/golang-lru\n+\n+go 1.12"
    }
  ]
}
