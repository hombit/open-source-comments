{
  "sha": "1221d342849f54dd20f58391a4b1d542398d9116",
  "node_id": "MDY6Q29tbWl0NzU2OTU3ODoxMjIxZDM0Mjg0OWY1NGRkMjBmNTgzOTFhNGIxZDU0MjM5OGQ5MTE2",
  "commit": {
    "author": {
      "name": "Rafael dos Santos Silva",
      "email": "xfalcox@gmail.com",
      "date": "2019-07-15T16:05:55Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2019-07-15T16:05:55Z"
    },
    "message": "FEATURE: Make Discourse work offline with WorkboxJS (#7870)",
    "tree": {
      "sha": "4078e3d513e1d78b588f93ae148ed253be7e80df",
      "url": "https://api.github.com/repos/discourse/discourse/git/trees/4078e3d513e1d78b588f93ae148ed253be7e80df"
    },
    "url": "https://api.github.com/repos/discourse/discourse/git/commits/1221d342849f54dd20f58391a4b1d542398d9116",
    "comment_count": 1,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdLKRkCRBK7hj4Ov3rIwAAdHIIAHG95ArVe6Z1XV/QV9/Ykc9r\niFDnpUCX4Wm/7E77AJtCDWXjh6o/E4xBEvvVnz9+peWhnf3ovzTENgA2D6sl8IKK\nuFclvRqY+D5UiDX5SAoydb9VPSv4YQW3D12TewUt5iHnQb3dgLWR99HzXeC6H9Ty\nEVMfZWlO7JFbJiJwlFsuvGtHXqIO7G+lECrPlN3lV3ijx39PjVA+wQrXWaQbSoWN\nVNJ66hh9yyt7b0bCqrZdYCItXkyPI26cGQi27F9ScP+o8gWH5lhAsScJAWGk1Nqk\nki2xk+9m1qVu64iqYnQcmrQzur9lqgeNIAoK1WrXXkZM0QInCgPdcZsFmdjU7HU=\n=/NJ+\n-----END PGP SIGNATURE-----\n",
      "payload": "tree 4078e3d513e1d78b588f93ae148ed253be7e80df\nparent 839916aa4901ab62fb84bcaf7d91c4354091f506\nauthor Rafael dos Santos Silva <xfalcox@gmail.com> 1563206755 -0300\ncommitter GitHub <noreply@github.com> 1563206755 -0300\n\nFEATURE: Make Discourse work offline with WorkboxJS (#7870)\n\n"
    }
  },
  "url": "https://api.github.com/repos/discourse/discourse/commits/1221d342849f54dd20f58391a4b1d542398d9116",
  "html_url": "https://github.com/discourse/discourse/commit/1221d342849f54dd20f58391a4b1d542398d9116",
  "comments_url": "https://api.github.com/repos/discourse/discourse/commits/1221d342849f54dd20f58391a4b1d542398d9116/comments",
  "author": {
    "login": "xfalcox",
    "id": 1385470,
    "node_id": "MDQ6VXNlcjEzODU0NzA=",
    "avatar_url": "https://avatars3.githubusercontent.com/u/1385470?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/xfalcox",
    "html_url": "https://github.com/xfalcox",
    "followers_url": "https://api.github.com/users/xfalcox/followers",
    "following_url": "https://api.github.com/users/xfalcox/following{/other_user}",
    "gists_url": "https://api.github.com/users/xfalcox/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/xfalcox/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/xfalcox/subscriptions",
    "organizations_url": "https://api.github.com/users/xfalcox/orgs",
    "repos_url": "https://api.github.com/users/xfalcox/repos",
    "events_url": "https://api.github.com/users/xfalcox/events{/privacy}",
    "received_events_url": "https://api.github.com/users/xfalcox/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "839916aa4901ab62fb84bcaf7d91c4354091f506",
      "url": "https://api.github.com/repos/discourse/discourse/commits/839916aa4901ab62fb84bcaf7d91c4354091f506",
      "html_url": "https://github.com/discourse/discourse/commit/839916aa4901ab62fb84bcaf7d91c4354091f506"
    }
  ],
  "stats": {
    "total": 4733,
    "additions": 4618,
    "deletions": 115
  },
  "files": [
    {
      "sha": "92ae9886256c68069a23e9be9e79d7d372205e68",
      "filename": "app/assets/javascripts/discourse/initializers/register-service-worker.js.es6",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/app/assets/javascripts/discourse/initializers/register-service-worker.js.es6",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/app/assets/javascripts/discourse/initializers/register-service-worker.js.es6",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/app/assets/javascripts/discourse/initializers/register-service-worker.js.es6?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -9,9 +9,7 @@ export default {\n     const isSupported = isSecured && \"serviceWorker\" in navigator;\n \n     if (isSupported) {\n-      const isApple = !!navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i);\n-\n-      if (Discourse.ServiceWorkerURL && !isApple) {\n+      if (Discourse.ServiceWorkerURL) {\n         navigator.serviceWorker.getRegistrations().then(registrations => {\n           for (let registration of registrations) {\n             if ("
    },
    {
      "sha": "e4ca8df52edcc8799337c63e4f6bc59afbcc67f6",
      "filename": "app/assets/javascripts/discourse/lib/ajax.js.es6",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/app/assets/javascripts/discourse/lib/ajax.js.es6",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/app/assets/javascripts/discourse/lib/ajax.js.es6",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/app/assets/javascripts/discourse/lib/ajax.js.es6?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -140,7 +140,7 @@ export function ajax() {\n     }\n \n     if (args.type === \"GET\" && args.cache !== true) {\n-      args.cache = false;\n+      args.cache = true; // Disable JQuery cache busting param, which was created to deal with IE8\n     }\n \n     ajaxObj = $.ajax(Discourse.getURL(url), args);"
    },
    {
      "sha": "56d5eb7bc1f2f080bce82e9968847153c3eeea0d",
      "filename": "app/assets/javascripts/service-worker.js.erb",
      "status": "modified",
      "additions": 18,
      "deletions": 110,
      "changes": 128,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/app/assets/javascripts/service-worker.js.erb",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/app/assets/javascripts/service-worker.js.erb",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/app/assets/javascripts/service-worker.js.erb?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -1,117 +1,25 @@\n 'use strict';\n \n+importScripts(\"<%= ::UrlHelper.absolute(\"/javascripts/workbox/workbox-sw.js\") %>\");\n \n-// Special offline and fetch interception is restricted to Android only\n-// we have had a large amount of pain supporting this on Firefox / Safari\n-// it is only strongly required on Android, when PWA gets better on iOS\n-// we can unlock it there as well, for Desktop we can consider unlocking it\n-// if we start supporting offline browsing for laptops\n-if (/(android)/i.test(navigator.userAgent)) {\n-\n-  // Incrementing CACHE_VERSION will kick off the install event and force previously cached\n-  // resources to be cached again.\n-  const CACHE_VERSION = 1;\n-\n-  const CURRENT_CACHES = {\n-    offline: 'offline-v' + CACHE_VERSION\n-  };\n-\n-  const OFFLINE_URL = 'offline.html';\n-\n-  const createCacheBustedRequest = function(url) {\n-    var headers = new Headers({\n-      'Discourse-Track-View': '0'\n-    });\n-\n-    var request = new Request(url, {cache: 'reload', headers: headers});\n-    // See https://fetch.spec.whatwg.org/#concept-request-mode\n-    // This is not yet supported in Chrome as of M48, so we need to explicitly check to see\n-    // if the cache: 'reload' option had any effect.\n-    if ('cache' in request) {\n-      return request;\n-    }\n-\n-    // If {cache: 'reload'} didn't have any effect, append a cache-busting URL parameter instead.\n-    var bustedUrl = new URL(url, self.location.href);\n-    bustedUrl.search += (bustedUrl.search ? '&' : '') + 'cachebust=' + Date.now();\n-    return new Request(bustedUrl, {headers: headers});\n-  }\n-\n-  self.addEventListener('install', function(event) {\n-    event.waitUntil(\n-      // We can't use cache.add() here, since we want OFFLINE_URL to be the cache key, but\n-      // the actual URL we end up requesting might include a cache-busting parameter.\n-      fetch(createCacheBustedRequest(OFFLINE_URL)).then(function(response) {\n-        return caches.open(CURRENT_CACHES.offline).then(function(cache) {\n-          return cache.put(OFFLINE_URL, response);\n-        });\n-      }).then(function(cache) {\n-        self.skipWaiting();\n-      })\n-    );\n-  });\n-\n-  self.addEventListener('activate', function(event) {\n-    // Delete all caches that aren't named in CURRENT_CACHES.\n-    // While there is only one cache in this example, the same logic will handle the case where\n-    // there are multiple versioned caches.\n-    var expectedCacheNames = Object.keys(CURRENT_CACHES).map(function(key) {\n-      return CURRENT_CACHES[key];\n-    });\n-\n-    event.waitUntil(\n-      caches.keys().then(function(cacheNames) {\n-        return Promise.all(\n-          cacheNames.map(function(cacheName) {\n-            if (expectedCacheNames.indexOf(cacheName) === -1) {\n-              // If this cache name isn't present in the array of \"expected\" cache names,\n-              // then delete it.\n-              return caches.delete(cacheName);\n-            }\n-          })\n-        );\n-      }).then(function() {\n-        self.clients.claim()\n-      })\n-    );\n-  });\n-\n-  self.addEventListener('fetch', function(event) {\n-    // Bypass service workers if this is a url with a token param\n-    if(/\\?.*token/i.test(event.request.url)) {\n-      return;\n-    }\n-    // We only want to call event.respondWith() if this is a navigation request\n-    // for an HTML page.\n-    // request.mode of 'navigate' is unfortunately not supported in Chrome\n-    // versions older than 49, so we need to include a less precise fallback,\n-    // which checks for a GET request with an Accept: text/html header.\n-    if (event.request.mode === 'navigate' ||\n-        (event.request.method === 'GET' &&\n-         event.request.headers.get('accept').includes('text/html'))) {\n-      event.respondWith(\n-        fetch(event.request).catch(function(error) {\n-          // The catch is only triggered if fetch() throws an exception, which will most likely\n-          // happen due to the server being unreachable.\n-          // If fetch() returns a valid HTTP response with an response code in the 4xx or 5xx\n-          // range, the catch() will NOT be called. If you need custom handling for 4xx or 5xx\n-          // errors, see https://github.com/GoogleChrome/samples/tree/gh-pages/service-worker/fallback-response\n-          if (!navigator.onLine) {\n-            return caches.match(OFFLINE_URL);\n-          } else {\n-            throw new Error(error);\n-          }\n-        })\n-      );\n-    }\n-\n-    // If our if() condition is false, then this fetch handler won't intercept the request.\n-    // If there are any other fetch handlers registered, they will get a chance to call\n-    // event.respondWith(). If no fetch handlers call event.respondWith(), the request will be\n-    // handled by the browser as if there were no service worker involvement.\n-  });\n+workbox.setConfig({\n+  modulePathPrefix: \"<%= ::UrlHelper.absolute(\"/javascripts/workbox\") %>\"\n+});\n \n-}\n+const cacheVersion = \"1\";\n+\n+// Cache all GET requests, so Discourse can be used while offline\n+workbox.routing.registerRoute(\n+  new RegExp('.*?'), // Matches all, GET is implicit\n+  new workbox.strategies.NetworkFirst({ // This will only use the cache when a network request fails\n+    cacheName: \"discourse-\" + cacheVersion,\n+    plugins: [\n+      new workbox.expiration.Plugin({\n+        maxAgeSeconds: 7* 24 * 60 * 60, // 7 days\n+      }),\n+    ],\n+  })\n+);\n \n const idleThresholdTime = 1000 * 10; // 10 seconds\n var lastAction = -1;"
    },
    {
      "sha": "f66c6afa3975fa7dcf689812fe77ca6a696f8e3e",
      "filename": "lib/tasks/javascript.rake",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/lib/tasks/javascript.rake",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/lib/tasks/javascript.rake",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/lib/tasks/javascript.rake?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -90,6 +90,26 @@ task 'javascript:update' do\n     }, {\n       # TODO: drop when we eventually drop IE11, this will land in iOS in version 13\n       source: 'intersection-observer/intersection-observer.js'\n+    }, {\n+      source: 'workbox-sw/build/.',\n+      destination: 'workbox',\n+      public: true\n+    }, {\n+      source: 'workbox-routing/build/.',\n+      destination: 'workbox',\n+      public: true\n+    }, {\n+      source: 'workbox-core/build/.',\n+      destination: 'workbox',\n+      public: true\n+    }, {\n+      source: 'workbox-strategies/build/.',\n+      destination: 'workbox',\n+      public: true\n+    }, {\n+      source: 'workbox-expiration/build/.',\n+      destination: 'workbox',\n+      public: true\n     }\n   ]\n "
    },
    {
      "sha": "c4bce5ac06f74506197aaccfb3df1fe99ba2db8c",
      "filename": "package.json",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/package.json",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/package.json",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/package.json?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -30,7 +30,12 @@\n     \"mousetrap\": \"https://github.com/discourse/mousetrap#firefox-alt-key\",\n     \"pikaday\": \"1.8.0\",\n     \"resumablejs\": \"1.1.0\",\n-    \"spectrum-colorpicker\": \"1.8.0\"\n+    \"spectrum-colorpicker\": \"1.8.0\",\n+    \"workbox-core\": \"^4.3.1\",\n+    \"workbox-expiration\": \"^4.3.1\",\n+    \"workbox-routing\": \"^4.3.1\",\n+    \"workbox-strategies\": \"^4.3.1\",\n+    \"workbox-sw\": \"^4.3.1\"\n   },\n   \"devDependencies\": {\n     \"@arkweid/lefthook\": \"^0.5.6\","
    },
    {
      "sha": "18b8b85f19e12fdb3720ea7bf18888153be5178d",
      "filename": "public/javascripts/workbox/workbox-core.dev.js",
      "status": "added",
      "additions": 1712,
      "deletions": 0,
      "changes": 1712,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.dev.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.dev.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-core.dev.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,1712 @@\n+this.workbox = this.workbox || {};\n+this.workbox.core = (function (exports) {\n+  'use strict';\n+\n+  try {\n+    self['workbox:core:4.3.1'] && _();\n+  } catch (e) {} // eslint-disable-line\n+\n+  /*\n+    Copyright 2019 Google LLC\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const logger = (() => {\n+    let inGroup = false;\n+    const methodToColorMap = {\n+      debug: `#7f8c8d`,\n+      // Gray\n+      log: `#2ecc71`,\n+      // Green\n+      warn: `#f39c12`,\n+      // Yellow\n+      error: `#c0392b`,\n+      // Red\n+      groupCollapsed: `#3498db`,\n+      // Blue\n+      groupEnd: null // No colored prefix on groupEnd\n+\n+    };\n+\n+    const print = function (method, args) {\n+      if (method === 'groupCollapsed') {\n+        // Safari doesn't print all console.groupCollapsed() arguments:\n+        // https://bugs.webkit.org/show_bug.cgi?id=182754\n+        if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n+          console[method](...args);\n+          return;\n+        }\n+      }\n+\n+      const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`]; // When in a group, the workbox prefix is not displayed.\n+\n+      const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n+      console[method](...logPrefix, ...args);\n+\n+      if (method === 'groupCollapsed') {\n+        inGroup = true;\n+      }\n+\n+      if (method === 'groupEnd') {\n+        inGroup = false;\n+      }\n+    };\n+\n+    const api = {};\n+\n+    for (const method of Object.keys(methodToColorMap)) {\n+      api[method] = (...args) => {\n+        print(method, args);\n+      };\n+    }\n+\n+    return api;\n+  })();\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const messages = {\n+    'invalid-value': ({\n+      paramName,\n+      validValueDescription,\n+      value\n+    }) => {\n+      if (!paramName || !validValueDescription) {\n+        throw new Error(`Unexpected input to 'invalid-value' error.`);\n+      }\n+\n+      return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n+    },\n+    'not-in-sw': ({\n+      moduleName\n+    }) => {\n+      if (!moduleName) {\n+        throw new Error(`Unexpected input to 'not-in-sw' error.`);\n+      }\n+\n+      return `The '${moduleName}' must be used in a service worker.`;\n+    },\n+    'not-an-array': ({\n+      moduleName,\n+      className,\n+      funcName,\n+      paramName\n+    }) => {\n+      if (!moduleName || !className || !funcName || !paramName) {\n+        throw new Error(`Unexpected input to 'not-an-array' error.`);\n+      }\n+\n+      return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n+    },\n+    'incorrect-type': ({\n+      expectedType,\n+      paramName,\n+      moduleName,\n+      className,\n+      funcName\n+    }) => {\n+      if (!expectedType || !paramName || !moduleName || !funcName) {\n+        throw new Error(`Unexpected input to 'incorrect-type' error.`);\n+      }\n+\n+      return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className ? className + '.' : ''}` + `${funcName}()' must be of type ${expectedType}.`;\n+    },\n+    'incorrect-class': ({\n+      expectedClass,\n+      paramName,\n+      moduleName,\n+      className,\n+      funcName,\n+      isReturnValueProblem\n+    }) => {\n+      if (!expectedClass || !moduleName || !funcName) {\n+        throw new Error(`Unexpected input to 'incorrect-class' error.`);\n+      }\n+\n+      if (isReturnValueProblem) {\n+        return `The return value from ` + `'${moduleName}.${className ? className + '.' : ''}${funcName}()' ` + `must be an instance of class ${expectedClass.name}.`;\n+      }\n+\n+      return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className ? className + '.' : ''}${funcName}()' ` + `must be an instance of class ${expectedClass.name}.`;\n+    },\n+    'missing-a-method': ({\n+      expectedMethod,\n+      paramName,\n+      moduleName,\n+      className,\n+      funcName\n+    }) => {\n+      if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n+        throw new Error(`Unexpected input to 'missing-a-method' error.`);\n+      }\n+\n+      return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n+    },\n+    'add-to-cache-list-unexpected-type': ({\n+      entry\n+    }) => {\n+      return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n+    },\n+    'add-to-cache-list-conflicting-entries': ({\n+      firstEntry,\n+      secondEntry\n+    }) => {\n+      if (!firstEntry || !secondEntry) {\n+        throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n+      }\n+\n+      return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry._entryId} but different revision details. Workbox is ` + `is unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;\n+    },\n+    'plugin-error-request-will-fetch': ({\n+      thrownError\n+    }) => {\n+      if (!thrownError) {\n+        throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n+      }\n+\n+      return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownError.message}'.`;\n+    },\n+    'invalid-cache-name': ({\n+      cacheNameId,\n+      value\n+    }) => {\n+      if (!cacheNameId) {\n+        throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n+      }\n+\n+      return `You must provide a name containing at least one character for ` + `setCacheDeatils({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n+    },\n+    'unregister-route-but-not-found-with-method': ({\n+      method\n+    }) => {\n+      if (!method) {\n+        throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n+      }\n+\n+      return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n+    },\n+    'unregister-route-route-not-registered': () => {\n+      return `The route you're trying to unregister was not previously ` + `registered.`;\n+    },\n+    'queue-replay-failed': ({\n+      name\n+    }) => {\n+      return `Replaying the background sync queue '${name}' failed.`;\n+    },\n+    'duplicate-queue-name': ({\n+      name\n+    }) => {\n+      return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n+    },\n+    'expired-test-without-max-age': ({\n+      methodName,\n+      paramName\n+    }) => {\n+      return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n+    },\n+    'unsupported-route-type': ({\n+      moduleName,\n+      className,\n+      funcName,\n+      paramName\n+    }) => {\n+      return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n+    },\n+    'not-array-of-class': ({\n+      value,\n+      expectedClass,\n+      moduleName,\n+      className,\n+      funcName,\n+      paramName\n+    }) => {\n+      return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n+    },\n+    'max-entries-or-age-required': ({\n+      moduleName,\n+      className,\n+      funcName\n+    }) => {\n+      return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n+    },\n+    'statuses-or-headers-required': ({\n+      moduleName,\n+      className,\n+      funcName\n+    }) => {\n+      return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n+    },\n+    'invalid-string': ({\n+      moduleName,\n+      className,\n+      funcName,\n+      paramName\n+    }) => {\n+      if (!paramName || !moduleName || !funcName) {\n+        throw new Error(`Unexpected input to 'invalid-string' error.`);\n+      }\n+\n+      return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;\n+    },\n+    'channel-name-required': () => {\n+      return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n+    },\n+    'invalid-responses-are-same-args': () => {\n+      return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n+    },\n+    'expire-custom-caches-only': () => {\n+      return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n+    },\n+    'unit-must-be-bytes': ({\n+      normalizedRangeHeader\n+    }) => {\n+      if (!normalizedRangeHeader) {\n+        throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n+      }\n+\n+      return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n+    },\n+    'single-range-only': ({\n+      normalizedRangeHeader\n+    }) => {\n+      if (!normalizedRangeHeader) {\n+        throw new Error(`Unexpected input to 'single-range-only' error.`);\n+      }\n+\n+      return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n+    },\n+    'invalid-range-values': ({\n+      normalizedRangeHeader\n+    }) => {\n+      if (!normalizedRangeHeader) {\n+        throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n+      }\n+\n+      return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n+    },\n+    'no-range-header': () => {\n+      return `No Range header was found in the Request provided.`;\n+    },\n+    'range-not-satisfiable': ({\n+      size,\n+      start,\n+      end\n+    }) => {\n+      return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n+    },\n+    'attempt-to-cache-non-get-request': ({\n+      url,\n+      method\n+    }) => {\n+      return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n+    },\n+    'cache-put-with-no-response': ({\n+      url\n+    }) => {\n+      return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n+    },\n+    'no-response': ({\n+      url,\n+      error\n+    }) => {\n+      let message = `The strategy could not generate a response for '${url}'.`;\n+\n+      if (error) {\n+        message += ` The underlying error is ${error}.`;\n+      }\n+\n+      return message;\n+    },\n+    'bad-precaching-response': ({\n+      url,\n+      status\n+    }) => {\n+      return `The precaching request for '${url}' failed with an HTTP ` + `status of ${status}.`;\n+    }\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  const generatorFunction = (code, ...args) => {\n+    const message = messages[code];\n+\n+    if (!message) {\n+      throw new Error(`Unable to find message for code '${code}'.`);\n+    }\n+\n+    return message(...args);\n+  };\n+\n+  const messageGenerator = generatorFunction;\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Workbox errors should be thrown with this class.\n+   * This allows use to ensure the type easily in tests,\n+   * helps developers identify errors from workbox\n+   * easily and allows use to optimise error\n+   * messages correctly.\n+   *\n+   * @private\n+   */\n+\n+  class WorkboxError extends Error {\n+    /**\n+     *\n+     * @param {string} errorCode The error code that\n+     * identifies this particular error.\n+     * @param {Object=} details Any relevant arguments\n+     * that will help developers identify issues should\n+     * be added as a key on the context object.\n+     */\n+    constructor(errorCode, details) {\n+      let message = messageGenerator(errorCode, details);\n+      super(message);\n+      this.name = errorCode;\n+      this.details = details;\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /*\n+   * This method returns true if the current context is a service worker.\n+   */\n+\n+  const isSWEnv = moduleName => {\n+    if (!('ServiceWorkerGlobalScope' in self)) {\n+      throw new WorkboxError('not-in-sw', {\n+        moduleName\n+      });\n+    }\n+  };\n+  /*\n+   * This method throws if the supplied value is not an array.\n+   * The destructed values are required to produce a meaningful error for users.\n+   * The destructed and restructured object is so it's clear what is\n+   * needed.\n+   */\n+\n+\n+  const isArray = (value, {\n+    moduleName,\n+    className,\n+    funcName,\n+    paramName\n+  }) => {\n+    if (!Array.isArray(value)) {\n+      throw new WorkboxError('not-an-array', {\n+        moduleName,\n+        className,\n+        funcName,\n+        paramName\n+      });\n+    }\n+  };\n+\n+  const hasMethod = (object, expectedMethod, {\n+    moduleName,\n+    className,\n+    funcName,\n+    paramName\n+  }) => {\n+    const type = typeof object[expectedMethod];\n+\n+    if (type !== 'function') {\n+      throw new WorkboxError('missing-a-method', {\n+        paramName,\n+        expectedMethod,\n+        moduleName,\n+        className,\n+        funcName\n+      });\n+    }\n+  };\n+\n+  const isType = (object, expectedType, {\n+    moduleName,\n+    className,\n+    funcName,\n+    paramName\n+  }) => {\n+    if (typeof object !== expectedType) {\n+      throw new WorkboxError('incorrect-type', {\n+        paramName,\n+        expectedType,\n+        moduleName,\n+        className,\n+        funcName\n+      });\n+    }\n+  };\n+\n+  const isInstance = (object, expectedClass, {\n+    moduleName,\n+    className,\n+    funcName,\n+    paramName,\n+    isReturnValueProblem\n+  }) => {\n+    if (!(object instanceof expectedClass)) {\n+      throw new WorkboxError('incorrect-class', {\n+        paramName,\n+        expectedClass,\n+        moduleName,\n+        className,\n+        funcName,\n+        isReturnValueProblem\n+      });\n+    }\n+  };\n+\n+  const isOneOf = (value, validValues, {\n+    paramName\n+  }) => {\n+    if (!validValues.includes(value)) {\n+      throw new WorkboxError('invalid-value', {\n+        paramName,\n+        value,\n+        validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`\n+      });\n+    }\n+  };\n+\n+  const isArrayOfClass = (value, expectedClass, {\n+    moduleName,\n+    className,\n+    funcName,\n+    paramName\n+  }) => {\n+    const error = new WorkboxError('not-array-of-class', {\n+      value,\n+      expectedClass,\n+      moduleName,\n+      className,\n+      funcName,\n+      paramName\n+    });\n+\n+    if (!Array.isArray(value)) {\n+      throw error;\n+    }\n+\n+    for (let item of value) {\n+      if (!(item instanceof expectedClass)) {\n+        throw error;\n+      }\n+    }\n+  };\n+\n+  const finalAssertExports = {\n+    hasMethod,\n+    isArray,\n+    isInstance,\n+    isOneOf,\n+    isSWEnv,\n+    isType,\n+    isArrayOfClass\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  const quotaErrorCallbacks = new Set();\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Adds a function to the set of quotaErrorCallbacks that will be executed if\n+   * there's a quota error.\n+   *\n+   * @param {Function} callback\n+   * @memberof workbox.core\n+   */\n+\n+  function registerQuotaErrorCallback(callback) {\n+    {\n+      finalAssertExports.isType(callback, 'function', {\n+        moduleName: 'workbox-core',\n+        funcName: 'register',\n+        paramName: 'callback'\n+      });\n+    }\n+\n+    quotaErrorCallbacks.add(callback);\n+\n+    {\n+      logger.log('Registered a callback to respond to quota errors.', callback);\n+    }\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const _cacheNameDetails = {\n+    googleAnalytics: 'googleAnalytics',\n+    precache: 'precache-v2',\n+    prefix: 'workbox',\n+    runtime: 'runtime',\n+    suffix: self.registration.scope\n+  };\n+\n+  const _createCacheName = cacheName => {\n+    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value.length > 0).join('-');\n+  };\n+\n+  const cacheNames = {\n+    updateDetails: details => {\n+      Object.keys(_cacheNameDetails).forEach(key => {\n+        if (typeof details[key] !== 'undefined') {\n+          _cacheNameDetails[key] = details[key];\n+        }\n+      });\n+    },\n+    getGoogleAnalyticsName: userCacheName => {\n+      return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n+    },\n+    getPrecacheName: userCacheName => {\n+      return userCacheName || _createCacheName(_cacheNameDetails.precache);\n+    },\n+    getPrefix: () => {\n+      return _cacheNameDetails.prefix;\n+    },\n+    getRuntimeName: userCacheName => {\n+      return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n+    },\n+    getSuffix: () => {\n+      return _cacheNameDetails.suffix;\n+    }\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  const getFriendlyURL = url => {\n+    const urlObj = new URL(url, location);\n+\n+    if (urlObj.origin === location.origin) {\n+      return urlObj.pathname;\n+    }\n+\n+    return urlObj.href;\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Runs all of the callback functions, one at a time sequentially, in the order\n+   * in which they were registered.\n+   *\n+   * @memberof workbox.core\n+   * @private\n+   */\n+\n+  async function executeQuotaErrorCallbacks() {\n+    {\n+      logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);\n+    }\n+\n+    for (const callback of quotaErrorCallbacks) {\n+      await callback();\n+\n+      {\n+        logger.log(callback, 'is complete.');\n+      }\n+    }\n+\n+    {\n+      logger.log('Finished running callbacks.');\n+    }\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const pluginEvents = {\n+    CACHE_DID_UPDATE: 'cacheDidUpdate',\n+    CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\n+    CACHE_WILL_UPDATE: 'cacheWillUpdate',\n+    CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n+    FETCH_DID_FAIL: 'fetchDidFail',\n+    FETCH_DID_SUCCEED: 'fetchDidSucceed',\n+    REQUEST_WILL_FETCH: 'requestWillFetch'\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const pluginUtils = {\n+    filter: (plugins, callbackName) => {\n+      return plugins.filter(plugin => callbackName in plugin);\n+    }\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Wrapper around cache.put().\n+   *\n+   * Will call `cacheDidUpdate` on plugins if the cache was updated, using\n+   * `matchOptions` when determining what the old entry is.\n+   *\n+   * @param {Object} options\n+   * @param {string} options.cacheName\n+   * @param {Request} options.request\n+   * @param {Response} options.response\n+   * @param {Event} [options.event]\n+   * @param {Array<Object>} [options.plugins=[]]\n+   * @param {Object} [options.matchOptions]\n+   *\n+   * @private\n+   * @memberof module:workbox-core\n+   */\n+\n+  const putWrapper = async ({\n+    cacheName,\n+    request,\n+    response,\n+    event,\n+    plugins = [],\n+    matchOptions\n+  } = {}) => {\n+    {\n+      if (request.method && request.method !== 'GET') {\n+        throw new WorkboxError('attempt-to-cache-non-get-request', {\n+          url: getFriendlyURL(request.url),\n+          method: request.method\n+        });\n+      }\n+    }\n+\n+    const effectiveRequest = await _getEffectiveRequest({\n+      plugins,\n+      request,\n+      mode: 'write'\n+    });\n+\n+    if (!response) {\n+      {\n+        logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n+      }\n+\n+      throw new WorkboxError('cache-put-with-no-response', {\n+        url: getFriendlyURL(effectiveRequest.url)\n+      });\n+    }\n+\n+    let responseToCache = await _isResponseSafeToCache({\n+      event,\n+      plugins,\n+      response,\n+      request: effectiveRequest\n+    });\n+\n+    if (!responseToCache) {\n+      {\n+        logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` + `not be cached.`, responseToCache);\n+      }\n+\n+      return;\n+    }\n+\n+    const cache = await caches.open(cacheName);\n+    const updatePlugins = pluginUtils.filter(plugins, pluginEvents.CACHE_DID_UPDATE);\n+    let oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n+      cacheName,\n+      matchOptions,\n+      request: effectiveRequest\n+    }) : null;\n+\n+    {\n+      logger.debug(`Updating the '${cacheName}' cache with a new Response for ` + `${getFriendlyURL(effectiveRequest.url)}.`);\n+    }\n+\n+    try {\n+      await cache.put(effectiveRequest, responseToCache);\n+    } catch (error) {\n+      // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n+      if (error.name === 'QuotaExceededError') {\n+        await executeQuotaErrorCallbacks();\n+      }\n+\n+      throw error;\n+    }\n+\n+    for (let plugin of updatePlugins) {\n+      await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n+        cacheName,\n+        event,\n+        oldResponse,\n+        newResponse: responseToCache,\n+        request: effectiveRequest\n+      });\n+    }\n+  };\n+  /**\n+   * This is a wrapper around cache.match().\n+   *\n+   * @param {Object} options\n+   * @param {string} options.cacheName Name of the cache to match against.\n+   * @param {Request} options.request The Request that will be used to look up\n+   *     cache entries.\n+   * @param {Event} [options.event] The event that propted the action.\n+   * @param {Object} [options.matchOptions] Options passed to cache.match().\n+   * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n+   * @return {Response} A cached response if available.\n+   *\n+   * @private\n+   * @memberof module:workbox-core\n+   */\n+\n+\n+  const matchWrapper = async ({\n+    cacheName,\n+    request,\n+    event,\n+    matchOptions,\n+    plugins = []\n+  }) => {\n+    const cache = await caches.open(cacheName);\n+    const effectiveRequest = await _getEffectiveRequest({\n+      plugins,\n+      request,\n+      mode: 'read'\n+    });\n+    let cachedResponse = await cache.match(effectiveRequest, matchOptions);\n+\n+    {\n+      if (cachedResponse) {\n+        logger.debug(`Found a cached response in '${cacheName}'.`);\n+      } else {\n+        logger.debug(`No cached response found in '${cacheName}'.`);\n+      }\n+    }\n+\n+    for (const plugin of plugins) {\n+      if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n+        cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED].call(plugin, {\n+          cacheName,\n+          event,\n+          matchOptions,\n+          cachedResponse,\n+          request: effectiveRequest\n+        });\n+\n+        {\n+          if (cachedResponse) {\n+            finalAssertExports.isInstance(cachedResponse, Response, {\n+              moduleName: 'Plugin',\n+              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n+              isReturnValueProblem: true\n+            });\n+          }\n+        }\n+      }\n+    }\n+\n+    return cachedResponse;\n+  };\n+  /**\n+   * This method will call cacheWillUpdate on the available plugins (or use\n+   * status === 200) to determine if the Response is safe and valid to cache.\n+   *\n+   * @param {Object} options\n+   * @param {Request} options.request\n+   * @param {Response} options.response\n+   * @param {Event} [options.event]\n+   * @param {Array<Object>} [options.plugins=[]]\n+   * @return {Promise<Response>}\n+   *\n+   * @private\n+   * @memberof module:workbox-core\n+   */\n+\n+\n+  const _isResponseSafeToCache = async ({\n+    request,\n+    response,\n+    event,\n+    plugins\n+  }) => {\n+    let responseToCache = response;\n+    let pluginsUsed = false;\n+\n+    for (let plugin of plugins) {\n+      if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n+        pluginsUsed = true;\n+        responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE].call(plugin, {\n+          request,\n+          response: responseToCache,\n+          event\n+        });\n+\n+        {\n+          if (responseToCache) {\n+            finalAssertExports.isInstance(responseToCache, Response, {\n+              moduleName: 'Plugin',\n+              funcName: pluginEvents.CACHE_WILL_UPDATE,\n+              isReturnValueProblem: true\n+            });\n+          }\n+        }\n+\n+        if (!responseToCache) {\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (!pluginsUsed) {\n+      {\n+        if (!responseToCache.status === 200) {\n+          if (responseToCache.status === 0) {\n+            logger.warn(`The response for '${request.url}' is an opaque ` + `response. The caching strategy that you're using will not ` + `cache opaque responses by default.`);\n+          } else {\n+            logger.debug(`The response for '${request.url}' returned ` + `a status code of '${response.status}' and won't be cached as a ` + `result.`);\n+          }\n+        }\n+      }\n+\n+      responseToCache = responseToCache.status === 200 ? responseToCache : null;\n+    }\n+\n+    return responseToCache ? responseToCache : null;\n+  };\n+  /**\n+   * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\n+   * executes any of those callbacks found in sequence. The final `Request` object\n+   * returned by the last plugin is treated as the cache key for cache reads\n+   * and/or writes.\n+   *\n+   * @param {Object} options\n+   * @param {Request} options.request\n+   * @param {string} options.mode\n+   * @param {Array<Object>} [options.plugins=[]]\n+   * @return {Promise<Request>}\n+   *\n+   * @private\n+   * @memberof module:workbox-core\n+   */\n+\n+\n+  const _getEffectiveRequest = async ({\n+    request,\n+    mode,\n+    plugins\n+  }) => {\n+    const cacheKeyWillBeUsedPlugins = pluginUtils.filter(plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\n+    let effectiveRequest = request;\n+\n+    for (const plugin of cacheKeyWillBeUsedPlugins) {\n+      effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(plugin, {\n+        mode,\n+        request: effectiveRequest\n+      });\n+\n+      if (typeof effectiveRequest === 'string') {\n+        effectiveRequest = new Request(effectiveRequest);\n+      }\n+\n+      {\n+        finalAssertExports.isInstance(effectiveRequest, Request, {\n+          moduleName: 'Plugin',\n+          funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\n+          isReturnValueProblem: true\n+        });\n+      }\n+    }\n+\n+    return effectiveRequest;\n+  };\n+\n+  const cacheWrapper = {\n+    put: putWrapper,\n+    match: matchWrapper\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * A class that wraps common IndexedDB functionality in a promise-based API.\n+   * It exposes all the underlying power and functionality of IndexedDB, but\n+   * wraps the most commonly used features in a way that's much simpler to use.\n+   *\n+   * @private\n+   */\n+\n+  class DBWrapper {\n+    /**\n+     * @param {string} name\n+     * @param {number} version\n+     * @param {Object=} [callback]\n+     * @param {!Function} [callbacks.onupgradeneeded]\n+     * @param {!Function} [callbacks.onversionchange] Defaults to\n+     *     DBWrapper.prototype._onversionchange when not specified.\n+     * @private\n+     */\n+    constructor(name, version, {\n+      onupgradeneeded,\n+      onversionchange = this._onversionchange\n+    } = {}) {\n+      this._name = name;\n+      this._version = version;\n+      this._onupgradeneeded = onupgradeneeded;\n+      this._onversionchange = onversionchange; // If this is null, it means the database isn't open.\n+\n+      this._db = null;\n+    }\n+    /**\n+     * Returns the IDBDatabase instance (not normally needed).\n+     *\n+     * @private\n+     */\n+\n+\n+    get db() {\n+      return this._db;\n+    }\n+    /**\n+     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n+     * callback, and added an onversionchange callback to the database.\n+     *\n+     * @return {IDBDatabase}\n+     * @private\n+     */\n+\n+\n+    async open() {\n+      if (this._db) return;\n+      this._db = await new Promise((resolve, reject) => {\n+        // This flag is flipped to true if the timeout callback runs prior\n+        // to the request failing or succeeding. Note: we use a timeout instead\n+        // of an onblocked handler since there are cases where onblocked will\n+        // never never run. A timeout better handles all possible scenarios:\n+        // https://github.com/w3c/IndexedDB/issues/223\n+        let openRequestTimedOut = false;\n+        setTimeout(() => {\n+          openRequestTimedOut = true;\n+          reject(new Error('The open request was blocked and timed out'));\n+        }, this.OPEN_TIMEOUT);\n+        const openRequest = indexedDB.open(this._name, this._version);\n+\n+        openRequest.onerror = () => reject(openRequest.error);\n+\n+        openRequest.onupgradeneeded = evt => {\n+          if (openRequestTimedOut) {\n+            openRequest.transaction.abort();\n+            evt.target.result.close();\n+          } else if (this._onupgradeneeded) {\n+            this._onupgradeneeded(evt);\n+          }\n+        };\n+\n+        openRequest.onsuccess = ({\n+          target\n+        }) => {\n+          const db = target.result;\n+\n+          if (openRequestTimedOut) {\n+            db.close();\n+          } else {\n+            db.onversionchange = this._onversionchange.bind(this);\n+            resolve(db);\n+          }\n+        };\n+      });\n+      return this;\n+    }\n+    /**\n+     * Polyfills the native `getKey()` method. Note, this is overridden at\n+     * runtime if the browser supports the native method.\n+     *\n+     * @param {string} storeName\n+     * @param {*} query\n+     * @return {Array}\n+     * @private\n+     */\n+\n+\n+    async getKey(storeName, query) {\n+      return (await this.getAllKeys(storeName, query, 1))[0];\n+    }\n+    /**\n+     * Polyfills the native `getAll()` method. Note, this is overridden at\n+     * runtime if the browser supports the native method.\n+     *\n+     * @param {string} storeName\n+     * @param {*} query\n+     * @param {number} count\n+     * @return {Array}\n+     * @private\n+     */\n+\n+\n+    async getAll(storeName, query, count) {\n+      return await this.getAllMatching(storeName, {\n+        query,\n+        count\n+      });\n+    }\n+    /**\n+     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n+     * runtime if the browser supports the native method.\n+     *\n+     * @param {string} storeName\n+     * @param {*} query\n+     * @param {number} count\n+     * @return {Array}\n+     * @private\n+     */\n+\n+\n+    async getAllKeys(storeName, query, count) {\n+      return (await this.getAllMatching(storeName, {\n+        query,\n+        count,\n+        includeKeys: true\n+      })).map(({\n+        key\n+      }) => key);\n+    }\n+    /**\n+     * Supports flexible lookup in an object store by specifying an index,\n+     * query, direction, and count. This method returns an array of objects\n+     * with the signature .\n+     *\n+     * @param {string} storeName\n+     * @param {Object} [opts]\n+     * @param {string} [opts.index] The index to use (if specified).\n+     * @param {*} [opts.query]\n+     * @param {IDBCursorDirection} [opts.direction]\n+     * @param {number} [opts.count] The max number of results to return.\n+     * @param {boolean} [opts.includeKeys] When true, the structure of the\n+     *     returned objects is changed from an array of values to an array of\n+     *     objects in the form {key, primaryKey, value}.\n+     * @return {Array}\n+     * @private\n+     */\n+\n+\n+    async getAllMatching(storeName, {\n+      index,\n+      query = null,\n+      // IE errors if query === `undefined`.\n+      direction = 'next',\n+      count,\n+      includeKeys\n+    } = {}) {\n+      return await this.transaction([storeName], 'readonly', (txn, done) => {\n+        const store = txn.objectStore(storeName);\n+        const target = index ? store.index(index) : store;\n+        const results = [];\n+\n+        target.openCursor(query, direction).onsuccess = ({\n+          target\n+        }) => {\n+          const cursor = target.result;\n+\n+          if (cursor) {\n+            const {\n+              primaryKey,\n+              key,\n+              value\n+            } = cursor;\n+            results.push(includeKeys ? {\n+              primaryKey,\n+              key,\n+              value\n+            } : value);\n+\n+            if (count && results.length >= count) {\n+              done(results);\n+            } else {\n+              cursor.continue();\n+            }\n+          } else {\n+            done(results);\n+          }\n+        };\n+      });\n+    }\n+    /**\n+     * Accepts a list of stores, a transaction type, and a callback and\n+     * performs a transaction. A promise is returned that resolves to whatever\n+     * value the callback chooses. The callback holds all the transaction logic\n+     * and is invoked with two arguments:\n+     *   1. The IDBTransaction object\n+     *   2. A `done` function, that's used to resolve the promise when\n+     *      when the transaction is done, if passed a value, the promise is\n+     *      resolved to that value.\n+     *\n+     * @param {Array<string>} storeNames An array of object store names\n+     *     involved in the transaction.\n+     * @param {string} type Can be `readonly` or `readwrite`.\n+     * @param {!Function} callback\n+     * @return {*} The result of the transaction ran by the callback.\n+     * @private\n+     */\n+\n+\n+    async transaction(storeNames, type, callback) {\n+      await this.open();\n+      return await new Promise((resolve, reject) => {\n+        const txn = this._db.transaction(storeNames, type);\n+\n+        txn.onabort = ({\n+          target\n+        }) => reject(target.error);\n+\n+        txn.oncomplete = () => resolve();\n+\n+        callback(txn, value => resolve(value));\n+      });\n+    }\n+    /**\n+     * Delegates async to a native IDBObjectStore method.\n+     *\n+     * @param {string} method The method name.\n+     * @param {string} storeName The object store name.\n+     * @param {string} type Can be `readonly` or `readwrite`.\n+     * @param {...*} args The list of args to pass to the native method.\n+     * @return {*} The result of the transaction.\n+     * @private\n+     */\n+\n+\n+    async _call(method, storeName, type, ...args) {\n+      const callback = (txn, done) => {\n+        txn.objectStore(storeName)[method](...args).onsuccess = ({\n+          target\n+        }) => {\n+          done(target.result);\n+        };\n+      };\n+\n+      return await this.transaction([storeName], type, callback);\n+    }\n+    /**\n+     * The default onversionchange handler, which closes the database so other\n+     * connections can open without being blocked.\n+     *\n+     * @private\n+     */\n+\n+\n+    _onversionchange() {\n+      this.close();\n+    }\n+    /**\n+     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n+     * doesn't need to be called since:\n+     *   1. It's usually better to keep a connection open since opening\n+     *      a new connection is somewhat slow.\n+     *   2. Connections are automatically closed when the reference is\n+     *      garbage collected.\n+     * The primary use case for needing to close a connection is when another\n+     * reference (typically in another tab) needs to upgrade it and would be\n+     * blocked by the current, open connection.\n+     *\n+     * @private\n+     */\n+\n+\n+    close() {\n+      if (this._db) {\n+        this._db.close();\n+\n+        this._db = null;\n+      }\n+    }\n+\n+  } // Exposed to let users modify the default timeout on a per-instance\n+  // or global basis.\n+\n+  DBWrapper.prototype.OPEN_TIMEOUT = 2000; // Wrap native IDBObjectStore methods according to their mode.\n+\n+  const methodsToWrap = {\n+    'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n+    'readwrite': ['add', 'put', 'clear', 'delete']\n+  };\n+\n+  for (const [mode, methods] of Object.entries(methodsToWrap)) {\n+    for (const method of methods) {\n+      if (method in IDBObjectStore.prototype) {\n+        // Don't use arrow functions here since we're outside of the class.\n+        DBWrapper.prototype[method] = async function (storeName, ...args) {\n+          return await this._call(method, storeName, mode, ...args);\n+        };\n+      }\n+    }\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * The Deferred class composes Promises in a way that allows for them to be\n+   * resolved or rejected from outside the constructor. In most cases promises\n+   * should be used directly, but Deferreds can be necessary when the logic to\n+   * resolve a promise must be separate.\n+   *\n+   * @private\n+   */\n+\n+  class Deferred {\n+    /**\n+     * Creates a promise and exposes its resolve and reject functions as methods.\n+     */\n+    constructor() {\n+      this.promise = new Promise((resolve, reject) => {\n+        this.resolve = resolve;\n+        this.reject = reject;\n+      });\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Deletes the database.\n+   * Note: this is exported separately from the DBWrapper module because most\n+   * usages of IndexedDB in workbox dont need deleting, and this way it can be\n+   * reused in tests to delete databases without creating DBWrapper instances.\n+   *\n+   * @param {string} name The database name.\n+   * @private\n+   */\n+\n+  const deleteDatabase = async name => {\n+    await new Promise((resolve, reject) => {\n+      const request = indexedDB.deleteDatabase(name);\n+\n+      request.onerror = ({\n+        target\n+      }) => {\n+        reject(target.error);\n+      };\n+\n+      request.onblocked = () => {\n+        reject(new Error('Delete blocked'));\n+      };\n+\n+      request.onsuccess = () => {\n+        resolve();\n+      };\n+    });\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Wrapper around the fetch API.\n+   *\n+   * Will call requestWillFetch on available plugins.\n+   *\n+   * @param {Object} options\n+   * @param {Request|string} options.request\n+   * @param {Object} [options.fetchOptions]\n+   * @param {Event} [options.event]\n+   * @param {Array<Object>} [options.plugins=[]]\n+   * @return {Promise<Response>}\n+   *\n+   * @private\n+   * @memberof module:workbox-core\n+   */\n+\n+  const wrappedFetch = async ({\n+    request,\n+    fetchOptions,\n+    event,\n+    plugins = []\n+  }) => {\n+    // We *should* be able to call `await event.preloadResponse` even if it's\n+    // undefined, but for some reason, doing so leads to errors in our Node unit\n+    // tests. To work around that, explicitly check preloadResponse's value first.\n+    if (event && event.preloadResponse) {\n+      const possiblePreloadResponse = await event.preloadResponse;\n+\n+      if (possiblePreloadResponse) {\n+        {\n+          logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n+        }\n+\n+        return possiblePreloadResponse;\n+      }\n+    }\n+\n+    if (typeof request === 'string') {\n+      request = new Request(request);\n+    }\n+\n+    {\n+      finalAssertExports.isInstance(request, Request, {\n+        paramName: request,\n+        expectedClass: 'Request',\n+        moduleName: 'workbox-core',\n+        className: 'fetchWrapper',\n+        funcName: 'wrappedFetch'\n+      });\n+    }\n+\n+    const failedFetchPlugins = pluginUtils.filter(plugins, pluginEvents.FETCH_DID_FAIL); // If there is a fetchDidFail plugin, we need to save a clone of the\n+    // original request before it's either modified by a requestWillFetch\n+    // plugin or before the original request's body is consumed via fetch().\n+\n+    const originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n+\n+    try {\n+      for (let plugin of plugins) {\n+        if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n+          request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n+            request: request.clone(),\n+            event\n+          });\n+\n+          {\n+            if (request) {\n+              finalAssertExports.isInstance(request, Request, {\n+                moduleName: 'Plugin',\n+                funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n+                isReturnValueProblem: true\n+              });\n+            }\n+          }\n+        }\n+      }\n+    } catch (err) {\n+      throw new WorkboxError('plugin-error-request-will-fetch', {\n+        thrownError: err\n+      });\n+    } // The request can be altered by plugins with `requestWillFetch` making\n+    // the original request (Most likely from a `fetch` event) to be different\n+    // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n+\n+\n+    let pluginFilteredRequest = request.clone();\n+\n+    try {\n+      let fetchResponse; // See https://github.com/GoogleChrome/workbox/issues/1796\n+\n+      if (request.mode === 'navigate') {\n+        fetchResponse = await fetch(request);\n+      } else {\n+        fetchResponse = await fetch(request, fetchOptions);\n+      }\n+\n+      {\n+        logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n+      }\n+\n+      for (const plugin of plugins) {\n+        if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\n+          fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED].call(plugin, {\n+            event,\n+            request: pluginFilteredRequest,\n+            response: fetchResponse\n+          });\n+\n+          {\n+            if (fetchResponse) {\n+              finalAssertExports.isInstance(fetchResponse, Response, {\n+                moduleName: 'Plugin',\n+                funcName: pluginEvents.FETCH_DID_SUCCEED,\n+                isReturnValueProblem: true\n+              });\n+            }\n+          }\n+        }\n+      }\n+\n+      return fetchResponse;\n+    } catch (error) {\n+      {\n+        logger.error(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n+      }\n+\n+      for (const plugin of failedFetchPlugins) {\n+        await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n+          error,\n+          event,\n+          originalRequest: originalRequest.clone(),\n+          request: pluginFilteredRequest.clone()\n+        });\n+      }\n+\n+      throw error;\n+    }\n+  };\n+\n+  const fetchWrapper = {\n+    fetch: wrappedFetch\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  var _private = /*#__PURE__*/Object.freeze({\n+    assert: finalAssertExports,\n+    cacheNames: cacheNames,\n+    cacheWrapper: cacheWrapper,\n+    DBWrapper: DBWrapper,\n+    Deferred: Deferred,\n+    deleteDatabase: deleteDatabase,\n+    executeQuotaErrorCallbacks: executeQuotaErrorCallbacks,\n+    fetchWrapper: fetchWrapper,\n+    getFriendlyURL: getFriendlyURL,\n+    logger: logger,\n+    WorkboxError: WorkboxError\n+  });\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Claim any currently available clients once the service worker\n+   * becomes active. This is normally used in conjunction with `skipWaiting()`.\n+   *\n+   * @alias workbox.core.clientsClaim\n+   */\n+\n+  const clientsClaim = () => {\n+    addEventListener('activate', () => clients.claim());\n+  };\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Get the current cache names and prefix/suffix used by Workbox.\n+   *\n+   * `cacheNames.precache` is used for precached assets,\n+   * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n+   * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\n+   *\n+   * `cacheNames.prefix` can be used to retrieve just the current prefix value.\n+   * `cacheNames.suffix` can be used to retrieve just the current suffix value.\n+   *\n+   * @return {Object} An object with `precache`, `runtime`, `prefix`, and\n+   *     `googleAnalytics` properties.\n+   *\n+   * @alias workbox.core.cacheNames\n+   */\n+\n+  const cacheNames$1 = {\n+    get googleAnalytics() {\n+      return cacheNames.getGoogleAnalyticsName();\n+    },\n+\n+    get precache() {\n+      return cacheNames.getPrecacheName();\n+    },\n+\n+    get prefix() {\n+      return cacheNames.getPrefix();\n+    },\n+\n+    get runtime() {\n+      return cacheNames.getRuntimeName();\n+    },\n+\n+    get suffix() {\n+      return cacheNames.getSuffix();\n+    }\n+\n+  };\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Modifies the default cache names used by the Workbox packages.\n+   * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n+   *\n+   * @param {Object} details\n+   * @param {Object} [details.prefix] The string to add to the beginning of\n+   *     the precache and runtime cache names.\n+   * @param {Object} [details.suffix] The string to add to the end of\n+   *     the precache and runtime cache names.\n+   * @param {Object} [details.precache] The cache name to use for precache\n+   *     caching.\n+   * @param {Object} [details.runtime] The cache name to use for runtime caching.\n+   * @param {Object} [details.googleAnalytics] The cache name to use for\n+   *     `workbox-google-analytics` caching.\n+   *\n+   * @alias workbox.core.setCacheNameDetails\n+   */\n+\n+  const setCacheNameDetails = details => {\n+    {\n+      Object.keys(details).forEach(key => {\n+        finalAssertExports.isType(details[key], 'string', {\n+          moduleName: 'workbox-core',\n+          funcName: 'setCacheNameDetails',\n+          paramName: `details.${key}`\n+        });\n+      });\n+\n+      if ('precache' in details && details.precache.length === 0) {\n+        throw new WorkboxError('invalid-cache-name', {\n+          cacheNameId: 'precache',\n+          value: details.precache\n+        });\n+      }\n+\n+      if ('runtime' in details && details.runtime.length === 0) {\n+        throw new WorkboxError('invalid-cache-name', {\n+          cacheNameId: 'runtime',\n+          value: details.runtime\n+        });\n+      }\n+\n+      if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n+        throw new WorkboxError('invalid-cache-name', {\n+          cacheNameId: 'googleAnalytics',\n+          value: details.googleAnalytics\n+        });\n+      }\n+    }\n+\n+    cacheNames.updateDetails(details);\n+  };\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Force a service worker to become active, instead of waiting. This is\n+   * normally used in conjunction with `clientsClaim()`.\n+   *\n+   * @alias workbox.core.skipWaiting\n+   */\n+\n+  const skipWaiting = () => {\n+    // We need to explicitly call `self.skipWaiting()` here because we're\n+    // shadowing `skipWaiting` with this local function.\n+    addEventListener('install', () => self.skipWaiting());\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  try {\n+    self.workbox.v = self.workbox.v || {};\n+  } catch (errer) {} // NOOP\n+\n+  exports._private = _private;\n+  exports.clientsClaim = clientsClaim;\n+  exports.cacheNames = cacheNames$1;\n+  exports.registerQuotaErrorCallback = registerQuotaErrorCallback;\n+  exports.setCacheNameDetails = setCacheNameDetails;\n+  exports.skipWaiting = skipWaiting;\n+\n+  return exports;\n+\n+}({}));\n+//# sourceMappingURL=workbox-core.dev.js.map"
    },
    {
      "sha": "879a7658d3d2b800118ef2d2450d37ab4a080088",
      "filename": "public/javascripts/workbox/workbox-core.dev.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.dev.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.dev.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-core.dev.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-core.dev.js\",\"sources\":[\"../_version.mjs\",\"../_private/logger.mjs\",\"../models/messages/messages.mjs\",\"../models/messages/messageGenerator.mjs\",\"../_private/WorkboxError.mjs\",\"../_private/assert.mjs\",\"../models/quotaErrorCallbacks.mjs\",\"../registerQuotaErrorCallback.mjs\",\"../_private/cacheNames.mjs\",\"../_private/getFriendlyURL.mjs\",\"../_private/executeQuotaErrorCallbacks.mjs\",\"../models/pluginEvents.mjs\",\"../utils/pluginUtils.mjs\",\"../_private/cacheWrapper.mjs\",\"../_private/DBWrapper.mjs\",\"../_private/Deferred.mjs\",\"../_private/deleteDatabase.mjs\",\"../_private/fetchWrapper.mjs\",\"../_private.mjs\",\"../clientsClaim.mjs\",\"../cacheNames.mjs\",\"../setCacheNameDetails.mjs\",\"../skipWaiting.mjs\",\"../index.mjs\"],\"sourcesContent\":[\"try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2019 Google LLC\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\\n  let inGroup = false;\\n\\n  const methodToColorMap = {\\n    debug: `#7f8c8d`, // Gray\\n    log: `#2ecc71`, // Green\\n    warn: `#f39c12`, // Yellow\\n    error: `#c0392b`, // Red\\n    groupCollapsed: `#3498db`, // Blue\\n    groupEnd: null, // No colored prefix on groupEnd\\n  };\\n\\n  const print = function(method, args) {\\n    if (method === 'groupCollapsed') {\\n      // Safari doesn't print all console.groupCollapsed() arguments:\\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\\n        console[method](...args);\\n        return;\\n      }\\n    }\\n\\n    const styles = [\\n      `background: ${methodToColorMap[method]}`,\\n      `border-radius: 0.5em`,\\n      `color: white`,\\n      `font-weight: bold`,\\n      `padding: 2px 0.5em`,\\n    ];\\n\\n    // When in a group, the workbox prefix is not displayed.\\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\\n\\n    console[method](...logPrefix, ...args);\\n\\n    if (method === 'groupCollapsed') {\\n      inGroup = true;\\n    }\\n    if (method === 'groupEnd') {\\n      inGroup = false;\\n    }\\n  };\\n\\n  const api = {};\\n  for (const method of Object.keys(methodToColorMap)) {\\n    api[method] = (...args) => {\\n      print(method, args);\\n    };\\n  }\\n\\n  return api;\\n})();\\n\\nexport {logger};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../../_version.mjs';\\n\\n\\nexport const messages = {\\n  'invalid-value': ({paramName, validValueDescription, value}) => {\\n    if (!paramName || !validValueDescription) {\\n      throw new Error(`Unexpected input to 'invalid-value' error.`);\\n    }\\n    return `The '${paramName}' parameter was given a value with an ` +\\n      `unexpected value. ${validValueDescription} Received a value of ` +\\n      `${JSON.stringify(value)}.`;\\n  },\\n\\n  'not-in-sw': ({moduleName}) => {\\n    if (!moduleName) {\\n      throw new Error(`Unexpected input to 'not-in-sw' error.`);\\n    }\\n    return `The '${moduleName}' must be used in a service worker.`;\\n  },\\n\\n  'not-an-array': ({moduleName, className, funcName, paramName}) => {\\n    if (!moduleName || !className || !funcName || !paramName) {\\n      throw new Error(`Unexpected input to 'not-an-array' error.`);\\n    }\\n    return `The parameter '${paramName}' passed into ` +\\n      `'${moduleName}.${className}.${funcName}()' must be an array.`;\\n  },\\n\\n  'incorrect-type': ({expectedType, paramName, moduleName, className,\\n    funcName}) => {\\n    if (!expectedType || !paramName || !moduleName || !funcName) {\\n      throw new Error(`Unexpected input to 'incorrect-type' error.`);\\n    }\\n    return `The parameter '${paramName}' passed into ` +\\n      `'${moduleName}.${className ? (className + '.') : ''}` +\\n      `${funcName}()' must be of type ${expectedType}.`;\\n  },\\n\\n  'incorrect-class': ({expectedClass, paramName, moduleName, className,\\n    funcName, isReturnValueProblem}) => {\\n    if (!expectedClass || !moduleName || !funcName) {\\n      throw new Error(`Unexpected input to 'incorrect-class' error.`);\\n    }\\n\\n    if (isReturnValueProblem) {\\n      return `The return value from ` +\\n        `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\\n        `must be an instance of class ${expectedClass.name}.`;\\n    }\\n\\n    return `The parameter '${paramName}' passed into ` +\\n      `'${moduleName}.${className ? (className + '.') : ''}${funcName}()' ` +\\n      `must be an instance of class ${expectedClass.name}.`;\\n  },\\n\\n  'missing-a-method': ({expectedMethod, paramName, moduleName, className,\\n    funcName}) => {\\n    if (!expectedMethod || !paramName || !moduleName || !className\\n        || !funcName) {\\n      throw new Error(`Unexpected input to 'missing-a-method' error.`);\\n    }\\n    return `${moduleName}.${className}.${funcName}() expected the ` +\\n      `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\\n  },\\n\\n  'add-to-cache-list-unexpected-type': ({entry}) => {\\n    return `An unexpected entry was passed to ` +\\n    `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` +\\n    `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` +\\n    `strings with one or more characters, objects with a url property or ` +\\n    `Request objects.`;\\n  },\\n\\n  'add-to-cache-list-conflicting-entries': ({firstEntry, secondEntry}) => {\\n    if (!firstEntry || !secondEntry) {\\n      throw new Error(`Unexpected input to ` +\\n        `'add-to-cache-list-duplicate-entries' error.`);\\n    }\\n\\n    return `Two of the entries passed to ` +\\n      `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` +\\n      `${firstEntry._entryId} but different revision details. Workbox is ` +\\n      `is unable to cache and version the asset correctly. Please remove one ` +\\n      `of the entries.`;\\n  },\\n\\n  'plugin-error-request-will-fetch': ({thrownError}) => {\\n    if (!thrownError) {\\n      throw new Error(`Unexpected input to ` +\\n        `'plugin-error-request-will-fetch', error.`);\\n    }\\n\\n    return `An error was thrown by a plugins 'requestWillFetch()' method. ` +\\n      `The thrown error message was: '${thrownError.message}'.`;\\n  },\\n\\n  'invalid-cache-name': ({cacheNameId, value}) => {\\n    if (!cacheNameId) {\\n      throw new Error(\\n          `Expected a 'cacheNameId' for error 'invalid-cache-name'`);\\n    }\\n\\n    return `You must provide a name containing at least one character for ` +\\n      `setCacheDeatils({${cacheNameId}: '...'}). Received a value of ` +\\n      `'${JSON.stringify(value)}'`;\\n  },\\n\\n  'unregister-route-but-not-found-with-method': ({method}) => {\\n    if (!method) {\\n      throw new Error(`Unexpected input to ` +\\n        `'unregister-route-but-not-found-with-method' error.`);\\n    }\\n\\n    return `The route you're trying to unregister was not  previously ` +\\n      `registered for the method type '${method}'.`;\\n  },\\n\\n  'unregister-route-route-not-registered': () => {\\n    return `The route you're trying to unregister was not previously ` +\\n      `registered.`;\\n  },\\n\\n  'queue-replay-failed': ({name}) => {\\n    return `Replaying the background sync queue '${name}' failed.`;\\n  },\\n\\n  'duplicate-queue-name': ({name}) => {\\n    return `The Queue name '${name}' is already being used. ` +\\n        `All instances of backgroundSync.Queue must be given unique names.`;\\n  },\\n\\n  'expired-test-without-max-age': ({methodName, paramName}) => {\\n    return `The '${methodName}()' method can only be used when the ` +\\n      `'${paramName}' is used in the constructor.`;\\n  },\\n\\n  'unsupported-route-type': ({moduleName, className, funcName, paramName}) => {\\n    return `The supplied '${paramName}' parameter was an unsupported type. ` +\\n      `Please check the docs for ${moduleName}.${className}.${funcName} for ` +\\n      `valid input types.`;\\n  },\\n\\n  'not-array-of-class': ({value, expectedClass,\\n    moduleName, className, funcName, paramName}) => {\\n    return `The supplied '${paramName}' parameter must be an array of ` +\\n      `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` +\\n      `Please check the call to ${moduleName}.${className}.${funcName}() ` +\\n      `to fix the issue.`;\\n  },\\n\\n  'max-entries-or-age-required': ({moduleName, className, funcName}) => {\\n    return `You must define either config.maxEntries or config.maxAgeSeconds` +\\n      `in ${moduleName}.${className}.${funcName}`;\\n  },\\n\\n  'statuses-or-headers-required': ({moduleName, className, funcName}) => {\\n    return `You must define either config.statuses or config.headers` +\\n      `in ${moduleName}.${className}.${funcName}`;\\n  },\\n\\n  'invalid-string': ({moduleName, className, funcName, paramName}) => {\\n    if (!paramName || !moduleName || !funcName) {\\n      throw new Error(`Unexpected input to 'invalid-string' error.`);\\n    }\\n    return `When using strings, the '${paramName}' parameter must start with ` +\\n      `'http' (for cross-origin matches) or '/' (for same-origin matches). ` +\\n      `Please see the docs for ${moduleName}.${funcName}() for ` +\\n      `more info.`;\\n  },\\n\\n  'channel-name-required': () => {\\n    return `You must provide a channelName to construct a ` +\\n    `BroadcastCacheUpdate instance.`;\\n  },\\n\\n  'invalid-responses-are-same-args': () => {\\n    return `The arguments passed into responsesAreSame() appear to be ` +\\n      `invalid. Please ensure valid Responses are used.`;\\n  },\\n\\n  'expire-custom-caches-only': () => {\\n    return `You must provide a 'cacheName' property when using the ` +\\n      `expiration plugin with a runtime caching strategy.`;\\n  },\\n\\n  'unit-must-be-bytes': ({normalizedRangeHeader}) => {\\n    if (!normalizedRangeHeader) {\\n      throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\\n    }\\n    return `The 'unit' portion of the Range header must be set to 'bytes'. ` +\\n      `The Range header provided was \\\"${normalizedRangeHeader}\\\"`;\\n  },\\n\\n  'single-range-only': ({normalizedRangeHeader}) => {\\n    if (!normalizedRangeHeader) {\\n      throw new Error(`Unexpected input to 'single-range-only' error.`);\\n    }\\n    return `Multiple ranges are not supported. Please use a  single start ` +\\n      `value, and optional end value. The Range header provided was ` +\\n      `\\\"${normalizedRangeHeader}\\\"`;\\n  },\\n\\n  'invalid-range-values': ({normalizedRangeHeader}) => {\\n    if (!normalizedRangeHeader) {\\n      throw new Error(`Unexpected input to 'invalid-range-values' error.`);\\n    }\\n    return `The Range header is missing both start and end values. At least ` +\\n      `one of those values is needed. The Range header provided was ` +\\n      `\\\"${normalizedRangeHeader}\\\"`;\\n  },\\n\\n  'no-range-header': () => {\\n    return `No Range header was found in the Request provided.`;\\n  },\\n\\n  'range-not-satisfiable': ({size, start, end}) => {\\n    return `The start (${start}) and end (${end}) values in the Range are ` +\\n      `not satisfiable by the cached response, which is ${size} bytes.`;\\n  },\\n\\n  'attempt-to-cache-non-get-request': ({url, method}) => {\\n    return `Unable to cache '${url}' because it is a '${method}' request and ` +\\n      `only 'GET' requests can be cached.`;\\n  },\\n\\n  'cache-put-with-no-response': ({url}) => {\\n    return `There was an attempt to cache '${url}' but the response was not ` +\\n      `defined.`;\\n  },\\n\\n  'no-response': ({url, error}) => {\\n    let message = `The strategy could not generate a response for '${url}'.`;\\n    if (error) {\\n      message += ` The underlying error is ${error}.`;\\n    }\\n    return message;\\n  },\\n\\n  'bad-precaching-response': ({url, status}) => {\\n    return `The precaching request for '${url}' failed with an HTTP ` +\\n      `status of ${status}.`;\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {messages} from './messages.mjs';\\nimport '../../_version.mjs';\\n\\nconst fallback = (code, ...args) => {\\n  let msg = code;\\n  if (args.length > 0) {\\n    msg += ` :: ${JSON.stringify(args)}`;\\n  }\\n  return msg;\\n};\\n\\nconst generatorFunction = (code, ...args) => {\\n  const message = messages[code];\\n  if (!message) {\\n    throw new Error(`Unable to find message for code '${code}'.`);\\n  }\\n\\n  return message(...args);\\n};\\n\\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\\n    fallback : generatorFunction;\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\\nimport '../_version.mjs';\\n\\n/**\\n * Workbox errors should be thrown with this class.\\n * This allows use to ensure the type easily in tests,\\n * helps developers identify errors from workbox\\n * easily and allows use to optimise error\\n * messages correctly.\\n *\\n * @private\\n */\\nclass WorkboxError extends Error {\\n  /**\\n   *\\n   * @param {string} errorCode The error code that\\n   * identifies this particular error.\\n   * @param {Object=} details Any relevant arguments\\n   * that will help developers identify issues should\\n   * be added as a key on the context object.\\n   */\\n  constructor(errorCode, details) {\\n    let message = messageGenerator(errorCode, details);\\n\\n    super(message);\\n\\n    this.name = errorCode;\\n    this.details = details;\\n  }\\n}\\n\\nexport {WorkboxError};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\\nimport '../_version.mjs';\\n\\n/*\\n * This method returns true if the current context is a service worker.\\n */\\nconst isSWEnv = (moduleName) => {\\n  if (!('ServiceWorkerGlobalScope' in self)) {\\n    throw new WorkboxError('not-in-sw', {moduleName});\\n  }\\n};\\n\\n/*\\n * This method throws if the supplied value is not an array.\\n * The destructed values are required to produce a meaningful error for users.\\n * The destructed and restructured object is so it's clear what is\\n * needed.\\n */\\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\\n  if (!Array.isArray(value)) {\\n    throw new WorkboxError('not-an-array', {\\n      moduleName,\\n      className,\\n      funcName,\\n      paramName,\\n    });\\n  }\\n};\\n\\nconst hasMethod = (object, expectedMethod,\\n    {moduleName, className, funcName, paramName}) => {\\n  const type = typeof object[expectedMethod];\\n  if (type !== 'function') {\\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\\n      moduleName, className, funcName});\\n  }\\n};\\n\\nconst isType = (object, expectedType,\\n    {moduleName, className, funcName, paramName}) => {\\n  if (typeof object !== expectedType) {\\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\\n      moduleName, className, funcName});\\n  }\\n};\\n\\nconst isInstance = (object, expectedClass,\\n    {moduleName, className, funcName,\\n      paramName, isReturnValueProblem}) => {\\n  if (!(object instanceof expectedClass)) {\\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\\n      moduleName, className, funcName, isReturnValueProblem});\\n  }\\n};\\n\\nconst isOneOf = (value, validValues, {paramName}) => {\\n  if (!validValues.includes(value)) {\\n    throw new WorkboxError('invalid-value', {\\n      paramName,\\n      value,\\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\\n    });\\n  }\\n};\\n\\nconst isArrayOfClass = (value, expectedClass,\\n    {moduleName, className, funcName, paramName}) => {\\n  const error = new WorkboxError('not-array-of-class', {\\n    value, expectedClass,\\n    moduleName, className, funcName, paramName,\\n  });\\n  if (!Array.isArray(value)) {\\n    throw error;\\n  }\\n\\n  for (let item of value) {\\n    if (!(item instanceof expectedClass)) {\\n      throw error;\\n    }\\n  }\\n};\\n\\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\\n  hasMethod,\\n  isArray,\\n  isInstance,\\n  isOneOf,\\n  isSWEnv,\\n  isType,\\n  isArrayOfClass,\\n};\\n\\nexport {finalAssertExports as assert};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n// Callbacks to be executed whenever there's a quota error.\\nconst quotaErrorCallbacks = new Set();\\n\\nexport {quotaErrorCallbacks};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from './_private/logger.mjs';\\nimport {assert} from './_private/assert.mjs';\\nimport {quotaErrorCallbacks} from './models/quotaErrorCallbacks.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\\n * there's a quota error.\\n *\\n * @param {Function} callback\\n * @memberof workbox.core\\n */\\nfunction registerQuotaErrorCallback(callback) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    assert.isType(callback, 'function', {\\n      moduleName: 'workbox-core',\\n      funcName: 'register',\\n      paramName: 'callback',\\n    });\\n  }\\n\\n  quotaErrorCallbacks.add(callback);\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.log('Registered a callback to respond to quota errors.', callback);\\n  }\\n}\\n\\nexport {registerQuotaErrorCallback};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\nconst _cacheNameDetails = {\\n  googleAnalytics: 'googleAnalytics',\\n  precache: 'precache-v2',\\n  prefix: 'workbox',\\n  runtime: 'runtime',\\n  suffix: self.registration.scope,\\n};\\n\\nconst _createCacheName = (cacheName) => {\\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\\n      .filter((value) => value.length > 0)\\n      .join('-');\\n};\\n\\nexport const cacheNames = {\\n  updateDetails: (details) => {\\n    Object.keys(_cacheNameDetails).forEach((key) => {\\n      if (typeof details[key] !== 'undefined') {\\n        _cacheNameDetails[key] = details[key];\\n      }\\n    });\\n  },\\n  getGoogleAnalyticsName: (userCacheName) => {\\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\\n  },\\n  getPrecacheName: (userCacheName) => {\\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\\n  },\\n  getPrefix: () => {\\n    return _cacheNameDetails.prefix;\\n  },\\n  getRuntimeName: (userCacheName) => {\\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\\n  },\\n  getSuffix: () => {\\n    return _cacheNameDetails.suffix;\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\nconst getFriendlyURL = (url) => {\\n  const urlObj = new URL(url, location);\\n  if (urlObj.origin === location.origin) {\\n    return urlObj.pathname;\\n  }\\n  return urlObj.href;\\n};\\n\\nexport {getFriendlyURL};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from '../_private/logger.mjs';\\nimport {quotaErrorCallbacks} from '../models/quotaErrorCallbacks.mjs';\\nimport '../_version.mjs';\\n\\n\\n/**\\n * Runs all of the callback functions, one at a time sequentially, in the order\\n * in which they were registered.\\n *\\n * @memberof workbox.core\\n * @private\\n */\\nasync function executeQuotaErrorCallbacks() {\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.log(`About to run ${quotaErrorCallbacks.size} ` +\\n        `callbacks to clean up caches.`);\\n  }\\n\\n  for (const callback of quotaErrorCallbacks) {\\n    await callback();\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.log(callback, 'is complete.');\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.log('Finished running callbacks.');\\n  }\\n}\\n\\nexport {executeQuotaErrorCallbacks};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\nexport const pluginEvents = {\\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\\n  CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\\n  FETCH_DID_FAIL: 'fetchDidFail',\\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\\n  REQUEST_WILL_FETCH: 'requestWillFetch',\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\nexport const pluginUtils = {\\n  filter: (plugins, callbackName) => {\\n    return plugins.filter((plugin) => callbackName in plugin);\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {WorkboxError} from './WorkboxError.mjs';\\nimport {assert} from './assert.mjs';\\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\\nimport {logger} from './logger.mjs';\\nimport {executeQuotaErrorCallbacks} from './executeQuotaErrorCallbacks.mjs';\\nimport {pluginEvents} from '../models/pluginEvents.mjs';\\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\\nimport '../_version.mjs';\\n\\n\\n/**\\n * Wrapper around cache.put().\\n *\\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\\n * `matchOptions` when determining what the old entry is.\\n *\\n * @param {Object} options\\n * @param {string} options.cacheName\\n * @param {Request} options.request\\n * @param {Response} options.response\\n * @param {Event} [options.event]\\n * @param {Array<Object>} [options.plugins=[]]\\n * @param {Object} [options.matchOptions]\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst putWrapper = async ({\\n  cacheName,\\n  request,\\n  response,\\n  event,\\n  plugins = [],\\n  matchOptions,\\n} = {}) => {\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (request.method && request.method !== 'GET') {\\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\\n        url: getFriendlyURL(request.url),\\n        method: request.method,\\n      });\\n    }\\n  }\\n\\n  const effectiveRequest = await _getEffectiveRequest({\\n    plugins, request, mode: 'write'});\\n\\n  if (!response) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.error(`Cannot cache non-existent response for ` +\\n        `'${getFriendlyURL(effectiveRequest.url)}'.`);\\n    }\\n\\n    throw new WorkboxError('cache-put-with-no-response', {\\n      url: getFriendlyURL(effectiveRequest.url),\\n    });\\n  }\\n\\n  let responseToCache = await _isResponseSafeToCache({\\n    event,\\n    plugins,\\n    response,\\n    request: effectiveRequest,\\n  });\\n\\n  if (!responseToCache) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\\n      `not be cached.`, responseToCache);\\n    }\\n    return;\\n  }\\n\\n  const cache = await caches.open(cacheName);\\n\\n  const updatePlugins = pluginUtils.filter(\\n      plugins, pluginEvents.CACHE_DID_UPDATE);\\n\\n  let oldResponse = updatePlugins.length > 0 ?\\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\\n      null;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\\n      `${getFriendlyURL(effectiveRequest.url)}.`);\\n  }\\n\\n  try {\\n    await cache.put(effectiveRequest, responseToCache);\\n  } catch (error) {\\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\\n    if (error.name === 'QuotaExceededError') {\\n      await executeQuotaErrorCallbacks();\\n    }\\n    throw error;\\n  }\\n\\n  for (let plugin of updatePlugins) {\\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\\n      cacheName,\\n      event,\\n      oldResponse,\\n      newResponse: responseToCache,\\n      request: effectiveRequest,\\n    });\\n  }\\n};\\n\\n/**\\n * This is a wrapper around cache.match().\\n *\\n * @param {Object} options\\n * @param {string} options.cacheName Name of the cache to match against.\\n * @param {Request} options.request The Request that will be used to look up\\n *     cache entries.\\n * @param {Event} [options.event] The event that propted the action.\\n * @param {Object} [options.matchOptions] Options passed to cache.match().\\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\\n * @return {Response} A cached response if available.\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst matchWrapper = async ({\\n  cacheName,\\n  request,\\n  event,\\n  matchOptions,\\n  plugins = [],\\n}) => {\\n  const cache = await caches.open(cacheName);\\n\\n  const effectiveRequest = await _getEffectiveRequest({\\n    plugins, request, mode: 'read'});\\n\\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (cachedResponse) {\\n      logger.debug(`Found a cached response in '${cacheName}'.`);\\n    } else {\\n      logger.debug(`No cached response found in '${cacheName}'.`);\\n    }\\n  }\\n\\n  for (const plugin of plugins) {\\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\\n          .call(plugin, {\\n            cacheName,\\n            event,\\n            matchOptions,\\n            cachedResponse,\\n            request: effectiveRequest,\\n          });\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (cachedResponse) {\\n          assert.isInstance(cachedResponse, Response, {\\n            moduleName: 'Plugin',\\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\\n            isReturnValueProblem: true,\\n          });\\n        }\\n      }\\n    }\\n  }\\n\\n  return cachedResponse;\\n};\\n\\n/**\\n * This method will call cacheWillUpdate on the available plugins (or use\\n * status === 200) to determine if the Response is safe and valid to cache.\\n *\\n * @param {Object} options\\n * @param {Request} options.request\\n * @param {Response} options.response\\n * @param {Event} [options.event]\\n * @param {Array<Object>} [options.plugins=[]]\\n * @return {Promise<Response>}\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\\n  let responseToCache = response;\\n  let pluginsUsed = false;\\n  for (let plugin of plugins) {\\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\\n      pluginsUsed = true;\\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\\n          .call(plugin, {\\n            request,\\n            response: responseToCache,\\n            event,\\n          });\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (responseToCache) {\\n          assert.isInstance(responseToCache, Response, {\\n            moduleName: 'Plugin',\\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\\n            isReturnValueProblem: true,\\n          });\\n        }\\n      }\\n\\n      if (!responseToCache) {\\n        break;\\n      }\\n    }\\n  }\\n\\n  if (!pluginsUsed) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!responseToCache.status === 200) {\\n        if (responseToCache.status === 0) {\\n          logger.warn(`The response for '${request.url}' is an opaque ` +\\n            `response. The caching strategy that you're using will not ` +\\n            `cache opaque responses by default.`);\\n        } else {\\n          logger.debug(`The response for '${request.url}' returned ` +\\n          `a status code of '${response.status}' and won't be cached as a ` +\\n          `result.`);\\n        }\\n      }\\n    }\\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\\n  }\\n\\n  return responseToCache ? responseToCache : null;\\n};\\n\\n/**\\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\\n * executes any of those callbacks found in sequence. The final `Request` object\\n * returned by the last plugin is treated as the cache key for cache reads\\n * and/or writes.\\n *\\n * @param {Object} options\\n * @param {Request} options.request\\n * @param {string} options.mode\\n * @param {Array<Object>} [options.plugins=[]]\\n * @return {Promise<Request>}\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(\\n      plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\\n\\n  let effectiveRequest = request;\\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(\\n        plugin, {mode, request: effectiveRequest});\\n\\n    if (typeof effectiveRequest === 'string') {\\n      effectiveRequest = new Request(effectiveRequest);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(effectiveRequest, Request, {\\n        moduleName: 'Plugin',\\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\\n        isReturnValueProblem: true,\\n      });\\n    }\\n  }\\n\\n  return effectiveRequest;\\n};\\n\\nexport const cacheWrapper = {\\n  put: putWrapper,\\n  match: matchWrapper,\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n/**\\n * A class that wraps common IndexedDB functionality in a promise-based API.\\n * It exposes all the underlying power and functionality of IndexedDB, but\\n * wraps the most commonly used features in a way that's much simpler to use.\\n *\\n * @private\\n */\\nexport class DBWrapper {\\n  /**\\n   * @param {string} name\\n   * @param {number} version\\n   * @param {Object=} [callback]\\n   * @param {!Function} [callbacks.onupgradeneeded]\\n   * @param {!Function} [callbacks.onversionchange] Defaults to\\n   *     DBWrapper.prototype._onversionchange when not specified.\\n   * @private\\n   */\\n  constructor(name, version, {\\n    onupgradeneeded,\\n    onversionchange = this._onversionchange,\\n  } = {}) {\\n    this._name = name;\\n    this._version = version;\\n    this._onupgradeneeded = onupgradeneeded;\\n    this._onversionchange = onversionchange;\\n\\n    // If this is null, it means the database isn't open.\\n    this._db = null;\\n  }\\n\\n  /**\\n   * Returns the IDBDatabase instance (not normally needed).\\n   *\\n   * @private\\n   */\\n  get db() {\\n    return this._db;\\n  }\\n\\n  /**\\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\\n   * callback, and added an onversionchange callback to the database.\\n   *\\n   * @return {IDBDatabase}\\n   * @private\\n   */\\n  async open() {\\n    if (this._db) return;\\n\\n    this._db = await new Promise((resolve, reject) => {\\n      // This flag is flipped to true if the timeout callback runs prior\\n      // to the request failing or succeeding. Note: we use a timeout instead\\n      // of an onblocked handler since there are cases where onblocked will\\n      // never never run. A timeout better handles all possible scenarios:\\n      // https://github.com/w3c/IndexedDB/issues/223\\n      let openRequestTimedOut = false;\\n      setTimeout(() => {\\n        openRequestTimedOut = true;\\n        reject(new Error('The open request was blocked and timed out'));\\n      }, this.OPEN_TIMEOUT);\\n\\n      const openRequest = indexedDB.open(this._name, this._version);\\n      openRequest.onerror = () => reject(openRequest.error);\\n      openRequest.onupgradeneeded = (evt) => {\\n        if (openRequestTimedOut) {\\n          openRequest.transaction.abort();\\n          evt.target.result.close();\\n        } else if (this._onupgradeneeded) {\\n          this._onupgradeneeded(evt);\\n        }\\n      };\\n      openRequest.onsuccess = ({target}) => {\\n        const db = target.result;\\n        if (openRequestTimedOut) {\\n          db.close();\\n        } else {\\n          db.onversionchange = this._onversionchange.bind(this);\\n          resolve(db);\\n        }\\n      };\\n    });\\n\\n    return this;\\n  }\\n\\n  /**\\n   * Polyfills the native `getKey()` method. Note, this is overridden at\\n   * runtime if the browser supports the native method.\\n   *\\n   * @param {string} storeName\\n   * @param {*} query\\n   * @return {Array}\\n   * @private\\n   */\\n  async getKey(storeName, query) {\\n    return (await this.getAllKeys(storeName, query, 1))[0];\\n  }\\n\\n  /**\\n   * Polyfills the native `getAll()` method. Note, this is overridden at\\n   * runtime if the browser supports the native method.\\n   *\\n   * @param {string} storeName\\n   * @param {*} query\\n   * @param {number} count\\n   * @return {Array}\\n   * @private\\n   */\\n  async getAll(storeName, query, count) {\\n    return await this.getAllMatching(storeName, {query, count});\\n  }\\n\\n\\n  /**\\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\\n   * runtime if the browser supports the native method.\\n   *\\n   * @param {string} storeName\\n   * @param {*} query\\n   * @param {number} count\\n   * @return {Array}\\n   * @private\\n   */\\n  async getAllKeys(storeName, query, count) {\\n    return (await this.getAllMatching(\\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\\n  }\\n\\n  /**\\n   * Supports flexible lookup in an object store by specifying an index,\\n   * query, direction, and count. This method returns an array of objects\\n   * with the signature .\\n   *\\n   * @param {string} storeName\\n   * @param {Object} [opts]\\n   * @param {string} [opts.index] The index to use (if specified).\\n   * @param {*} [opts.query]\\n   * @param {IDBCursorDirection} [opts.direction]\\n   * @param {number} [opts.count] The max number of results to return.\\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\\n   *     returned objects is changed from an array of values to an array of\\n   *     objects in the form {key, primaryKey, value}.\\n   * @return {Array}\\n   * @private\\n   */\\n  async getAllMatching(storeName, {\\n    index,\\n    query = null, // IE errors if query === `undefined`.\\n    direction = 'next',\\n    count,\\n    includeKeys,\\n  } = {}) {\\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\\n      const store = txn.objectStore(storeName);\\n      const target = index ? store.index(index) : store;\\n      const results = [];\\n\\n      target.openCursor(query, direction).onsuccess = ({target}) => {\\n        const cursor = target.result;\\n        if (cursor) {\\n          const {primaryKey, key, value} = cursor;\\n          results.push(includeKeys ? {primaryKey, key, value} : value);\\n          if (count && results.length >= count) {\\n            done(results);\\n          } else {\\n            cursor.continue();\\n          }\\n        } else {\\n          done(results);\\n        }\\n      };\\n    });\\n  }\\n\\n  /**\\n   * Accepts a list of stores, a transaction type, and a callback and\\n   * performs a transaction. A promise is returned that resolves to whatever\\n   * value the callback chooses. The callback holds all the transaction logic\\n   * and is invoked with two arguments:\\n   *   1. The IDBTransaction object\\n   *   2. A `done` function, that's used to resolve the promise when\\n   *      when the transaction is done, if passed a value, the promise is\\n   *      resolved to that value.\\n   *\\n   * @param {Array<string>} storeNames An array of object store names\\n   *     involved in the transaction.\\n   * @param {string} type Can be `readonly` or `readwrite`.\\n   * @param {!Function} callback\\n   * @return {*} The result of the transaction ran by the callback.\\n   * @private\\n   */\\n  async transaction(storeNames, type, callback) {\\n    await this.open();\\n    return await new Promise((resolve, reject) => {\\n      const txn = this._db.transaction(storeNames, type);\\n      txn.onabort = ({target}) => reject(target.error);\\n      txn.oncomplete = () => resolve();\\n\\n      callback(txn, (value) => resolve(value));\\n    });\\n  }\\n\\n  /**\\n   * Delegates async to a native IDBObjectStore method.\\n   *\\n   * @param {string} method The method name.\\n   * @param {string} storeName The object store name.\\n   * @param {string} type Can be `readonly` or `readwrite`.\\n   * @param {...*} args The list of args to pass to the native method.\\n   * @return {*} The result of the transaction.\\n   * @private\\n   */\\n  async _call(method, storeName, type, ...args) {\\n    const callback = (txn, done) => {\\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\\n        done(target.result);\\n      };\\n    };\\n\\n    return await this.transaction([storeName], type, callback);\\n  }\\n\\n  /**\\n   * The default onversionchange handler, which closes the database so other\\n   * connections can open without being blocked.\\n   *\\n   * @private\\n   */\\n  _onversionchange() {\\n    this.close();\\n  }\\n\\n  /**\\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\\n   * doesn't need to be called since:\\n   *   1. It's usually better to keep a connection open since opening\\n   *      a new connection is somewhat slow.\\n   *   2. Connections are automatically closed when the reference is\\n   *      garbage collected.\\n   * The primary use case for needing to close a connection is when another\\n   * reference (typically in another tab) needs to upgrade it and would be\\n   * blocked by the current, open connection.\\n   *\\n   * @private\\n   */\\n  close() {\\n    if (this._db) {\\n      this._db.close();\\n      this._db = null;\\n    }\\n  }\\n}\\n\\n// Exposed to let users modify the default timeout on a per-instance\\n// or global basis.\\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\\n\\n// Wrap native IDBObjectStore methods according to their mode.\\nconst methodsToWrap = {\\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\\n  'readwrite': ['add', 'put', 'clear', 'delete'],\\n};\\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\\n  for (const method of methods) {\\n    if (method in IDBObjectStore.prototype) {\\n      // Don't use arrow functions here since we're outside of the class.\\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\\n        return await this._call(method, storeName, mode, ...args);\\n      };\\n    }\\n  }\\n}\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n/**\\n * The Deferred class composes Promises in a way that allows for them to be\\n * resolved or rejected from outside the constructor. In most cases promises\\n * should be used directly, but Deferreds can be necessary when the logic to\\n * resolve a promise must be separate.\\n *\\n * @private\\n */\\nexport class Deferred {\\n  /**\\n   * Creates a promise and exposes its resolve and reject functions as methods.\\n   */\\n  constructor() {\\n    this.promise = new Promise((resolve, reject) => {\\n      this.resolve = resolve;\\n      this.reject = reject;\\n    });\\n  }\\n}\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n/**\\n * Deletes the database.\\n * Note: this is exported separately from the DBWrapper module because most\\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\\n * reused in tests to delete databases without creating DBWrapper instances.\\n *\\n * @param {string} name The database name.\\n * @private\\n */\\nexport const deleteDatabase = async (name) => {\\n  await new Promise((resolve, reject) => {\\n    const request = indexedDB.deleteDatabase(name);\\n    request.onerror = ({target}) => {\\n      reject(target.error);\\n    };\\n    request.onblocked = () => {\\n      reject(new Error('Delete blocked'));\\n    };\\n    request.onsuccess = () => {\\n      resolve();\\n    };\\n  });\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {WorkboxError} from './WorkboxError.mjs';\\nimport {logger} from './logger.mjs';\\nimport {assert} from './assert.mjs';\\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\\nimport {pluginEvents} from '../models/pluginEvents.mjs';\\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\\nimport '../_version.mjs';\\n\\n/**\\n * Wrapper around the fetch API.\\n *\\n * Will call requestWillFetch on available plugins.\\n *\\n * @param {Object} options\\n * @param {Request|string} options.request\\n * @param {Object} [options.fetchOptions]\\n * @param {Event} [options.event]\\n * @param {Array<Object>} [options.plugins=[]]\\n * @return {Promise<Response>}\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst wrappedFetch = async ({\\n  request,\\n  fetchOptions,\\n  event,\\n  plugins = []}) => {\\n  // We *should* be able to call `await event.preloadResponse` even if it's\\n  // undefined, but for some reason, doing so leads to errors in our Node unit\\n  // tests. To work around that, explicitly check preloadResponse's value first.\\n  if (event && event.preloadResponse) {\\n    const possiblePreloadResponse = await event.preloadResponse;\\n    if (possiblePreloadResponse) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.log(`Using a preloaded navigation response for ` +\\n          `'${getFriendlyURL(request.url)}'`);\\n      }\\n      return possiblePreloadResponse;\\n    }\\n  }\\n\\n  if (typeof request === 'string') {\\n    request = new Request(request);\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    assert.isInstance(request, Request, {\\n      paramName: request,\\n      expectedClass: 'Request',\\n      moduleName: 'workbox-core',\\n      className: 'fetchWrapper',\\n      funcName: 'wrappedFetch',\\n    });\\n  }\\n\\n  const failedFetchPlugins = pluginUtils.filter(\\n      plugins, pluginEvents.FETCH_DID_FAIL);\\n\\n  // If there is a fetchDidFail plugin, we need to save a clone of the\\n  // original request before it's either modified by a requestWillFetch\\n  // plugin or before the original request's body is consumed via fetch().\\n  const originalRequest = failedFetchPlugins.length > 0 ?\\n    request.clone() : null;\\n\\n  try {\\n    for (let plugin of plugins) {\\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\\n          request: request.clone(),\\n          event,\\n        });\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          if (request) {\\n            assert.isInstance(request, Request, {\\n              moduleName: 'Plugin',\\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\\n              isReturnValueProblem: true,\\n            });\\n          }\\n        }\\n      }\\n    }\\n  } catch (err) {\\n    throw new WorkboxError('plugin-error-request-will-fetch', {\\n      thrownError: err,\\n    });\\n  }\\n\\n  // The request can be altered by plugins with `requestWillFetch` making\\n  // the original request (Most likely from a `fetch` event) to be different\\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\\n  let pluginFilteredRequest = request.clone();\\n\\n  try {\\n    let fetchResponse;\\n\\n    // See https://github.com/GoogleChrome/workbox/issues/1796\\n    if (request.mode === 'navigate') {\\n      fetchResponse = await fetch(request);\\n    } else {\\n      fetchResponse = await fetch(request, fetchOptions);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.debug(`Network request for `+\\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\\n      `status '${fetchResponse.status}'.`);\\n    }\\n\\n    for (const plugin of plugins) {\\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\\n            .call(plugin, {\\n              event,\\n              request: pluginFilteredRequest,\\n              response: fetchResponse,\\n            });\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          if (fetchResponse) {\\n            assert.isInstance(fetchResponse, Response, {\\n              moduleName: 'Plugin',\\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\\n              isReturnValueProblem: true,\\n            });\\n          }\\n        }\\n      }\\n    }\\n\\n    return fetchResponse;\\n  } catch (error) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.error(`Network request for `+\\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\\n    }\\n\\n    for (const plugin of failedFetchPlugins) {\\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\\n        error,\\n        event,\\n        originalRequest: originalRequest.clone(),\\n        request: pluginFilteredRequest.clone(),\\n      });\\n    }\\n\\n    throw error;\\n  }\\n};\\n\\nconst fetchWrapper = {\\n  fetch: wrappedFetch,\\n};\\n\\nexport {fetchWrapper};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\n// We either expose defaults or we expose every named export.\\nimport {assert} from './_private/assert.mjs';\\nimport {cacheNames} from './_private/cacheNames.mjs';\\nimport {cacheWrapper} from './_private/cacheWrapper.mjs';\\nimport {DBWrapper} from './_private/DBWrapper.mjs';\\nimport {Deferred} from './_private/Deferred.mjs';\\nimport {deleteDatabase} from './_private/deleteDatabase.mjs';\\nimport {executeQuotaErrorCallbacks} from './_private/executeQuotaErrorCallbacks.mjs';\\nimport {fetchWrapper} from './_private/fetchWrapper.mjs';\\nimport {getFriendlyURL} from './_private/getFriendlyURL.mjs';\\nimport {logger} from './_private/logger.mjs';\\nimport {WorkboxError} from './_private/WorkboxError.mjs';\\n\\nimport './_version.mjs';\\n\\nexport {\\n  assert,\\n  cacheNames,\\n  cacheWrapper,\\n  DBWrapper,\\n  Deferred,\\n  deleteDatabase,\\n  executeQuotaErrorCallbacks,\\n  fetchWrapper,\\n  getFriendlyURL,\\n  logger,\\n  WorkboxError,\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport './_version.mjs';\\n\\n\\n/**\\n * Claim any currently available clients once the service worker\\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\\n *\\n * @alias workbox.core.clientsClaim\\n */\\nexport const clientsClaim = () => {\\n  addEventListener('activate', () => clients.claim());\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {cacheNames as _cacheNames} from './_private/cacheNames.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Get the current cache names and prefix/suffix used by Workbox.\\n *\\n * `cacheNames.precache` is used for precached assets,\\n * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\\n * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\\n *\\n * `cacheNames.prefix` can be used to retrieve just the current prefix value.\\n * `cacheNames.suffix` can be used to retrieve just the current suffix value.\\n *\\n * @return {Object} An object with `precache`, `runtime`, `prefix`, and\\n *     `googleAnalytics` properties.\\n *\\n * @alias workbox.core.cacheNames\\n */\\nexport const cacheNames = {\\n  get googleAnalytics() {\\n    return _cacheNames.getGoogleAnalyticsName();\\n  },\\n  get precache() {\\n    return _cacheNames.getPrecacheName();\\n  },\\n  get prefix() {\\n    return _cacheNames.getPrefix();\\n  },\\n  get runtime() {\\n    return _cacheNames.getRuntimeName();\\n  },\\n  get suffix() {\\n    return _cacheNames.getSuffix();\\n  },\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from './_private/assert.mjs';\\nimport {cacheNames} from './_private/cacheNames.mjs';\\nimport {WorkboxError} from './_private/WorkboxError.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Modifies the default cache names used by the Workbox packages.\\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\\n *\\n * @param {Object} details\\n * @param {Object} [details.prefix] The string to add to the beginning of\\n *     the precache and runtime cache names.\\n * @param {Object} [details.suffix] The string to add to the end of\\n *     the precache and runtime cache names.\\n * @param {Object} [details.precache] The cache name to use for precache\\n *     caching.\\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\\n * @param {Object} [details.googleAnalytics] The cache name to use for\\n *     `workbox-google-analytics` caching.\\n *\\n * @alias workbox.core.setCacheNameDetails\\n */\\nexport const setCacheNameDetails = (details) => {\\n  if (process.env.NODE_ENV !== 'production') {\\n    Object.keys(details).forEach((key) => {\\n      assert.isType(details[key], 'string', {\\n        moduleName: 'workbox-core',\\n        funcName: 'setCacheNameDetails',\\n        paramName: `details.${key}`,\\n      });\\n    });\\n\\n    if ('precache' in details && details.precache.length === 0) {\\n      throw new WorkboxError('invalid-cache-name', {\\n        cacheNameId: 'precache',\\n        value: details.precache,\\n      });\\n    }\\n\\n    if ('runtime' in details && details.runtime.length === 0) {\\n      throw new WorkboxError('invalid-cache-name', {\\n        cacheNameId: 'runtime',\\n        value: details.runtime,\\n      });\\n    }\\n\\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\\n      throw new WorkboxError('invalid-cache-name', {\\n        cacheNameId: 'googleAnalytics',\\n        value: details.googleAnalytics,\\n      });\\n    }\\n  }\\n\\n  cacheNames.updateDetails(details);\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport './_version.mjs';\\n\\n\\n/**\\n * Force a service worker to become active, instead of waiting. This is\\n * normally used in conjunction with `clientsClaim()`.\\n *\\n * @alias workbox.core.skipWaiting\\n */\\nexport const skipWaiting = () => {\\n  // We need to explicitly call `self.skipWaiting()` here because we're\\n  // shadowing `skipWaiting` with this local function.\\n  addEventListener('install', () => self.skipWaiting());\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {registerQuotaErrorCallback} from './registerQuotaErrorCallback.mjs';\\nimport * as _private from './_private.mjs';\\nimport {clientsClaim} from './clientsClaim.mjs';\\nimport {cacheNames} from './cacheNames.mjs';\\nimport {setCacheNameDetails} from './setCacheNameDetails.mjs';\\nimport {skipWaiting} from './skipWaiting.mjs';\\nimport './_version.mjs';\\n\\n\\n// Give our version strings something to hang off of.\\ntry {\\n  self.workbox.v = self.workbox.v || {};\\n} catch (errer) {\\n  // NOOP\\n}\\n\\n/**\\n * All of the Workbox service worker libraries use workbox-core for shared\\n * code as well as setting default values that need to be shared (like cache\\n * names).\\n *\\n * @namespace workbox.core\\n */\\n\\nexport {\\n  _private,\\n  clientsClaim,\\n  cacheNames,\\n  registerQuotaErrorCallback,\\n  setCacheNameDetails,\\n  skipWaiting,\\n};\\n\"],\"names\":[\"self\",\"_\",\"e\",\"logger\",\"process\",\"inGroup\",\"methodToColorMap\",\"debug\",\"log\",\"warn\",\"error\",\"groupCollapsed\",\"groupEnd\",\"print\",\"method\",\"args\",\"test\",\"navigator\",\"userAgent\",\"console\",\"styles\",\"logPrefix\",\"join\",\"api\",\"Object\",\"keys\",\"messages\",\"paramName\",\"validValueDescription\",\"value\",\"Error\",\"JSON\",\"stringify\",\"moduleName\",\"className\",\"funcName\",\"expectedType\",\"expectedClass\",\"isReturnValueProblem\",\"name\",\"expectedMethod\",\"entry\",\"firstEntry\",\"secondEntry\",\"_entryId\",\"thrownError\",\"message\",\"cacheNameId\",\"methodName\",\"normalizedRangeHeader\",\"size\",\"start\",\"end\",\"url\",\"status\",\"generatorFunction\",\"code\",\"messageGenerator\",\"WorkboxError\",\"constructor\",\"errorCode\",\"details\",\"isSWEnv\",\"isArray\",\"Array\",\"hasMethod\",\"object\",\"type\",\"isType\",\"isInstance\",\"isOneOf\",\"validValues\",\"includes\",\"isArrayOfClass\",\"item\",\"finalAssertExports\",\"quotaErrorCallbacks\",\"Set\",\"registerQuotaErrorCallback\",\"callback\",\"assert\",\"add\",\"_cacheNameDetails\",\"googleAnalytics\",\"precache\",\"prefix\",\"runtime\",\"suffix\",\"registration\",\"scope\",\"_createCacheName\",\"cacheName\",\"filter\",\"length\",\"cacheNames\",\"updateDetails\",\"forEach\",\"key\",\"getGoogleAnalyticsName\",\"userCacheName\",\"getPrecacheName\",\"getPrefix\",\"getRuntimeName\",\"getSuffix\",\"getFriendlyURL\",\"urlObj\",\"URL\",\"location\",\"origin\",\"pathname\",\"href\",\"executeQuotaErrorCallbacks\",\"pluginEvents\",\"CACHE_DID_UPDATE\",\"CACHE_KEY_WILL_BE_USED\",\"CACHE_WILL_UPDATE\",\"CACHED_RESPONSE_WILL_BE_USED\",\"FETCH_DID_FAIL\",\"FETCH_DID_SUCCEED\",\"REQUEST_WILL_FETCH\",\"pluginUtils\",\"plugins\",\"callbackName\",\"plugin\",\"putWrapper\",\"request\",\"response\",\"event\",\"matchOptions\",\"effectiveRequest\",\"_getEffectiveRequest\",\"mode\",\"responseToCache\",\"_isResponseSafeToCache\",\"cache\",\"caches\",\"open\",\"updatePlugins\",\"oldResponse\",\"matchWrapper\",\"put\",\"call\",\"newResponse\",\"cachedResponse\",\"match\",\"Response\",\"pluginsUsed\",\"cacheKeyWillBeUsedPlugins\",\"Request\",\"cacheWrapper\",\"DBWrapper\",\"version\",\"onupgradeneeded\",\"onversionchange\",\"_onversionchange\",\"_name\",\"_version\",\"_onupgradeneeded\",\"_db\",\"db\",\"Promise\",\"resolve\",\"reject\",\"openRequestTimedOut\",\"setTimeout\",\"OPEN_TIMEOUT\",\"openRequest\",\"indexedDB\",\"onerror\",\"evt\",\"transaction\",\"abort\",\"target\",\"result\",\"close\",\"onsuccess\",\"bind\",\"getKey\",\"storeName\",\"query\",\"getAllKeys\",\"getAll\",\"count\",\"getAllMatching\",\"includeKeys\",\"map\",\"index\",\"direction\",\"txn\",\"done\",\"store\",\"objectStore\",\"results\",\"openCursor\",\"cursor\",\"primaryKey\",\"push\",\"continue\",\"storeNames\",\"onabort\",\"oncomplete\",\"_call\",\"prototype\",\"methodsToWrap\",\"methods\",\"entries\",\"IDBObjectStore\",\"Deferred\",\"promise\",\"deleteDatabase\",\"onblocked\",\"wrappedFetch\",\"fetchOptions\",\"preloadResponse\",\"possiblePreloadResponse\",\"failedFetchPlugins\",\"originalRequest\",\"clone\",\"err\",\"pluginFilteredRequest\",\"fetchResponse\",\"fetch\",\"fetchWrapper\",\"clientsClaim\",\"addEventListener\",\"clients\",\"claim\",\"_cacheNames\",\"setCacheNameDetails\",\"skipWaiting\",\"workbox\",\"v\",\"errer\"],\"mappings\":\";;;;EAAA,IAAG;EAACA,EAAAA,IAAI,CAAC,oBAAD,CAAJ,IAA4BC,CAAC,EAA7B;EAAgC,CAApC,CAAoC,OAAMC,CAAN,EAAQ;;ECA5C;;;;;;AAOA,EAGA,MAAMC,MAAM,GAAGC,AAA+C,CAAC,MAAM;EACnE,MAAIC,OAAO,GAAG,KAAd;EAEA,QAAMC,gBAAgB,GAAG;EACvBC,IAAAA,KAAK,EAAG,SADe;EACL;EAClBC,IAAAA,GAAG,EAAG,SAFiB;EAEP;EAChBC,IAAAA,IAAI,EAAG,SAHgB;EAGN;EACjBC,IAAAA,KAAK,EAAG,SAJe;EAIL;EAClBC,IAAAA,cAAc,EAAG,SALM;EAKI;EAC3BC,IAAAA,QAAQ,EAAE,IANa;;EAAA,GAAzB;;EASA,QAAMC,KAAK,GAAG,UAASC,MAAT,EAAiBC,IAAjB,EAAuB;EACnC,QAAID,MAAM,KAAK,gBAAf,EAAiC;EAC/B;EACA;EACA,UAAI,iCAAiCE,IAAjC,CAAsCC,SAAS,CAACC,SAAhD,CAAJ,EAAgE;EAC9DC,QAAAA,OAAO,CAACL,MAAD,CAAP,CAAgB,GAAGC,IAAnB;EACA;EACD;EACF;;EAED,UAAMK,MAAM,GAAG,CACZ,eAAcd,gBAAgB,CAACQ,MAAD,CAAS,EAD3B,EAEZ,sBAFY,EAGZ,cAHY,EAIZ,mBAJY,EAKZ,oBALY,CAAf,CAVmC;;EAmBnC,UAAMO,SAAS,GAAGhB,OAAO,GAAG,EAAH,GAAQ,CAAC,WAAD,EAAce,MAAM,CAACE,IAAP,CAAY,GAAZ,CAAd,CAAjC;EAEAH,IAAAA,OAAO,CAACL,MAAD,CAAP,CAAgB,GAAGO,SAAnB,EAA8B,GAAGN,IAAjC;;EAEA,QAAID,MAAM,KAAK,gBAAf,EAAiC;EAC/BT,MAAAA,OAAO,GAAG,IAAV;EACD;;EACD,QAAIS,MAAM,KAAK,UAAf,EAA2B;EACzBT,MAAAA,OAAO,GAAG,KAAV;EACD;EACF,GA7BD;;EA+BA,QAAMkB,GAAG,GAAG,EAAZ;;EACA,OAAK,MAAMT,MAAX,IAAqBU,MAAM,CAACC,IAAP,CAAYnB,gBAAZ,CAArB,EAAoD;EAClDiB,IAAAA,GAAG,CAACT,MAAD,CAAH,GAAc,CAAC,GAAGC,IAAJ,KAAa;EACzBF,MAAAA,KAAK,CAACC,MAAD,EAASC,IAAT,CAAL;EACD,KAFD;EAGD;;EAED,SAAOQ,GAAP;EACD,CAnD6D,GAA9D;;ECVA;;;;;;;AAQA,EAGO,MAAMG,QAAQ,GAAG;EACtB,mBAAiB,CAAC;EAACC,IAAAA,SAAD;EAAYC,IAAAA,qBAAZ;EAAmCC,IAAAA;EAAnC,GAAD,KAA+C;EAC9D,QAAI,CAACF,SAAD,IAAc,CAACC,qBAAnB,EAA0C;EACxC,YAAM,IAAIE,KAAJ,CAAW,4CAAX,CAAN;EACD;;EACD,WAAQ,QAAOH,SAAU,wCAAlB,GACJ,qBAAoBC,qBAAsB,uBADtC,GAEJ,GAAEG,IAAI,CAACC,SAAL,CAAeH,KAAf,CAAsB,GAF3B;EAGD,GARqB;EAUtB,eAAa,CAAC;EAACI,IAAAA;EAAD,GAAD,KAAkB;EAC7B,QAAI,CAACA,UAAL,EAAiB;EACf,YAAM,IAAIH,KAAJ,CAAW,wCAAX,CAAN;EACD;;EACD,WAAQ,QAAOG,UAAW,qCAA1B;EACD,GAfqB;EAiBtB,kBAAgB,CAAC;EAACA,IAAAA,UAAD;EAAaC,IAAAA,SAAb;EAAwBC,IAAAA,QAAxB;EAAkCR,IAAAA;EAAlC,GAAD,KAAkD;EAChE,QAAI,CAACM,UAAD,IAAe,CAACC,SAAhB,IAA6B,CAACC,QAA9B,IAA0C,CAACR,SAA/C,EAA0D;EACxD,YAAM,IAAIG,KAAJ,CAAW,2CAAX,CAAN;EACD;;EACD,WAAQ,kBAAiBH,SAAU,gBAA5B,GACJ,IAAGM,UAAW,IAAGC,SAAU,IAAGC,QAAS,uBAD1C;EAED,GAvBqB;EAyBtB,oBAAkB,CAAC;EAACC,IAAAA,YAAD;EAAeT,IAAAA,SAAf;EAA0BM,IAAAA,UAA1B;EAAsCC,IAAAA,SAAtC;EACjBC,IAAAA;EADiB,GAAD,KACF;EACd,QAAI,CAACC,YAAD,IAAiB,CAACT,SAAlB,IAA+B,CAACM,UAAhC,IAA8C,CAACE,QAAnD,EAA6D;EAC3D,YAAM,IAAIL,KAAJ,CAAW,6CAAX,CAAN;EACD;;EACD,WAAQ,kBAAiBH,SAAU,gBAA5B,GACJ,IAAGM,UAAW,IAAGC,SAAS,GAAIA,SAAS,GAAG,GAAhB,GAAuB,EAAG,EADhD,GAEJ,GAAEC,QAAS,uBAAsBC,YAAa,GAFjD;EAGD,GAjCqB;EAmCtB,qBAAmB,CAAC;EAACC,IAAAA,aAAD;EAAgBV,IAAAA,SAAhB;EAA2BM,IAAAA,UAA3B;EAAuCC,IAAAA,SAAvC;EAClBC,IAAAA,QADkB;EACRG,IAAAA;EADQ,GAAD,KACmB;EACpC,QAAI,CAACD,aAAD,IAAkB,CAACJ,UAAnB,IAAiC,CAACE,QAAtC,EAAgD;EAC9C,YAAM,IAAIL,KAAJ,CAAW,8CAAX,CAAN;EACD;;EAED,QAAIQ,oBAAJ,EAA0B;EACxB,aAAQ,wBAAD,GACJ,IAAGL,UAAW,IAAGC,SAAS,GAAIA,SAAS,GAAG,GAAhB,GAAuB,EAAG,GAAEC,QAAS,MAD3D,GAEJ,gCAA+BE,aAAa,CAACE,IAAK,GAFrD;EAGD;;EAED,WAAQ,kBAAiBZ,SAAU,gBAA5B,GACJ,IAAGM,UAAW,IAAGC,SAAS,GAAIA,SAAS,GAAG,GAAhB,GAAuB,EAAG,GAAEC,QAAS,MAD3D,GAEJ,gCAA+BE,aAAa,CAACE,IAAK,GAFrD;EAGD,GAlDqB;EAoDtB,sBAAoB,CAAC;EAACC,IAAAA,cAAD;EAAiBb,IAAAA,SAAjB;EAA4BM,IAAAA,UAA5B;EAAwCC,IAAAA,SAAxC;EACnBC,IAAAA;EADmB,GAAD,KACJ;EACd,QAAI,CAACK,cAAD,IAAmB,CAACb,SAApB,IAAiC,CAACM,UAAlC,IAAgD,CAACC,SAAjD,IACG,CAACC,QADR,EACkB;EAChB,YAAM,IAAIL,KAAJ,CAAW,+CAAX,CAAN;EACD;;EACD,WAAQ,GAAEG,UAAW,IAAGC,SAAU,IAAGC,QAAS,kBAAvC,GACJ,IAAGR,SAAU,4BAA2Ba,cAAe,WAD1D;EAED,GA5DqB;EA8DtB,uCAAqC,CAAC;EAACC,IAAAA;EAAD,GAAD,KAAa;EAChD,WAAQ,oCAAD,GACN,qEADM,GAEN,IAAGV,IAAI,CAACC,SAAL,CAAeS,KAAf,CAAsB,iDAFnB,GAGN,sEAHM,GAIN,kBAJD;EAKD,GApEqB;EAsEtB,2CAAyC,CAAC;EAACC,IAAAA,UAAD;EAAaC,IAAAA;EAAb,GAAD,KAA+B;EACtE,QAAI,CAACD,UAAD,IAAe,CAACC,WAApB,EAAiC;EAC/B,YAAM,IAAIb,KAAJ,CAAW,sBAAD,GACb,8CADG,CAAN;EAED;;EAED,WAAQ,+BAAD,GACJ,uEADI,GAEJ,GAAEY,UAAU,CAACE,QAAS,8CAFlB,GAGJ,wEAHI,GAIJ,iBAJH;EAKD,GAjFqB;EAmFtB,qCAAmC,CAAC;EAACC,IAAAA;EAAD,GAAD,KAAmB;EACpD,QAAI,CAACA,WAAL,EAAkB;EAChB,YAAM,IAAIf,KAAJ,CAAW,sBAAD,GACb,2CADG,CAAN;EAED;;EAED,WAAQ,gEAAD,GACJ,kCAAiCe,WAAW,CAACC,OAAQ,IADxD;EAED,GA3FqB;EA6FtB,wBAAsB,CAAC;EAACC,IAAAA,WAAD;EAAclB,IAAAA;EAAd,GAAD,KAA0B;EAC9C,QAAI,CAACkB,WAAL,EAAkB;EAChB,YAAM,IAAIjB,KAAJ,CACD,yDADC,CAAN;EAED;;EAED,WAAQ,gEAAD,GACJ,oBAAmBiB,WAAY,iCAD3B,GAEJ,IAAGhB,IAAI,CAACC,SAAL,CAAeH,KAAf,CAAsB,GAF5B;EAGD,GAtGqB;EAwGtB,gDAA8C,CAAC;EAACf,IAAAA;EAAD,GAAD,KAAc;EAC1D,QAAI,CAACA,MAAL,EAAa;EACX,YAAM,IAAIgB,KAAJ,CAAW,sBAAD,GACb,qDADG,CAAN;EAED;;EAED,WAAQ,4DAAD,GACJ,mCAAkChB,MAAO,IAD5C;EAED,GAhHqB;EAkHtB,2CAAyC,MAAM;EAC7C,WAAQ,2DAAD,GACJ,aADH;EAED,GArHqB;EAuHtB,yBAAuB,CAAC;EAACyB,IAAAA;EAAD,GAAD,KAAY;EACjC,WAAQ,wCAAuCA,IAAK,WAApD;EACD,GAzHqB;EA2HtB,0BAAwB,CAAC;EAACA,IAAAA;EAAD,GAAD,KAAY;EAClC,WAAQ,mBAAkBA,IAAK,2BAAxB,GACF,mEADL;EAED,GA9HqB;EAgItB,kCAAgC,CAAC;EAACS,IAAAA,UAAD;EAAarB,IAAAA;EAAb,GAAD,KAA6B;EAC3D,WAAQ,QAAOqB,UAAW,uCAAnB,GACJ,IAAGrB,SAAU,+BADhB;EAED,GAnIqB;EAqItB,4BAA0B,CAAC;EAACM,IAAAA,UAAD;EAAaC,IAAAA,SAAb;EAAwBC,IAAAA,QAAxB;EAAkCR,IAAAA;EAAlC,GAAD,KAAkD;EAC1E,WAAQ,iBAAgBA,SAAU,uCAA3B,GACJ,6BAA4BM,UAAW,IAAGC,SAAU,IAAGC,QAAS,OAD5D,GAEJ,oBAFH;EAGD,GAzIqB;EA2ItB,wBAAsB,CAAC;EAACN,IAAAA,KAAD;EAAQQ,IAAAA,aAAR;EACrBJ,IAAAA,UADqB;EACTC,IAAAA,SADS;EACEC,IAAAA,QADF;EACYR,IAAAA;EADZ,GAAD,KAC4B;EAChD,WAAQ,iBAAgBA,SAAU,kCAA3B,GACJ,IAAGU,aAAc,wBAAuBN,IAAI,CAACC,SAAL,CAAeH,KAAf,CAAsB,MAD1D,GAEJ,4BAA2BI,UAAW,IAAGC,SAAU,IAAGC,QAAS,KAF3D,GAGJ,mBAHH;EAID,GAjJqB;EAmJtB,iCAA+B,CAAC;EAACF,IAAAA,UAAD;EAAaC,IAAAA,SAAb;EAAwBC,IAAAA;EAAxB,GAAD,KAAuC;EACpE,WAAQ,kEAAD,GACJ,MAAKF,UAAW,IAAGC,SAAU,IAAGC,QAAS,EAD5C;EAED,GAtJqB;EAwJtB,kCAAgC,CAAC;EAACF,IAAAA,UAAD;EAAaC,IAAAA,SAAb;EAAwBC,IAAAA;EAAxB,GAAD,KAAuC;EACrE,WAAQ,0DAAD,GACJ,MAAKF,UAAW,IAAGC,SAAU,IAAGC,QAAS,EAD5C;EAED,GA3JqB;EA6JtB,oBAAkB,CAAC;EAACF,IAAAA,UAAD;EAAaC,IAAAA,SAAb;EAAwBC,IAAAA,QAAxB;EAAkCR,IAAAA;EAAlC,GAAD,KAAkD;EAClE,QAAI,CAACA,SAAD,IAAc,CAACM,UAAf,IAA6B,CAACE,QAAlC,EAA4C;EAC1C,YAAM,IAAIL,KAAJ,CAAW,6CAAX,CAAN;EACD;;EACD,WAAQ,4BAA2BH,SAAU,8BAAtC,GACJ,sEADI,GAEJ,2BAA0BM,UAAW,IAAGE,QAAS,SAF7C,GAGJ,YAHH;EAID,GArKqB;EAuKtB,2BAAyB,MAAM;EAC7B,WAAQ,gDAAD,GACN,gCADD;EAED,GA1KqB;EA4KtB,qCAAmC,MAAM;EACvC,WAAQ,4DAAD,GACJ,kDADH;EAED,GA/KqB;EAiLtB,+BAA6B,MAAM;EACjC,WAAQ,yDAAD,GACJ,oDADH;EAED,GApLqB;EAsLtB,wBAAsB,CAAC;EAACc,IAAAA;EAAD,GAAD,KAA6B;EACjD,QAAI,CAACA,qBAAL,EAA4B;EAC1B,YAAM,IAAInB,KAAJ,CAAW,iDAAX,CAAN;EACD;;EACD,WAAQ,iEAAD,GACJ,kCAAiCmB,qBAAsB,GAD1D;EAED,GA5LqB;EA8LtB,uBAAqB,CAAC;EAACA,IAAAA;EAAD,GAAD,KAA6B;EAChD,QAAI,CAACA,qBAAL,EAA4B;EAC1B,YAAM,IAAInB,KAAJ,CAAW,gDAAX,CAAN;EACD;;EACD,WAAQ,gEAAD,GACJ,+DADI,GAEJ,IAAGmB,qBAAsB,GAF5B;EAGD,GArMqB;EAuMtB,0BAAwB,CAAC;EAACA,IAAAA;EAAD,GAAD,KAA6B;EACnD,QAAI,CAACA,qBAAL,EAA4B;EAC1B,YAAM,IAAInB,KAAJ,CAAW,mDAAX,CAAN;EACD;;EACD,WAAQ,kEAAD,GACJ,+DADI,GAEJ,IAAGmB,qBAAsB,GAF5B;EAGD,GA9MqB;EAgNtB,qBAAmB,MAAM;EACvB,WAAQ,oDAAR;EACD,GAlNqB;EAoNtB,2BAAyB,CAAC;EAACC,IAAAA,IAAD;EAAOC,IAAAA,KAAP;EAAcC,IAAAA;EAAd,GAAD,KAAwB;EAC/C,WAAQ,cAAaD,KAAM,cAAaC,GAAI,4BAArC,GACJ,oDAAmDF,IAAK,SAD3D;EAED,GAvNqB;EAyNtB,sCAAoC,CAAC;EAACG,IAAAA,GAAD;EAAMvC,IAAAA;EAAN,GAAD,KAAmB;EACrD,WAAQ,oBAAmBuC,GAAI,sBAAqBvC,MAAO,gBAApD,GACJ,oCADH;EAED,GA5NqB;EA8NtB,gCAA8B,CAAC;EAACuC,IAAAA;EAAD,GAAD,KAAW;EACvC,WAAQ,kCAAiCA,GAAI,6BAAtC,GACJ,UADH;EAED,GAjOqB;EAmOtB,iBAAe,CAAC;EAACA,IAAAA,GAAD;EAAM3C,IAAAA;EAAN,GAAD,KAAkB;EAC/B,QAAIoC,OAAO,GAAI,mDAAkDO,GAAI,IAArE;;EACA,QAAI3C,KAAJ,EAAW;EACToC,MAAAA,OAAO,IAAK,4BAA2BpC,KAAM,GAA7C;EACD;;EACD,WAAOoC,OAAP;EACD,GAzOqB;EA2OtB,6BAA2B,CAAC;EAACO,IAAAA,GAAD;EAAMC,IAAAA;EAAN,GAAD,KAAmB;EAC5C,WAAQ,+BAA8BD,GAAI,wBAAnC,GACJ,aAAYC,MAAO,GADtB;EAED;EA9OqB,CAAjB;;ECXP;;;;;;;AAQA;EAWA,MAAMC,iBAAiB,GAAG,CAACC,IAAD,EAAO,GAAGzC,IAAV,KAAmB;EAC3C,QAAM+B,OAAO,GAAGpB,QAAQ,CAAC8B,IAAD,CAAxB;;EACA,MAAI,CAACV,OAAL,EAAc;EACZ,UAAM,IAAIhB,KAAJ,CAAW,oCAAmC0B,IAAK,IAAnD,CAAN;EACD;;EAED,SAAOV,OAAO,CAAC,GAAG/B,IAAJ,CAAd;EACD,CAPD;;AASA,EAAO,MAAM0C,gBAAgB,GAAIrD,AAClBmD,iBADR;;EC5BP;;;;;;;AAQA,EAGA;;;;;;;;;;EASA,MAAMG,YAAN,SAA2B5B,KAA3B,CAAiC;EAC/B;;;;;;;;EAQA6B,EAAAA,WAAW,CAACC,SAAD,EAAYC,OAAZ,EAAqB;EAC9B,QAAIf,OAAO,GAAGW,gBAAgB,CAACG,SAAD,EAAYC,OAAZ,CAA9B;EAEA,UAAMf,OAAN;EAEA,SAAKP,IAAL,GAAYqB,SAAZ;EACA,SAAKC,OAAL,GAAeA,OAAf;EACD;;EAhB8B;;ECpBjC;;;;;;;AAQA,EAGA;;;;EAGA,MAAMC,OAAO,GAAI7B,UAAD,IAAgB;EAC9B,MAAI,EAAE,8BAA8BjC,IAAhC,CAAJ,EAA2C;EACzC,UAAM,IAAI0D,YAAJ,CAAiB,WAAjB,EAA8B;EAACzB,MAAAA;EAAD,KAA9B,CAAN;EACD;EACF,CAJD;EAMA;;;;;;;;EAMA,MAAM8B,OAAO,GAAG,CAAClC,KAAD,EAAQ;EAACI,EAAAA,UAAD;EAAaC,EAAAA,SAAb;EAAwBC,EAAAA,QAAxB;EAAkCR,EAAAA;EAAlC,CAAR,KAAyD;EACvE,MAAI,CAACqC,KAAK,CAACD,OAAN,CAAclC,KAAd,CAAL,EAA2B;EACzB,UAAM,IAAI6B,YAAJ,CAAiB,cAAjB,EAAiC;EACrCzB,MAAAA,UADqC;EAErCC,MAAAA,SAFqC;EAGrCC,MAAAA,QAHqC;EAIrCR,MAAAA;EAJqC,KAAjC,CAAN;EAMD;EACF,CATD;;EAWA,MAAMsC,SAAS,GAAG,CAACC,MAAD,EAAS1B,cAAT,EACd;EAACP,EAAAA,UAAD;EAAaC,EAAAA,SAAb;EAAwBC,EAAAA,QAAxB;EAAkCR,EAAAA;EAAlC,CADc,KACmC;EACnD,QAAMwC,IAAI,GAAG,OAAOD,MAAM,CAAC1B,cAAD,CAA1B;;EACA,MAAI2B,IAAI,KAAK,UAAb,EAAyB;EACvB,UAAM,IAAIT,YAAJ,CAAiB,kBAAjB,EAAqC;EAAC/B,MAAAA,SAAD;EAAYa,MAAAA,cAAZ;EACzCP,MAAAA,UADyC;EAC7BC,MAAAA,SAD6B;EAClBC,MAAAA;EADkB,KAArC,CAAN;EAED;EACF,CAPD;;EASA,MAAMiC,MAAM,GAAG,CAACF,MAAD,EAAS9B,YAAT,EACX;EAACH,EAAAA,UAAD;EAAaC,EAAAA,SAAb;EAAwBC,EAAAA,QAAxB;EAAkCR,EAAAA;EAAlC,CADW,KACsC;EACnD,MAAI,OAAOuC,MAAP,KAAkB9B,YAAtB,EAAoC;EAClC,UAAM,IAAIsB,YAAJ,CAAiB,gBAAjB,EAAmC;EAAC/B,MAAAA,SAAD;EAAYS,MAAAA,YAAZ;EACvCH,MAAAA,UADuC;EAC3BC,MAAAA,SAD2B;EAChBC,MAAAA;EADgB,KAAnC,CAAN;EAED;EACF,CAND;;EAQA,MAAMkC,UAAU,GAAG,CAACH,MAAD,EAAS7B,aAAT,EACf;EAACJ,EAAAA,UAAD;EAAaC,EAAAA,SAAb;EAAwBC,EAAAA,QAAxB;EACER,EAAAA,SADF;EACaW,EAAAA;EADb,CADe,KAEwB;EACzC,MAAI,EAAE4B,MAAM,YAAY7B,aAApB,CAAJ,EAAwC;EACtC,UAAM,IAAIqB,YAAJ,CAAiB,iBAAjB,EAAoC;EAAC/B,MAAAA,SAAD;EAAYU,MAAAA,aAAZ;EACxCJ,MAAAA,UADwC;EAC5BC,MAAAA,SAD4B;EACjBC,MAAAA,QADiB;EACPG,MAAAA;EADO,KAApC,CAAN;EAED;EACF,CAPD;;EASA,MAAMgC,OAAO,GAAG,CAACzC,KAAD,EAAQ0C,WAAR,EAAqB;EAAC5C,EAAAA;EAAD,CAArB,KAAqC;EACnD,MAAI,CAAC4C,WAAW,CAACC,QAAZ,CAAqB3C,KAArB,CAAL,EAAkC;EAChC,UAAM,IAAI6B,YAAJ,CAAiB,eAAjB,EAAkC;EACtC/B,MAAAA,SADsC;EAEtCE,MAAAA,KAFsC;EAGtCD,MAAAA,qBAAqB,EAAG,oBAAmBG,IAAI,CAACC,SAAL,CAAeuC,WAAf,CAA4B;EAHjC,KAAlC,CAAN;EAKD;EACF,CARD;;EAUA,MAAME,cAAc,GAAG,CAAC5C,KAAD,EAAQQ,aAAR,EACnB;EAACJ,EAAAA,UAAD;EAAaC,EAAAA,SAAb;EAAwBC,EAAAA,QAAxB;EAAkCR,EAAAA;EAAlC,CADmB,KAC8B;EACnD,QAAMjB,KAAK,GAAG,IAAIgD,YAAJ,CAAiB,oBAAjB,EAAuC;EACnD7B,IAAAA,KADmD;EAC5CQ,IAAAA,aAD4C;EAEnDJ,IAAAA,UAFmD;EAEvCC,IAAAA,SAFuC;EAE5BC,IAAAA,QAF4B;EAElBR,IAAAA;EAFkB,GAAvC,CAAd;;EAIA,MAAI,CAACqC,KAAK,CAACD,OAAN,CAAclC,KAAd,CAAL,EAA2B;EACzB,UAAMnB,KAAN;EACD;;EAED,OAAK,IAAIgE,IAAT,IAAiB7C,KAAjB,EAAwB;EACtB,QAAI,EAAE6C,IAAI,YAAYrC,aAAlB,CAAJ,EAAsC;EACpC,YAAM3B,KAAN;EACD;EACF;EACF,CAfD;;EAiBA,MAAMiE,kBAAkB,GAAGvE,AAA+C;EACxE6D,EAAAA,SADwE;EAExEF,EAAAA,OAFwE;EAGxEM,EAAAA,UAHwE;EAIxEC,EAAAA,OAJwE;EAKxER,EAAAA,OALwE;EAMxEM,EAAAA,MANwE;EAOxEK,EAAAA;EAPwE,CAA1E;;EC1FA;;;;;;;AAQA;EAIA,MAAMG,mBAAmB,GAAG,IAAIC,GAAJ,EAA5B;;ECZA;;;;;;;AAQA,EAMA;;;;;;;;EAOA,SAASC,0BAAT,CAAoCC,QAApC,EAA8C;EAC5C,EAA2C;EACzCC,IAAAA,kBAAM,CAACZ,MAAP,CAAcW,QAAd,EAAwB,UAAxB,EAAoC;EAClC9C,MAAAA,UAAU,EAAE,cADsB;EAElCE,MAAAA,QAAQ,EAAE,UAFwB;EAGlCR,MAAAA,SAAS,EAAE;EAHuB,KAApC;EAKD;;EAEDiD,EAAAA,mBAAmB,CAACK,GAApB,CAAwBF,QAAxB;;EAEA,EAA2C;EACzC5E,IAAAA,MAAM,CAACK,GAAP,CAAW,mDAAX,EAAgEuE,QAAhE;EACD;EACF;;ECnCD;;;;;;;AAQA,EAGA,MAAMG,iBAAiB,GAAG;EACxBC,EAAAA,eAAe,EAAE,iBADO;EAExBC,EAAAA,QAAQ,EAAE,aAFc;EAGxBC,EAAAA,MAAM,EAAE,SAHgB;EAIxBC,EAAAA,OAAO,EAAE,SAJe;EAKxBC,EAAAA,MAAM,EAAEvF,IAAI,CAACwF,YAAL,CAAkBC;EALF,CAA1B;;EAQA,MAAMC,gBAAgB,GAAIC,SAAD,IAAe;EACtC,SAAO,CAACT,iBAAiB,CAACG,MAAnB,EAA2BM,SAA3B,EAAsCT,iBAAiB,CAACK,MAAxD,EACFK,MADE,CACM/D,KAAD,IAAWA,KAAK,CAACgE,MAAN,GAAe,CAD/B,EAEFvE,IAFE,CAEG,GAFH,CAAP;EAGD,CAJD;;AAMA,EAAO,MAAMwE,UAAU,GAAG;EACxBC,EAAAA,aAAa,EAAGlC,OAAD,IAAa;EAC1BrC,IAAAA,MAAM,CAACC,IAAP,CAAYyD,iBAAZ,EAA+Bc,OAA/B,CAAwCC,GAAD,IAAS;EAC9C,UAAI,OAAOpC,OAAO,CAACoC,GAAD,CAAd,KAAwB,WAA5B,EAAyC;EACvCf,QAAAA,iBAAiB,CAACe,GAAD,CAAjB,GAAyBpC,OAAO,CAACoC,GAAD,CAAhC;EACD;EACF,KAJD;EAKD,GAPuB;EAQxBC,EAAAA,sBAAsB,EAAGC,aAAD,IAAmB;EACzC,WAAOA,aAAa,IAAIT,gBAAgB,CAACR,iBAAiB,CAACC,eAAnB,CAAxC;EACD,GAVuB;EAWxBiB,EAAAA,eAAe,EAAGD,aAAD,IAAmB;EAClC,WAAOA,aAAa,IAAIT,gBAAgB,CAACR,iBAAiB,CAACE,QAAnB,CAAxC;EACD,GAbuB;EAcxBiB,EAAAA,SAAS,EAAE,MAAM;EACf,WAAOnB,iBAAiB,CAACG,MAAzB;EACD,GAhBuB;EAiBxBiB,EAAAA,cAAc,EAAGH,aAAD,IAAmB;EACjC,WAAOA,aAAa,IAAIT,gBAAgB,CAACR,iBAAiB,CAACI,OAAnB,CAAxC;EACD,GAnBuB;EAoBxBiB,EAAAA,SAAS,EAAE,MAAM;EACf,WAAOrB,iBAAiB,CAACK,MAAzB;EACD;EAtBuB,CAAnB;;ECzBP;;;;;;;AAQA;EAEA,MAAMiB,cAAc,GAAInD,GAAD,IAAS;EAC9B,QAAMoD,MAAM,GAAG,IAAIC,GAAJ,CAAQrD,GAAR,EAAasD,QAAb,CAAf;;EACA,MAAIF,MAAM,CAACG,MAAP,KAAkBD,QAAQ,CAACC,MAA/B,EAAuC;EACrC,WAAOH,MAAM,CAACI,QAAd;EACD;;EACD,SAAOJ,MAAM,CAACK,IAAd;EACD,CAND;;ECVA;;;;;;;AAQA,EAKA;;;;;;;;EAOA,eAAeC,0BAAf,GAA4C;EAC1C,EAA2C;EACzC5G,IAAAA,MAAM,CAACK,GAAP,CAAY,gBAAeoE,mBAAmB,CAAC1B,IAAK,GAAzC,GACN,+BADL;EAED;;EAED,OAAK,MAAM6B,QAAX,IAAuBH,mBAAvB,EAA4C;EAC1C,UAAMG,QAAQ,EAAd;;EACA,IAA2C;EACzC5E,MAAAA,MAAM,CAACK,GAAP,CAAWuE,QAAX,EAAqB,cAArB;EACD;EACF;;EAED,EAA2C;EACzC5E,IAAAA,MAAM,CAACK,GAAP,CAAW,6BAAX;EACD;EACF;;ECpCD;;;;;;;AAQA,EAGO,MAAMwG,YAAY,GAAG;EAC1BC,EAAAA,gBAAgB,EAAE,gBADQ;EAE1BC,EAAAA,sBAAsB,EAAE,oBAFE;EAG1BC,EAAAA,iBAAiB,EAAE,iBAHO;EAI1BC,EAAAA,4BAA4B,EAAE,0BAJJ;EAK1BC,EAAAA,cAAc,EAAE,cALU;EAM1BC,EAAAA,iBAAiB,EAAE,iBANO;EAO1BC,EAAAA,kBAAkB,EAAE;EAPM,CAArB;;ECXP;;;;;;;AAQA,EAEO,MAAMC,WAAW,GAAG;EACzB5B,EAAAA,MAAM,EAAE,CAAC6B,OAAD,EAAUC,YAAV,KAA2B;EACjC,WAAOD,OAAO,CAAC7B,MAAR,CAAgB+B,MAAD,IAAYD,YAAY,IAAIC,MAA3C,CAAP;EACD;EAHwB,CAApB;;ECVP;;;;;;;AAQA,EAUA;;;;;;;;;;;;;;;;;;EAiBA,MAAMC,UAAU,GAAG,OAAO;EACxBjC,EAAAA,SADwB;EAExBkC,EAAAA,OAFwB;EAGxBC,EAAAA,QAHwB;EAIxBC,EAAAA,KAJwB;EAKxBN,EAAAA,OAAO,GAAG,EALc;EAMxBO,EAAAA;EANwB,IAOtB,EAPe,KAOR;EACT,EAA2C;EACzC,QAAIH,OAAO,CAAC/G,MAAR,IAAkB+G,OAAO,CAAC/G,MAAR,KAAmB,KAAzC,EAAgD;EAC9C,YAAM,IAAI4C,YAAJ,CAAiB,kCAAjB,EAAqD;EACzDL,QAAAA,GAAG,EAAEmD,cAAc,CAACqB,OAAO,CAACxE,GAAT,CADsC;EAEzDvC,QAAAA,MAAM,EAAE+G,OAAO,CAAC/G;EAFyC,OAArD,CAAN;EAID;EACF;;EAED,QAAMmH,gBAAgB,GAAG,MAAMC,oBAAoB,CAAC;EAClDT,IAAAA,OADkD;EACzCI,IAAAA,OADyC;EAChCM,IAAAA,IAAI,EAAE;EAD0B,GAAD,CAAnD;;EAGA,MAAI,CAACL,QAAL,EAAe;EACb,IAA2C;EACzC3H,MAAAA,MAAM,CAACO,KAAP,CAAc,yCAAD,GACV,IAAG8F,cAAc,CAACyB,gBAAgB,CAAC5E,GAAlB,CAAuB,IAD3C;EAED;;EAED,UAAM,IAAIK,YAAJ,CAAiB,4BAAjB,EAA+C;EACnDL,MAAAA,GAAG,EAAEmD,cAAc,CAACyB,gBAAgB,CAAC5E,GAAlB;EADgC,KAA/C,CAAN;EAGD;;EAED,MAAI+E,eAAe,GAAG,MAAMC,sBAAsB,CAAC;EACjDN,IAAAA,KADiD;EAEjDN,IAAAA,OAFiD;EAGjDK,IAAAA,QAHiD;EAIjDD,IAAAA,OAAO,EAAEI;EAJwC,GAAD,CAAlD;;EAOA,MAAI,CAACG,eAAL,EAAsB;EACpB,IAA2C;EACzCjI,MAAAA,MAAM,CAACI,KAAP,CAAc,aAAYiG,cAAc,CAACyB,gBAAgB,CAAC5E,GAAlB,CAAuB,SAAlD,GACZ,gBADD,EACkB+E,eADlB;EAED;;EACD;EACD;;EAED,QAAME,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAY7C,SAAZ,CAApB;EAEA,QAAM8C,aAAa,GAAGjB,WAAW,CAAC5B,MAAZ,CAClB6B,OADkB,EACTT,YAAY,CAACC,gBADJ,CAAtB;EAGA,MAAIyB,WAAW,GAAGD,aAAa,CAAC5C,MAAd,GAAuB,CAAvB,GACd,MAAM8C,YAAY,CAAC;EAAChD,IAAAA,SAAD;EAAYqC,IAAAA,YAAZ;EAA0BH,IAAAA,OAAO,EAAEI;EAAnC,GAAD,CADJ,GAEd,IAFJ;;EAIA,EAA2C;EACzC9H,IAAAA,MAAM,CAACI,KAAP,CAAc,iBAAgBoF,SAAU,kCAA3B,GACV,GAAEa,cAAc,CAACyB,gBAAgB,CAAC5E,GAAlB,CAAuB,GAD1C;EAED;;EAED,MAAI;EACF,UAAMiF,KAAK,CAACM,GAAN,CAAUX,gBAAV,EAA4BG,eAA5B,CAAN;EACD,GAFD,CAEE,OAAO1H,KAAP,EAAc;EACd;EACA,QAAIA,KAAK,CAAC6B,IAAN,KAAe,oBAAnB,EAAyC;EACvC,YAAMwE,0BAA0B,EAAhC;EACD;;EACD,UAAMrG,KAAN;EACD;;EAED,OAAK,IAAIiH,MAAT,IAAmBc,aAAnB,EAAkC;EAChC,UAAMd,MAAM,CAACX,YAAY,CAACC,gBAAd,CAAN,CAAsC4B,IAAtC,CAA2ClB,MAA3C,EAAmD;EACvDhC,MAAAA,SADuD;EAEvDoC,MAAAA,KAFuD;EAGvDW,MAAAA,WAHuD;EAIvDI,MAAAA,WAAW,EAAEV,eAJ0C;EAKvDP,MAAAA,OAAO,EAAEI;EAL8C,KAAnD,CAAN;EAOD;EACF,CA/ED;EAiFA;;;;;;;;;;;;;;;;;EAeA,MAAMU,YAAY,GAAG,OAAO;EAC1BhD,EAAAA,SAD0B;EAE1BkC,EAAAA,OAF0B;EAG1BE,EAAAA,KAH0B;EAI1BC,EAAAA,YAJ0B;EAK1BP,EAAAA,OAAO,GAAG;EALgB,CAAP,KAMf;EACJ,QAAMa,KAAK,GAAG,MAAMC,MAAM,CAACC,IAAP,CAAY7C,SAAZ,CAApB;EAEA,QAAMsC,gBAAgB,GAAG,MAAMC,oBAAoB,CAAC;EAClDT,IAAAA,OADkD;EACzCI,IAAAA,OADyC;EAChCM,IAAAA,IAAI,EAAE;EAD0B,GAAD,CAAnD;EAGA,MAAIY,cAAc,GAAG,MAAMT,KAAK,CAACU,KAAN,CAAYf,gBAAZ,EAA8BD,YAA9B,CAA3B;;EACA,EAA2C;EACzC,QAAIe,cAAJ,EAAoB;EAClB5I,MAAAA,MAAM,CAACI,KAAP,CAAc,+BAA8BoF,SAAU,IAAtD;EACD,KAFD,MAEO;EACLxF,MAAAA,MAAM,CAACI,KAAP,CAAc,gCAA+BoF,SAAU,IAAvD;EACD;EACF;;EAED,OAAK,MAAMgC,MAAX,IAAqBF,OAArB,EAA8B;EAC5B,QAAIT,YAAY,CAACI,4BAAb,IAA6CO,MAAjD,EAAyD;EACvDoB,MAAAA,cAAc,GAAG,MAAMpB,MAAM,CAACX,YAAY,CAACI,4BAAd,CAAN,CAClByB,IADkB,CACblB,MADa,EACL;EACZhC,QAAAA,SADY;EAEZoC,QAAAA,KAFY;EAGZC,QAAAA,YAHY;EAIZe,QAAAA,cAJY;EAKZlB,QAAAA,OAAO,EAAEI;EALG,OADK,CAAvB;;EAQA,MAA2C;EACzC,YAAIc,cAAJ,EAAoB;EAClB/D,UAAAA,kBAAM,CAACX,UAAP,CAAkB0E,cAAlB,EAAkCE,QAAlC,EAA4C;EAC1ChH,YAAAA,UAAU,EAAE,QAD8B;EAE1CE,YAAAA,QAAQ,EAAE6E,YAAY,CAACI,4BAFmB;EAG1C9E,YAAAA,oBAAoB,EAAE;EAHoB,WAA5C;EAKD;EACF;EACF;EACF;;EAED,SAAOyG,cAAP;EACD,CA5CD;EA8CA;;;;;;;;;;;;;;;;EAcA,MAAMV,sBAAsB,GAAG,OAAO;EAACR,EAAAA,OAAD;EAAUC,EAAAA,QAAV;EAAoBC,EAAAA,KAApB;EAA2BN,EAAAA;EAA3B,CAAP,KAA+C;EAC5E,MAAIW,eAAe,GAAGN,QAAtB;EACA,MAAIoB,WAAW,GAAG,KAAlB;;EACA,OAAK,IAAIvB,MAAT,IAAmBF,OAAnB,EAA4B;EAC1B,QAAIT,YAAY,CAACG,iBAAb,IAAkCQ,MAAtC,EAA8C;EAC5CuB,MAAAA,WAAW,GAAG,IAAd;EACAd,MAAAA,eAAe,GAAG,MAAMT,MAAM,CAACX,YAAY,CAACG,iBAAd,CAAN,CACnB0B,IADmB,CACdlB,MADc,EACN;EACZE,QAAAA,OADY;EAEZC,QAAAA,QAAQ,EAAEM,eAFE;EAGZL,QAAAA;EAHY,OADM,CAAxB;;EAOA,MAA2C;EACzC,YAAIK,eAAJ,EAAqB;EACnBpD,UAAAA,kBAAM,CAACX,UAAP,CAAkB+D,eAAlB,EAAmCa,QAAnC,EAA6C;EAC3ChH,YAAAA,UAAU,EAAE,QAD+B;EAE3CE,YAAAA,QAAQ,EAAE6E,YAAY,CAACG,iBAFoB;EAG3C7E,YAAAA,oBAAoB,EAAE;EAHqB,WAA7C;EAKD;EACF;;EAED,UAAI,CAAC8F,eAAL,EAAsB;EACpB;EACD;EACF;EACF;;EAED,MAAI,CAACc,WAAL,EAAkB;EAChB,IAA2C;EACzC,UAAI,CAACd,eAAe,CAAC9E,MAAjB,KAA4B,GAAhC,EAAqC;EACnC,YAAI8E,eAAe,CAAC9E,MAAhB,KAA2B,CAA/B,EAAkC;EAChCnD,UAAAA,MAAM,CAACM,IAAP,CAAa,qBAAoBoH,OAAO,CAACxE,GAAI,iBAAjC,GACT,4DADS,GAET,oCAFH;EAGD,SAJD,MAIO;EACLlD,UAAAA,MAAM,CAACI,KAAP,CAAc,qBAAoBsH,OAAO,CAACxE,GAAI,aAAjC,GACZ,qBAAoByE,QAAQ,CAACxE,MAAO,6BADxB,GAEZ,SAFD;EAGD;EACF;EACF;;EACD8E,IAAAA,eAAe,GAAGA,eAAe,CAAC9E,MAAhB,KAA2B,GAA3B,GAAiC8E,eAAjC,GAAmD,IAArE;EACD;;EAED,SAAOA,eAAe,GAAGA,eAAH,GAAqB,IAA3C;EACD,CA/CD;EAiDA;;;;;;;;;;;;;;;;;EAeA,MAAMF,oBAAoB,GAAG,OAAO;EAACL,EAAAA,OAAD;EAAUM,EAAAA,IAAV;EAAgBV,EAAAA;EAAhB,CAAP,KAAoC;EAC/D,QAAM0B,yBAAyB,GAAG3B,WAAW,CAAC5B,MAAZ,CAC9B6B,OAD8B,EACrBT,YAAY,CAACE,sBADQ,CAAlC;EAGA,MAAIe,gBAAgB,GAAGJ,OAAvB;;EACA,OAAK,MAAMF,MAAX,IAAqBwB,yBAArB,EAAgD;EAC9ClB,IAAAA,gBAAgB,GAAG,MAAMN,MAAM,CAACX,YAAY,CAACE,sBAAd,CAAN,CAA4C2B,IAA5C,CACrBlB,MADqB,EACb;EAACQ,MAAAA,IAAD;EAAON,MAAAA,OAAO,EAAEI;EAAhB,KADa,CAAzB;;EAGA,QAAI,OAAOA,gBAAP,KAA4B,QAAhC,EAA0C;EACxCA,MAAAA,gBAAgB,GAAG,IAAImB,OAAJ,CAAYnB,gBAAZ,CAAnB;EACD;;EAED,IAA2C;EACzCjD,MAAAA,kBAAM,CAACX,UAAP,CAAkB4D,gBAAlB,EAAoCmB,OAApC,EAA6C;EAC3CnH,QAAAA,UAAU,EAAE,QAD+B;EAE3CE,QAAAA,QAAQ,EAAE6E,YAAY,CAACE,sBAFoB;EAG3C5E,QAAAA,oBAAoB,EAAE;EAHqB,OAA7C;EAKD;EACF;;EAED,SAAO2F,gBAAP;EACD,CAvBD;;AAyBA,EAAO,MAAMoB,YAAY,GAAG;EAC1BT,EAAAA,GAAG,EAAEhB,UADqB;EAE1BoB,EAAAA,KAAK,EAAEL;EAFmB,CAArB;;ECxRP;;;;;;;AAQA,EAGA;;;;;;;;AAOA,EAAO,MAAMW,SAAN,CAAgB;EACrB;;;;;;;;;EASA3F,EAAAA,WAAW,CAACpB,IAAD,EAAOgH,OAAP,EAAgB;EACzBC,IAAAA,eADyB;EAEzBC,IAAAA,eAAe,GAAG,KAAKC;EAFE,MAGvB,EAHO,EAGH;EACN,SAAKC,KAAL,GAAapH,IAAb;EACA,SAAKqH,QAAL,GAAgBL,OAAhB;EACA,SAAKM,gBAAL,GAAwBL,eAAxB;EACA,SAAKE,gBAAL,GAAwBD,eAAxB,CAJM;;EAON,SAAKK,GAAL,GAAW,IAAX;EACD;EAED;;;;;;;EAKA,MAAIC,EAAJ,GAAS;EACP,WAAO,KAAKD,GAAZ;EACD;EAED;;;;;;;;;EAOA,QAAMtB,IAAN,GAAa;EACX,QAAI,KAAKsB,GAAT,EAAc;EAEd,SAAKA,GAAL,GAAW,MAAM,IAAIE,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;EAChD;EACA;EACA;EACA;EACA;EACA,UAAIC,mBAAmB,GAAG,KAA1B;EACAC,MAAAA,UAAU,CAAC,MAAM;EACfD,QAAAA,mBAAmB,GAAG,IAAtB;EACAD,QAAAA,MAAM,CAAC,IAAIpI,KAAJ,CAAU,4CAAV,CAAD,CAAN;EACD,OAHS,EAGP,KAAKuI,YAHE,CAAV;EAKA,YAAMC,WAAW,GAAGC,SAAS,CAAC/B,IAAV,CAAe,KAAKmB,KAApB,EAA2B,KAAKC,QAAhC,CAApB;;EACAU,MAAAA,WAAW,CAACE,OAAZ,GAAsB,MAAMN,MAAM,CAACI,WAAW,CAAC5J,KAAb,CAAlC;;EACA4J,MAAAA,WAAW,CAACd,eAAZ,GAA+BiB,GAAD,IAAS;EACrC,YAAIN,mBAAJ,EAAyB;EACvBG,UAAAA,WAAW,CAACI,WAAZ,CAAwBC,KAAxB;EACAF,UAAAA,GAAG,CAACG,MAAJ,CAAWC,MAAX,CAAkBC,KAAlB;EACD,SAHD,MAGO,IAAI,KAAKjB,gBAAT,EAA2B;EAChC,eAAKA,gBAAL,CAAsBY,GAAtB;EACD;EACF,OAPD;;EAQAH,MAAAA,WAAW,CAACS,SAAZ,GAAwB,CAAC;EAACH,QAAAA;EAAD,OAAD,KAAc;EACpC,cAAMb,EAAE,GAAGa,MAAM,CAACC,MAAlB;;EACA,YAAIV,mBAAJ,EAAyB;EACvBJ,UAAAA,EAAE,CAACe,KAAH;EACD,SAFD,MAEO;EACLf,UAAAA,EAAE,CAACN,eAAH,GAAqB,KAAKC,gBAAL,CAAsBsB,IAAtB,CAA2B,IAA3B,CAArB;EACAf,UAAAA,OAAO,CAACF,EAAD,CAAP;EACD;EACF,OARD;EASD,KA/BgB,CAAjB;EAiCA,WAAO,IAAP;EACD;EAED;;;;;;;;;;;EASA,QAAMkB,MAAN,CAAaC,SAAb,EAAwBC,KAAxB,EAA+B;EAC7B,WAAO,CAAC,MAAM,KAAKC,UAAL,CAAgBF,SAAhB,EAA2BC,KAA3B,EAAkC,CAAlC,CAAP,EAA6C,CAA7C,CAAP;EACD;EAED;;;;;;;;;;;;EAUA,QAAME,MAAN,CAAaH,SAAb,EAAwBC,KAAxB,EAA+BG,KAA/B,EAAsC;EACpC,WAAO,MAAM,KAAKC,cAAL,CAAoBL,SAApB,EAA+B;EAACC,MAAAA,KAAD;EAAQG,MAAAA;EAAR,KAA/B,CAAb;EACD;EAGD;;;;;;;;;;;;EAUA,QAAMF,UAAN,CAAiBF,SAAjB,EAA4BC,KAA5B,EAAmCG,KAAnC,EAA0C;EACxC,WAAO,CAAC,MAAM,KAAKC,cAAL,CACVL,SADU,EACC;EAACC,MAAAA,KAAD;EAAQG,MAAAA,KAAR;EAAeE,MAAAA,WAAW,EAAE;EAA5B,KADD,CAAP,EAC4CC,GAD5C,CACgD,CAAC;EAACxF,MAAAA;EAAD,KAAD,KAAWA,GAD3D,CAAP;EAED;EAED;;;;;;;;;;;;;;;;;;;EAiBA,QAAMsF,cAAN,CAAqBL,SAArB,EAAgC;EAC9BQ,IAAAA,KAD8B;EAE9BP,IAAAA,KAAK,GAAG,IAFsB;EAEhB;EACdQ,IAAAA,SAAS,GAAG,MAHkB;EAI9BL,IAAAA,KAJ8B;EAK9BE,IAAAA;EAL8B,MAM5B,EANJ,EAMQ;EACN,WAAO,MAAM,KAAKd,WAAL,CAAiB,CAACQ,SAAD,CAAjB,EAA8B,UAA9B,EAA0C,CAACU,GAAD,EAAMC,IAAN,KAAe;EACpE,YAAMC,KAAK,GAAGF,GAAG,CAACG,WAAJ,CAAgBb,SAAhB,CAAd;EACA,YAAMN,MAAM,GAAGc,KAAK,GAAGI,KAAK,CAACJ,KAAN,CAAYA,KAAZ,CAAH,GAAwBI,KAA5C;EACA,YAAME,OAAO,GAAG,EAAhB;;EAEApB,MAAAA,MAAM,CAACqB,UAAP,CAAkBd,KAAlB,EAAyBQ,SAAzB,EAAoCZ,SAApC,GAAgD,CAAC;EAACH,QAAAA;EAAD,OAAD,KAAc;EAC5D,cAAMsB,MAAM,GAAGtB,MAAM,CAACC,MAAtB;;EACA,YAAIqB,MAAJ,EAAY;EACV,gBAAM;EAACC,YAAAA,UAAD;EAAalG,YAAAA,GAAb;EAAkBpE,YAAAA;EAAlB,cAA2BqK,MAAjC;EACAF,UAAAA,OAAO,CAACI,IAAR,CAAaZ,WAAW,GAAG;EAACW,YAAAA,UAAD;EAAalG,YAAAA,GAAb;EAAkBpE,YAAAA;EAAlB,WAAH,GAA8BA,KAAtD;;EACA,cAAIyJ,KAAK,IAAIU,OAAO,CAACnG,MAAR,IAAkByF,KAA/B,EAAsC;EACpCO,YAAAA,IAAI,CAACG,OAAD,CAAJ;EACD,WAFD,MAEO;EACLE,YAAAA,MAAM,CAACG,QAAP;EACD;EACF,SARD,MAQO;EACLR,UAAAA,IAAI,CAACG,OAAD,CAAJ;EACD;EACF,OAbD;EAcD,KAnBY,CAAb;EAoBD;EAED;;;;;;;;;;;;;;;;;;;EAiBA,QAAMtB,WAAN,CAAkB4B,UAAlB,EAA8BnI,IAA9B,EAAoCY,QAApC,EAA8C;EAC5C,UAAM,KAAKyD,IAAL,EAAN;EACA,WAAO,MAAM,IAAIwB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;EAC5C,YAAM0B,GAAG,GAAG,KAAK9B,GAAL,CAASY,WAAT,CAAqB4B,UAArB,EAAiCnI,IAAjC,CAAZ;;EACAyH,MAAAA,GAAG,CAACW,OAAJ,GAAc,CAAC;EAAC3B,QAAAA;EAAD,OAAD,KAAcV,MAAM,CAACU,MAAM,CAAClK,KAAR,CAAlC;;EACAkL,MAAAA,GAAG,CAACY,UAAJ,GAAiB,MAAMvC,OAAO,EAA9B;;EAEAlF,MAAAA,QAAQ,CAAC6G,GAAD,EAAO/J,KAAD,IAAWoI,OAAO,CAACpI,KAAD,CAAxB,CAAR;EACD,KANY,CAAb;EAOD;EAED;;;;;;;;;;;;EAUA,QAAM4K,KAAN,CAAY3L,MAAZ,EAAoBoK,SAApB,EAA+B/G,IAA/B,EAAqC,GAAGpD,IAAxC,EAA8C;EAC5C,UAAMgE,QAAQ,GAAG,CAAC6G,GAAD,EAAMC,IAAN,KAAe;EAC9BD,MAAAA,GAAG,CAACG,WAAJ,CAAgBb,SAAhB,EAA2BpK,MAA3B,EAAmC,GAAGC,IAAtC,EAA4CgK,SAA5C,GAAwD,CAAC;EAACH,QAAAA;EAAD,OAAD,KAAc;EACpEiB,QAAAA,IAAI,CAACjB,MAAM,CAACC,MAAR,CAAJ;EACD,OAFD;EAGD,KAJD;;EAMA,WAAO,MAAM,KAAKH,WAAL,CAAiB,CAACQ,SAAD,CAAjB,EAA8B/G,IAA9B,EAAoCY,QAApC,CAAb;EACD;EAED;;;;;;;;EAMA2E,EAAAA,gBAAgB,GAAG;EACjB,SAAKoB,KAAL;EACD;EAED;;;;;;;;;;;;;;;EAaAA,EAAAA,KAAK,GAAG;EACN,QAAI,KAAKhB,GAAT,EAAc;EACZ,WAAKA,GAAL,CAASgB,KAAT;;EACA,WAAKhB,GAAL,GAAW,IAAX;EACD;EACF;;EAnPoB;EAuPvB;;EACAR,SAAS,CAACoD,SAAV,CAAoBrC,YAApB,GAAmC,IAAnC;;EAGA,MAAMsC,aAAa,GAAG;EACpB,cAAY,CAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA2B,QAA3B,EAAqC,YAArC,CADQ;EAEpB,eAAa,CAAC,KAAD,EAAQ,KAAR,EAAe,OAAf,EAAwB,QAAxB;EAFO,CAAtB;;EAIA,KAAK,MAAM,CAACxE,IAAD,EAAOyE,OAAP,CAAX,IAA8BpL,MAAM,CAACqL,OAAP,CAAeF,aAAf,CAA9B,EAA6D;EAC3D,OAAK,MAAM7L,MAAX,IAAqB8L,OAArB,EAA8B;EAC5B,QAAI9L,MAAM,IAAIgM,cAAc,CAACJ,SAA7B,EAAwC;EACtC;EACApD,MAAAA,SAAS,CAACoD,SAAV,CAAoB5L,MAApB,IAA8B,gBAAeoK,SAAf,EAA0B,GAAGnK,IAA7B,EAAmC;EAC/D,eAAO,MAAM,KAAK0L,KAAL,CAAW3L,MAAX,EAAmBoK,SAAnB,EAA8B/C,IAA9B,EAAoC,GAAGpH,IAAvC,CAAb;EACD,OAFD;EAGD;EACF;EACF;;EC1RD;;;;;;;AAQA,EAGA;;;;;;;;;AAQA,EAAO,MAAMgM,QAAN,CAAe;EACpB;;;EAGApJ,EAAAA,WAAW,GAAG;EACZ,SAAKqJ,OAAL,GAAe,IAAIhD,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;EAC9C,WAAKD,OAAL,GAAeA,OAAf;EACA,WAAKC,MAAL,GAAcA,MAAd;EACD,KAHc,CAAf;EAID;;EATmB;;ECnBtB;;;;;;;AAQA,EAGA;;;;;;;;;;AASA,EAAO,MAAM+C,cAAc,GAAG,MAAO1K,IAAP,IAAgB;EAC5C,QAAM,IAAIyH,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;EACrC,UAAMrC,OAAO,GAAG0C,SAAS,CAAC0C,cAAV,CAAyB1K,IAAzB,CAAhB;;EACAsF,IAAAA,OAAO,CAAC2C,OAAR,GAAkB,CAAC;EAACI,MAAAA;EAAD,KAAD,KAAc;EAC9BV,MAAAA,MAAM,CAACU,MAAM,CAAClK,KAAR,CAAN;EACD,KAFD;;EAGAmH,IAAAA,OAAO,CAACqF,SAAR,GAAoB,MAAM;EACxBhD,MAAAA,MAAM,CAAC,IAAIpI,KAAJ,CAAU,gBAAV,CAAD,CAAN;EACD,KAFD;;EAGA+F,IAAAA,OAAO,CAACkD,SAAR,GAAoB,MAAM;EACxBd,MAAAA,OAAO;EACR,KAFD;EAGD,GAXK,CAAN;EAYD,CAbM;;ECpBP;;;;;;;AAQA,EAQA;;;;;;;;;;;;;;;;EAeA,MAAMkD,YAAY,GAAG,OAAO;EAC1BtF,EAAAA,OAD0B;EAE1BuF,EAAAA,YAF0B;EAG1BrF,EAAAA,KAH0B;EAI1BN,EAAAA,OAAO,GAAG;EAJgB,CAAP,KAID;EAClB;EACA;EACA;EACA,MAAIM,KAAK,IAAIA,KAAK,CAACsF,eAAnB,EAAoC;EAClC,UAAMC,uBAAuB,GAAG,MAAMvF,KAAK,CAACsF,eAA5C;;EACA,QAAIC,uBAAJ,EAA6B;EAC3B,MAA2C;EACzCnN,QAAAA,MAAM,CAACK,GAAP,CAAY,4CAAD,GACR,IAAGgG,cAAc,CAACqB,OAAO,CAACxE,GAAT,CAAc,GADlC;EAED;;EACD,aAAOiK,uBAAP;EACD;EACF;;EAED,MAAI,OAAOzF,OAAP,KAAmB,QAAvB,EAAiC;EAC/BA,IAAAA,OAAO,GAAG,IAAIuB,OAAJ,CAAYvB,OAAZ,CAAV;EACD;;EAED,EAA2C;EACzC7C,IAAAA,kBAAM,CAACX,UAAP,CAAkBwD,OAAlB,EAA2BuB,OAA3B,EAAoC;EAClCzH,MAAAA,SAAS,EAAEkG,OADuB;EAElCxF,MAAAA,aAAa,EAAE,SAFmB;EAGlCJ,MAAAA,UAAU,EAAE,cAHsB;EAIlCC,MAAAA,SAAS,EAAE,cAJuB;EAKlCC,MAAAA,QAAQ,EAAE;EALwB,KAApC;EAOD;;EAED,QAAMoL,kBAAkB,GAAG/F,WAAW,CAAC5B,MAAZ,CACvB6B,OADuB,EACdT,YAAY,CAACK,cADC,CAA3B,CA7BkB;EAiClB;EACA;;EACA,QAAMmG,eAAe,GAAGD,kBAAkB,CAAC1H,MAAnB,GAA4B,CAA5B,GACtBgC,OAAO,CAAC4F,KAAR,EADsB,GACJ,IADpB;;EAGA,MAAI;EACF,SAAK,IAAI9F,MAAT,IAAmBF,OAAnB,EAA4B;EAC1B,UAAIT,YAAY,CAACO,kBAAb,IAAmCI,MAAvC,EAA+C;EAC7CE,QAAAA,OAAO,GAAG,MAAMF,MAAM,CAACX,YAAY,CAACO,kBAAd,CAAN,CAAwCsB,IAAxC,CAA6ClB,MAA7C,EAAqD;EACnEE,UAAAA,OAAO,EAAEA,OAAO,CAAC4F,KAAR,EAD0D;EAEnE1F,UAAAA;EAFmE,SAArD,CAAhB;;EAKA,QAA2C;EACzC,cAAIF,OAAJ,EAAa;EACX7C,YAAAA,kBAAM,CAACX,UAAP,CAAkBwD,OAAlB,EAA2BuB,OAA3B,EAAoC;EAClCnH,cAAAA,UAAU,EAAE,QADsB;EAElCE,cAAAA,QAAQ,EAAE6E,YAAY,CAACI,4BAFW;EAGlC9E,cAAAA,oBAAoB,EAAE;EAHY,aAApC;EAKD;EACF;EACF;EACF;EACF,GAnBD,CAmBE,OAAOoL,GAAP,EAAY;EACZ,UAAM,IAAIhK,YAAJ,CAAiB,iCAAjB,EAAoD;EACxDb,MAAAA,WAAW,EAAE6K;EAD2C,KAApD,CAAN;EAGD,GA7DiB;EAgElB;EACA;;;EACA,MAAIC,qBAAqB,GAAG9F,OAAO,CAAC4F,KAAR,EAA5B;;EAEA,MAAI;EACF,QAAIG,aAAJ,CADE;;EAIF,QAAI/F,OAAO,CAACM,IAAR,KAAiB,UAArB,EAAiC;EAC/ByF,MAAAA,aAAa,GAAG,MAAMC,KAAK,CAAChG,OAAD,CAA3B;EACD,KAFD,MAEO;EACL+F,MAAAA,aAAa,GAAG,MAAMC,KAAK,CAAChG,OAAD,EAAUuF,YAAV,CAA3B;EACD;;EAED,IAA2C;EACzCjN,MAAAA,MAAM,CAACI,KAAP,CAAc,sBAAD,GACZ,IAAGiG,cAAc,CAACqB,OAAO,CAACxE,GAAT,CAAc,6BADnB,GAEZ,WAAUuK,aAAa,CAACtK,MAAO,IAFhC;EAGD;;EAED,SAAK,MAAMqE,MAAX,IAAqBF,OAArB,EAA8B;EAC5B,UAAIT,YAAY,CAACM,iBAAb,IAAkCK,MAAtC,EAA8C;EAC5CiG,QAAAA,aAAa,GAAG,MAAMjG,MAAM,CAACX,YAAY,CAACM,iBAAd,CAAN,CACjBuB,IADiB,CACZlB,MADY,EACJ;EACZI,UAAAA,KADY;EAEZF,UAAAA,OAAO,EAAE8F,qBAFG;EAGZ7F,UAAAA,QAAQ,EAAE8F;EAHE,SADI,CAAtB;;EAOA,QAA2C;EACzC,cAAIA,aAAJ,EAAmB;EACjB5I,YAAAA,kBAAM,CAACX,UAAP,CAAkBuJ,aAAlB,EAAiC3E,QAAjC,EAA2C;EACzChH,cAAAA,UAAU,EAAE,QAD6B;EAEzCE,cAAAA,QAAQ,EAAE6E,YAAY,CAACM,iBAFkB;EAGzChF,cAAAA,oBAAoB,EAAE;EAHmB,aAA3C;EAKD;EACF;EACF;EACF;;EAED,WAAOsL,aAAP;EACD,GAtCD,CAsCE,OAAOlN,KAAP,EAAc;EACd,IAA2C;EACzCP,MAAAA,MAAM,CAACO,KAAP,CAAc,sBAAD,GACZ,IAAG8F,cAAc,CAACqB,OAAO,CAACxE,GAAT,CAAc,mBADhC,EACoD3C,KADpD;EAED;;EAED,SAAK,MAAMiH,MAAX,IAAqB4F,kBAArB,EAAyC;EACvC,YAAM5F,MAAM,CAACX,YAAY,CAACK,cAAd,CAAN,CAAoCwB,IAApC,CAAyClB,MAAzC,EAAiD;EACrDjH,QAAAA,KADqD;EAErDqH,QAAAA,KAFqD;EAGrDyF,QAAAA,eAAe,EAAEA,eAAe,CAACC,KAAhB,EAHoC;EAIrD5F,QAAAA,OAAO,EAAE8F,qBAAqB,CAACF,KAAtB;EAJ4C,OAAjD,CAAN;EAMD;;EAED,UAAM/M,KAAN;EACD;EACF,CA/HD;;EAiIA,MAAMoN,YAAY,GAAG;EACnBD,EAAAA,KAAK,EAAEV;EADY,CAArB;;EChKA;;;;;;;;;;;;;;;;;;;;;;ECAA;;;;;;;AAQA,EAGA;;;;;;;AAMA,QAAaY,YAAY,GAAG,MAAM;EAChCC,EAAAA,gBAAgB,CAAC,UAAD,EAAa,MAAMC,OAAO,CAACC,KAAR,EAAnB,CAAhB;EACD,CAFM;;ECjBP;;;;;;;AAQA,EAIA;;;;;;;;;;;;;;;;AAeA,QAAapI,YAAU,GAAG;EACxB,MAAIX,eAAJ,GAAsB;EACpB,WAAOgJ,UAAW,CAACjI,sBAAZ,EAAP;EACD,GAHuB;;EAIxB,MAAId,QAAJ,GAAe;EACb,WAAO+I,UAAW,CAAC/H,eAAZ,EAAP;EACD,GANuB;;EAOxB,MAAIf,MAAJ,GAAa;EACX,WAAO8I,UAAW,CAAC9H,SAAZ,EAAP;EACD,GATuB;;EAUxB,MAAIf,OAAJ,GAAc;EACZ,WAAO6I,UAAW,CAAC7H,cAAZ,EAAP;EACD,GAZuB;;EAaxB,MAAIf,MAAJ,GAAa;EACX,WAAO4I,UAAW,CAAC5H,SAAZ,EAAP;EACD;;EAfuB,CAAnB;;EC3BP;;;;;;;AAQA,EAMA;;;;;;;;;;;;;;;;;;AAiBA,QAAa6H,mBAAmB,GAAIvK,OAAD,IAAa;EAC9C,EAA2C;EACzCrC,IAAAA,MAAM,CAACC,IAAP,CAAYoC,OAAZ,EAAqBmC,OAArB,CAA8BC,GAAD,IAAS;EACpCjB,MAAAA,kBAAM,CAACZ,MAAP,CAAcP,OAAO,CAACoC,GAAD,CAArB,EAA4B,QAA5B,EAAsC;EACpChE,QAAAA,UAAU,EAAE,cADwB;EAEpCE,QAAAA,QAAQ,EAAE,qBAF0B;EAGpCR,QAAAA,SAAS,EAAG,WAAUsE,GAAI;EAHU,OAAtC;EAKD,KAND;;EAQA,QAAI,cAAcpC,OAAd,IAAyBA,OAAO,CAACuB,QAAR,CAAiBS,MAAjB,KAA4B,CAAzD,EAA4D;EAC1D,YAAM,IAAInC,YAAJ,CAAiB,oBAAjB,EAAuC;EAC3CX,QAAAA,WAAW,EAAE,UAD8B;EAE3ClB,QAAAA,KAAK,EAAEgC,OAAO,CAACuB;EAF4B,OAAvC,CAAN;EAID;;EAED,QAAI,aAAavB,OAAb,IAAwBA,OAAO,CAACyB,OAAR,CAAgBO,MAAhB,KAA2B,CAAvD,EAA0D;EACxD,YAAM,IAAInC,YAAJ,CAAiB,oBAAjB,EAAuC;EAC3CX,QAAAA,WAAW,EAAE,SAD8B;EAE3ClB,QAAAA,KAAK,EAAEgC,OAAO,CAACyB;EAF4B,OAAvC,CAAN;EAID;;EAED,QAAI,qBAAqBzB,OAArB,IAAgCA,OAAO,CAACsB,eAAR,CAAwBU,MAAxB,KAAmC,CAAvE,EAA0E;EACxE,YAAM,IAAInC,YAAJ,CAAiB,oBAAjB,EAAuC;EAC3CX,QAAAA,WAAW,EAAE,iBAD8B;EAE3ClB,QAAAA,KAAK,EAAEgC,OAAO,CAACsB;EAF4B,OAAvC,CAAN;EAID;EACF;;EAEDW,EAAAA,UAAU,CAACC,aAAX,CAAyBlC,OAAzB;EACD,CAjCM;;EC/BP;;;;;;;AAQA,EAGA;;;;;;;AAMA,QAAawK,WAAW,GAAG,MAAM;EAC/B;EACA;EACAL,EAAAA,gBAAgB,CAAC,SAAD,EAAY,MAAMhO,IAAI,CAACqO,WAAL,EAAlB,CAAhB;EACD,CAJM;;ECjBP;;;;;;;AAQA;EAUA,IAAI;EACFrO,EAAAA,IAAI,CAACsO,OAAL,CAAaC,CAAb,GAAiBvO,IAAI,CAACsO,OAAL,CAAaC,CAAb,IAAkB,EAAnC;EACD,CAFD,CAEE,OAAOC,KAAP,EAAc,EAAd;;;;;;;;;;;;;;;\"}\n\\ No newline at end of file"
    },
    {
      "sha": "526e32b1d4861b20f8650c63a83d0ff1b1ec3d86",
      "filename": "public/javascripts/workbox/workbox-core.prod.js",
      "status": "added",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.prod.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.prod.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-core.prod.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,2 @@\n+this.workbox=this.workbox||{},this.workbox.core=function(e){\"use strict\";try{self[\"workbox:core:4.3.1\"]&&_()}catch(e){}const t=(e,...t)=>{let n=e;return t.length>0&&(n+=` :: ${JSON.stringify(t)}`),n};class n extends Error{constructor(e,n){super(t(e,n)),this.name=e,this.details=n}}const s=new Set;const r={googleAnalytics:\"googleAnalytics\",precache:\"precache-v2\",prefix:\"workbox\",runtime:\"runtime\",suffix:self.registration.scope},a=e=>[r.prefix,e,r.suffix].filter(e=>e.length>0).join(\"-\"),i={updateDetails:e=>{Object.keys(r).forEach(t=>{void 0!==e[t]&&(r[t]=e[t])})},getGoogleAnalyticsName:e=>e||a(r.googleAnalytics),getPrecacheName:e=>e||a(r.precache),getPrefix:()=>r.prefix,getRuntimeName:e=>e||a(r.runtime),getSuffix:()=>r.suffix},c=e=>{const t=new URL(e,location);return t.origin===location.origin?t.pathname:t.href};async function o(){for(const e of s)await e()}const l=\"cacheDidUpdate\",u=\"cacheKeyWillBeUsed\",h=\"cacheWillUpdate\",f=\"cachedResponseWillBeUsed\",w=\"fetchDidFail\",g=\"fetchDidSucceed\",d=\"requestWillFetch\",p=(e,t)=>e.filter(e=>t in e),y=async({cacheName:e,request:t,event:n,matchOptions:s,plugins:r=[]})=>{const a=await caches.open(e),i=await q({plugins:r,request:t,mode:\"read\"});let c=await a.match(i,s);for(const t of r)f in t&&(c=await t[f].call(t,{cacheName:e,event:n,matchOptions:s,cachedResponse:c,request:i}));return c},m=async({request:e,response:t,event:n,plugins:s})=>{let r=t,a=!1;for(let t of s)if(h in t&&(a=!0,!(r=await t[h].call(t,{request:e,response:r,event:n}))))break;return a||(r=200===r.status?r:null),r||null},q=async({request:e,mode:t,plugins:n})=>{const s=p(n,u);let r=e;for(const e of s)\"string\"==typeof(r=await e[u].call(e,{mode:t,request:r}))&&(r=new Request(r));return r},v={put:async({cacheName:e,request:t,response:s,event:r,plugins:a=[],matchOptions:i}={})=>{const u=await q({plugins:a,request:t,mode:\"write\"});if(!s)throw new n(\"cache-put-with-no-response\",{url:c(u.url)});let h=await m({event:r,plugins:a,response:s,request:u});if(!h)return;const f=await caches.open(e),w=p(a,l);let g=w.length>0?await y({cacheName:e,matchOptions:i,request:u}):null;try{await f.put(u,h)}catch(e){throw\"QuotaExceededError\"===e.name&&await o(),e}for(let t of w)await t[l].call(t,{cacheName:e,event:r,oldResponse:g,newResponse:h,request:u})},match:y};class x{constructor(e,t,{onupgradeneeded:n,onversionchange:s=this.t}={}){this.s=e,this.i=t,this.o=n,this.t=s,this.l=null}get db(){return this.l}async open(){if(!this.l)return this.l=await new Promise((e,t)=>{let n=!1;setTimeout(()=>{n=!0,t(new Error(\"The open request was blocked and timed out\"))},this.OPEN_TIMEOUT);const s=indexedDB.open(this.s,this.i);s.onerror=(()=>t(s.error)),s.onupgradeneeded=(e=>{n?(s.transaction.abort(),e.target.result.close()):this.o&&this.o(e)}),s.onsuccess=(({target:t})=>{const s=t.result;n?s.close():(s.onversionchange=this.t.bind(this),e(s))})}),this}async getKey(e,t){return(await this.getAllKeys(e,t,1))[0]}async getAll(e,t,n){return await this.getAllMatching(e,{query:t,count:n})}async getAllKeys(e,t,n){return(await this.getAllMatching(e,{query:t,count:n,includeKeys:!0})).map(({key:e})=>e)}async getAllMatching(e,{index:t,query:n=null,direction:s=\"next\",count:r,includeKeys:a}={}){return await this.transaction([e],\"readonly\",(i,c)=>{const o=i.objectStore(e),l=t?o.index(t):o,u=[];l.openCursor(n,s).onsuccess=(({target:e})=>{const t=e.result;if(t){const{primaryKey:e,key:n,value:s}=t;u.push(a?{primaryKey:e,key:n,value:s}:s),r&&u.length>=r?c(u):t.continue()}else c(u)})})}async transaction(e,t,n){return await this.open(),await new Promise((s,r)=>{const a=this.l.transaction(e,t);a.onabort=(({target:e})=>r(e.error)),a.oncomplete=(()=>s()),n(a,e=>s(e))})}async u(e,t,n,...s){return await this.transaction([t],n,(n,r)=>{n.objectStore(t)[e](...s).onsuccess=(({target:e})=>{r(e.result)})})}t(){this.close()}close(){this.l&&(this.l.close(),this.l=null)}}x.prototype.OPEN_TIMEOUT=2e3;const b={readonly:[\"get\",\"count\",\"getKey\",\"getAll\",\"getAllKeys\"],readwrite:[\"add\",\"put\",\"clear\",\"delete\"]};for(const[e,t]of Object.entries(b))for(const n of t)n in IDBObjectStore.prototype&&(x.prototype[n]=async function(t,...s){return await this.u(n,t,e,...s)});const D={fetch:async({request:e,fetchOptions:t,event:s,plugins:r=[]})=>{if(s&&s.preloadResponse){const e=await s.preloadResponse;if(e)return e}\"string\"==typeof e&&(e=new Request(e));const a=p(r,w),i=a.length>0?e.clone():null;try{for(let t of r)d in t&&(e=await t[d].call(t,{request:e.clone(),event:s}))}catch(e){throw new n(\"plugin-error-request-will-fetch\",{thrownError:e})}let c=e.clone();try{let n;n=\"navigate\"===e.mode?await fetch(e):await fetch(e,t);for(const e of r)g in e&&(n=await e[g].call(e,{event:s,request:c,response:n}));return n}catch(e){for(const t of a)await t[w].call(t,{error:e,event:s,originalRequest:i.clone(),request:c.clone()});throw e}}};var E=Object.freeze({assert:null,cacheNames:i,cacheWrapper:v,DBWrapper:x,Deferred:class{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}},deleteDatabase:async e=>{await new Promise((t,n)=>{const s=indexedDB.deleteDatabase(e);s.onerror=(({target:e})=>{n(e.error)}),s.onblocked=(()=>{n(new Error(\"Delete blocked\"))}),s.onsuccess=(()=>{t()})})},executeQuotaErrorCallbacks:o,fetchWrapper:D,getFriendlyURL:c,logger:null,WorkboxError:n});const N={get googleAnalytics(){return i.getGoogleAnalyticsName()},get precache(){return i.getPrecacheName()},get prefix(){return i.getPrefix()},get runtime(){return i.getRuntimeName()},get suffix(){return i.getSuffix()}};try{self.workbox.v=self.workbox.v||{}}catch(e){}return e._private=E,e.clientsClaim=(()=>{addEventListener(\"activate\",()=>clients.claim())}),e.cacheNames=N,e.registerQuotaErrorCallback=function(e){s.add(e)},e.setCacheNameDetails=(e=>{i.updateDetails(e)}),e.skipWaiting=(()=>{addEventListener(\"install\",()=>self.skipWaiting())}),e}({});\n+//# sourceMappingURL=workbox-core.prod.js.map"
    },
    {
      "sha": "71b89fb5a7a000f4abe29bbaa23dfb707337f960",
      "filename": "public/javascripts/workbox/workbox-core.prod.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.prod.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-core.prod.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-core.prod.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-core.prod.js\",\"sources\":[\"../_version.mjs\",\"../_private/logger.mjs\",\"../models/messages/messageGenerator.mjs\",\"../_private/WorkboxError.mjs\",\"../_private/assert.mjs\",\"../models/quotaErrorCallbacks.mjs\",\"../_private/cacheNames.mjs\",\"../_private/getFriendlyURL.mjs\",\"../_private/executeQuotaErrorCallbacks.mjs\",\"../models/pluginEvents.mjs\",\"../utils/pluginUtils.mjs\",\"../_private/cacheWrapper.mjs\",\"../_private/DBWrapper.mjs\",\"../_private/deleteDatabase.mjs\",\"../_private/fetchWrapper.mjs\",\"../_private/Deferred.mjs\",\"../cacheNames.mjs\",\"../index.mjs\",\"../clientsClaim.mjs\",\"../registerQuotaErrorCallback.mjs\",\"../setCacheNameDetails.mjs\",\"../skipWaiting.mjs\"],\"sourcesContent\":[\"try{self['workbox:core:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2019 Google LLC\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\nconst logger = process.env.NODE_ENV === 'production' ? null : (() => {\\n  let inGroup = false;\\n\\n  const methodToColorMap = {\\n    debug: `#7f8c8d`, // Gray\\n    log: `#2ecc71`, // Green\\n    warn: `#f39c12`, // Yellow\\n    error: `#c0392b`, // Red\\n    groupCollapsed: `#3498db`, // Blue\\n    groupEnd: null, // No colored prefix on groupEnd\\n  };\\n\\n  const print = function(method, args) {\\n    if (method === 'groupCollapsed') {\\n      // Safari doesn't print all console.groupCollapsed() arguments:\\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\\n        console[method](...args);\\n        return;\\n      }\\n    }\\n\\n    const styles = [\\n      `background: ${methodToColorMap[method]}`,\\n      `border-radius: 0.5em`,\\n      `color: white`,\\n      `font-weight: bold`,\\n      `padding: 2px 0.5em`,\\n    ];\\n\\n    // When in a group, the workbox prefix is not displayed.\\n    const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\\n\\n    console[method](...logPrefix, ...args);\\n\\n    if (method === 'groupCollapsed') {\\n      inGroup = true;\\n    }\\n    if (method === 'groupEnd') {\\n      inGroup = false;\\n    }\\n  };\\n\\n  const api = {};\\n  for (const method of Object.keys(methodToColorMap)) {\\n    api[method] = (...args) => {\\n      print(method, args);\\n    };\\n  }\\n\\n  return api;\\n})();\\n\\nexport {logger};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {messages} from './messages.mjs';\\nimport '../../_version.mjs';\\n\\nconst fallback = (code, ...args) => {\\n  let msg = code;\\n  if (args.length > 0) {\\n    msg += ` :: ${JSON.stringify(args)}`;\\n  }\\n  return msg;\\n};\\n\\nconst generatorFunction = (code, ...args) => {\\n  const message = messages[code];\\n  if (!message) {\\n    throw new Error(`Unable to find message for code '${code}'.`);\\n  }\\n\\n  return message(...args);\\n};\\n\\nexport const messageGenerator = (process.env.NODE_ENV === 'production') ?\\n    fallback : generatorFunction;\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {messageGenerator} from '../models/messages/messageGenerator.mjs';\\nimport '../_version.mjs';\\n\\n/**\\n * Workbox errors should be thrown with this class.\\n * This allows use to ensure the type easily in tests,\\n * helps developers identify errors from workbox\\n * easily and allows use to optimise error\\n * messages correctly.\\n *\\n * @private\\n */\\nclass WorkboxError extends Error {\\n  /**\\n   *\\n   * @param {string} errorCode The error code that\\n   * identifies this particular error.\\n   * @param {Object=} details Any relevant arguments\\n   * that will help developers identify issues should\\n   * be added as a key on the context object.\\n   */\\n  constructor(errorCode, details) {\\n    let message = messageGenerator(errorCode, details);\\n\\n    super(message);\\n\\n    this.name = errorCode;\\n    this.details = details;\\n  }\\n}\\n\\nexport {WorkboxError};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {WorkboxError} from '../_private/WorkboxError.mjs';\\nimport '../_version.mjs';\\n\\n/*\\n * This method returns true if the current context is a service worker.\\n */\\nconst isSWEnv = (moduleName) => {\\n  if (!('ServiceWorkerGlobalScope' in self)) {\\n    throw new WorkboxError('not-in-sw', {moduleName});\\n  }\\n};\\n\\n/*\\n * This method throws if the supplied value is not an array.\\n * The destructed values are required to produce a meaningful error for users.\\n * The destructed and restructured object is so it's clear what is\\n * needed.\\n */\\nconst isArray = (value, {moduleName, className, funcName, paramName}) => {\\n  if (!Array.isArray(value)) {\\n    throw new WorkboxError('not-an-array', {\\n      moduleName,\\n      className,\\n      funcName,\\n      paramName,\\n    });\\n  }\\n};\\n\\nconst hasMethod = (object, expectedMethod,\\n    {moduleName, className, funcName, paramName}) => {\\n  const type = typeof object[expectedMethod];\\n  if (type !== 'function') {\\n    throw new WorkboxError('missing-a-method', {paramName, expectedMethod,\\n      moduleName, className, funcName});\\n  }\\n};\\n\\nconst isType = (object, expectedType,\\n    {moduleName, className, funcName, paramName}) => {\\n  if (typeof object !== expectedType) {\\n    throw new WorkboxError('incorrect-type', {paramName, expectedType,\\n      moduleName, className, funcName});\\n  }\\n};\\n\\nconst isInstance = (object, expectedClass,\\n    {moduleName, className, funcName,\\n      paramName, isReturnValueProblem}) => {\\n  if (!(object instanceof expectedClass)) {\\n    throw new WorkboxError('incorrect-class', {paramName, expectedClass,\\n      moduleName, className, funcName, isReturnValueProblem});\\n  }\\n};\\n\\nconst isOneOf = (value, validValues, {paramName}) => {\\n  if (!validValues.includes(value)) {\\n    throw new WorkboxError('invalid-value', {\\n      paramName,\\n      value,\\n      validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`,\\n    });\\n  }\\n};\\n\\nconst isArrayOfClass = (value, expectedClass,\\n    {moduleName, className, funcName, paramName}) => {\\n  const error = new WorkboxError('not-array-of-class', {\\n    value, expectedClass,\\n    moduleName, className, funcName, paramName,\\n  });\\n  if (!Array.isArray(value)) {\\n    throw error;\\n  }\\n\\n  for (let item of value) {\\n    if (!(item instanceof expectedClass)) {\\n      throw error;\\n    }\\n  }\\n};\\n\\nconst finalAssertExports = process.env.NODE_ENV === 'production' ? null : {\\n  hasMethod,\\n  isArray,\\n  isInstance,\\n  isOneOf,\\n  isSWEnv,\\n  isType,\\n  isArrayOfClass,\\n};\\n\\nexport {finalAssertExports as assert};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n// Callbacks to be executed whenever there's a quota error.\\nconst quotaErrorCallbacks = new Set();\\n\\nexport {quotaErrorCallbacks};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\nconst _cacheNameDetails = {\\n  googleAnalytics: 'googleAnalytics',\\n  precache: 'precache-v2',\\n  prefix: 'workbox',\\n  runtime: 'runtime',\\n  suffix: self.registration.scope,\\n};\\n\\nconst _createCacheName = (cacheName) => {\\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix]\\n      .filter((value) => value.length > 0)\\n      .join('-');\\n};\\n\\nexport const cacheNames = {\\n  updateDetails: (details) => {\\n    Object.keys(_cacheNameDetails).forEach((key) => {\\n      if (typeof details[key] !== 'undefined') {\\n        _cacheNameDetails[key] = details[key];\\n      }\\n    });\\n  },\\n  getGoogleAnalyticsName: (userCacheName) => {\\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\\n  },\\n  getPrecacheName: (userCacheName) => {\\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\\n  },\\n  getPrefix: () => {\\n    return _cacheNameDetails.prefix;\\n  },\\n  getRuntimeName: (userCacheName) => {\\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\\n  },\\n  getSuffix: () => {\\n    return _cacheNameDetails.suffix;\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\nconst getFriendlyURL = (url) => {\\n  const urlObj = new URL(url, location);\\n  if (urlObj.origin === location.origin) {\\n    return urlObj.pathname;\\n  }\\n  return urlObj.href;\\n};\\n\\nexport {getFriendlyURL};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from '../_private/logger.mjs';\\nimport {quotaErrorCallbacks} from '../models/quotaErrorCallbacks.mjs';\\nimport '../_version.mjs';\\n\\n\\n/**\\n * Runs all of the callback functions, one at a time sequentially, in the order\\n * in which they were registered.\\n *\\n * @memberof workbox.core\\n * @private\\n */\\nasync function executeQuotaErrorCallbacks() {\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.log(`About to run ${quotaErrorCallbacks.size} ` +\\n        `callbacks to clean up caches.`);\\n  }\\n\\n  for (const callback of quotaErrorCallbacks) {\\n    await callback();\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.log(callback, 'is complete.');\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.log('Finished running callbacks.');\\n  }\\n}\\n\\nexport {executeQuotaErrorCallbacks};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\nexport const pluginEvents = {\\n  CACHE_DID_UPDATE: 'cacheDidUpdate',\\n  CACHE_KEY_WILL_BE_USED: 'cacheKeyWillBeUsed',\\n  CACHE_WILL_UPDATE: 'cacheWillUpdate',\\n  CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\\n  FETCH_DID_FAIL: 'fetchDidFail',\\n  FETCH_DID_SUCCEED: 'fetchDidSucceed',\\n  REQUEST_WILL_FETCH: 'requestWillFetch',\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\nexport const pluginUtils = {\\n  filter: (plugins, callbackName) => {\\n    return plugins.filter((plugin) => callbackName in plugin);\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {WorkboxError} from './WorkboxError.mjs';\\nimport {assert} from './assert.mjs';\\nimport {getFriendlyURL} from './getFriendlyURL.mjs';\\nimport {logger} from './logger.mjs';\\nimport {executeQuotaErrorCallbacks} from './executeQuotaErrorCallbacks.mjs';\\nimport {pluginEvents} from '../models/pluginEvents.mjs';\\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\\nimport '../_version.mjs';\\n\\n\\n/**\\n * Wrapper around cache.put().\\n *\\n * Will call `cacheDidUpdate` on plugins if the cache was updated, using\\n * `matchOptions` when determining what the old entry is.\\n *\\n * @param {Object} options\\n * @param {string} options.cacheName\\n * @param {Request} options.request\\n * @param {Response} options.response\\n * @param {Event} [options.event]\\n * @param {Array<Object>} [options.plugins=[]]\\n * @param {Object} [options.matchOptions]\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst putWrapper = async ({\\n  cacheName,\\n  request,\\n  response,\\n  event,\\n  plugins = [],\\n  matchOptions,\\n} = {}) => {\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (request.method && request.method !== 'GET') {\\n      throw new WorkboxError('attempt-to-cache-non-get-request', {\\n        url: getFriendlyURL(request.url),\\n        method: request.method,\\n      });\\n    }\\n  }\\n\\n  const effectiveRequest = await _getEffectiveRequest({\\n    plugins, request, mode: 'write'});\\n\\n  if (!response) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.error(`Cannot cache non-existent response for ` +\\n        `'${getFriendlyURL(effectiveRequest.url)}'.`);\\n    }\\n\\n    throw new WorkboxError('cache-put-with-no-response', {\\n      url: getFriendlyURL(effectiveRequest.url),\\n    });\\n  }\\n\\n  let responseToCache = await _isResponseSafeToCache({\\n    event,\\n    plugins,\\n    response,\\n    request: effectiveRequest,\\n  });\\n\\n  if (!responseToCache) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' will ` +\\n      `not be cached.`, responseToCache);\\n    }\\n    return;\\n  }\\n\\n  const cache = await caches.open(cacheName);\\n\\n  const updatePlugins = pluginUtils.filter(\\n      plugins, pluginEvents.CACHE_DID_UPDATE);\\n\\n  let oldResponse = updatePlugins.length > 0 ?\\n      await matchWrapper({cacheName, matchOptions, request: effectiveRequest}) :\\n      null;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.debug(`Updating the '${cacheName}' cache with a new Response for ` +\\n      `${getFriendlyURL(effectiveRequest.url)}.`);\\n  }\\n\\n  try {\\n    await cache.put(effectiveRequest, responseToCache);\\n  } catch (error) {\\n    // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\\n    if (error.name === 'QuotaExceededError') {\\n      await executeQuotaErrorCallbacks();\\n    }\\n    throw error;\\n  }\\n\\n  for (let plugin of updatePlugins) {\\n    await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\\n      cacheName,\\n      event,\\n      oldResponse,\\n      newResponse: responseToCache,\\n      request: effectiveRequest,\\n    });\\n  }\\n};\\n\\n/**\\n * This is a wrapper around cache.match().\\n *\\n * @param {Object} options\\n * @param {string} options.cacheName Name of the cache to match against.\\n * @param {Request} options.request The Request that will be used to look up\\n *     cache entries.\\n * @param {Event} [options.event] The event that propted the action.\\n * @param {Object} [options.matchOptions] Options passed to cache.match().\\n * @param {Array<Object>} [options.plugins=[]] Array of plugins.\\n * @return {Response} A cached response if available.\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst matchWrapper = async ({\\n  cacheName,\\n  request,\\n  event,\\n  matchOptions,\\n  plugins = [],\\n}) => {\\n  const cache = await caches.open(cacheName);\\n\\n  const effectiveRequest = await _getEffectiveRequest({\\n    plugins, request, mode: 'read'});\\n\\n  let cachedResponse = await cache.match(effectiveRequest, matchOptions);\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (cachedResponse) {\\n      logger.debug(`Found a cached response in '${cacheName}'.`);\\n    } else {\\n      logger.debug(`No cached response found in '${cacheName}'.`);\\n    }\\n  }\\n\\n  for (const plugin of plugins) {\\n    if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\\n      cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED]\\n          .call(plugin, {\\n            cacheName,\\n            event,\\n            matchOptions,\\n            cachedResponse,\\n            request: effectiveRequest,\\n          });\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (cachedResponse) {\\n          assert.isInstance(cachedResponse, Response, {\\n            moduleName: 'Plugin',\\n            funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\\n            isReturnValueProblem: true,\\n          });\\n        }\\n      }\\n    }\\n  }\\n\\n  return cachedResponse;\\n};\\n\\n/**\\n * This method will call cacheWillUpdate on the available plugins (or use\\n * status === 200) to determine if the Response is safe and valid to cache.\\n *\\n * @param {Object} options\\n * @param {Request} options.request\\n * @param {Response} options.response\\n * @param {Event} [options.event]\\n * @param {Array<Object>} [options.plugins=[]]\\n * @return {Promise<Response>}\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst _isResponseSafeToCache = async ({request, response, event, plugins}) => {\\n  let responseToCache = response;\\n  let pluginsUsed = false;\\n  for (let plugin of plugins) {\\n    if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\\n      pluginsUsed = true;\\n      responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE]\\n          .call(plugin, {\\n            request,\\n            response: responseToCache,\\n            event,\\n          });\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (responseToCache) {\\n          assert.isInstance(responseToCache, Response, {\\n            moduleName: 'Plugin',\\n            funcName: pluginEvents.CACHE_WILL_UPDATE,\\n            isReturnValueProblem: true,\\n          });\\n        }\\n      }\\n\\n      if (!responseToCache) {\\n        break;\\n      }\\n    }\\n  }\\n\\n  if (!pluginsUsed) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!responseToCache.status === 200) {\\n        if (responseToCache.status === 0) {\\n          logger.warn(`The response for '${request.url}' is an opaque ` +\\n            `response. The caching strategy that you're using will not ` +\\n            `cache opaque responses by default.`);\\n        } else {\\n          logger.debug(`The response for '${request.url}' returned ` +\\n          `a status code of '${response.status}' and won't be cached as a ` +\\n          `result.`);\\n        }\\n      }\\n    }\\n    responseToCache = responseToCache.status === 200 ? responseToCache : null;\\n  }\\n\\n  return responseToCache ? responseToCache : null;\\n};\\n\\n/**\\n * Checks the list of plugins for the cacheKeyWillBeUsed callback, and\\n * executes any of those callbacks found in sequence. The final `Request` object\\n * returned by the last plugin is treated as the cache key for cache reads\\n * and/or writes.\\n *\\n * @param {Object} options\\n * @param {Request} options.request\\n * @param {string} options.mode\\n * @param {Array<Object>} [options.plugins=[]]\\n * @return {Promise<Request>}\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst _getEffectiveRequest = async ({request, mode, plugins}) => {\\n  const cacheKeyWillBeUsedPlugins = pluginUtils.filter(\\n      plugins, pluginEvents.CACHE_KEY_WILL_BE_USED);\\n\\n  let effectiveRequest = request;\\n  for (const plugin of cacheKeyWillBeUsedPlugins) {\\n    effectiveRequest = await plugin[pluginEvents.CACHE_KEY_WILL_BE_USED].call(\\n        plugin, {mode, request: effectiveRequest});\\n\\n    if (typeof effectiveRequest === 'string') {\\n      effectiveRequest = new Request(effectiveRequest);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(effectiveRequest, Request, {\\n        moduleName: 'Plugin',\\n        funcName: pluginEvents.CACHE_KEY_WILL_BE_USED,\\n        isReturnValueProblem: true,\\n      });\\n    }\\n  }\\n\\n  return effectiveRequest;\\n};\\n\\nexport const cacheWrapper = {\\n  put: putWrapper,\\n  match: matchWrapper,\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n/**\\n * A class that wraps common IndexedDB functionality in a promise-based API.\\n * It exposes all the underlying power and functionality of IndexedDB, but\\n * wraps the most commonly used features in a way that's much simpler to use.\\n *\\n * @private\\n */\\nexport class DBWrapper {\\n  /**\\n   * @param {string} name\\n   * @param {number} version\\n   * @param {Object=} [callback]\\n   * @param {!Function} [callbacks.onupgradeneeded]\\n   * @param {!Function} [callbacks.onversionchange] Defaults to\\n   *     DBWrapper.prototype._onversionchange when not specified.\\n   * @private\\n   */\\n  constructor(name, version, {\\n    onupgradeneeded,\\n    onversionchange = this._onversionchange,\\n  } = {}) {\\n    this._name = name;\\n    this._version = version;\\n    this._onupgradeneeded = onupgradeneeded;\\n    this._onversionchange = onversionchange;\\n\\n    // If this is null, it means the database isn't open.\\n    this._db = null;\\n  }\\n\\n  /**\\n   * Returns the IDBDatabase instance (not normally needed).\\n   *\\n   * @private\\n   */\\n  get db() {\\n    return this._db;\\n  }\\n\\n  /**\\n   * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\\n   * callback, and added an onversionchange callback to the database.\\n   *\\n   * @return {IDBDatabase}\\n   * @private\\n   */\\n  async open() {\\n    if (this._db) return;\\n\\n    this._db = await new Promise((resolve, reject) => {\\n      // This flag is flipped to true if the timeout callback runs prior\\n      // to the request failing or succeeding. Note: we use a timeout instead\\n      // of an onblocked handler since there are cases where onblocked will\\n      // never never run. A timeout better handles all possible scenarios:\\n      // https://github.com/w3c/IndexedDB/issues/223\\n      let openRequestTimedOut = false;\\n      setTimeout(() => {\\n        openRequestTimedOut = true;\\n        reject(new Error('The open request was blocked and timed out'));\\n      }, this.OPEN_TIMEOUT);\\n\\n      const openRequest = indexedDB.open(this._name, this._version);\\n      openRequest.onerror = () => reject(openRequest.error);\\n      openRequest.onupgradeneeded = (evt) => {\\n        if (openRequestTimedOut) {\\n          openRequest.transaction.abort();\\n          evt.target.result.close();\\n        } else if (this._onupgradeneeded) {\\n          this._onupgradeneeded(evt);\\n        }\\n      };\\n      openRequest.onsuccess = ({target}) => {\\n        const db = target.result;\\n        if (openRequestTimedOut) {\\n          db.close();\\n        } else {\\n          db.onversionchange = this._onversionchange.bind(this);\\n          resolve(db);\\n        }\\n      };\\n    });\\n\\n    return this;\\n  }\\n\\n  /**\\n   * Polyfills the native `getKey()` method. Note, this is overridden at\\n   * runtime if the browser supports the native method.\\n   *\\n   * @param {string} storeName\\n   * @param {*} query\\n   * @return {Array}\\n   * @private\\n   */\\n  async getKey(storeName, query) {\\n    return (await this.getAllKeys(storeName, query, 1))[0];\\n  }\\n\\n  /**\\n   * Polyfills the native `getAll()` method. Note, this is overridden at\\n   * runtime if the browser supports the native method.\\n   *\\n   * @param {string} storeName\\n   * @param {*} query\\n   * @param {number} count\\n   * @return {Array}\\n   * @private\\n   */\\n  async getAll(storeName, query, count) {\\n    return await this.getAllMatching(storeName, {query, count});\\n  }\\n\\n\\n  /**\\n   * Polyfills the native `getAllKeys()` method. Note, this is overridden at\\n   * runtime if the browser supports the native method.\\n   *\\n   * @param {string} storeName\\n   * @param {*} query\\n   * @param {number} count\\n   * @return {Array}\\n   * @private\\n   */\\n  async getAllKeys(storeName, query, count) {\\n    return (await this.getAllMatching(\\n        storeName, {query, count, includeKeys: true})).map(({key}) => key);\\n  }\\n\\n  /**\\n   * Supports flexible lookup in an object store by specifying an index,\\n   * query, direction, and count. This method returns an array of objects\\n   * with the signature .\\n   *\\n   * @param {string} storeName\\n   * @param {Object} [opts]\\n   * @param {string} [opts.index] The index to use (if specified).\\n   * @param {*} [opts.query]\\n   * @param {IDBCursorDirection} [opts.direction]\\n   * @param {number} [opts.count] The max number of results to return.\\n   * @param {boolean} [opts.includeKeys] When true, the structure of the\\n   *     returned objects is changed from an array of values to an array of\\n   *     objects in the form {key, primaryKey, value}.\\n   * @return {Array}\\n   * @private\\n   */\\n  async getAllMatching(storeName, {\\n    index,\\n    query = null, // IE errors if query === `undefined`.\\n    direction = 'next',\\n    count,\\n    includeKeys,\\n  } = {}) {\\n    return await this.transaction([storeName], 'readonly', (txn, done) => {\\n      const store = txn.objectStore(storeName);\\n      const target = index ? store.index(index) : store;\\n      const results = [];\\n\\n      target.openCursor(query, direction).onsuccess = ({target}) => {\\n        const cursor = target.result;\\n        if (cursor) {\\n          const {primaryKey, key, value} = cursor;\\n          results.push(includeKeys ? {primaryKey, key, value} : value);\\n          if (count && results.length >= count) {\\n            done(results);\\n          } else {\\n            cursor.continue();\\n          }\\n        } else {\\n          done(results);\\n        }\\n      };\\n    });\\n  }\\n\\n  /**\\n   * Accepts a list of stores, a transaction type, and a callback and\\n   * performs a transaction. A promise is returned that resolves to whatever\\n   * value the callback chooses. The callback holds all the transaction logic\\n   * and is invoked with two arguments:\\n   *   1. The IDBTransaction object\\n   *   2. A `done` function, that's used to resolve the promise when\\n   *      when the transaction is done, if passed a value, the promise is\\n   *      resolved to that value.\\n   *\\n   * @param {Array<string>} storeNames An array of object store names\\n   *     involved in the transaction.\\n   * @param {string} type Can be `readonly` or `readwrite`.\\n   * @param {!Function} callback\\n   * @return {*} The result of the transaction ran by the callback.\\n   * @private\\n   */\\n  async transaction(storeNames, type, callback) {\\n    await this.open();\\n    return await new Promise((resolve, reject) => {\\n      const txn = this._db.transaction(storeNames, type);\\n      txn.onabort = ({target}) => reject(target.error);\\n      txn.oncomplete = () => resolve();\\n\\n      callback(txn, (value) => resolve(value));\\n    });\\n  }\\n\\n  /**\\n   * Delegates async to a native IDBObjectStore method.\\n   *\\n   * @param {string} method The method name.\\n   * @param {string} storeName The object store name.\\n   * @param {string} type Can be `readonly` or `readwrite`.\\n   * @param {...*} args The list of args to pass to the native method.\\n   * @return {*} The result of the transaction.\\n   * @private\\n   */\\n  async _call(method, storeName, type, ...args) {\\n    const callback = (txn, done) => {\\n      txn.objectStore(storeName)[method](...args).onsuccess = ({target}) => {\\n        done(target.result);\\n      };\\n    };\\n\\n    return await this.transaction([storeName], type, callback);\\n  }\\n\\n  /**\\n   * The default onversionchange handler, which closes the database so other\\n   * connections can open without being blocked.\\n   *\\n   * @private\\n   */\\n  _onversionchange() {\\n    this.close();\\n  }\\n\\n  /**\\n   * Closes the connection opened by `DBWrapper.open()`. Generally this method\\n   * doesn't need to be called since:\\n   *   1. It's usually better to keep a connection open since opening\\n   *      a new connection is somewhat slow.\\n   *   2. Connections are automatically closed when the reference is\\n   *      garbage collected.\\n   * The primary use case for needing to close a connection is when another\\n   * reference (typically in another tab) needs to upgrade it and would be\\n   * blocked by the current, open connection.\\n   *\\n   * @private\\n   */\\n  close() {\\n    if (this._db) {\\n      this._db.close();\\n      this._db = null;\\n    }\\n  }\\n}\\n\\n// Exposed to let users modify the default timeout on a per-instance\\n// or global basis.\\nDBWrapper.prototype.OPEN_TIMEOUT = 2000;\\n\\n// Wrap native IDBObjectStore methods according to their mode.\\nconst methodsToWrap = {\\n  'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\\n  'readwrite': ['add', 'put', 'clear', 'delete'],\\n};\\nfor (const [mode, methods] of Object.entries(methodsToWrap)) {\\n  for (const method of methods) {\\n    if (method in IDBObjectStore.prototype) {\\n      // Don't use arrow functions here since we're outside of the class.\\n      DBWrapper.prototype[method] = async function(storeName, ...args) {\\n        return await this._call(method, storeName, mode, ...args);\\n      };\\n    }\\n  }\\n}\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n/**\\n * Deletes the database.\\n * Note: this is exported separately from the DBWrapper module because most\\n * usages of IndexedDB in workbox dont need deleting, and this way it can be\\n * reused in tests to delete databases without creating DBWrapper instances.\\n *\\n * @param {string} name The database name.\\n * @private\\n */\\nexport const deleteDatabase = async (name) => {\\n  await new Promise((resolve, reject) => {\\n    const request = indexedDB.deleteDatabase(name);\\n    request.onerror = ({target}) => {\\n      reject(target.error);\\n    };\\n    request.onblocked = () => {\\n      reject(new Error('Delete blocked'));\\n    };\\n    request.onsuccess = () => {\\n      resolve();\\n    };\\n  });\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {WorkboxError} from './WorkboxError.mjs';\\nimport {logger} from './logger.mjs';\\nimport {assert} from './assert.mjs';\\nimport {getFriendlyURL} from '../_private/getFriendlyURL.mjs';\\nimport {pluginEvents} from '../models/pluginEvents.mjs';\\nimport {pluginUtils} from '../utils/pluginUtils.mjs';\\nimport '../_version.mjs';\\n\\n/**\\n * Wrapper around the fetch API.\\n *\\n * Will call requestWillFetch on available plugins.\\n *\\n * @param {Object} options\\n * @param {Request|string} options.request\\n * @param {Object} [options.fetchOptions]\\n * @param {Event} [options.event]\\n * @param {Array<Object>} [options.plugins=[]]\\n * @return {Promise<Response>}\\n *\\n * @private\\n * @memberof module:workbox-core\\n */\\nconst wrappedFetch = async ({\\n  request,\\n  fetchOptions,\\n  event,\\n  plugins = []}) => {\\n  // We *should* be able to call `await event.preloadResponse` even if it's\\n  // undefined, but for some reason, doing so leads to errors in our Node unit\\n  // tests. To work around that, explicitly check preloadResponse's value first.\\n  if (event && event.preloadResponse) {\\n    const possiblePreloadResponse = await event.preloadResponse;\\n    if (possiblePreloadResponse) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.log(`Using a preloaded navigation response for ` +\\n          `'${getFriendlyURL(request.url)}'`);\\n      }\\n      return possiblePreloadResponse;\\n    }\\n  }\\n\\n  if (typeof request === 'string') {\\n    request = new Request(request);\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    assert.isInstance(request, Request, {\\n      paramName: request,\\n      expectedClass: 'Request',\\n      moduleName: 'workbox-core',\\n      className: 'fetchWrapper',\\n      funcName: 'wrappedFetch',\\n    });\\n  }\\n\\n  const failedFetchPlugins = pluginUtils.filter(\\n      plugins, pluginEvents.FETCH_DID_FAIL);\\n\\n  // If there is a fetchDidFail plugin, we need to save a clone of the\\n  // original request before it's either modified by a requestWillFetch\\n  // plugin or before the original request's body is consumed via fetch().\\n  const originalRequest = failedFetchPlugins.length > 0 ?\\n    request.clone() : null;\\n\\n  try {\\n    for (let plugin of plugins) {\\n      if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\\n        request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\\n          request: request.clone(),\\n          event,\\n        });\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          if (request) {\\n            assert.isInstance(request, Request, {\\n              moduleName: 'Plugin',\\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\\n              isReturnValueProblem: true,\\n            });\\n          }\\n        }\\n      }\\n    }\\n  } catch (err) {\\n    throw new WorkboxError('plugin-error-request-will-fetch', {\\n      thrownError: err,\\n    });\\n  }\\n\\n  // The request can be altered by plugins with `requestWillFetch` making\\n  // the original request (Most likely from a `fetch` event) to be different\\n  // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\\n  let pluginFilteredRequest = request.clone();\\n\\n  try {\\n    let fetchResponse;\\n\\n    // See https://github.com/GoogleChrome/workbox/issues/1796\\n    if (request.mode === 'navigate') {\\n      fetchResponse = await fetch(request);\\n    } else {\\n      fetchResponse = await fetch(request, fetchOptions);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.debug(`Network request for `+\\n      `'${getFriendlyURL(request.url)}' returned a response with ` +\\n      `status '${fetchResponse.status}'.`);\\n    }\\n\\n    for (const plugin of plugins) {\\n      if (pluginEvents.FETCH_DID_SUCCEED in plugin) {\\n        fetchResponse = await plugin[pluginEvents.FETCH_DID_SUCCEED]\\n            .call(plugin, {\\n              event,\\n              request: pluginFilteredRequest,\\n              response: fetchResponse,\\n            });\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          if (fetchResponse) {\\n            assert.isInstance(fetchResponse, Response, {\\n              moduleName: 'Plugin',\\n              funcName: pluginEvents.FETCH_DID_SUCCEED,\\n              isReturnValueProblem: true,\\n            });\\n          }\\n        }\\n      }\\n    }\\n\\n    return fetchResponse;\\n  } catch (error) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.error(`Network request for `+\\n      `'${getFriendlyURL(request.url)}' threw an error.`, error);\\n    }\\n\\n    for (const plugin of failedFetchPlugins) {\\n      await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\\n        error,\\n        event,\\n        originalRequest: originalRequest.clone(),\\n        request: pluginFilteredRequest.clone(),\\n      });\\n    }\\n\\n    throw error;\\n  }\\n};\\n\\nconst fetchWrapper = {\\n  fetch: wrappedFetch,\\n};\\n\\nexport {fetchWrapper};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n\\n/**\\n * The Deferred class composes Promises in a way that allows for them to be\\n * resolved or rejected from outside the constructor. In most cases promises\\n * should be used directly, but Deferreds can be necessary when the logic to\\n * resolve a promise must be separate.\\n *\\n * @private\\n */\\nexport class Deferred {\\n  /**\\n   * Creates a promise and exposes its resolve and reject functions as methods.\\n   */\\n  constructor() {\\n    this.promise = new Promise((resolve, reject) => {\\n      this.resolve = resolve;\\n      this.reject = reject;\\n    });\\n  }\\n}\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {cacheNames as _cacheNames} from './_private/cacheNames.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Get the current cache names and prefix/suffix used by Workbox.\\n *\\n * `cacheNames.precache` is used for precached assets,\\n * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\\n * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\\n *\\n * `cacheNames.prefix` can be used to retrieve just the current prefix value.\\n * `cacheNames.suffix` can be used to retrieve just the current suffix value.\\n *\\n * @return {Object} An object with `precache`, `runtime`, `prefix`, and\\n *     `googleAnalytics` properties.\\n *\\n * @alias workbox.core.cacheNames\\n */\\nexport const cacheNames = {\\n  get googleAnalytics() {\\n    return _cacheNames.getGoogleAnalyticsName();\\n  },\\n  get precache() {\\n    return _cacheNames.getPrecacheName();\\n  },\\n  get prefix() {\\n    return _cacheNames.getPrefix();\\n  },\\n  get runtime() {\\n    return _cacheNames.getRuntimeName();\\n  },\\n  get suffix() {\\n    return _cacheNames.getSuffix();\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {registerQuotaErrorCallback} from './registerQuotaErrorCallback.mjs';\\nimport * as _private from './_private.mjs';\\nimport {clientsClaim} from './clientsClaim.mjs';\\nimport {cacheNames} from './cacheNames.mjs';\\nimport {setCacheNameDetails} from './setCacheNameDetails.mjs';\\nimport {skipWaiting} from './skipWaiting.mjs';\\nimport './_version.mjs';\\n\\n\\n// Give our version strings something to hang off of.\\ntry {\\n  self.workbox.v = self.workbox.v || {};\\n} catch (errer) {\\n  // NOOP\\n}\\n\\n/**\\n * All of the Workbox service worker libraries use workbox-core for shared\\n * code as well as setting default values that need to be shared (like cache\\n * names).\\n *\\n * @namespace workbox.core\\n */\\n\\nexport {\\n  _private,\\n  clientsClaim,\\n  cacheNames,\\n  registerQuotaErrorCallback,\\n  setCacheNameDetails,\\n  skipWaiting,\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport './_version.mjs';\\n\\n\\n/**\\n * Claim any currently available clients once the service worker\\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\\n *\\n * @alias workbox.core.clientsClaim\\n */\\nexport const clientsClaim = () => {\\n  addEventListener('activate', () => clients.claim());\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from './_private/logger.mjs';\\nimport {assert} from './_private/assert.mjs';\\nimport {quotaErrorCallbacks} from './models/quotaErrorCallbacks.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\\n * there's a quota error.\\n *\\n * @param {Function} callback\\n * @memberof workbox.core\\n */\\nfunction registerQuotaErrorCallback(callback) {\\n  if (process.env.NODE_ENV !== 'production') {\\n    assert.isType(callback, 'function', {\\n      moduleName: 'workbox-core',\\n      funcName: 'register',\\n      paramName: 'callback',\\n    });\\n  }\\n\\n  quotaErrorCallbacks.add(callback);\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    logger.log('Registered a callback to respond to quota errors.', callback);\\n  }\\n}\\n\\nexport {registerQuotaErrorCallback};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from './_private/assert.mjs';\\nimport {cacheNames} from './_private/cacheNames.mjs';\\nimport {WorkboxError} from './_private/WorkboxError.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Modifies the default cache names used by the Workbox packages.\\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\\n *\\n * @param {Object} details\\n * @param {Object} [details.prefix] The string to add to the beginning of\\n *     the precache and runtime cache names.\\n * @param {Object} [details.suffix] The string to add to the end of\\n *     the precache and runtime cache names.\\n * @param {Object} [details.precache] The cache name to use for precache\\n *     caching.\\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\\n * @param {Object} [details.googleAnalytics] The cache name to use for\\n *     `workbox-google-analytics` caching.\\n *\\n * @alias workbox.core.setCacheNameDetails\\n */\\nexport const setCacheNameDetails = (details) => {\\n  if (process.env.NODE_ENV !== 'production') {\\n    Object.keys(details).forEach((key) => {\\n      assert.isType(details[key], 'string', {\\n        moduleName: 'workbox-core',\\n        funcName: 'setCacheNameDetails',\\n        paramName: `details.${key}`,\\n      });\\n    });\\n\\n    if ('precache' in details && details.precache.length === 0) {\\n      throw new WorkboxError('invalid-cache-name', {\\n        cacheNameId: 'precache',\\n        value: details.precache,\\n      });\\n    }\\n\\n    if ('runtime' in details && details.runtime.length === 0) {\\n      throw new WorkboxError('invalid-cache-name', {\\n        cacheNameId: 'runtime',\\n        value: details.runtime,\\n      });\\n    }\\n\\n    if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\\n      throw new WorkboxError('invalid-cache-name', {\\n        cacheNameId: 'googleAnalytics',\\n        value: details.googleAnalytics,\\n      });\\n    }\\n  }\\n\\n  cacheNames.updateDetails(details);\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport './_version.mjs';\\n\\n\\n/**\\n * Force a service worker to become active, instead of waiting. This is\\n * normally used in conjunction with `clientsClaim()`.\\n *\\n * @alias workbox.core.skipWaiting\\n */\\nexport const skipWaiting = () => {\\n  // We need to explicitly call `self.skipWaiting()` here because we're\\n  // shadowing `skipWaiting` with this local function.\\n  addEventListener('install', () => self.skipWaiting());\\n};\\n\"],\"names\":[\"self\",\"_\",\"e\",\"messageGenerator\",\"code\",\"args\",\"msg\",\"length\",\"JSON\",\"stringify\",\"WorkboxError\",\"Error\",\"constructor\",\"errorCode\",\"details\",\"name\",\"quotaErrorCallbacks\",\"Set\",\"_cacheNameDetails\",\"googleAnalytics\",\"precache\",\"prefix\",\"runtime\",\"suffix\",\"registration\",\"scope\",\"_createCacheName\",\"cacheName\",\"filter\",\"value\",\"join\",\"cacheNames\",\"updateDetails\",\"Object\",\"keys\",\"forEach\",\"key\",\"getGoogleAnalyticsName\",\"userCacheName\",\"getPrecacheName\",\"getPrefix\",\"getRuntimeName\",\"getSuffix\",\"getFriendlyURL\",\"url\",\"urlObj\",\"URL\",\"location\",\"origin\",\"pathname\",\"href\",\"async\",\"executeQuotaErrorCallbacks\",\"callback\",\"pluginEvents\",\"pluginUtils\",\"plugins\",\"callbackName\",\"plugin\",\"matchWrapper\",\"request\",\"event\",\"matchOptions\",\"cache\",\"caches\",\"open\",\"effectiveRequest\",\"_getEffectiveRequest\",\"mode\",\"cachedResponse\",\"match\",\"call\",\"_isResponseSafeToCache\",\"response\",\"responseToCache\",\"pluginsUsed\",\"status\",\"cacheKeyWillBeUsedPlugins\",\"Request\",\"cacheWrapper\",\"put\",\"updatePlugins\",\"oldResponse\",\"error\",\"newResponse\",\"DBWrapper\",\"version\",\"onupgradeneeded\",\"onversionchange\",\"this\",\"_onversionchange\",\"_name\",\"_version\",\"_onupgradeneeded\",\"_db\",\"Promise\",\"resolve\",\"reject\",\"openRequestTimedOut\",\"setTimeout\",\"OPEN_TIMEOUT\",\"openRequest\",\"indexedDB\",\"onerror\",\"evt\",\"transaction\",\"abort\",\"target\",\"result\",\"close\",\"onsuccess\",\"db\",\"bind\",\"storeName\",\"query\",\"getAllKeys\",\"count\",\"getAllMatching\",\"includeKeys\",\"map\",\"index\",\"direction\",\"txn\",\"done\",\"store\",\"objectStore\",\"results\",\"openCursor\",\"cursor\",\"primaryKey\",\"push\",\"continue\",\"storeNames\",\"type\",\"onabort\",\"oncomplete\",\"method\",\"prototype\",\"methodsToWrap\",\"methods\",\"entries\",\"IDBObjectStore\",\"_call\",\"fetchWrapper\",\"fetch\",\"fetchOptions\",\"preloadResponse\",\"possiblePreloadResponse\",\"failedFetchPlugins\",\"originalRequest\",\"clone\",\"err\",\"thrownError\",\"pluginFilteredRequest\",\"fetchResponse\",\"process\",\"promise\",\"deleteDatabase\",\"onblocked\",\"_cacheNames\",\"workbox\",\"v\",\"errer\",\"addEventListener\",\"clients\",\"claim\",\"add\",\"skipWaiting\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
    },
    {
      "sha": "cbd068b4f098b983a24985b550dae46b655beeff",
      "filename": "public/javascripts/workbox/workbox-expiration.dev.js",
      "status": "added",
      "additions": 652,
      "deletions": 0,
      "changes": 652,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.dev.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.dev.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-expiration.dev.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,652 @@\n+this.workbox = this.workbox || {};\n+this.workbox.expiration = (function (exports, DBWrapper_mjs, deleteDatabase_mjs, WorkboxError_mjs, assert_mjs, logger_mjs, cacheNames_mjs, getFriendlyURL_mjs, registerQuotaErrorCallback_mjs) {\n+  'use strict';\n+\n+  try {\n+    self['workbox:expiration:4.3.1'] && _();\n+  } catch (e) {} // eslint-disable-line\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const DB_NAME = 'workbox-expiration';\n+  const OBJECT_STORE_NAME = 'cache-entries';\n+\n+  const normalizeURL = unNormalizedUrl => {\n+    const url = new URL(unNormalizedUrl, location);\n+    url.hash = '';\n+    return url.href;\n+  };\n+  /**\n+   * Returns the timestamp model.\n+   *\n+   * @private\n+   */\n+\n+\n+  class CacheTimestampsModel {\n+    /**\n+     *\n+     * @param {string} cacheName\n+     *\n+     * @private\n+     */\n+    constructor(cacheName) {\n+      this._cacheName = cacheName;\n+      this._db = new DBWrapper_mjs.DBWrapper(DB_NAME, 1, {\n+        onupgradeneeded: event => this._handleUpgrade(event)\n+      });\n+    }\n+    /**\n+     * Should perform an upgrade of indexedDB.\n+     *\n+     * @param {Event} event\n+     *\n+     * @private\n+     */\n+\n+\n+    _handleUpgrade(event) {\n+      const db = event.target.result; // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n+      // have to use the `id` keyPath here and create our own values (a\n+      // concatenation of `url + cacheName`) instead of simply using\n+      // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n+\n+      const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n+        keyPath: 'id'\n+      }); // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n+      // create a single index with the keyPath `['cacheName', 'timestamp']`\n+      // instead of doing both these indexes.\n+\n+      objStore.createIndex('cacheName', 'cacheName', {\n+        unique: false\n+      });\n+      objStore.createIndex('timestamp', 'timestamp', {\n+        unique: false\n+      }); // Previous versions of `workbox-expiration` used `this._cacheName`\n+      // as the IDBDatabase name.\n+\n+      deleteDatabase_mjs.deleteDatabase(this._cacheName);\n+    }\n+    /**\n+     * @param {string} url\n+     * @param {number} timestamp\n+     *\n+     * @private\n+     */\n+\n+\n+    async setTimestamp(url, timestamp) {\n+      url = normalizeURL(url);\n+      await this._db.put(OBJECT_STORE_NAME, {\n+        url,\n+        timestamp,\n+        cacheName: this._cacheName,\n+        // Creating an ID from the URL and cache name won't be necessary once\n+        // Edge switches to Chromium and all browsers we support work with\n+        // array keyPaths.\n+        id: this._getId(url)\n+      });\n+    }\n+    /**\n+     * Returns the timestamp stored for a given URL.\n+     *\n+     * @param {string} url\n+     * @return {number}\n+     *\n+     * @private\n+     */\n+\n+\n+    async getTimestamp(url) {\n+      const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\n+      return entry.timestamp;\n+    }\n+    /**\n+     * Iterates through all the entries in the object store (from newest to\n+     * oldest) and removes entries once either `maxCount` is reached or the\n+     * entry's timestamp is less than `minTimestamp`.\n+     *\n+     * @param {number} minTimestamp\n+     * @param {number} maxCount\n+     *\n+     * @private\n+     */\n+\n+\n+    async expireEntries(minTimestamp, maxCount) {\n+      const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\n+        const store = txn.objectStore(OBJECT_STORE_NAME);\n+        const entriesToDelete = [];\n+        let entriesNotDeletedCount = 0;\n+\n+        store.index('timestamp').openCursor(null, 'prev').onsuccess = ({\n+          target\n+        }) => {\n+          const cursor = target.result;\n+\n+          if (cursor) {\n+            const result = cursor.value; // TODO(philipwalton): once we can use a multi-key index, we\n+            // won't have to check `cacheName` here.\n+\n+            if (result.cacheName === this._cacheName) {\n+              // Delete an entry if it's older than the max age or\n+              // if we already have the max number allowed.\n+              if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n+                // TODO(philipwalton): we should be able to delete the\n+                // entry right here, but doing so causes an iteration\n+                // bug in Safari stable (fixed in TP). Instead we can\n+                // store the keys of the entries to delete, and then\n+                // delete the separate transactions.\n+                // https://github.com/GoogleChrome/workbox/issues/1978\n+                // cursor.delete();\n+                // We only need to return the URL, not the whole entry.\n+                entriesToDelete.push(cursor.value);\n+              } else {\n+                entriesNotDeletedCount++;\n+              }\n+            }\n+\n+            cursor.continue();\n+          } else {\n+            done(entriesToDelete);\n+          }\n+        };\n+      }); // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n+      // we should be able to remove this loop and do the entry deletion in the\n+      // cursor loop above:\n+      // https://github.com/GoogleChrome/workbox/issues/1978\n+\n+      const urlsDeleted = [];\n+\n+      for (const entry of entriesToDelete) {\n+        await this._db.delete(OBJECT_STORE_NAME, entry.id);\n+        urlsDeleted.push(entry.url);\n+      }\n+\n+      return urlsDeleted;\n+    }\n+    /**\n+     * Takes a URL and returns an ID that will be unique in the object store.\n+     *\n+     * @param {string} url\n+     * @return {string}\n+     *\n+     * @private\n+     */\n+\n+\n+    _getId(url) {\n+      // Creating an ID from the URL and cache name won't be necessary once\n+      // Edge switches to Chromium and all browsers we support work with\n+      // array keyPaths.\n+      return this._cacheName + '|' + normalizeURL(url);\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * The `CacheExpiration` class allows you define an expiration and / or\n+   * limit on the number of responses stored in a\n+   * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n+   *\n+   * @memberof workbox.expiration\n+   */\n+\n+  class CacheExpiration {\n+    /**\n+     * To construct a new CacheExpiration instance you must provide at least\n+     * one of the `config` properties.\n+     *\n+     * @param {string} cacheName Name of the cache to apply restrictions to.\n+     * @param {Object} config\n+     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n+     * Entries used the least will be removed as the maximum is reached.\n+     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n+     * it's treated as stale and removed.\n+     */\n+    constructor(cacheName, config = {}) {\n+      {\n+        assert_mjs.assert.isType(cacheName, 'string', {\n+          moduleName: 'workbox-expiration',\n+          className: 'CacheExpiration',\n+          funcName: 'constructor',\n+          paramName: 'cacheName'\n+        });\n+\n+        if (!(config.maxEntries || config.maxAgeSeconds)) {\n+          throw new WorkboxError_mjs.WorkboxError('max-entries-or-age-required', {\n+            moduleName: 'workbox-expiration',\n+            className: 'CacheExpiration',\n+            funcName: 'constructor'\n+          });\n+        }\n+\n+        if (config.maxEntries) {\n+          assert_mjs.assert.isType(config.maxEntries, 'number', {\n+            moduleName: 'workbox-expiration',\n+            className: 'CacheExpiration',\n+            funcName: 'constructor',\n+            paramName: 'config.maxEntries'\n+          }); // TODO: Assert is positive\n+        }\n+\n+        if (config.maxAgeSeconds) {\n+          assert_mjs.assert.isType(config.maxAgeSeconds, 'number', {\n+            moduleName: 'workbox-expiration',\n+            className: 'CacheExpiration',\n+            funcName: 'constructor',\n+            paramName: 'config.maxAgeSeconds'\n+          }); // TODO: Assert is positive\n+        }\n+      }\n+\n+      this._isRunning = false;\n+      this._rerunRequested = false;\n+      this._maxEntries = config.maxEntries;\n+      this._maxAgeSeconds = config.maxAgeSeconds;\n+      this._cacheName = cacheName;\n+      this._timestampModel = new CacheTimestampsModel(cacheName);\n+    }\n+    /**\n+     * Expires entries for the given cache and given criteria.\n+     */\n+\n+\n+    async expireEntries() {\n+      if (this._isRunning) {\n+        this._rerunRequested = true;\n+        return;\n+      }\n+\n+      this._isRunning = true;\n+      const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : undefined;\n+      const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n+\n+      const cache = await caches.open(this._cacheName);\n+\n+      for (const url of urlsExpired) {\n+        await cache.delete(url);\n+      }\n+\n+      {\n+        if (urlsExpired.length > 0) {\n+          logger_mjs.logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n+          logger_mjs.logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n+          urlsExpired.forEach(url => logger_mjs.logger.log(`    ${url}`));\n+          logger_mjs.logger.groupEnd();\n+        } else {\n+          logger_mjs.logger.debug(`Cache expiration ran and found no entries to remove.`);\n+        }\n+      }\n+\n+      this._isRunning = false;\n+\n+      if (this._rerunRequested) {\n+        this._rerunRequested = false;\n+        this.expireEntries();\n+      }\n+    }\n+    /**\n+     * Update the timestamp for the given URL. This ensures the when\n+     * removing entries based on maximum entries, most recently used\n+     * is accurate or when expiring, the timestamp is up-to-date.\n+     *\n+     * @param {string} url\n+     */\n+\n+\n+    async updateTimestamp(url) {\n+      {\n+        assert_mjs.assert.isType(url, 'string', {\n+          moduleName: 'workbox-expiration',\n+          className: 'CacheExpiration',\n+          funcName: 'updateTimestamp',\n+          paramName: 'url'\n+        });\n+      }\n+\n+      await this._timestampModel.setTimestamp(url, Date.now());\n+    }\n+    /**\n+     * Can be used to check if a URL has expired or not before it's used.\n+     *\n+     * This requires a look up from IndexedDB, so can be slow.\n+     *\n+     * Note: This method will not remove the cached entry, call\n+     * `expireEntries()` to remove indexedDB and Cache entries.\n+     *\n+     * @param {string} url\n+     * @return {boolean}\n+     */\n+\n+\n+    async isURLExpired(url) {\n+      {\n+        if (!this._maxAgeSeconds) {\n+          throw new WorkboxError_mjs.WorkboxError(`expired-test-without-max-age`, {\n+            methodName: 'isURLExpired',\n+            paramName: 'maxAgeSeconds'\n+          });\n+        }\n+      }\n+\n+      const timestamp = await this._timestampModel.getTimestamp(url);\n+      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n+      return timestamp < expireOlderThan;\n+    }\n+    /**\n+     * Removes the IndexedDB object store used to keep track of cache expiration\n+     * metadata.\n+     */\n+\n+\n+    async delete() {\n+      // Make sure we don't attempt another rerun if we're called in the middle of\n+      // a cache expiration.\n+      this._rerunRequested = false;\n+      await this._timestampModel.expireEntries(Infinity); // Expires all.\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * This plugin can be used in the Workbox APIs to regularly enforce a\n+   * limit on the age and / or the number of cached requests.\n+   *\n+   * Whenever a cached request is used or updated, this plugin will look\n+   * at the used Cache and remove any old or extra requests.\n+   *\n+   * When using `maxAgeSeconds`, requests may be used *once* after expiring\n+   * because the expiration clean up will not have occurred until *after* the\n+   * cached request has been used. If the request has a \"Date\" header, then\n+   * a light weight expiration check is performed and the request will not be\n+   * used immediately.\n+   *\n+   * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\n+   *\n+   * @memberof workbox.expiration\n+   */\n+\n+  class Plugin {\n+    /**\n+     * @param {Object} config\n+     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n+     * Entries used the least will be removed as the maximum is reached.\n+     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n+     * it's treated as stale and removed.\n+     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n+     * automatic deletion if the available storage quota has been exceeded.\n+     */\n+    constructor(config = {}) {\n+      {\n+        if (!(config.maxEntries || config.maxAgeSeconds)) {\n+          throw new WorkboxError_mjs.WorkboxError('max-entries-or-age-required', {\n+            moduleName: 'workbox-expiration',\n+            className: 'Plugin',\n+            funcName: 'constructor'\n+          });\n+        }\n+\n+        if (config.maxEntries) {\n+          assert_mjs.assert.isType(config.maxEntries, 'number', {\n+            moduleName: 'workbox-expiration',\n+            className: 'Plugin',\n+            funcName: 'constructor',\n+            paramName: 'config.maxEntries'\n+          });\n+        }\n+\n+        if (config.maxAgeSeconds) {\n+          assert_mjs.assert.isType(config.maxAgeSeconds, 'number', {\n+            moduleName: 'workbox-expiration',\n+            className: 'Plugin',\n+            funcName: 'constructor',\n+            paramName: 'config.maxAgeSeconds'\n+          });\n+        }\n+      }\n+\n+      this._config = config;\n+      this._maxAgeSeconds = config.maxAgeSeconds;\n+      this._cacheExpirations = new Map();\n+\n+      if (config.purgeOnQuotaError) {\n+        registerQuotaErrorCallback_mjs.registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n+      }\n+    }\n+    /**\n+     * A simple helper method to return a CacheExpiration instance for a given\n+     * cache name.\n+     *\n+     * @param {string} cacheName\n+     * @return {CacheExpiration}\n+     *\n+     * @private\n+     */\n+\n+\n+    _getCacheExpiration(cacheName) {\n+      if (cacheName === cacheNames_mjs.cacheNames.getRuntimeName()) {\n+        throw new WorkboxError_mjs.WorkboxError('expire-custom-caches-only');\n+      }\n+\n+      let cacheExpiration = this._cacheExpirations.get(cacheName);\n+\n+      if (!cacheExpiration) {\n+        cacheExpiration = new CacheExpiration(cacheName, this._config);\n+\n+        this._cacheExpirations.set(cacheName, cacheExpiration);\n+      }\n+\n+      return cacheExpiration;\n+    }\n+    /**\n+     * A \"lifecycle\" callback that will be triggered automatically by the\n+     * `workbox.strategies` handlers when a `Response` is about to be returned\n+     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n+     * the handler. It allows the `Response` to be inspected for freshness and\n+     * prevents it from being used if the `Response`'s `Date` header value is\n+     * older than the configured `maxAgeSeconds`.\n+     *\n+     * @param {Object} options\n+     * @param {string} options.cacheName Name of the cache the response is in.\n+     * @param {Response} options.cachedResponse The `Response` object that's been\n+     *     read from a cache and whose freshness should be checked.\n+     * @return {Response} Either the `cachedResponse`, if it's\n+     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n+     *\n+     * @private\n+     */\n+\n+\n+    cachedResponseWillBeUsed({\n+      event,\n+      request,\n+      cacheName,\n+      cachedResponse\n+    }) {\n+      if (!cachedResponse) {\n+        return null;\n+      }\n+\n+      let isFresh = this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n+      // expired, it'll only be used once.\n+\n+\n+      const cacheExpiration = this._getCacheExpiration(cacheName);\n+\n+      cacheExpiration.expireEntries(); // Update the metadata for the request URL to the current timestamp,\n+      // but don't `await` it as we don't want to block the response.\n+\n+      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n+\n+      if (event) {\n+        try {\n+          event.waitUntil(updateTimestampDone);\n+        } catch (error) {\n+          {\n+            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n+          }\n+        }\n+      }\n+\n+      return isFresh ? cachedResponse : null;\n+    }\n+    /**\n+     * @param {Response} cachedResponse\n+     * @return {boolean}\n+     *\n+     * @private\n+     */\n+\n+\n+    _isResponseDateFresh(cachedResponse) {\n+      if (!this._maxAgeSeconds) {\n+        // We aren't expiring by age, so return true, it's fresh\n+        return true;\n+      } // Check if the 'date' header will suffice a quick expiration check.\n+      // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n+      // discussion.\n+\n+\n+      const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n+\n+      if (dateHeaderTimestamp === null) {\n+        // Unable to parse date, so assume it's fresh.\n+        return true;\n+      } // If we have a valid headerTime, then our response is fresh iff the\n+      // headerTime plus maxAgeSeconds is greater than the current time.\n+\n+\n+      const now = Date.now();\n+      return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n+    }\n+    /**\n+     * This method will extract the data header and parse it into a useful\n+     * value.\n+     *\n+     * @param {Response} cachedResponse\n+     * @return {number}\n+     *\n+     * @private\n+     */\n+\n+\n+    _getDateHeaderTimestamp(cachedResponse) {\n+      if (!cachedResponse.headers.has('date')) {\n+        return null;\n+      }\n+\n+      const dateHeader = cachedResponse.headers.get('date');\n+      const parsedDate = new Date(dateHeader);\n+      const headerTime = parsedDate.getTime(); // If the Date header was invalid for some reason, parsedDate.getTime()\n+      // will return NaN.\n+\n+      if (isNaN(headerTime)) {\n+        return null;\n+      }\n+\n+      return headerTime;\n+    }\n+    /**\n+     * A \"lifecycle\" callback that will be triggered automatically by the\n+     * `workbox.strategies` handlers when an entry is added to a cache.\n+     *\n+     * @param {Object} options\n+     * @param {string} options.cacheName Name of the cache that was updated.\n+     * @param {string} options.request The Request for the cached entry.\n+     *\n+     * @private\n+     */\n+\n+\n+    async cacheDidUpdate({\n+      cacheName,\n+      request\n+    }) {\n+      {\n+        assert_mjs.assert.isType(cacheName, 'string', {\n+          moduleName: 'workbox-expiration',\n+          className: 'Plugin',\n+          funcName: 'cacheDidUpdate',\n+          paramName: 'cacheName'\n+        });\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-expiration',\n+          className: 'Plugin',\n+          funcName: 'cacheDidUpdate',\n+          paramName: 'request'\n+        });\n+      }\n+\n+      const cacheExpiration = this._getCacheExpiration(cacheName);\n+\n+      await cacheExpiration.updateTimestamp(request.url);\n+      await cacheExpiration.expireEntries();\n+    }\n+    /**\n+     * This is a helper method that performs two operations:\n+     *\n+     * - Deletes *all* the underlying Cache instances associated with this plugin\n+     * instance, by calling caches.delete() on your behalf.\n+     * - Deletes the metadata from IndexedDB used to keep track of expiration\n+     * details for each Cache instance.\n+     *\n+     * When using cache expiration, calling this method is preferable to calling\n+     * `caches.delete()` directly, since this will ensure that the IndexedDB\n+     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n+     *\n+     * Note that if you're *not* using cache expiration for a given cache, calling\n+     * `caches.delete()` and passing in the cache's name should be sufficient.\n+     * There is no Workbox-specific method needed for cleanup in that case.\n+     */\n+\n+\n+    async deleteCacheAndMetadata() {\n+      // Do this one at a time instead of all at once via `Promise.all()` to\n+      // reduce the chance of inconsistency if a promise rejects.\n+      for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n+        await caches.delete(cacheName);\n+        await cacheExpiration.delete();\n+      } // Reset this._cacheExpirations to its initial state.\n+\n+\n+      this._cacheExpirations = new Map();\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  exports.CacheExpiration = CacheExpiration;\n+  exports.Plugin = Plugin;\n+\n+  return exports;\n+\n+}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core));\n+//# sourceMappingURL=workbox-expiration.dev.js.map"
    },
    {
      "sha": "d0a03072a07cbf1824ebd671f93deca1d34e362c",
      "filename": "public/javascripts/workbox/workbox-expiration.dev.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.dev.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.dev.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-expiration.dev.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-expiration.dev.js\",\"sources\":[\"../_version.mjs\",\"../models/CacheTimestampsModel.mjs\",\"../CacheExpiration.mjs\",\"../Plugin.mjs\",\"../index.mjs\"],\"sourcesContent\":[\"try{self['workbox:expiration:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\\nimport '../_version.mjs';\\n\\n\\nconst DB_NAME = 'workbox-expiration';\\nconst OBJECT_STORE_NAME = 'cache-entries';\\n\\nconst normalizeURL = (unNormalizedUrl) => {\\n  const url = new URL(unNormalizedUrl, location);\\n  url.hash = '';\\n\\n  return url.href;\\n};\\n\\n\\n/**\\n * Returns the timestamp model.\\n *\\n * @private\\n */\\nclass CacheTimestampsModel {\\n  /**\\n   *\\n   * @param {string} cacheName\\n   *\\n   * @private\\n   */\\n  constructor(cacheName) {\\n    this._cacheName = cacheName;\\n\\n    this._db = new DBWrapper(DB_NAME, 1, {\\n      onupgradeneeded: (event) => this._handleUpgrade(event),\\n    });\\n  }\\n\\n  /**\\n   * Should perform an upgrade of indexedDB.\\n   *\\n   * @param {Event} event\\n   *\\n   * @private\\n   */\\n  _handleUpgrade(event) {\\n    const db = event.target.result;\\n\\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\\n    // have to use the `id` keyPath here and create our own values (a\\n    // concatenation of `url + cacheName`) instead of simply using\\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\\n\\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\\n    // instead of doing both these indexes.\\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\\n\\n    // Previous versions of `workbox-expiration` used `this._cacheName`\\n    // as the IDBDatabase name.\\n    deleteDatabase(this._cacheName);\\n  }\\n\\n  /**\\n   * @param {string} url\\n   * @param {number} timestamp\\n   *\\n   * @private\\n   */\\n  async setTimestamp(url, timestamp) {\\n    url = normalizeURL(url);\\n\\n    await this._db.put(OBJECT_STORE_NAME, {\\n      url,\\n      timestamp,\\n      cacheName: this._cacheName,\\n      // Creating an ID from the URL and cache name won't be necessary once\\n      // Edge switches to Chromium and all browsers we support work with\\n      // array keyPaths.\\n      id: this._getId(url),\\n    });\\n  }\\n\\n  /**\\n   * Returns the timestamp stored for a given URL.\\n   *\\n   * @param {string} url\\n   * @return {number}\\n   *\\n   * @private\\n   */\\n  async getTimestamp(url) {\\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\\n    return entry.timestamp;\\n  }\\n\\n  /**\\n   * Iterates through all the entries in the object store (from newest to\\n   * oldest) and removes entries once either `maxCount` is reached or the\\n   * entry's timestamp is less than `minTimestamp`.\\n   *\\n   * @param {number} minTimestamp\\n   * @param {number} maxCount\\n   *\\n   * @private\\n   */\\n  async expireEntries(minTimestamp, maxCount) {\\n    const entriesToDelete = await this._db.transaction(\\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\\n          const store = txn.objectStore(OBJECT_STORE_NAME);\\n          const entriesToDelete = [];\\n          let entriesNotDeletedCount = 0;\\n\\n          store.index('timestamp')\\n              .openCursor(null, 'prev')\\n              .onsuccess = ({target}) => {\\n                const cursor = target.result;\\n                if (cursor) {\\n                  const result = cursor.value;\\n                  // TODO(philipwalton): once we can use a multi-key index, we\\n                  // won't have to check `cacheName` here.\\n                  if (result.cacheName === this._cacheName) {\\n                    // Delete an entry if it's older than the max age or\\n                    // if we already have the max number allowed.\\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\\n                      // TODO(philipwalton): we should be able to delete the\\n                      // entry right here, but doing so causes an iteration\\n                      // bug in Safari stable (fixed in TP). Instead we can\\n                      // store the keys of the entries to delete, and then\\n                      // delete the separate transactions.\\n                      // https://github.com/GoogleChrome/workbox/issues/1978\\n                      // cursor.delete();\\n\\n                      // We only need to return the URL, not the whole entry.\\n                      entriesToDelete.push(cursor.value);\\n                    } else {\\n                      entriesNotDeletedCount++;\\n                    }\\n                  }\\n                  cursor.continue();\\n                } else {\\n                  done(entriesToDelete);\\n                }\\n              };\\n        });\\n\\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\\n    // we should be able to remove this loop and do the entry deletion in the\\n    // cursor loop above:\\n    // https://github.com/GoogleChrome/workbox/issues/1978\\n    const urlsDeleted = [];\\n    for (const entry of entriesToDelete) {\\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\\n      urlsDeleted.push(entry.url);\\n    }\\n\\n    return urlsDeleted;\\n  }\\n\\n  /**\\n   * Takes a URL and returns an ID that will be unique in the object store.\\n   *\\n   * @param {string} url\\n   * @return {string}\\n   *\\n   * @private\\n   */\\n  _getId(url) {\\n    // Creating an ID from the URL and cache name won't be necessary once\\n    // Edge switches to Chromium and all browsers we support work with\\n    // array keyPaths.\\n    return this._cacheName + '|' + normalizeURL(url);\\n  }\\n}\\n\\nexport {CacheTimestampsModel};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\n\\nimport './_version.mjs';\\n\\n/**\\n * The `CacheExpiration` class allows you define an expiration and / or\\n * limit on the number of responses stored in a\\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\\n *\\n * @memberof workbox.expiration\\n */\\nclass CacheExpiration {\\n  /**\\n   * To construct a new CacheExpiration instance you must provide at least\\n   * one of the `config` properties.\\n   *\\n   * @param {string} cacheName Name of the cache to apply restrictions to.\\n   * @param {Object} config\\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\\n   * Entries used the least will be removed as the maximum is reached.\\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\\n   * it's treated as stale and removed.\\n   */\\n  constructor(cacheName, config = {}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(cacheName, 'string', {\\n        moduleName: 'workbox-expiration',\\n        className: 'CacheExpiration',\\n        funcName: 'constructor',\\n        paramName: 'cacheName',\\n      });\\n\\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\\n        throw new WorkboxError('max-entries-or-age-required', {\\n          moduleName: 'workbox-expiration',\\n          className: 'CacheExpiration',\\n          funcName: 'constructor',\\n        });\\n      }\\n\\n      if (config.maxEntries) {\\n        assert.isType(config.maxEntries, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'CacheExpiration',\\n          funcName: 'constructor',\\n          paramName: 'config.maxEntries',\\n        });\\n\\n        // TODO: Assert is positive\\n      }\\n\\n      if (config.maxAgeSeconds) {\\n        assert.isType(config.maxAgeSeconds, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'CacheExpiration',\\n          funcName: 'constructor',\\n          paramName: 'config.maxAgeSeconds',\\n        });\\n\\n        // TODO: Assert is positive\\n      }\\n    }\\n\\n    this._isRunning = false;\\n    this._rerunRequested = false;\\n    this._maxEntries = config.maxEntries;\\n    this._maxAgeSeconds = config.maxAgeSeconds;\\n    this._cacheName = cacheName;\\n    this._timestampModel = new CacheTimestampsModel(cacheName);\\n  }\\n\\n  /**\\n   * Expires entries for the given cache and given criteria.\\n   */\\n  async expireEntries() {\\n    if (this._isRunning) {\\n      this._rerunRequested = true;\\n      return;\\n    }\\n    this._isRunning = true;\\n\\n    const minTimestamp = this._maxAgeSeconds ?\\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\\n\\n    const urlsExpired = await this._timestampModel.expireEntries(\\n        minTimestamp, this._maxEntries);\\n\\n    // Delete URLs from the cache\\n    const cache = await caches.open(this._cacheName);\\n    for (const url of urlsExpired) {\\n      await cache.delete(url);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (urlsExpired.length > 0) {\\n        logger.groupCollapsed(\\n            `Expired ${urlsExpired.length} ` +\\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\\n          `'${this._cacheName}' cache.`);\\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\\n            'URL' : 'URLs'}:`);\\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\\n        logger.groupEnd();\\n      } else {\\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\\n      }\\n    }\\n\\n    this._isRunning = false;\\n    if (this._rerunRequested) {\\n      this._rerunRequested = false;\\n      this.expireEntries();\\n    }\\n  }\\n\\n  /**\\n   * Update the timestamp for the given URL. This ensures the when\\n   * removing entries based on maximum entries, most recently used\\n   * is accurate or when expiring, the timestamp is up-to-date.\\n   *\\n   * @param {string} url\\n   */\\n  async updateTimestamp(url) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(url, 'string', {\\n        moduleName: 'workbox-expiration',\\n        className: 'CacheExpiration',\\n        funcName: 'updateTimestamp',\\n        paramName: 'url',\\n      });\\n    }\\n\\n    await this._timestampModel.setTimestamp(url, Date.now());\\n  }\\n\\n  /**\\n   * Can be used to check if a URL has expired or not before it's used.\\n   *\\n   * This requires a look up from IndexedDB, so can be slow.\\n   *\\n   * Note: This method will not remove the cached entry, call\\n   * `expireEntries()` to remove indexedDB and Cache entries.\\n   *\\n   * @param {string} url\\n   * @return {boolean}\\n   */\\n  async isURLExpired(url) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!this._maxAgeSeconds) {\\n        throw new WorkboxError(`expired-test-without-max-age`, {\\n          methodName: 'isURLExpired',\\n          paramName: 'maxAgeSeconds',\\n        });\\n      }\\n    }\\n\\n    const timestamp = await this._timestampModel.getTimestamp(url);\\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\\n    return (timestamp < expireOlderThan);\\n  }\\n\\n  /**\\n   * Removes the IndexedDB object store used to keep track of cache expiration\\n   * metadata.\\n   */\\n  async delete() {\\n    // Make sure we don't attempt another rerun if we're called in the middle of\\n    // a cache expiration.\\n    this._rerunRequested = false;\\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\\n  }\\n}\\n\\nexport {CacheExpiration};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {registerQuotaErrorCallback}\\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\\n\\nimport {CacheExpiration} from './CacheExpiration.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * This plugin can be used in the Workbox APIs to regularly enforce a\\n * limit on the age and / or the number of cached requests.\\n *\\n * Whenever a cached request is used or updated, this plugin will look\\n * at the used Cache and remove any old or extra requests.\\n *\\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\\n * because the expiration clean up will not have occurred until *after* the\\n * cached request has been used. If the request has a \\\"Date\\\" header, then\\n * a light weight expiration check is performed and the request will not be\\n * used immediately.\\n *\\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\\n *\\n * @memberof workbox.expiration\\n */\\nclass Plugin {\\n  /**\\n   * @param {Object} config\\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\\n   * Entries used the least will be removed as the maximum is reached.\\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\\n   * it's treated as stale and removed.\\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\\n   * automatic deletion if the available storage quota has been exceeded.\\n   */\\n  constructor(config = {}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\\n        throw new WorkboxError('max-entries-or-age-required', {\\n          moduleName: 'workbox-expiration',\\n          className: 'Plugin',\\n          funcName: 'constructor',\\n        });\\n      }\\n\\n      if (config.maxEntries) {\\n        assert.isType(config.maxEntries, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'Plugin',\\n          funcName: 'constructor',\\n          paramName: 'config.maxEntries',\\n        });\\n      }\\n\\n      if (config.maxAgeSeconds) {\\n        assert.isType(config.maxAgeSeconds, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'Plugin',\\n          funcName: 'constructor',\\n          paramName: 'config.maxAgeSeconds',\\n        });\\n      }\\n    }\\n\\n    this._config = config;\\n    this._maxAgeSeconds = config.maxAgeSeconds;\\n    this._cacheExpirations = new Map();\\n\\n    if (config.purgeOnQuotaError) {\\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\\n    }\\n  }\\n\\n  /**\\n   * A simple helper method to return a CacheExpiration instance for a given\\n   * cache name.\\n   *\\n   * @param {string} cacheName\\n   * @return {CacheExpiration}\\n   *\\n   * @private\\n   */\\n  _getCacheExpiration(cacheName) {\\n    if (cacheName === cacheNames.getRuntimeName()) {\\n      throw new WorkboxError('expire-custom-caches-only');\\n    }\\n\\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\\n    if (!cacheExpiration) {\\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\\n      this._cacheExpirations.set(cacheName, cacheExpiration);\\n    }\\n    return cacheExpiration;\\n  }\\n\\n  /**\\n   * A \\\"lifecycle\\\" callback that will be triggered automatically by the\\n   * `workbox.strategies` handlers when a `Response` is about to be returned\\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\\n   * the handler. It allows the `Response` to be inspected for freshness and\\n   * prevents it from being used if the `Response`'s `Date` header value is\\n   * older than the configured `maxAgeSeconds`.\\n   *\\n   * @param {Object} options\\n   * @param {string} options.cacheName Name of the cache the response is in.\\n   * @param {Response} options.cachedResponse The `Response` object that's been\\n   *     read from a cache and whose freshness should be checked.\\n   * @return {Response} Either the `cachedResponse`, if it's\\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\\n   *\\n   * @private\\n   */\\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\\n    if (!cachedResponse) {\\n      return null;\\n    }\\n\\n    let isFresh = this._isResponseDateFresh(cachedResponse);\\n\\n    // Expire entries to ensure that even if the expiration date has\\n    // expired, it'll only be used once.\\n    const cacheExpiration = this._getCacheExpiration(cacheName);\\n    cacheExpiration.expireEntries();\\n\\n    // Update the metadata for the request URL to the current timestamp,\\n    // but don't `await` it as we don't want to block the response.\\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\\n    if (event) {\\n      try {\\n        event.waitUntil(updateTimestampDone);\\n      } catch (error) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.warn(`Unable to ensure service worker stays alive when ` +\\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\\n        }\\n      }\\n    }\\n\\n    return isFresh ? cachedResponse : null;\\n  }\\n\\n  /**\\n   * @param {Response} cachedResponse\\n   * @return {boolean}\\n   *\\n   * @private\\n   */\\n  _isResponseDateFresh(cachedResponse) {\\n    if (!this._maxAgeSeconds) {\\n      // We aren't expiring by age, so return true, it's fresh\\n      return true;\\n    }\\n\\n    // Check if the 'date' header will suffice a quick expiration check.\\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\\n    // discussion.\\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\\n    if (dateHeaderTimestamp === null) {\\n      // Unable to parse date, so assume it's fresh.\\n      return true;\\n    }\\n\\n    // If we have a valid headerTime, then our response is fresh iff the\\n    // headerTime plus maxAgeSeconds is greater than the current time.\\n    const now = Date.now();\\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\\n  }\\n\\n  /**\\n   * This method will extract the data header and parse it into a useful\\n   * value.\\n   *\\n   * @param {Response} cachedResponse\\n   * @return {number}\\n   *\\n   * @private\\n   */\\n  _getDateHeaderTimestamp(cachedResponse) {\\n    if (!cachedResponse.headers.has('date')) {\\n      return null;\\n    }\\n\\n    const dateHeader = cachedResponse.headers.get('date');\\n    const parsedDate = new Date(dateHeader);\\n    const headerTime = parsedDate.getTime();\\n\\n    // If the Date header was invalid for some reason, parsedDate.getTime()\\n    // will return NaN.\\n    if (isNaN(headerTime)) {\\n      return null;\\n    }\\n\\n    return headerTime;\\n  }\\n\\n  /**\\n   * A \\\"lifecycle\\\" callback that will be triggered automatically by the\\n   * `workbox.strategies` handlers when an entry is added to a cache.\\n   *\\n   * @param {Object} options\\n   * @param {string} options.cacheName Name of the cache that was updated.\\n   * @param {string} options.request The Request for the cached entry.\\n   *\\n   * @private\\n   */\\n  async cacheDidUpdate({cacheName, request}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(cacheName, 'string', {\\n        moduleName: 'workbox-expiration',\\n        className: 'Plugin',\\n        funcName: 'cacheDidUpdate',\\n        paramName: 'cacheName',\\n      });\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-expiration',\\n        className: 'Plugin',\\n        funcName: 'cacheDidUpdate',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    const cacheExpiration = this._getCacheExpiration(cacheName);\\n    await cacheExpiration.updateTimestamp(request.url);\\n    await cacheExpiration.expireEntries();\\n  }\\n\\n\\n  /**\\n   * This is a helper method that performs two operations:\\n   *\\n   * - Deletes *all* the underlying Cache instances associated with this plugin\\n   * instance, by calling caches.delete() on your behalf.\\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\\n   * details for each Cache instance.\\n   *\\n   * When using cache expiration, calling this method is preferable to calling\\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\\n   *\\n   * Note that if you're *not* using cache expiration for a given cache, calling\\n   * `caches.delete()` and passing in the cache's name should be sufficient.\\n   * There is no Workbox-specific method needed for cleanup in that case.\\n   */\\n  async deleteCacheAndMetadata() {\\n    // Do this one at a time instead of all at once via `Promise.all()` to\\n    // reduce the chance of inconsistency if a promise rejects.\\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\\n      await caches.delete(cacheName);\\n      await cacheExpiration.delete();\\n    }\\n\\n    // Reset this._cacheExpirations to its initial state.\\n    this._cacheExpirations = new Map();\\n  }\\n}\\n\\nexport {Plugin};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {CacheExpiration} from './CacheExpiration.mjs';\\nimport {Plugin} from './Plugin.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * @namespace workbox.expiration\\n */\\n\\nexport {\\n  CacheExpiration,\\n  Plugin,\\n};\\n\"],\"names\":[\"self\",\"_\",\"e\",\"DB_NAME\",\"OBJECT_STORE_NAME\",\"normalizeURL\",\"unNormalizedUrl\",\"url\",\"URL\",\"location\",\"hash\",\"href\",\"CacheTimestampsModel\",\"constructor\",\"cacheName\",\"_cacheName\",\"_db\",\"DBWrapper\",\"onupgradeneeded\",\"event\",\"_handleUpgrade\",\"db\",\"target\",\"result\",\"objStore\",\"createObjectStore\",\"keyPath\",\"createIndex\",\"unique\",\"deleteDatabase\",\"setTimestamp\",\"timestamp\",\"put\",\"id\",\"_getId\",\"getTimestamp\",\"entry\",\"get\",\"expireEntries\",\"minTimestamp\",\"maxCount\",\"entriesToDelete\",\"transaction\",\"txn\",\"done\",\"store\",\"objectStore\",\"entriesNotDeletedCount\",\"index\",\"openCursor\",\"onsuccess\",\"cursor\",\"value\",\"push\",\"continue\",\"urlsDeleted\",\"delete\",\"CacheExpiration\",\"config\",\"assert\",\"isType\",\"moduleName\",\"className\",\"funcName\",\"paramName\",\"maxEntries\",\"maxAgeSeconds\",\"WorkboxError\",\"_isRunning\",\"_rerunRequested\",\"_maxEntries\",\"_maxAgeSeconds\",\"_timestampModel\",\"Date\",\"now\",\"undefined\",\"urlsExpired\",\"cache\",\"caches\",\"open\",\"length\",\"logger\",\"groupCollapsed\",\"log\",\"forEach\",\"groupEnd\",\"debug\",\"updateTimestamp\",\"isURLExpired\",\"methodName\",\"expireOlderThan\",\"Infinity\",\"Plugin\",\"_config\",\"_cacheExpirations\",\"Map\",\"purgeOnQuotaError\",\"registerQuotaErrorCallback\",\"deleteCacheAndMetadata\",\"_getCacheExpiration\",\"cacheNames\",\"getRuntimeName\",\"cacheExpiration\",\"set\",\"cachedResponseWillBeUsed\",\"request\",\"cachedResponse\",\"isFresh\",\"_isResponseDateFresh\",\"updateTimestampDone\",\"waitUntil\",\"error\",\"warn\",\"getFriendlyURL\",\"dateHeaderTimestamp\",\"_getDateHeaderTimestamp\",\"headers\",\"has\",\"dateHeader\",\"parsedDate\",\"headerTime\",\"getTime\",\"isNaN\",\"cacheDidUpdate\",\"isInstance\",\"Request\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
    },
    {
      "sha": "7c8f84040ed83397ea83227700f1f53acacc3c4a",
      "filename": "public/javascripts/workbox/workbox-expiration.prod.js",
      "status": "added",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.prod.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.prod.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-expiration.prod.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,2 @@\n+this.workbox=this.workbox||{},this.workbox.expiration=function(t,e,s,i,a,n){\"use strict\";try{self[\"workbox:expiration:4.3.1\"]&&_()}catch(t){}const h=\"workbox-expiration\",c=\"cache-entries\",r=t=>{const e=new URL(t,location);return e.hash=\"\",e.href};class o{constructor(t){this.t=t,this.s=new e.DBWrapper(h,1,{onupgradeneeded:t=>this.i(t)})}i(t){const e=t.target.result.createObjectStore(c,{keyPath:\"id\"});e.createIndex(\"cacheName\",\"cacheName\",{unique:!1}),e.createIndex(\"timestamp\",\"timestamp\",{unique:!1}),s.deleteDatabase(this.t)}async setTimestamp(t,e){t=r(t),await this.s.put(c,{url:t,timestamp:e,cacheName:this.t,id:this.h(t)})}async getTimestamp(t){return(await this.s.get(c,this.h(t))).timestamp}async expireEntries(t,e){const s=await this.s.transaction(c,\"readwrite\",(s,i)=>{const a=s.objectStore(c),n=[];let h=0;a.index(\"timestamp\").openCursor(null,\"prev\").onsuccess=(({target:s})=>{const a=s.result;if(a){const s=a.value;s.cacheName===this.t&&(t&&s.timestamp<t||e&&h>=e?n.push(a.value):h++),a.continue()}else i(n)})}),i=[];for(const t of s)await this.s.delete(c,t.id),i.push(t.url);return i}h(t){return this.t+\"|\"+r(t)}}class u{constructor(t,e={}){this.o=!1,this.u=!1,this.l=e.maxEntries,this.p=e.maxAgeSeconds,this.t=t,this.m=new o(t)}async expireEntries(){if(this.o)return void(this.u=!0);this.o=!0;const t=this.p?Date.now()-1e3*this.p:void 0,e=await this.m.expireEntries(t,this.l),s=await caches.open(this.t);for(const t of e)await s.delete(t);this.o=!1,this.u&&(this.u=!1,this.expireEntries())}async updateTimestamp(t){await this.m.setTimestamp(t,Date.now())}async isURLExpired(t){return await this.m.getTimestamp(t)<Date.now()-1e3*this.p}async delete(){this.u=!1,await this.m.expireEntries(1/0)}}return t.CacheExpiration=u,t.Plugin=class{constructor(t={}){this.D=t,this.p=t.maxAgeSeconds,this.g=new Map,t.purgeOnQuotaError&&n.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}k(t){if(t===a.cacheNames.getRuntimeName())throw new i.WorkboxError(\"expire-custom-caches-only\");let e=this.g.get(t);return e||(e=new u(t,this.D),this.g.set(t,e)),e}cachedResponseWillBeUsed({event:t,request:e,cacheName:s,cachedResponse:i}){if(!i)return null;let a=this.N(i);const n=this.k(s);n.expireEntries();const h=n.updateTimestamp(e.url);if(t)try{t.waitUntil(h)}catch(t){}return a?i:null}N(t){if(!this.p)return!0;const e=this._(t);return null===e||e>=Date.now()-1e3*this.p}_(t){if(!t.headers.has(\"date\"))return null;const e=t.headers.get(\"date\"),s=new Date(e).getTime();return isNaN(s)?null:s}async cacheDidUpdate({cacheName:t,request:e}){const s=this.k(t);await s.updateTimestamp(e.url),await s.expireEntries()}async deleteCacheAndMetadata(){for(const[t,e]of this.g)await caches.delete(t),await e.delete();this.g=new Map}},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);\n+//# sourceMappingURL=workbox-expiration.prod.js.map"
    },
    {
      "sha": "6cb8ede7ba34a923585d495db475224465464a57",
      "filename": "public/javascripts/workbox/workbox-expiration.prod.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.prod.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-expiration.prod.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-expiration.prod.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-expiration.prod.js\",\"sources\":[\"../_version.mjs\",\"../models/CacheTimestampsModel.mjs\",\"../CacheExpiration.mjs\",\"../Plugin.mjs\"],\"sourcesContent\":[\"try{self['workbox:expiration:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\\nimport {deleteDatabase} from 'workbox-core/_private/deleteDatabase.mjs';\\nimport '../_version.mjs';\\n\\n\\nconst DB_NAME = 'workbox-expiration';\\nconst OBJECT_STORE_NAME = 'cache-entries';\\n\\nconst normalizeURL = (unNormalizedUrl) => {\\n  const url = new URL(unNormalizedUrl, location);\\n  url.hash = '';\\n\\n  return url.href;\\n};\\n\\n\\n/**\\n * Returns the timestamp model.\\n *\\n * @private\\n */\\nclass CacheTimestampsModel {\\n  /**\\n   *\\n   * @param {string} cacheName\\n   *\\n   * @private\\n   */\\n  constructor(cacheName) {\\n    this._cacheName = cacheName;\\n\\n    this._db = new DBWrapper(DB_NAME, 1, {\\n      onupgradeneeded: (event) => this._handleUpgrade(event),\\n    });\\n  }\\n\\n  /**\\n   * Should perform an upgrade of indexedDB.\\n   *\\n   * @param {Event} event\\n   *\\n   * @private\\n   */\\n  _handleUpgrade(event) {\\n    const db = event.target.result;\\n\\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\\n    // have to use the `id` keyPath here and create our own values (a\\n    // concatenation of `url + cacheName`) instead of simply using\\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\\n    const objStore = db.createObjectStore(OBJECT_STORE_NAME, {keyPath: 'id'});\\n\\n    // TODO(philipwalton): once we don't have to support EdgeHTML, we can\\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\\n    // instead of doing both these indexes.\\n    objStore.createIndex('cacheName', 'cacheName', {unique: false});\\n    objStore.createIndex('timestamp', 'timestamp', {unique: false});\\n\\n    // Previous versions of `workbox-expiration` used `this._cacheName`\\n    // as the IDBDatabase name.\\n    deleteDatabase(this._cacheName);\\n  }\\n\\n  /**\\n   * @param {string} url\\n   * @param {number} timestamp\\n   *\\n   * @private\\n   */\\n  async setTimestamp(url, timestamp) {\\n    url = normalizeURL(url);\\n\\n    await this._db.put(OBJECT_STORE_NAME, {\\n      url,\\n      timestamp,\\n      cacheName: this._cacheName,\\n      // Creating an ID from the URL and cache name won't be necessary once\\n      // Edge switches to Chromium and all browsers we support work with\\n      // array keyPaths.\\n      id: this._getId(url),\\n    });\\n  }\\n\\n  /**\\n   * Returns the timestamp stored for a given URL.\\n   *\\n   * @param {string} url\\n   * @return {number}\\n   *\\n   * @private\\n   */\\n  async getTimestamp(url) {\\n    const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\\n    return entry.timestamp;\\n  }\\n\\n  /**\\n   * Iterates through all the entries in the object store (from newest to\\n   * oldest) and removes entries once either `maxCount` is reached or the\\n   * entry's timestamp is less than `minTimestamp`.\\n   *\\n   * @param {number} minTimestamp\\n   * @param {number} maxCount\\n   *\\n   * @private\\n   */\\n  async expireEntries(minTimestamp, maxCount) {\\n    const entriesToDelete = await this._db.transaction(\\n        OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\\n          const store = txn.objectStore(OBJECT_STORE_NAME);\\n          const entriesToDelete = [];\\n          let entriesNotDeletedCount = 0;\\n\\n          store.index('timestamp')\\n              .openCursor(null, 'prev')\\n              .onsuccess = ({target}) => {\\n                const cursor = target.result;\\n                if (cursor) {\\n                  const result = cursor.value;\\n                  // TODO(philipwalton): once we can use a multi-key index, we\\n                  // won't have to check `cacheName` here.\\n                  if (result.cacheName === this._cacheName) {\\n                    // Delete an entry if it's older than the max age or\\n                    // if we already have the max number allowed.\\n                    if ((minTimestamp && result.timestamp < minTimestamp) ||\\n                        (maxCount && entriesNotDeletedCount >= maxCount)) {\\n                      // TODO(philipwalton): we should be able to delete the\\n                      // entry right here, but doing so causes an iteration\\n                      // bug in Safari stable (fixed in TP). Instead we can\\n                      // store the keys of the entries to delete, and then\\n                      // delete the separate transactions.\\n                      // https://github.com/GoogleChrome/workbox/issues/1978\\n                      // cursor.delete();\\n\\n                      // We only need to return the URL, not the whole entry.\\n                      entriesToDelete.push(cursor.value);\\n                    } else {\\n                      entriesNotDeletedCount++;\\n                    }\\n                  }\\n                  cursor.continue();\\n                } else {\\n                  done(entriesToDelete);\\n                }\\n              };\\n        });\\n\\n    // TODO(philipwalton): once the Safari bug in the following issue is fixed,\\n    // we should be able to remove this loop and do the entry deletion in the\\n    // cursor loop above:\\n    // https://github.com/GoogleChrome/workbox/issues/1978\\n    const urlsDeleted = [];\\n    for (const entry of entriesToDelete) {\\n      await this._db.delete(OBJECT_STORE_NAME, entry.id);\\n      urlsDeleted.push(entry.url);\\n    }\\n\\n    return urlsDeleted;\\n  }\\n\\n  /**\\n   * Takes a URL and returns an ID that will be unique in the object store.\\n   *\\n   * @param {string} url\\n   * @return {string}\\n   *\\n   * @private\\n   */\\n  _getId(url) {\\n    // Creating an ID from the URL and cache name won't be necessary once\\n    // Edge switches to Chromium and all browsers we support work with\\n    // array keyPaths.\\n    return this._cacheName + '|' + normalizeURL(url);\\n  }\\n}\\n\\nexport {CacheTimestampsModel};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {CacheTimestampsModel} from './models/CacheTimestampsModel.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\n\\nimport './_version.mjs';\\n\\n/**\\n * The `CacheExpiration` class allows you define an expiration and / or\\n * limit on the number of responses stored in a\\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\\n *\\n * @memberof workbox.expiration\\n */\\nclass CacheExpiration {\\n  /**\\n   * To construct a new CacheExpiration instance you must provide at least\\n   * one of the `config` properties.\\n   *\\n   * @param {string} cacheName Name of the cache to apply restrictions to.\\n   * @param {Object} config\\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\\n   * Entries used the least will be removed as the maximum is reached.\\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\\n   * it's treated as stale and removed.\\n   */\\n  constructor(cacheName, config = {}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(cacheName, 'string', {\\n        moduleName: 'workbox-expiration',\\n        className: 'CacheExpiration',\\n        funcName: 'constructor',\\n        paramName: 'cacheName',\\n      });\\n\\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\\n        throw new WorkboxError('max-entries-or-age-required', {\\n          moduleName: 'workbox-expiration',\\n          className: 'CacheExpiration',\\n          funcName: 'constructor',\\n        });\\n      }\\n\\n      if (config.maxEntries) {\\n        assert.isType(config.maxEntries, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'CacheExpiration',\\n          funcName: 'constructor',\\n          paramName: 'config.maxEntries',\\n        });\\n\\n        // TODO: Assert is positive\\n      }\\n\\n      if (config.maxAgeSeconds) {\\n        assert.isType(config.maxAgeSeconds, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'CacheExpiration',\\n          funcName: 'constructor',\\n          paramName: 'config.maxAgeSeconds',\\n        });\\n\\n        // TODO: Assert is positive\\n      }\\n    }\\n\\n    this._isRunning = false;\\n    this._rerunRequested = false;\\n    this._maxEntries = config.maxEntries;\\n    this._maxAgeSeconds = config.maxAgeSeconds;\\n    this._cacheName = cacheName;\\n    this._timestampModel = new CacheTimestampsModel(cacheName);\\n  }\\n\\n  /**\\n   * Expires entries for the given cache and given criteria.\\n   */\\n  async expireEntries() {\\n    if (this._isRunning) {\\n      this._rerunRequested = true;\\n      return;\\n    }\\n    this._isRunning = true;\\n\\n    const minTimestamp = this._maxAgeSeconds ?\\n        Date.now() - (this._maxAgeSeconds * 1000) : undefined;\\n\\n    const urlsExpired = await this._timestampModel.expireEntries(\\n        minTimestamp, this._maxEntries);\\n\\n    // Delete URLs from the cache\\n    const cache = await caches.open(this._cacheName);\\n    for (const url of urlsExpired) {\\n      await cache.delete(url);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (urlsExpired.length > 0) {\\n        logger.groupCollapsed(\\n            `Expired ${urlsExpired.length} ` +\\n          `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\\n          `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\\n          `'${this._cacheName}' cache.`);\\n        logger.log(`Expired the following ${urlsExpired.length === 1 ?\\n            'URL' : 'URLs'}:`);\\n        urlsExpired.forEach((url) => logger.log(`    ${url}`));\\n        logger.groupEnd();\\n      } else {\\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\\n      }\\n    }\\n\\n    this._isRunning = false;\\n    if (this._rerunRequested) {\\n      this._rerunRequested = false;\\n      this.expireEntries();\\n    }\\n  }\\n\\n  /**\\n   * Update the timestamp for the given URL. This ensures the when\\n   * removing entries based on maximum entries, most recently used\\n   * is accurate or when expiring, the timestamp is up-to-date.\\n   *\\n   * @param {string} url\\n   */\\n  async updateTimestamp(url) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(url, 'string', {\\n        moduleName: 'workbox-expiration',\\n        className: 'CacheExpiration',\\n        funcName: 'updateTimestamp',\\n        paramName: 'url',\\n      });\\n    }\\n\\n    await this._timestampModel.setTimestamp(url, Date.now());\\n  }\\n\\n  /**\\n   * Can be used to check if a URL has expired or not before it's used.\\n   *\\n   * This requires a look up from IndexedDB, so can be slow.\\n   *\\n   * Note: This method will not remove the cached entry, call\\n   * `expireEntries()` to remove indexedDB and Cache entries.\\n   *\\n   * @param {string} url\\n   * @return {boolean}\\n   */\\n  async isURLExpired(url) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!this._maxAgeSeconds) {\\n        throw new WorkboxError(`expired-test-without-max-age`, {\\n          methodName: 'isURLExpired',\\n          paramName: 'maxAgeSeconds',\\n        });\\n      }\\n    }\\n\\n    const timestamp = await this._timestampModel.getTimestamp(url);\\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\\n    return (timestamp < expireOlderThan);\\n  }\\n\\n  /**\\n   * Removes the IndexedDB object store used to keep track of cache expiration\\n   * metadata.\\n   */\\n  async delete() {\\n    // Make sure we don't attempt another rerun if we're called in the middle of\\n    // a cache expiration.\\n    this._rerunRequested = false;\\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\\n  }\\n}\\n\\nexport {CacheExpiration};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {registerQuotaErrorCallback}\\n  from 'workbox-core/registerQuotaErrorCallback.mjs';\\n\\nimport {CacheExpiration} from './CacheExpiration.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * This plugin can be used in the Workbox APIs to regularly enforce a\\n * limit on the age and / or the number of cached requests.\\n *\\n * Whenever a cached request is used or updated, this plugin will look\\n * at the used Cache and remove any old or extra requests.\\n *\\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\\n * because the expiration clean up will not have occurred until *after* the\\n * cached request has been used. If the request has a \\\"Date\\\" header, then\\n * a light weight expiration check is performed and the request will not be\\n * used immediately.\\n *\\n * When using `maxEntries`, the entry least-recently requested will be removed from the cache first.\\n *\\n * @memberof workbox.expiration\\n */\\nclass Plugin {\\n  /**\\n   * @param {Object} config\\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\\n   * Entries used the least will be removed as the maximum is reached.\\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\\n   * it's treated as stale and removed.\\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\\n   * automatic deletion if the available storage quota has been exceeded.\\n   */\\n  constructor(config = {}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\\n        throw new WorkboxError('max-entries-or-age-required', {\\n          moduleName: 'workbox-expiration',\\n          className: 'Plugin',\\n          funcName: 'constructor',\\n        });\\n      }\\n\\n      if (config.maxEntries) {\\n        assert.isType(config.maxEntries, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'Plugin',\\n          funcName: 'constructor',\\n          paramName: 'config.maxEntries',\\n        });\\n      }\\n\\n      if (config.maxAgeSeconds) {\\n        assert.isType(config.maxAgeSeconds, 'number', {\\n          moduleName: 'workbox-expiration',\\n          className: 'Plugin',\\n          funcName: 'constructor',\\n          paramName: 'config.maxAgeSeconds',\\n        });\\n      }\\n    }\\n\\n    this._config = config;\\n    this._maxAgeSeconds = config.maxAgeSeconds;\\n    this._cacheExpirations = new Map();\\n\\n    if (config.purgeOnQuotaError) {\\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\\n    }\\n  }\\n\\n  /**\\n   * A simple helper method to return a CacheExpiration instance for a given\\n   * cache name.\\n   *\\n   * @param {string} cacheName\\n   * @return {CacheExpiration}\\n   *\\n   * @private\\n   */\\n  _getCacheExpiration(cacheName) {\\n    if (cacheName === cacheNames.getRuntimeName()) {\\n      throw new WorkboxError('expire-custom-caches-only');\\n    }\\n\\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\\n    if (!cacheExpiration) {\\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\\n      this._cacheExpirations.set(cacheName, cacheExpiration);\\n    }\\n    return cacheExpiration;\\n  }\\n\\n  /**\\n   * A \\\"lifecycle\\\" callback that will be triggered automatically by the\\n   * `workbox.strategies` handlers when a `Response` is about to be returned\\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\\n   * the handler. It allows the `Response` to be inspected for freshness and\\n   * prevents it from being used if the `Response`'s `Date` header value is\\n   * older than the configured `maxAgeSeconds`.\\n   *\\n   * @param {Object} options\\n   * @param {string} options.cacheName Name of the cache the response is in.\\n   * @param {Response} options.cachedResponse The `Response` object that's been\\n   *     read from a cache and whose freshness should be checked.\\n   * @return {Response} Either the `cachedResponse`, if it's\\n   *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\\n   *\\n   * @private\\n   */\\n  cachedResponseWillBeUsed({event, request, cacheName, cachedResponse}) {\\n    if (!cachedResponse) {\\n      return null;\\n    }\\n\\n    let isFresh = this._isResponseDateFresh(cachedResponse);\\n\\n    // Expire entries to ensure that even if the expiration date has\\n    // expired, it'll only be used once.\\n    const cacheExpiration = this._getCacheExpiration(cacheName);\\n    cacheExpiration.expireEntries();\\n\\n    // Update the metadata for the request URL to the current timestamp,\\n    // but don't `await` it as we don't want to block the response.\\n    const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\\n    if (event) {\\n      try {\\n        event.waitUntil(updateTimestampDone);\\n      } catch (error) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.warn(`Unable to ensure service worker stays alive when ` +\\n            `updating cache entry for '${getFriendlyURL(event.request.url)}'.`);\\n        }\\n      }\\n    }\\n\\n    return isFresh ? cachedResponse : null;\\n  }\\n\\n  /**\\n   * @param {Response} cachedResponse\\n   * @return {boolean}\\n   *\\n   * @private\\n   */\\n  _isResponseDateFresh(cachedResponse) {\\n    if (!this._maxAgeSeconds) {\\n      // We aren't expiring by age, so return true, it's fresh\\n      return true;\\n    }\\n\\n    // Check if the 'date' header will suffice a quick expiration check.\\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\\n    // discussion.\\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\\n    if (dateHeaderTimestamp === null) {\\n      // Unable to parse date, so assume it's fresh.\\n      return true;\\n    }\\n\\n    // If we have a valid headerTime, then our response is fresh iff the\\n    // headerTime plus maxAgeSeconds is greater than the current time.\\n    const now = Date.now();\\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\\n  }\\n\\n  /**\\n   * This method will extract the data header and parse it into a useful\\n   * value.\\n   *\\n   * @param {Response} cachedResponse\\n   * @return {number}\\n   *\\n   * @private\\n   */\\n  _getDateHeaderTimestamp(cachedResponse) {\\n    if (!cachedResponse.headers.has('date')) {\\n      return null;\\n    }\\n\\n    const dateHeader = cachedResponse.headers.get('date');\\n    const parsedDate = new Date(dateHeader);\\n    const headerTime = parsedDate.getTime();\\n\\n    // If the Date header was invalid for some reason, parsedDate.getTime()\\n    // will return NaN.\\n    if (isNaN(headerTime)) {\\n      return null;\\n    }\\n\\n    return headerTime;\\n  }\\n\\n  /**\\n   * A \\\"lifecycle\\\" callback that will be triggered automatically by the\\n   * `workbox.strategies` handlers when an entry is added to a cache.\\n   *\\n   * @param {Object} options\\n   * @param {string} options.cacheName Name of the cache that was updated.\\n   * @param {string} options.request The Request for the cached entry.\\n   *\\n   * @private\\n   */\\n  async cacheDidUpdate({cacheName, request}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(cacheName, 'string', {\\n        moduleName: 'workbox-expiration',\\n        className: 'Plugin',\\n        funcName: 'cacheDidUpdate',\\n        paramName: 'cacheName',\\n      });\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-expiration',\\n        className: 'Plugin',\\n        funcName: 'cacheDidUpdate',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    const cacheExpiration = this._getCacheExpiration(cacheName);\\n    await cacheExpiration.updateTimestamp(request.url);\\n    await cacheExpiration.expireEntries();\\n  }\\n\\n\\n  /**\\n   * This is a helper method that performs two operations:\\n   *\\n   * - Deletes *all* the underlying Cache instances associated with this plugin\\n   * instance, by calling caches.delete() on your behalf.\\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\\n   * details for each Cache instance.\\n   *\\n   * When using cache expiration, calling this method is preferable to calling\\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\\n   *\\n   * Note that if you're *not* using cache expiration for a given cache, calling\\n   * `caches.delete()` and passing in the cache's name should be sufficient.\\n   * There is no Workbox-specific method needed for cleanup in that case.\\n   */\\n  async deleteCacheAndMetadata() {\\n    // Do this one at a time instead of all at once via `Promise.all()` to\\n    // reduce the chance of inconsistency if a promise rejects.\\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\\n      await caches.delete(cacheName);\\n      await cacheExpiration.delete();\\n    }\\n\\n    // Reset this._cacheExpirations to its initial state.\\n    this._cacheExpirations = new Map();\\n  }\\n}\\n\\nexport {Plugin};\\n\"],\"names\":[\"self\",\"_\",\"e\",\"DB_NAME\",\"OBJECT_STORE_NAME\",\"normalizeURL\",\"unNormalizedUrl\",\"url\",\"URL\",\"location\",\"hash\",\"href\",\"CacheTimestampsModel\",\"constructor\",\"cacheName\",\"_cacheName\",\"_db\",\"DBWrapper\",\"onupgradeneeded\",\"event\",\"this\",\"_handleUpgrade\",\"objStore\",\"target\",\"result\",\"createObjectStore\",\"keyPath\",\"createIndex\",\"unique\",\"deleteDatabase\",\"timestamp\",\"put\",\"id\",\"_getId\",\"get\",\"minTimestamp\",\"maxCount\",\"entriesToDelete\",\"transaction\",\"txn\",\"done\",\"store\",\"objectStore\",\"entriesNotDeletedCount\",\"index\",\"openCursor\",\"onsuccess\",\"cursor\",\"value\",\"push\",\"continue\",\"urlsDeleted\",\"entry\",\"delete\",\"CacheExpiration\",\"config\",\"_isRunning\",\"_rerunRequested\",\"_maxEntries\",\"maxEntries\",\"_maxAgeSeconds\",\"maxAgeSeconds\",\"_timestampModel\",\"Date\",\"now\",\"undefined\",\"urlsExpired\",\"expireEntries\",\"cache\",\"caches\",\"open\",\"setTimestamp\",\"getTimestamp\",\"Infinity\",\"_config\",\"_cacheExpirations\",\"Map\",\"purgeOnQuotaError\",\"registerQuotaErrorCallback\",\"deleteCacheAndMetadata\",\"_getCacheExpiration\",\"cacheNames\",\"getRuntimeName\",\"WorkboxError\",\"cacheExpiration\",\"set\",\"cachedResponseWillBeUsed\",\"request\",\"cachedResponse\",\"isFresh\",\"_isResponseDateFresh\",\"updateTimestampDone\",\"updateTimestamp\",\"waitUntil\",\"error\",\"dateHeaderTimestamp\",\"_getDateHeaderTimestamp\",\"headers\",\"has\",\"dateHeader\",\"headerTime\",\"getTime\",\"isNaN\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
    },
    {
      "sha": "b3acf069a4ddd059e61ad153d606d58adc96da6e",
      "filename": "public/javascripts/workbox/workbox-routing.dev.js",
      "status": "added",
      "additions": 1020,
      "deletions": 0,
      "changes": 1020,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.dev.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.dev.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-routing.dev.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,1020 @@\n+this.workbox = this.workbox || {};\n+this.workbox.routing = (function (exports, assert_mjs, logger_mjs, cacheNames_mjs, WorkboxError_mjs, getFriendlyURL_mjs) {\n+  'use strict';\n+\n+  try {\n+    self['workbox:routing:4.3.1'] && _();\n+  } catch (e) {} // eslint-disable-line\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * The default HTTP method, 'GET', used when there's no specific method\n+   * configured for a route.\n+   *\n+   * @type {string}\n+   *\n+   * @private\n+   */\n+\n+  const defaultMethod = 'GET';\n+  /**\n+   * The list of valid HTTP methods associated with requests that could be routed.\n+   *\n+   * @type {Array<string>}\n+   *\n+   * @private\n+   */\n+\n+  const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * @param {function()|Object} handler Either a function, or an object with a\n+   * 'handle' method.\n+   * @return {Object} An object with a handle method.\n+   *\n+   * @private\n+   */\n+\n+  const normalizeHandler = handler => {\n+    if (handler && typeof handler === 'object') {\n+      {\n+        assert_mjs.assert.hasMethod(handler, 'handle', {\n+          moduleName: 'workbox-routing',\n+          className: 'Route',\n+          funcName: 'constructor',\n+          paramName: 'handler'\n+        });\n+      }\n+\n+      return handler;\n+    } else {\n+      {\n+        assert_mjs.assert.isType(handler, 'function', {\n+          moduleName: 'workbox-routing',\n+          className: 'Route',\n+          funcName: 'constructor',\n+          paramName: 'handler'\n+        });\n+      }\n+\n+      return {\n+        handle: handler\n+      };\n+    }\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n+   * The \"match\" callback determine if a route should be used to \"handle\" a\n+   * request by returning a non-falsy value if it can. The \"handler\" callback\n+   * is called when there is a match and should return a Promise that resolves\n+   * to a `Response`.\n+   *\n+   * @memberof workbox.routing\n+   */\n+\n+  class Route {\n+    /**\n+     * Constructor for Route class.\n+     *\n+     * @param {workbox.routing.Route~matchCallback} match\n+     * A callback function that determines whether the route matches a given\n+     * `fetch` event by returning a non-falsy value.\n+     * @param {workbox.routing.Route~handlerCallback} handler A callback\n+     * function that returns a Promise resolving to a Response.\n+     * @param {string} [method='GET'] The HTTP method to match the Route\n+     * against.\n+     */\n+    constructor(match, handler, method) {\n+      {\n+        assert_mjs.assert.isType(match, 'function', {\n+          moduleName: 'workbox-routing',\n+          className: 'Route',\n+          funcName: 'constructor',\n+          paramName: 'match'\n+        });\n+\n+        if (method) {\n+          assert_mjs.assert.isOneOf(method, validMethods, {\n+            paramName: 'method'\n+          });\n+        }\n+      } // These values are referenced directly by Router so cannot be\n+      // altered by minifification.\n+\n+\n+      this.handler = normalizeHandler(handler);\n+      this.match = match;\n+      this.method = method || defaultMethod;\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * NavigationRoute makes it easy to create a [Route]{@link\n+   * workbox.routing.Route} that matches for browser\n+   * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n+   *\n+   * It will only match incoming Requests whose\n+   * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\n+   * is set to `navigate`.\n+   *\n+   * You can optionally only apply this route to a subset of navigation requests\n+   * by using one or both of the `blacklist` and `whitelist` parameters.\n+   *\n+   * @memberof workbox.routing\n+   * @extends workbox.routing.Route\n+   */\n+\n+  class NavigationRoute extends Route {\n+    /**\n+     * If both `blacklist` and `whiltelist` are provided, the `blacklist` will\n+     * take precedence and the request will not match this route.\n+     *\n+     * The regular expressions in `whitelist` and `blacklist`\n+     * are matched against the concatenated\n+     * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n+     * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n+     * portions of the requested URL.\n+     *\n+     * @param {workbox.routing.Route~handlerCallback} handler A callback\n+     * function that returns a Promise resulting in a Response.\n+     * @param {Object} options\n+     * @param {Array<RegExp>} [options.blacklist] If any of these patterns match,\n+     * the route will not handle the request (even if a whitelist RegExp matches).\n+     * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n+     * match the URL's pathname and search parameter, the route will handle the\n+     * request (assuming the blacklist doesn't match).\n+     */\n+    constructor(handler, {\n+      whitelist = [/./],\n+      blacklist = []\n+    } = {}) {\n+      {\n+        assert_mjs.assert.isArrayOfClass(whitelist, RegExp, {\n+          moduleName: 'workbox-routing',\n+          className: 'NavigationRoute',\n+          funcName: 'constructor',\n+          paramName: 'options.whitelist'\n+        });\n+        assert_mjs.assert.isArrayOfClass(blacklist, RegExp, {\n+          moduleName: 'workbox-routing',\n+          className: 'NavigationRoute',\n+          funcName: 'constructor',\n+          paramName: 'options.blacklist'\n+        });\n+      }\n+\n+      super(options => this._match(options), handler);\n+      this._whitelist = whitelist;\n+      this._blacklist = blacklist;\n+    }\n+    /**\n+     * Routes match handler.\n+     *\n+     * @param {Object} options\n+     * @param {URL} options.url\n+     * @param {Request} options.request\n+     * @return {boolean}\n+     *\n+     * @private\n+     */\n+\n+\n+    _match({\n+      url,\n+      request\n+    }) {\n+      if (request.mode !== 'navigate') {\n+        return false;\n+      }\n+\n+      const pathnameAndSearch = url.pathname + url.search;\n+\n+      for (const regExp of this._blacklist) {\n+        if (regExp.test(pathnameAndSearch)) {\n+          {\n+            logger_mjs.logger.log(`The navigation route is not being used, since the ` + `URL matches this blacklist pattern: ${regExp}`);\n+          }\n+\n+          return false;\n+        }\n+      }\n+\n+      if (this._whitelist.some(regExp => regExp.test(pathnameAndSearch))) {\n+        {\n+          logger_mjs.logger.debug(`The navigation route is being used.`);\n+        }\n+\n+        return true;\n+      }\n+\n+      {\n+        logger_mjs.logger.log(`The navigation route is not being used, since the URL ` + `being navigated to doesn't match the whitelist.`);\n+      }\n+\n+      return false;\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * RegExpRoute makes it easy to create a regular expression based\n+   * [Route]{@link workbox.routing.Route}.\n+   *\n+   * For same-origin requests the RegExp only needs to match part of the URL. For\n+   * requests against third-party servers, you must define a RegExp that matches\n+   * the start of the URL.\n+   *\n+   * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n+   *\n+   * @memberof workbox.routing\n+   * @extends workbox.routing.Route\n+   */\n+\n+  class RegExpRoute extends Route {\n+    /**\n+     * If the regulard expression contains\n+     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n+     * th ecaptured values will be passed to the\n+     * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n+     * argument.\n+     *\n+     * @param {RegExp} regExp The regular expression to match against URLs.\n+     * @param {workbox.routing.Route~handlerCallback} handler A callback\n+     * function that returns a Promise resulting in a Response.\n+     * @param {string} [method='GET'] The HTTP method to match the Route\n+     * against.\n+     */\n+    constructor(regExp, handler, method) {\n+      {\n+        assert_mjs.assert.isInstance(regExp, RegExp, {\n+          moduleName: 'workbox-routing',\n+          className: 'RegExpRoute',\n+          funcName: 'constructor',\n+          paramName: 'pattern'\n+        });\n+      }\n+\n+      const match = ({\n+        url\n+      }) => {\n+        const result = regExp.exec(url.href); // Return null immediately if there's no match.\n+\n+        if (!result) {\n+          return null;\n+        } // Require that the match start at the first character in the URL string\n+        // if it's a cross-origin request.\n+        // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n+        // behind this behavior.\n+\n+\n+        if (url.origin !== location.origin && result.index !== 0) {\n+          {\n+            logger_mjs.logger.debug(`The regular expression '${regExp}' only partially matched ` + `against the cross-origin URL '${url}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n+          }\n+\n+          return null;\n+        } // If the route matches, but there aren't any capture groups defined, then\n+        // this will return [], which is truthy and therefore sufficient to\n+        // indicate a match.\n+        // If there are capture groups, then it will return their values.\n+\n+\n+        return result.slice(1);\n+      };\n+\n+      super(match, handler, method);\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * The Router can be used to process a FetchEvent through one or more\n+   * [Routes]{@link workbox.routing.Route} responding  with a Request if\n+   * a matching route exists.\n+   *\n+   * If no route matches a given a request, the Router will use a \"default\"\n+   * handler if one is defined.\n+   *\n+   * Should the matching Route throw an error, the Router will use a \"catch\"\n+   * handler if one is defined to gracefully deal with issues and respond with a\n+   * Request.\n+   *\n+   * If a request matches multiple routes, the **earliest** registered route will\n+   * be used to respond to the request.\n+   *\n+   * @memberof workbox.routing\n+   */\n+\n+  class Router {\n+    /**\n+     * Initializes a new Router.\n+     */\n+    constructor() {\n+      this._routes = new Map();\n+    }\n+    /**\n+     * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n+     * method name ('GET', etc.) to an array of all the corresponding `Route`\n+     * instances that are registered.\n+     */\n+\n+\n+    get routes() {\n+      return this._routes;\n+    }\n+    /**\n+     * Adds a fetch event listener to respond to events when a route matches\n+     * the event's request.\n+     */\n+\n+\n+    addFetchListener() {\n+      self.addEventListener('fetch', event => {\n+        const {\n+          request\n+        } = event;\n+        const responsePromise = this.handleRequest({\n+          request,\n+          event\n+        });\n+\n+        if (responsePromise) {\n+          event.respondWith(responsePromise);\n+        }\n+      });\n+    }\n+    /**\n+     * Adds a message event listener for URLs to cache from the window.\n+     * This is useful to cache resources loaded on the page prior to when the\n+     * service worker started controlling it.\n+     *\n+     * The format of the message data sent from the window should be as follows.\n+     * Where the `urlsToCache` array may consist of URL strings or an array of\n+     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n+     *\n+     * ```\n+     * {\n+     *   type: 'CACHE_URLS',\n+     *   payload: {\n+     *     urlsToCache: [\n+     *       './script1.js',\n+     *       './script2.js',\n+     *       ['./script3.js', {mode: 'no-cors'}],\n+     *     ],\n+     *   },\n+     * }\n+     * ```\n+     */\n+\n+\n+    addCacheListener() {\n+      self.addEventListener('message', async event => {\n+        if (event.data && event.data.type === 'CACHE_URLS') {\n+          const {\n+            payload\n+          } = event.data;\n+\n+          {\n+            logger_mjs.logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n+          }\n+\n+          const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n+            if (typeof entry === 'string') {\n+              entry = [entry];\n+            }\n+\n+            const request = new Request(...entry);\n+            return this.handleRequest({\n+              request\n+            });\n+          }));\n+          event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.\n+\n+          if (event.ports && event.ports[0]) {\n+            await requestPromises;\n+            event.ports[0].postMessage(true);\n+          }\n+        }\n+      });\n+    }\n+    /**\n+     * Apply the routing rules to a FetchEvent object to get a Response from an\n+     * appropriate Route's handler.\n+     *\n+     * @param {Object} options\n+     * @param {Request} options.request The request to handle (this is usually\n+     *     from a fetch event, but it does not have to be).\n+     * @param {FetchEvent} [options.event] The event that triggered the request,\n+     *     if applicable.\n+     * @return {Promise<Response>|undefined} A promise is returned if a\n+     *     registered route can handle the request. If there is no matching\n+     *     route and there's no `defaultHandler`, `undefined` is returned.\n+     */\n+\n+\n+    handleRequest({\n+      request,\n+      event\n+    }) {\n+      {\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'handleRequest',\n+          paramName: 'options.request'\n+        });\n+      }\n+\n+      const url = new URL(request.url, location);\n+\n+      if (!url.protocol.startsWith('http')) {\n+        {\n+          logger_mjs.logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n+        }\n+\n+        return;\n+      }\n+\n+      let {\n+        params,\n+        route\n+      } = this.findMatchingRoute({\n+        url,\n+        request,\n+        event\n+      });\n+      let handler = route && route.handler;\n+      let debugMessages = [];\n+\n+      {\n+        if (handler) {\n+          debugMessages.push([`Found a route to handle this request:`, route]);\n+\n+          if (params) {\n+            debugMessages.push([`Passing the following params to the route's handler:`, params]);\n+          }\n+        }\n+      } // If we don't have a handler because there was no matching route, then\n+      // fall back to defaultHandler if that's defined.\n+\n+\n+      if (!handler && this._defaultHandler) {\n+        {\n+          debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler.`); // This is used for debugging in logs in the case of an error.\n+\n+          route = '[Default Handler]';\n+        }\n+\n+        handler = this._defaultHandler;\n+      }\n+\n+      if (!handler) {\n+        {\n+          // No handler so Workbox will do nothing. If logs is set of debug\n+          // i.e. verbose, we should print out this information.\n+          logger_mjs.logger.debug(`No route found for: ${getFriendlyURL_mjs.getFriendlyURL(url)}`);\n+        }\n+\n+        return;\n+      }\n+\n+      {\n+        // We have a handler, meaning Workbox is going to handle the route.\n+        // print the routing details to the console.\n+        logger_mjs.logger.groupCollapsed(`Router is responding to: ${getFriendlyURL_mjs.getFriendlyURL(url)}`);\n+        debugMessages.forEach(msg => {\n+          if (Array.isArray(msg)) {\n+            logger_mjs.logger.log(...msg);\n+          } else {\n+            logger_mjs.logger.log(msg);\n+          }\n+        }); // The Request and Response objects contains a great deal of information,\n+        // hide it under a group in case developers want to see it.\n+\n+        logger_mjs.logger.groupCollapsed(`View request details here.`);\n+        logger_mjs.logger.log(request);\n+        logger_mjs.logger.groupEnd();\n+        logger_mjs.logger.groupEnd();\n+      } // Wrap in try and catch in case the handle method throws a synchronous\n+      // error. It should still callback to the catch handler.\n+\n+\n+      let responsePromise;\n+\n+      try {\n+        responsePromise = handler.handle({\n+          url,\n+          request,\n+          event,\n+          params\n+        });\n+      } catch (err) {\n+        responsePromise = Promise.reject(err);\n+      }\n+\n+      if (responsePromise && this._catchHandler) {\n+        responsePromise = responsePromise.catch(err => {\n+          {\n+            // Still include URL here as it will be async from the console group\n+            // and may not make sense without the URL\n+            logger_mjs.logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL_mjs.getFriendlyURL(url)}. Falling back to Catch Handler.`);\n+            logger_mjs.logger.error(`Error thrown by:`, route);\n+            logger_mjs.logger.error(err);\n+            logger_mjs.logger.groupEnd();\n+          }\n+\n+          return this._catchHandler.handle({\n+            url,\n+            event,\n+            err\n+          });\n+        });\n+      }\n+\n+      return responsePromise;\n+    }\n+    /**\n+     * Checks a request and URL (and optionally an event) against the list of\n+     * registered routes, and if there's a match, returns the corresponding\n+     * route along with any params generated by the match.\n+     *\n+     * @param {Object} options\n+     * @param {URL} options.url\n+     * @param {Request} options.request The request to match.\n+     * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n+     * @return {Object} An object with `route` and `params` properties.\n+     *     They are populated if a matching route was found or `undefined`\n+     *     otherwise.\n+     */\n+\n+\n+    findMatchingRoute({\n+      url,\n+      request,\n+      event\n+    }) {\n+      {\n+        assert_mjs.assert.isInstance(url, URL, {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'findMatchingRoute',\n+          paramName: 'options.url'\n+        });\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'findMatchingRoute',\n+          paramName: 'options.request'\n+        });\n+      }\n+\n+      const routes = this._routes.get(request.method) || [];\n+\n+      for (const route of routes) {\n+        let params;\n+        let matchResult = route.match({\n+          url,\n+          request,\n+          event\n+        });\n+\n+        if (matchResult) {\n+          if (Array.isArray(matchResult) && matchResult.length > 0) {\n+            // Instead of passing an empty array in as params, use undefined.\n+            params = matchResult;\n+          } else if (matchResult.constructor === Object && Object.keys(matchResult).length > 0) {\n+            // Instead of passing an empty object in as params, use undefined.\n+            params = matchResult;\n+          } // Return early if have a match.\n+\n+\n+          return {\n+            route,\n+            params\n+          };\n+        }\n+      } // If no match was found above, return and empty object.\n+\n+\n+      return {};\n+    }\n+    /**\n+     * Define a default `handler` that's called when no routes explicitly\n+     * match the incoming request.\n+     *\n+     * Without a default handler, unmatched requests will go against the\n+     * network as if there were no service worker present.\n+     *\n+     * @param {workbox.routing.Route~handlerCallback} handler A callback\n+     * function that returns a Promise resulting in a Response.\n+     */\n+\n+\n+    setDefaultHandler(handler) {\n+      this._defaultHandler = normalizeHandler(handler);\n+    }\n+    /**\n+     * If a Route throws an error while handling a request, this `handler`\n+     * will be called and given a chance to provide a response.\n+     *\n+     * @param {workbox.routing.Route~handlerCallback} handler A callback\n+     * function that returns a Promise resulting in a Response.\n+     */\n+\n+\n+    setCatchHandler(handler) {\n+      this._catchHandler = normalizeHandler(handler);\n+    }\n+    /**\n+     * Registers a route with the router.\n+     *\n+     * @param {workbox.routing.Route} route The route to register.\n+     */\n+\n+\n+    registerRoute(route) {\n+      {\n+        assert_mjs.assert.isType(route, 'object', {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'registerRoute',\n+          paramName: 'route'\n+        });\n+        assert_mjs.assert.hasMethod(route, 'match', {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'registerRoute',\n+          paramName: 'route'\n+        });\n+        assert_mjs.assert.isType(route.handler, 'object', {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'registerRoute',\n+          paramName: 'route'\n+        });\n+        assert_mjs.assert.hasMethod(route.handler, 'handle', {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'registerRoute',\n+          paramName: 'route.handler'\n+        });\n+        assert_mjs.assert.isType(route.method, 'string', {\n+          moduleName: 'workbox-routing',\n+          className: 'Router',\n+          funcName: 'registerRoute',\n+          paramName: 'route.method'\n+        });\n+      }\n+\n+      if (!this._routes.has(route.method)) {\n+        this._routes.set(route.method, []);\n+      } // Give precedence to all of the earlier routes by adding this additional\n+      // route to the end of the array.\n+\n+\n+      this._routes.get(route.method).push(route);\n+    }\n+    /**\n+     * Unregisters a route with the router.\n+     *\n+     * @param {workbox.routing.Route} route The route to unregister.\n+     */\n+\n+\n+    unregisterRoute(route) {\n+      if (!this._routes.has(route.method)) {\n+        throw new WorkboxError_mjs.WorkboxError('unregister-route-but-not-found-with-method', {\n+          method: route.method\n+        });\n+      }\n+\n+      const routeIndex = this._routes.get(route.method).indexOf(route);\n+\n+      if (routeIndex > -1) {\n+        this._routes.get(route.method).splice(routeIndex, 1);\n+      } else {\n+        throw new WorkboxError_mjs.WorkboxError('unregister-route-route-not-registered');\n+      }\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  let defaultRouter;\n+  /**\n+   * Creates a new, singleton Router instance if one does not exist. If one\n+   * does already exist, that instance is returned.\n+   *\n+   * @private\n+   * @return {Router}\n+   */\n+\n+  const getOrCreateDefaultRouter = () => {\n+    if (!defaultRouter) {\n+      defaultRouter = new Router(); // The helpers that use the default Router assume these listeners exist.\n+\n+      defaultRouter.addFetchListener();\n+      defaultRouter.addCacheListener();\n+    }\n+\n+    return defaultRouter;\n+  };\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Registers a route that will return a precached file for a navigation\n+   * request. This is useful for the\n+   * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\n+   *\n+   * When determining the URL of the precached HTML document, you will likely need\n+   * to call `workbox.precaching.getCacheKeyForURL(originalUrl)`, to account for\n+   * the fact that Workbox's precaching naming conventions often results in URL\n+   * cache keys that contain extra revisioning info.\n+   *\n+   * This method will generate a\n+   * [NavigationRoute]{@link workbox.routing.NavigationRoute}\n+   * and call\n+   * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute} on a\n+   * singleton Router instance.\n+   *\n+   * @param {string} cachedAssetUrl The cache key to use for the HTML file.\n+   * @param {Object} [options]\n+   * @param {string} [options.cacheName] Cache name to store and retrieve\n+   * requests. Defaults to precache cache name provided by\n+   * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\n+   * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\n+   * match, the route will not handle the request (even if a whitelist entry\n+   * matches).\n+   * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n+   * match the URL's pathname and search parameter, the route will handle the\n+   * request (assuming the blacklist doesn't match).\n+   * @return {workbox.routing.NavigationRoute} Returns the generated\n+   * Route.\n+   *\n+   * @alias workbox.routing.registerNavigationRoute\n+   */\n+\n+  const registerNavigationRoute = (cachedAssetUrl, options = {}) => {\n+    {\n+      assert_mjs.assert.isType(cachedAssetUrl, 'string', {\n+        moduleName: 'workbox-routing',\n+        funcName: 'registerNavigationRoute',\n+        paramName: 'cachedAssetUrl'\n+      });\n+    }\n+\n+    const cacheName = cacheNames_mjs.cacheNames.getPrecacheName(options.cacheName);\n+\n+    const handler = async () => {\n+      try {\n+        const response = await caches.match(cachedAssetUrl, {\n+          cacheName\n+        });\n+\n+        if (response) {\n+          return response;\n+        } // This shouldn't normally happen, but there are edge cases:\n+        // https://github.com/GoogleChrome/workbox/issues/1441\n+\n+\n+        throw new Error(`The cache ${cacheName} did not have an entry for ` + `${cachedAssetUrl}.`);\n+      } catch (error) {\n+        // If there's either a cache miss, or the caches.match() call threw\n+        // an exception, then attempt to fulfill the navigation request with\n+        // a response from the network rather than leaving the user with a\n+        // failed navigation.\n+        {\n+          logger_mjs.logger.debug(`Unable to respond to navigation request with ` + `cached response. Falling back to network.`, error);\n+        } // This might still fail if the browser is offline...\n+\n+\n+        return fetch(cachedAssetUrl);\n+      }\n+    };\n+\n+    const route = new NavigationRoute(handler, {\n+      whitelist: options.whitelist,\n+      blacklist: options.blacklist\n+    });\n+    const defaultRouter = getOrCreateDefaultRouter();\n+    defaultRouter.registerRoute(route);\n+    return route;\n+  };\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Easily register a RegExp, string, or function with a caching\n+   * strategy to a singleton Router instance.\n+   *\n+   * This method will generate a Route for you if needed and\n+   * call [Router.registerRoute()]{@link\n+   * workbox.routing.Router#registerRoute}.\n+   *\n+   * @param {\n+   * RegExp|\n+   * string|\n+   * workbox.routing.Route~matchCallback|\n+   * workbox.routing.Route\n+   * } capture\n+   * If the capture param is a `Route`, all other arguments will be ignored.\n+   * @param {workbox.routing.Route~handlerCallback} handler A callback\n+   * function that returns a Promise resulting in a Response.\n+   * @param {string} [method='GET'] The HTTP method to match the Route\n+   * against.\n+   * @return {workbox.routing.Route} The generated `Route`(Useful for\n+   * unregistering).\n+   *\n+   * @alias workbox.routing.registerRoute\n+   */\n+\n+  const registerRoute = (capture, handler, method = 'GET') => {\n+    let route;\n+\n+    if (typeof capture === 'string') {\n+      const captureUrl = new URL(capture, location);\n+\n+      {\n+        if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n+          throw new WorkboxError_mjs.WorkboxError('invalid-string', {\n+            moduleName: 'workbox-routing',\n+            funcName: 'registerRoute',\n+            paramName: 'capture'\n+          });\n+        } // We want to check if Express-style wildcards are in the pathname only.\n+        // TODO: Remove this log message in v4.\n+\n+\n+        const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture; // See https://github.com/pillarjs/path-to-regexp#parameters\n+\n+        const wildcards = '[*:?+]';\n+\n+        if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n+          logger_mjs.logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n+        }\n+      }\n+\n+      const matchCallback = ({\n+        url\n+      }) => {\n+        {\n+          if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n+            logger_mjs.logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n+          }\n+        }\n+\n+        return url.href === captureUrl.href;\n+      };\n+\n+      route = new Route(matchCallback, handler, method);\n+    } else if (capture instanceof RegExp) {\n+      route = new RegExpRoute(capture, handler, method);\n+    } else if (typeof capture === 'function') {\n+      route = new Route(capture, handler, method);\n+    } else if (capture instanceof Route) {\n+      route = capture;\n+    } else {\n+      throw new WorkboxError_mjs.WorkboxError('unsupported-route-type', {\n+        moduleName: 'workbox-routing',\n+        funcName: 'registerRoute',\n+        paramName: 'capture'\n+      });\n+    }\n+\n+    const defaultRouter = getOrCreateDefaultRouter();\n+    defaultRouter.registerRoute(route);\n+    return route;\n+  };\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * If a Route throws an error while handling a request, this `handler`\n+   * will be called and given a chance to provide a response.\n+   *\n+   * @param {workbox.routing.Route~handlerCallback} handler A callback\n+   * function that returns a Promise resulting in a Response.\n+   *\n+   * @alias workbox.routing.setCatchHandler\n+   */\n+\n+  const setCatchHandler = handler => {\n+    const defaultRouter = getOrCreateDefaultRouter();\n+    defaultRouter.setCatchHandler(handler);\n+  };\n+\n+  /*\n+    Copyright 2019 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * Define a default `handler` that's called when no routes explicitly\n+   * match the incoming request.\n+   *\n+   * Without a default handler, unmatched requests will go against the\n+   * network as if there were no service worker present.\n+   *\n+   * @param {workbox.routing.Route~handlerCallback} handler A callback\n+   * function that returns a Promise resulting in a Response.\n+   *\n+   * @alias workbox.routing.setDefaultHandler\n+   */\n+\n+  const setDefaultHandler = handler => {\n+    const defaultRouter = getOrCreateDefaultRouter();\n+    defaultRouter.setDefaultHandler(handler);\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  {\n+    assert_mjs.assert.isSWEnv('workbox-routing');\n+  }\n+\n+  exports.NavigationRoute = NavigationRoute;\n+  exports.RegExpRoute = RegExpRoute;\n+  exports.registerNavigationRoute = registerNavigationRoute;\n+  exports.registerRoute = registerRoute;\n+  exports.Route = Route;\n+  exports.Router = Router;\n+  exports.setCatchHandler = setCatchHandler;\n+  exports.setDefaultHandler = setDefaultHandler;\n+\n+  return exports;\n+\n+}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n+//# sourceMappingURL=workbox-routing.dev.js.map"
    },
    {
      "sha": "710713224110ead4f07e094f065652683510933f",
      "filename": "public/javascripts/workbox/workbox-routing.dev.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.dev.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.dev.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-routing.dev.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-routing.dev.js\",\"sources\":[\"../_version.mjs\",\"../utils/constants.mjs\",\"../utils/normalizeHandler.mjs\",\"../Route.mjs\",\"../NavigationRoute.mjs\",\"../RegExpRoute.mjs\",\"../Router.mjs\",\"../utils/getOrCreateDefaultRouter.mjs\",\"../registerNavigationRoute.mjs\",\"../registerRoute.mjs\",\"../setCatchHandler.mjs\",\"../setDefaultHandler.mjs\",\"../index.mjs\"],\"sourcesContent\":[\"try{self['workbox:routing:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n/**\\n * The default HTTP method, 'GET', used when there's no specific method\\n * configured for a route.\\n *\\n * @type {string}\\n *\\n * @private\\n */\\nexport const defaultMethod = 'GET';\\n\\n/**\\n * The list of valid HTTP methods associated with requests that could be routed.\\n *\\n * @type {Array<string>}\\n *\\n * @private\\n */\\nexport const validMethods = [\\n  'DELETE',\\n  'GET',\\n  'HEAD',\\n  'PATCH',\\n  'POST',\\n  'PUT',\\n];\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport '../_version.mjs';\\n\\n/**\\n * @param {function()|Object} handler Either a function, or an object with a\\n * 'handle' method.\\n * @return {Object} An object with a handle method.\\n *\\n * @private\\n */\\nexport const normalizeHandler = (handler) => {\\n  if (handler && typeof handler === 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.hasMethod(handler, 'handle', {\\n        moduleName: 'workbox-routing',\\n        className: 'Route',\\n        funcName: 'constructor',\\n        paramName: 'handler',\\n      });\\n    }\\n    return handler;\\n  } else {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(handler, 'function', {\\n        moduleName: 'workbox-routing',\\n        className: 'Route',\\n        funcName: 'constructor',\\n        paramName: 'handler',\\n      });\\n    }\\n    return {handle: handler};\\n  }\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\n\\nimport {defaultMethod, validMethods} from './utils/constants.mjs';\\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * A `Route` consists of a pair of callback functions, \\\"match\\\" and \\\"handler\\\".\\n * The \\\"match\\\" callback determine if a route should be used to \\\"handle\\\" a\\n * request by returning a non-falsy value if it can. The \\\"handler\\\" callback\\n * is called when there is a match and should return a Promise that resolves\\n * to a `Response`.\\n *\\n * @memberof workbox.routing\\n */\\nclass Route {\\n  /**\\n   * Constructor for Route class.\\n   *\\n   * @param {workbox.routing.Route~matchCallback} match\\n   * A callback function that determines whether the route matches a given\\n   * `fetch` event by returning a non-falsy value.\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resolving to a Response.\\n   * @param {string} [method='GET'] The HTTP method to match the Route\\n   * against.\\n   */\\n  constructor(match, handler, method) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(match, 'function', {\\n        moduleName: 'workbox-routing',\\n        className: 'Route',\\n        funcName: 'constructor',\\n        paramName: 'match',\\n      });\\n\\n      if (method) {\\n        assert.isOneOf(method, validMethods, {paramName: 'method'});\\n      }\\n    }\\n\\n    // These values are referenced directly by Router so cannot be\\n    // altered by minifification.\\n    this.handler = normalizeHandler(handler);\\n    this.match = match;\\n    this.method = method || defaultMethod;\\n  }\\n}\\n\\nexport {Route};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {Route} from './Route.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * NavigationRoute makes it easy to create a [Route]{@link\\n * workbox.routing.Route} that matches for browser\\n * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\\n *\\n * It will only match incoming Requests whose\\n * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\\n * is set to `navigate`.\\n *\\n * You can optionally only apply this route to a subset of navigation requests\\n * by using one or both of the `blacklist` and `whitelist` parameters.\\n *\\n * @memberof workbox.routing\\n * @extends workbox.routing.Route\\n */\\nclass NavigationRoute extends Route {\\n  /**\\n   * If both `blacklist` and `whiltelist` are provided, the `blacklist` will\\n   * take precedence and the request will not match this route.\\n   *\\n   * The regular expressions in `whitelist` and `blacklist`\\n   * are matched against the concatenated\\n   * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\\n   * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\\n   * portions of the requested URL.\\n   *\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   * @param {Object} options\\n   * @param {Array<RegExp>} [options.blacklist] If any of these patterns match,\\n   * the route will not handle the request (even if a whitelist RegExp matches).\\n   * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\\n   * match the URL's pathname and search parameter, the route will handle the\\n   * request (assuming the blacklist doesn't match).\\n   */\\n  constructor(handler, {whitelist = [/./], blacklist = []} = {}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isArrayOfClass(whitelist, RegExp, {\\n        moduleName: 'workbox-routing',\\n        className: 'NavigationRoute',\\n        funcName: 'constructor',\\n        paramName: 'options.whitelist',\\n      });\\n      assert.isArrayOfClass(blacklist, RegExp, {\\n        moduleName: 'workbox-routing',\\n        className: 'NavigationRoute',\\n        funcName: 'constructor',\\n        paramName: 'options.blacklist',\\n      });\\n    }\\n\\n    super((options) => this._match(options), handler);\\n\\n    this._whitelist = whitelist;\\n    this._blacklist = blacklist;\\n  }\\n\\n  /**\\n   * Routes match handler.\\n   *\\n   * @param {Object} options\\n   * @param {URL} options.url\\n   * @param {Request} options.request\\n   * @return {boolean}\\n   *\\n   * @private\\n   */\\n  _match({url, request}) {\\n    if (request.mode !== 'navigate') {\\n      return false;\\n    }\\n\\n    const pathnameAndSearch = url.pathname + url.search;\\n\\n    for (const regExp of this._blacklist) {\\n      if (regExp.test(pathnameAndSearch)) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.log(`The navigation route is not being used, since the ` +\\n              `URL matches this blacklist pattern: ${regExp}`);\\n        }\\n        return false;\\n      }\\n    }\\n\\n    if (this._whitelist.some((regExp) => regExp.test(pathnameAndSearch))) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.debug(`The navigation route is being used.`);\\n      }\\n      return true;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.log(`The navigation route is not being used, since the URL ` +\\n          `being navigated to doesn't match the whitelist.`);\\n    }\\n    return false;\\n  }\\n}\\n\\nexport {NavigationRoute};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {Route} from './Route.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * RegExpRoute makes it easy to create a regular expression based\\n * [Route]{@link workbox.routing.Route}.\\n *\\n * For same-origin requests the RegExp only needs to match part of the URL. For\\n * requests against third-party servers, you must define a RegExp that matches\\n * the start of the URL.\\n *\\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\\n *\\n * @memberof workbox.routing\\n * @extends workbox.routing.Route\\n */\\nclass RegExpRoute extends Route {\\n  /**\\n   * If the regulard expression contains\\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\\n   * th ecaptured values will be passed to the\\n   * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\\n   * argument.\\n   *\\n   * @param {RegExp} regExp The regular expression to match against URLs.\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   * @param {string} [method='GET'] The HTTP method to match the Route\\n   * against.\\n   */\\n  constructor(regExp, handler, method) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(regExp, RegExp, {\\n        moduleName: 'workbox-routing',\\n        className: 'RegExpRoute',\\n        funcName: 'constructor',\\n        paramName: 'pattern',\\n      });\\n    }\\n\\n    const match = ({url}) => {\\n      const result = regExp.exec(url.href);\\n\\n      // Return null immediately if there's no match.\\n      if (!result) {\\n        return null;\\n      }\\n\\n      // Require that the match start at the first character in the URL string\\n      // if it's a cross-origin request.\\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\\n      // behind this behavior.\\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.debug(\\n              `The regular expression '${regExp}' only partially matched ` +\\n            `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\\n            `handle cross-origin requests if they match the entire URL.`\\n          );\\n        }\\n\\n        return null;\\n      }\\n\\n      // If the route matches, but there aren't any capture groups defined, then\\n      // this will return [], which is truthy and therefore sufficient to\\n      // indicate a match.\\n      // If there are capture groups, then it will return their values.\\n      return result.slice(1);\\n    };\\n\\n    super(match, handler, method);\\n  }\\n}\\n\\nexport {RegExpRoute};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\n\\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * The Router can be used to process a FetchEvent through one or more\\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\\n * a matching route exists.\\n *\\n * If no route matches a given a request, the Router will use a \\\"default\\\"\\n * handler if one is defined.\\n *\\n * Should the matching Route throw an error, the Router will use a \\\"catch\\\"\\n * handler if one is defined to gracefully deal with issues and respond with a\\n * Request.\\n *\\n * If a request matches multiple routes, the **earliest** registered route will\\n * be used to respond to the request.\\n *\\n * @memberof workbox.routing\\n */\\nclass Router {\\n  /**\\n   * Initializes a new Router.\\n   */\\n  constructor() {\\n    this._routes = new Map();\\n  }\\n\\n  /**\\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\\n   * instances that are registered.\\n   */\\n  get routes() {\\n    return this._routes;\\n  }\\n\\n  /**\\n   * Adds a fetch event listener to respond to events when a route matches\\n   * the event's request.\\n   */\\n  addFetchListener() {\\n    self.addEventListener('fetch', (event) => {\\n      const {request} = event;\\n      const responsePromise = this.handleRequest({request, event});\\n      if (responsePromise) {\\n        event.respondWith(responsePromise);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Adds a message event listener for URLs to cache from the window.\\n   * This is useful to cache resources loaded on the page prior to when the\\n   * service worker started controlling it.\\n   *\\n   * The format of the message data sent from the window should be as follows.\\n   * Where the `urlsToCache` array may consist of URL strings or an array of\\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\\n   *\\n   * ```\\n   * {\\n   *   type: 'CACHE_URLS',\\n   *   payload: {\\n   *     urlsToCache: [\\n   *       './script1.js',\\n   *       './script2.js',\\n   *       ['./script3.js', {mode: 'no-cors'}],\\n   *     ],\\n   *   },\\n   * }\\n   * ```\\n   */\\n  addCacheListener() {\\n    self.addEventListener('message', async (event) => {\\n      if (event.data && event.data.type === 'CACHE_URLS') {\\n        const {payload} = event.data;\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\\n        }\\n\\n        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\\n          if (typeof entry === 'string') {\\n            entry = [entry];\\n          }\\n\\n          const request = new Request(...entry);\\n          return this.handleRequest({request});\\n        }));\\n\\n        event.waitUntil(requestPromises);\\n\\n        // If a MessageChannel was used, reply to the message on success.\\n        if (event.ports && event.ports[0]) {\\n          await requestPromises;\\n          event.ports[0].postMessage(true);\\n        }\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Apply the routing rules to a FetchEvent object to get a Response from an\\n   * appropriate Route's handler.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to handle (this is usually\\n   *     from a fetch event, but it does not have to be).\\n   * @param {FetchEvent} [options.event] The event that triggered the request,\\n   *     if applicable.\\n   * @return {Promise<Response>|undefined} A promise is returned if a\\n   *     registered route can handle the request. If there is no matching\\n   *     route and there's no `defaultHandler`, `undefined` is returned.\\n   */\\n  handleRequest({request, event}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'handleRequest',\\n        paramName: 'options.request',\\n      });\\n    }\\n\\n    const url = new URL(request.url, location);\\n    if (!url.protocol.startsWith('http')) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.debug(\\n            `Workbox Router only supports URLs that start with 'http'.`);\\n      }\\n      return;\\n    }\\n\\n    let {params, route} = this.findMatchingRoute({url, request, event});\\n    let handler = route && route.handler;\\n\\n    let debugMessages = [];\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (handler) {\\n        debugMessages.push([\\n          `Found a route to handle this request:`, route,\\n        ]);\\n\\n        if (params) {\\n          debugMessages.push([\\n            `Passing the following params to the route's handler:`, params,\\n          ]);\\n        }\\n      }\\n    }\\n\\n    // If we don't have a handler because there was no matching route, then\\n    // fall back to defaultHandler if that's defined.\\n    if (!handler && this._defaultHandler) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        debugMessages.push(`Failed to find a matching route. Falling ` +\\n          `back to the default handler.`);\\n\\n        // This is used for debugging in logs in the case of an error.\\n        route = '[Default Handler]';\\n      }\\n      handler = this._defaultHandler;\\n    }\\n\\n    if (!handler) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        // No handler so Workbox will do nothing. If logs is set of debug\\n        // i.e. verbose, we should print out this information.\\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\\n      }\\n      return;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      // We have a handler, meaning Workbox is going to handle the route.\\n      // print the routing details to the console.\\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\\n      debugMessages.forEach((msg) => {\\n        if (Array.isArray(msg)) {\\n          logger.log(...msg);\\n        } else {\\n          logger.log(msg);\\n        }\\n      });\\n\\n      // The Request and Response objects contains a great deal of information,\\n      // hide it under a group in case developers want to see it.\\n      logger.groupCollapsed(`View request details here.`);\\n      logger.log(request);\\n      logger.groupEnd();\\n\\n      logger.groupEnd();\\n    }\\n\\n    // Wrap in try and catch in case the handle method throws a synchronous\\n    // error. It should still callback to the catch handler.\\n    let responsePromise;\\n    try {\\n      responsePromise = handler.handle({url, request, event, params});\\n    } catch (err) {\\n      responsePromise = Promise.reject(err);\\n    }\\n\\n    if (responsePromise && this._catchHandler) {\\n      responsePromise = responsePromise.catch((err) => {\\n        if (process.env.NODE_ENV !== 'production') {\\n          // Still include URL here as it will be async from the console group\\n          // and may not make sense without the URL\\n          logger.groupCollapsed(`Error thrown when responding to: ` +\\n            ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\\n          logger.error(`Error thrown by:`, route);\\n          logger.error(err);\\n          logger.groupEnd();\\n        }\\n        return this._catchHandler.handle({url, event, err});\\n      });\\n    }\\n\\n    return responsePromise;\\n  }\\n\\n  /**\\n   * Checks a request and URL (and optionally an event) against the list of\\n   * registered routes, and if there's a match, returns the corresponding\\n   * route along with any params generated by the match.\\n   *\\n   * @param {Object} options\\n   * @param {URL} options.url\\n   * @param {Request} options.request The request to match.\\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\\n   * @return {Object} An object with `route` and `params` properties.\\n   *     They are populated if a matching route was found or `undefined`\\n   *     otherwise.\\n   */\\n  findMatchingRoute({url, request, event}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(url, URL, {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'findMatchingRoute',\\n        paramName: 'options.url',\\n      });\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'findMatchingRoute',\\n        paramName: 'options.request',\\n      });\\n    }\\n\\n    const routes = this._routes.get(request.method) || [];\\n    for (const route of routes) {\\n      let params;\\n      let matchResult = route.match({url, request, event});\\n      if (matchResult) {\\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\\n          // Instead of passing an empty array in as params, use undefined.\\n          params = matchResult;\\n        } else if ((matchResult.constructor === Object &&\\n            Object.keys(matchResult).length > 0)) {\\n          // Instead of passing an empty object in as params, use undefined.\\n          params = matchResult;\\n        }\\n\\n        // Return early if have a match.\\n        return {route, params};\\n      }\\n    }\\n    // If no match was found above, return and empty object.\\n    return {};\\n  }\\n\\n  /**\\n   * Define a default `handler` that's called when no routes explicitly\\n   * match the incoming request.\\n   *\\n   * Without a default handler, unmatched requests will go against the\\n   * network as if there were no service worker present.\\n   *\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   */\\n  setDefaultHandler(handler) {\\n    this._defaultHandler = normalizeHandler(handler);\\n  }\\n\\n  /**\\n   * If a Route throws an error while handling a request, this `handler`\\n   * will be called and given a chance to provide a response.\\n   *\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   */\\n  setCatchHandler(handler) {\\n    this._catchHandler = normalizeHandler(handler);\\n  }\\n\\n  /**\\n   * Registers a route with the router.\\n   *\\n   * @param {workbox.routing.Route} route The route to register.\\n   */\\n  registerRoute(route) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(route, 'object', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route',\\n      });\\n\\n      assert.hasMethod(route, 'match', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route',\\n      });\\n\\n      assert.isType(route.handler, 'object', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route',\\n      });\\n\\n      assert.hasMethod(route.handler, 'handle', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route.handler',\\n      });\\n\\n      assert.isType(route.method, 'string', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route.method',\\n      });\\n    }\\n\\n    if (!this._routes.has(route.method)) {\\n      this._routes.set(route.method, []);\\n    }\\n\\n    // Give precedence to all of the earlier routes by adding this additional\\n    // route to the end of the array.\\n    this._routes.get(route.method).push(route);\\n  }\\n\\n  /**\\n   * Unregisters a route with the router.\\n   *\\n   * @param {workbox.routing.Route} route The route to unregister.\\n   */\\n  unregisterRoute(route) {\\n    if (!this._routes.has(route.method)) {\\n      throw new WorkboxError(\\n          'unregister-route-but-not-found-with-method', {\\n            method: route.method,\\n          }\\n      );\\n    }\\n\\n    const routeIndex = this._routes.get(route.method).indexOf(route);\\n    if (routeIndex > -1) {\\n      this._routes.get(route.method).splice(routeIndex, 1);\\n    } else {\\n      throw new WorkboxError('unregister-route-route-not-registered');\\n    }\\n  }\\n}\\n\\nexport {Router};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {Router} from '../Router.mjs';\\nimport '../_version.mjs';\\n\\nlet defaultRouter;\\n\\n/**\\n * Creates a new, singleton Router instance if one does not exist. If one\\n * does already exist, that instance is returned.\\n *\\n * @private\\n * @return {Router}\\n */\\nexport const getOrCreateDefaultRouter = () => {\\n  if (!defaultRouter) {\\n    defaultRouter = new Router();\\n\\n    // The helpers that use the default Router assume these listeners exist.\\n    defaultRouter.addFetchListener();\\n    defaultRouter.addCacheListener();\\n  }\\n  return defaultRouter;\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {NavigationRoute} from './NavigationRoute.mjs';\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Registers a route that will return a precached file for a navigation\\n * request. This is useful for the\\n * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\\n *\\n * When determining the URL of the precached HTML document, you will likely need\\n * to call `workbox.precaching.getCacheKeyForURL(originalUrl)`, to account for\\n * the fact that Workbox's precaching naming conventions often results in URL\\n * cache keys that contain extra revisioning info.\\n *\\n * This method will generate a\\n * [NavigationRoute]{@link workbox.routing.NavigationRoute}\\n * and call\\n * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute} on a\\n * singleton Router instance.\\n *\\n * @param {string} cachedAssetUrl The cache key to use for the HTML file.\\n * @param {Object} [options]\\n * @param {string} [options.cacheName] Cache name to store and retrieve\\n * requests. Defaults to precache cache name provided by\\n * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\\n * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\\n * match, the route will not handle the request (even if a whitelist entry\\n * matches).\\n * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\\n * match the URL's pathname and search parameter, the route will handle the\\n * request (assuming the blacklist doesn't match).\\n * @return {workbox.routing.NavigationRoute} Returns the generated\\n * Route.\\n *\\n * @alias workbox.routing.registerNavigationRoute\\n */\\nexport const registerNavigationRoute = (cachedAssetUrl, options = {}) => {\\n  if (process.env.NODE_ENV !== 'production') {\\n    assert.isType(cachedAssetUrl, 'string', {\\n      moduleName: 'workbox-routing',\\n      funcName: 'registerNavigationRoute',\\n      paramName: 'cachedAssetUrl',\\n    });\\n  }\\n\\n  const cacheName = cacheNames.getPrecacheName(options.cacheName);\\n  const handler = async () => {\\n    try {\\n      const response = await caches.match(cachedAssetUrl, {cacheName});\\n\\n      if (response) {\\n        return response;\\n      }\\n\\n      // This shouldn't normally happen, but there are edge cases:\\n      // https://github.com/GoogleChrome/workbox/issues/1441\\n      throw new Error(`The cache ${cacheName} did not have an entry for ` +\\n          `${cachedAssetUrl}.`);\\n    } catch (error) {\\n      // If there's either a cache miss, or the caches.match() call threw\\n      // an exception, then attempt to fulfill the navigation request with\\n      // a response from the network rather than leaving the user with a\\n      // failed navigation.\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.debug(`Unable to respond to navigation request with ` +\\n            `cached response. Falling back to network.`, error);\\n      }\\n\\n      // This might still fail if the browser is offline...\\n      return fetch(cachedAssetUrl);\\n    }\\n  };\\n\\n  const route = new NavigationRoute(handler, {\\n    whitelist: options.whitelist,\\n    blacklist: options.blacklist,\\n  });\\n\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.registerRoute(route);\\n\\n  return route;\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {Route} from './Route.mjs';\\nimport {RegExpRoute} from './RegExpRoute.mjs';\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Easily register a RegExp, string, or function with a caching\\n * strategy to a singleton Router instance.\\n *\\n * This method will generate a Route for you if needed and\\n * call [Router.registerRoute()]{@link\\n * workbox.routing.Router#registerRoute}.\\n *\\n * @param {\\n * RegExp|\\n * string|\\n * workbox.routing.Route~matchCallback|\\n * workbox.routing.Route\\n * } capture\\n * If the capture param is a `Route`, all other arguments will be ignored.\\n * @param {workbox.routing.Route~handlerCallback} handler A callback\\n * function that returns a Promise resulting in a Response.\\n * @param {string} [method='GET'] The HTTP method to match the Route\\n * against.\\n * @return {workbox.routing.Route} The generated `Route`(Useful for\\n * unregistering).\\n *\\n * @alias workbox.routing.registerRoute\\n */\\nexport const registerRoute = (capture, handler, method = 'GET') => {\\n  let route;\\n\\n  if (typeof capture === 'string') {\\n    const captureUrl = new URL(capture, location);\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\\n        throw new WorkboxError('invalid-string', {\\n          moduleName: 'workbox-routing',\\n          funcName: 'registerRoute',\\n          paramName: 'capture',\\n        });\\n      }\\n\\n      // We want to check if Express-style wildcards are in the pathname only.\\n      // TODO: Remove this log message in v4.\\n      const valueToCheck = capture.startsWith('http') ?\\n          captureUrl.pathname : capture;\\n\\n      // See https://github.com/pillarjs/path-to-regexp#parameters\\n      const wildcards = '[*:?+]';\\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\\n        logger.debug(\\n            `The '$capture' parameter contains an Express-style wildcard ` +\\n          `character (${wildcards}). Strings are now always interpreted as ` +\\n          `exact matches; use a RegExp for partial or wildcard matches.`\\n        );\\n      }\\n    }\\n\\n    const matchCallback = ({url}) => {\\n      if (process.env.NODE_ENV !== 'production') {\\n        if ((url.pathname === captureUrl.pathname) &&\\n            (url.origin !== captureUrl.origin)) {\\n          logger.debug(\\n              `${capture} only partially matches the cross-origin URL ` +\\n              `${url}. This route will only handle cross-origin requests ` +\\n              `if they match the entire URL.`);\\n        }\\n      }\\n\\n      return url.href === captureUrl.href;\\n    };\\n\\n    route = new Route(matchCallback, handler, method);\\n  } else if (capture instanceof RegExp) {\\n    route = new RegExpRoute(capture, handler, method);\\n  } else if (typeof capture === 'function') {\\n    route = new Route(capture, handler, method);\\n  } else if (capture instanceof Route) {\\n    route = capture;\\n  } else {\\n    throw new WorkboxError('unsupported-route-type', {\\n      moduleName: 'workbox-routing',\\n      funcName: 'registerRoute',\\n      paramName: 'capture',\\n    });\\n  }\\n\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.registerRoute(route);\\n\\n  return route;\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\n\\nimport './_version.mjs';\\n\\n/**\\n * If a Route throws an error while handling a request, this `handler`\\n * will be called and given a chance to provide a response.\\n *\\n * @param {workbox.routing.Route~handlerCallback} handler A callback\\n * function that returns a Promise resulting in a Response.\\n *\\n * @alias workbox.routing.setCatchHandler\\n */\\nexport const setCatchHandler = (handler) => {\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.setCatchHandler(handler);\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\n\\nimport './_version.mjs';\\n\\n/**\\n * Define a default `handler` that's called when no routes explicitly\\n * match the incoming request.\\n *\\n * Without a default handler, unmatched requests will go against the\\n * network as if there were no service worker present.\\n *\\n * @param {workbox.routing.Route~handlerCallback} handler A callback\\n * function that returns a Promise resulting in a Response.\\n *\\n * @alias workbox.routing.setDefaultHandler\\n */\\nexport const setDefaultHandler = (handler) => {\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.setDefaultHandler(handler);\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\n\\nimport {NavigationRoute} from './NavigationRoute.mjs';\\nimport {RegExpRoute} from './RegExpRoute.mjs';\\nimport {registerNavigationRoute} from './registerNavigationRoute.mjs';\\nimport {registerRoute} from './registerRoute.mjs';\\nimport {Route} from './Route.mjs';\\nimport {Router} from './Router.mjs';\\nimport {setCatchHandler} from './setCatchHandler.mjs';\\nimport {setDefaultHandler} from './setDefaultHandler.mjs';\\n\\nimport './_version.mjs';\\n\\nif (process.env.NODE_ENV !== 'production') {\\n  assert.isSWEnv('workbox-routing');\\n}\\n\\n/**\\n * @namespace workbox.routing\\n */\\n\\nexport {\\n  NavigationRoute,\\n  RegExpRoute,\\n  registerNavigationRoute,\\n  registerRoute,\\n  Route,\\n  Router,\\n  setCatchHandler,\\n  setDefaultHandler,\\n};\\n\"],\"names\":[\"self\",\"_\",\"e\",\"defaultMethod\",\"validMethods\",\"normalizeHandler\",\"handler\",\"assert\",\"hasMethod\",\"moduleName\",\"className\",\"funcName\",\"paramName\",\"isType\",\"handle\",\"Route\",\"constructor\",\"match\",\"method\",\"isOneOf\",\"NavigationRoute\",\"whitelist\",\"blacklist\",\"isArrayOfClass\",\"RegExp\",\"options\",\"_match\",\"_whitelist\",\"_blacklist\",\"url\",\"request\",\"mode\",\"pathnameAndSearch\",\"pathname\",\"search\",\"regExp\",\"test\",\"logger\",\"log\",\"some\",\"debug\",\"RegExpRoute\",\"isInstance\",\"result\",\"exec\",\"href\",\"origin\",\"location\",\"index\",\"slice\",\"Router\",\"_routes\",\"Map\",\"routes\",\"addFetchListener\",\"addEventListener\",\"event\",\"responsePromise\",\"handleRequest\",\"respondWith\",\"addCacheListener\",\"data\",\"type\",\"payload\",\"urlsToCache\",\"requestPromises\",\"Promise\",\"all\",\"map\",\"entry\",\"Request\",\"waitUntil\",\"ports\",\"postMessage\",\"URL\",\"protocol\",\"startsWith\",\"params\",\"route\",\"findMatchingRoute\",\"debugMessages\",\"push\",\"_defaultHandler\",\"getFriendlyURL\",\"groupCollapsed\",\"forEach\",\"msg\",\"Array\",\"isArray\",\"groupEnd\",\"err\",\"reject\",\"_catchHandler\",\"catch\",\"error\",\"get\",\"matchResult\",\"length\",\"Object\",\"keys\",\"setDefaultHandler\",\"setCatchHandler\",\"registerRoute\",\"has\",\"set\",\"unregisterRoute\",\"WorkboxError\",\"routeIndex\",\"indexOf\",\"splice\",\"defaultRouter\",\"getOrCreateDefaultRouter\",\"registerNavigationRoute\",\"cachedAssetUrl\",\"cacheName\",\"cacheNames\",\"getPrecacheName\",\"response\",\"caches\",\"Error\",\"fetch\",\"capture\",\"captureUrl\",\"valueToCheck\",\"wildcards\",\"matchCallback\",\"isSWEnv\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
    },
    {
      "sha": "ed87f9d141976f225c5d033185e5a49acfcaf18f",
      "filename": "public/javascripts/workbox/workbox-routing.prod.js",
      "status": "added",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.prod.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.prod.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-routing.prod.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,2 @@\n+this.workbox=this.workbox||{},this.workbox.routing=function(t,e,r){\"use strict\";try{self[\"workbox:routing:4.3.1\"]&&_()}catch(t){}const s=\"GET\",n=t=>t&&\"object\"==typeof t?t:{handle:t};class o{constructor(t,e,r){this.handler=n(e),this.match=t,this.method=r||s}}class i extends o{constructor(t,{whitelist:e=[/./],blacklist:r=[]}={}){super(t=>this.t(t),t),this.s=e,this.o=r}t({url:t,request:e}){if(\"navigate\"!==e.mode)return!1;const r=t.pathname+t.search;for(const t of this.o)if(t.test(r))return!1;return!!this.s.some(t=>t.test(r))}}class u extends o{constructor(t,e,r){super(({url:e})=>{const r=t.exec(e.href);return r?e.origin!==location.origin&&0!==r.index?null:r.slice(1):null},e,r)}}class c{constructor(){this.i=new Map}get routes(){return this.i}addFetchListener(){self.addEventListener(\"fetch\",t=>{const{request:e}=t,r=this.handleRequest({request:e,event:t});r&&t.respondWith(r)})}addCacheListener(){self.addEventListener(\"message\",async t=>{if(t.data&&\"CACHE_URLS\"===t.data.type){const{payload:e}=t.data,r=Promise.all(e.urlsToCache.map(t=>{\"string\"==typeof t&&(t=[t]);const e=new Request(...t);return this.handleRequest({request:e})}));t.waitUntil(r),t.ports&&t.ports[0]&&(await r,t.ports[0].postMessage(!0))}})}handleRequest({request:t,event:e}){const r=new URL(t.url,location);if(!r.protocol.startsWith(\"http\"))return;let s,{params:n,route:o}=this.findMatchingRoute({url:r,request:t,event:e}),i=o&&o.handler;if(!i&&this.u&&(i=this.u),i){try{s=i.handle({url:r,request:t,event:e,params:n})}catch(t){s=Promise.reject(t)}return s&&this.h&&(s=s.catch(t=>this.h.handle({url:r,event:e,err:t}))),s}}findMatchingRoute({url:t,request:e,event:r}){const s=this.i.get(e.method)||[];for(const n of s){let s,o=n.match({url:t,request:e,event:r});if(o)return Array.isArray(o)&&o.length>0?s=o:o.constructor===Object&&Object.keys(o).length>0&&(s=o),{route:n,params:s}}return{}}setDefaultHandler(t){this.u=n(t)}setCatchHandler(t){this.h=n(t)}registerRoute(t){this.i.has(t.method)||this.i.set(t.method,[]),this.i.get(t.method).push(t)}unregisterRoute(t){if(!this.i.has(t.method))throw new r.WorkboxError(\"unregister-route-but-not-found-with-method\",{method:t.method});const e=this.i.get(t.method).indexOf(t);if(!(e>-1))throw new r.WorkboxError(\"unregister-route-route-not-registered\");this.i.get(t.method).splice(e,1)}}let a;const h=()=>(a||((a=new c).addFetchListener(),a.addCacheListener()),a);return t.NavigationRoute=i,t.RegExpRoute=u,t.registerNavigationRoute=((t,r={})=>{const s=e.cacheNames.getPrecacheName(r.cacheName),n=new i(async()=>{try{const e=await caches.match(t,{cacheName:s});if(e)return e;throw new Error(`The cache ${s} did not have an entry for `+`${t}.`)}catch(e){return fetch(t)}},{whitelist:r.whitelist,blacklist:r.blacklist});return h().registerRoute(n),n}),t.registerRoute=((t,e,s=\"GET\")=>{let n;if(\"string\"==typeof t){const r=new URL(t,location);n=new o(({url:t})=>t.href===r.href,e,s)}else if(t instanceof RegExp)n=new u(t,e,s);else if(\"function\"==typeof t)n=new o(t,e,s);else{if(!(t instanceof o))throw new r.WorkboxError(\"unsupported-route-type\",{moduleName:\"workbox-routing\",funcName:\"registerRoute\",paramName:\"capture\"});n=t}return h().registerRoute(n),n}),t.Route=o,t.Router=c,t.setCatchHandler=(t=>{h().setCatchHandler(t)}),t.setDefaultHandler=(t=>{h().setDefaultHandler(t)}),t}({},workbox.core._private,workbox.core._private);\n+//# sourceMappingURL=workbox-routing.prod.js.map"
    },
    {
      "sha": "56e5c0eee45abca826648c455e11139bb57a1309",
      "filename": "public/javascripts/workbox/workbox-routing.prod.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.prod.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-routing.prod.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-routing.prod.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-routing.prod.js\",\"sources\":[\"../_version.mjs\",\"../utils/constants.mjs\",\"../utils/normalizeHandler.mjs\",\"../Route.mjs\",\"../NavigationRoute.mjs\",\"../RegExpRoute.mjs\",\"../Router.mjs\",\"../utils/getOrCreateDefaultRouter.mjs\",\"../registerNavigationRoute.mjs\",\"../registerRoute.mjs\",\"../setCatchHandler.mjs\",\"../setDefaultHandler.mjs\"],\"sourcesContent\":[\"try{self['workbox:routing:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\n/**\\n * The default HTTP method, 'GET', used when there's no specific method\\n * configured for a route.\\n *\\n * @type {string}\\n *\\n * @private\\n */\\nexport const defaultMethod = 'GET';\\n\\n/**\\n * The list of valid HTTP methods associated with requests that could be routed.\\n *\\n * @type {Array<string>}\\n *\\n * @private\\n */\\nexport const validMethods = [\\n  'DELETE',\\n  'GET',\\n  'HEAD',\\n  'PATCH',\\n  'POST',\\n  'PUT',\\n];\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport '../_version.mjs';\\n\\n/**\\n * @param {function()|Object} handler Either a function, or an object with a\\n * 'handle' method.\\n * @return {Object} An object with a handle method.\\n *\\n * @private\\n */\\nexport const normalizeHandler = (handler) => {\\n  if (handler && typeof handler === 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.hasMethod(handler, 'handle', {\\n        moduleName: 'workbox-routing',\\n        className: 'Route',\\n        funcName: 'constructor',\\n        paramName: 'handler',\\n      });\\n    }\\n    return handler;\\n  } else {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(handler, 'function', {\\n        moduleName: 'workbox-routing',\\n        className: 'Route',\\n        funcName: 'constructor',\\n        paramName: 'handler',\\n      });\\n    }\\n    return {handle: handler};\\n  }\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\n\\nimport {defaultMethod, validMethods} from './utils/constants.mjs';\\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * A `Route` consists of a pair of callback functions, \\\"match\\\" and \\\"handler\\\".\\n * The \\\"match\\\" callback determine if a route should be used to \\\"handle\\\" a\\n * request by returning a non-falsy value if it can. The \\\"handler\\\" callback\\n * is called when there is a match and should return a Promise that resolves\\n * to a `Response`.\\n *\\n * @memberof workbox.routing\\n */\\nclass Route {\\n  /**\\n   * Constructor for Route class.\\n   *\\n   * @param {workbox.routing.Route~matchCallback} match\\n   * A callback function that determines whether the route matches a given\\n   * `fetch` event by returning a non-falsy value.\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resolving to a Response.\\n   * @param {string} [method='GET'] The HTTP method to match the Route\\n   * against.\\n   */\\n  constructor(match, handler, method) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(match, 'function', {\\n        moduleName: 'workbox-routing',\\n        className: 'Route',\\n        funcName: 'constructor',\\n        paramName: 'match',\\n      });\\n\\n      if (method) {\\n        assert.isOneOf(method, validMethods, {paramName: 'method'});\\n      }\\n    }\\n\\n    // These values are referenced directly by Router so cannot be\\n    // altered by minifification.\\n    this.handler = normalizeHandler(handler);\\n    this.match = match;\\n    this.method = method || defaultMethod;\\n  }\\n}\\n\\nexport {Route};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {Route} from './Route.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * NavigationRoute makes it easy to create a [Route]{@link\\n * workbox.routing.Route} that matches for browser\\n * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\\n *\\n * It will only match incoming Requests whose\\n * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\\n * is set to `navigate`.\\n *\\n * You can optionally only apply this route to a subset of navigation requests\\n * by using one or both of the `blacklist` and `whitelist` parameters.\\n *\\n * @memberof workbox.routing\\n * @extends workbox.routing.Route\\n */\\nclass NavigationRoute extends Route {\\n  /**\\n   * If both `blacklist` and `whiltelist` are provided, the `blacklist` will\\n   * take precedence and the request will not match this route.\\n   *\\n   * The regular expressions in `whitelist` and `blacklist`\\n   * are matched against the concatenated\\n   * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\\n   * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\\n   * portions of the requested URL.\\n   *\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   * @param {Object} options\\n   * @param {Array<RegExp>} [options.blacklist] If any of these patterns match,\\n   * the route will not handle the request (even if a whitelist RegExp matches).\\n   * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\\n   * match the URL's pathname and search parameter, the route will handle the\\n   * request (assuming the blacklist doesn't match).\\n   */\\n  constructor(handler, {whitelist = [/./], blacklist = []} = {}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isArrayOfClass(whitelist, RegExp, {\\n        moduleName: 'workbox-routing',\\n        className: 'NavigationRoute',\\n        funcName: 'constructor',\\n        paramName: 'options.whitelist',\\n      });\\n      assert.isArrayOfClass(blacklist, RegExp, {\\n        moduleName: 'workbox-routing',\\n        className: 'NavigationRoute',\\n        funcName: 'constructor',\\n        paramName: 'options.blacklist',\\n      });\\n    }\\n\\n    super((options) => this._match(options), handler);\\n\\n    this._whitelist = whitelist;\\n    this._blacklist = blacklist;\\n  }\\n\\n  /**\\n   * Routes match handler.\\n   *\\n   * @param {Object} options\\n   * @param {URL} options.url\\n   * @param {Request} options.request\\n   * @return {boolean}\\n   *\\n   * @private\\n   */\\n  _match({url, request}) {\\n    if (request.mode !== 'navigate') {\\n      return false;\\n    }\\n\\n    const pathnameAndSearch = url.pathname + url.search;\\n\\n    for (const regExp of this._blacklist) {\\n      if (regExp.test(pathnameAndSearch)) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.log(`The navigation route is not being used, since the ` +\\n              `URL matches this blacklist pattern: ${regExp}`);\\n        }\\n        return false;\\n      }\\n    }\\n\\n    if (this._whitelist.some((regExp) => regExp.test(pathnameAndSearch))) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.debug(`The navigation route is being used.`);\\n      }\\n      return true;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.log(`The navigation route is not being used, since the URL ` +\\n          `being navigated to doesn't match the whitelist.`);\\n    }\\n    return false;\\n  }\\n}\\n\\nexport {NavigationRoute};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {Route} from './Route.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * RegExpRoute makes it easy to create a regular expression based\\n * [Route]{@link workbox.routing.Route}.\\n *\\n * For same-origin requests the RegExp only needs to match part of the URL. For\\n * requests against third-party servers, you must define a RegExp that matches\\n * the start of the URL.\\n *\\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\\n *\\n * @memberof workbox.routing\\n * @extends workbox.routing.Route\\n */\\nclass RegExpRoute extends Route {\\n  /**\\n   * If the regulard expression contains\\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\\n   * th ecaptured values will be passed to the\\n   * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\\n   * argument.\\n   *\\n   * @param {RegExp} regExp The regular expression to match against URLs.\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   * @param {string} [method='GET'] The HTTP method to match the Route\\n   * against.\\n   */\\n  constructor(regExp, handler, method) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(regExp, RegExp, {\\n        moduleName: 'workbox-routing',\\n        className: 'RegExpRoute',\\n        funcName: 'constructor',\\n        paramName: 'pattern',\\n      });\\n    }\\n\\n    const match = ({url}) => {\\n      const result = regExp.exec(url.href);\\n\\n      // Return null immediately if there's no match.\\n      if (!result) {\\n        return null;\\n      }\\n\\n      // Require that the match start at the first character in the URL string\\n      // if it's a cross-origin request.\\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\\n      // behind this behavior.\\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.debug(\\n              `The regular expression '${regExp}' only partially matched ` +\\n            `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\\n            `handle cross-origin requests if they match the entire URL.`\\n          );\\n        }\\n\\n        return null;\\n      }\\n\\n      // If the route matches, but there aren't any capture groups defined, then\\n      // this will return [], which is truthy and therefore sufficient to\\n      // indicate a match.\\n      // If there are capture groups, then it will return their values.\\n      return result.slice(1);\\n    };\\n\\n    super(match, handler, method);\\n  }\\n}\\n\\nexport {RegExpRoute};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\n\\nimport {normalizeHandler} from './utils/normalizeHandler.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * The Router can be used to process a FetchEvent through one or more\\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\\n * a matching route exists.\\n *\\n * If no route matches a given a request, the Router will use a \\\"default\\\"\\n * handler if one is defined.\\n *\\n * Should the matching Route throw an error, the Router will use a \\\"catch\\\"\\n * handler if one is defined to gracefully deal with issues and respond with a\\n * Request.\\n *\\n * If a request matches multiple routes, the **earliest** registered route will\\n * be used to respond to the request.\\n *\\n * @memberof workbox.routing\\n */\\nclass Router {\\n  /**\\n   * Initializes a new Router.\\n   */\\n  constructor() {\\n    this._routes = new Map();\\n  }\\n\\n  /**\\n   * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\\n   * instances that are registered.\\n   */\\n  get routes() {\\n    return this._routes;\\n  }\\n\\n  /**\\n   * Adds a fetch event listener to respond to events when a route matches\\n   * the event's request.\\n   */\\n  addFetchListener() {\\n    self.addEventListener('fetch', (event) => {\\n      const {request} = event;\\n      const responsePromise = this.handleRequest({request, event});\\n      if (responsePromise) {\\n        event.respondWith(responsePromise);\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Adds a message event listener for URLs to cache from the window.\\n   * This is useful to cache resources loaded on the page prior to when the\\n   * service worker started controlling it.\\n   *\\n   * The format of the message data sent from the window should be as follows.\\n   * Where the `urlsToCache` array may consist of URL strings or an array of\\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\\n   *\\n   * ```\\n   * {\\n   *   type: 'CACHE_URLS',\\n   *   payload: {\\n   *     urlsToCache: [\\n   *       './script1.js',\\n   *       './script2.js',\\n   *       ['./script3.js', {mode: 'no-cors'}],\\n   *     ],\\n   *   },\\n   * }\\n   * ```\\n   */\\n  addCacheListener() {\\n    self.addEventListener('message', async (event) => {\\n      if (event.data && event.data.type === 'CACHE_URLS') {\\n        const {payload} = event.data;\\n\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.debug(`Caching URLs from the window`, payload.urlsToCache);\\n        }\\n\\n        const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\\n          if (typeof entry === 'string') {\\n            entry = [entry];\\n          }\\n\\n          const request = new Request(...entry);\\n          return this.handleRequest({request});\\n        }));\\n\\n        event.waitUntil(requestPromises);\\n\\n        // If a MessageChannel was used, reply to the message on success.\\n        if (event.ports && event.ports[0]) {\\n          await requestPromises;\\n          event.ports[0].postMessage(true);\\n        }\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Apply the routing rules to a FetchEvent object to get a Response from an\\n   * appropriate Route's handler.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to handle (this is usually\\n   *     from a fetch event, but it does not have to be).\\n   * @param {FetchEvent} [options.event] The event that triggered the request,\\n   *     if applicable.\\n   * @return {Promise<Response>|undefined} A promise is returned if a\\n   *     registered route can handle the request. If there is no matching\\n   *     route and there's no `defaultHandler`, `undefined` is returned.\\n   */\\n  handleRequest({request, event}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'handleRequest',\\n        paramName: 'options.request',\\n      });\\n    }\\n\\n    const url = new URL(request.url, location);\\n    if (!url.protocol.startsWith('http')) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.debug(\\n            `Workbox Router only supports URLs that start with 'http'.`);\\n      }\\n      return;\\n    }\\n\\n    let {params, route} = this.findMatchingRoute({url, request, event});\\n    let handler = route && route.handler;\\n\\n    let debugMessages = [];\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (handler) {\\n        debugMessages.push([\\n          `Found a route to handle this request:`, route,\\n        ]);\\n\\n        if (params) {\\n          debugMessages.push([\\n            `Passing the following params to the route's handler:`, params,\\n          ]);\\n        }\\n      }\\n    }\\n\\n    // If we don't have a handler because there was no matching route, then\\n    // fall back to defaultHandler if that's defined.\\n    if (!handler && this._defaultHandler) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        debugMessages.push(`Failed to find a matching route. Falling ` +\\n          `back to the default handler.`);\\n\\n        // This is used for debugging in logs in the case of an error.\\n        route = '[Default Handler]';\\n      }\\n      handler = this._defaultHandler;\\n    }\\n\\n    if (!handler) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        // No handler so Workbox will do nothing. If logs is set of debug\\n        // i.e. verbose, we should print out this information.\\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\\n      }\\n      return;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      // We have a handler, meaning Workbox is going to handle the route.\\n      // print the routing details to the console.\\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\\n      debugMessages.forEach((msg) => {\\n        if (Array.isArray(msg)) {\\n          logger.log(...msg);\\n        } else {\\n          logger.log(msg);\\n        }\\n      });\\n\\n      // The Request and Response objects contains a great deal of information,\\n      // hide it under a group in case developers want to see it.\\n      logger.groupCollapsed(`View request details here.`);\\n      logger.log(request);\\n      logger.groupEnd();\\n\\n      logger.groupEnd();\\n    }\\n\\n    // Wrap in try and catch in case the handle method throws a synchronous\\n    // error. It should still callback to the catch handler.\\n    let responsePromise;\\n    try {\\n      responsePromise = handler.handle({url, request, event, params});\\n    } catch (err) {\\n      responsePromise = Promise.reject(err);\\n    }\\n\\n    if (responsePromise && this._catchHandler) {\\n      responsePromise = responsePromise.catch((err) => {\\n        if (process.env.NODE_ENV !== 'production') {\\n          // Still include URL here as it will be async from the console group\\n          // and may not make sense without the URL\\n          logger.groupCollapsed(`Error thrown when responding to: ` +\\n            ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\\n          logger.error(`Error thrown by:`, route);\\n          logger.error(err);\\n          logger.groupEnd();\\n        }\\n        return this._catchHandler.handle({url, event, err});\\n      });\\n    }\\n\\n    return responsePromise;\\n  }\\n\\n  /**\\n   * Checks a request and URL (and optionally an event) against the list of\\n   * registered routes, and if there's a match, returns the corresponding\\n   * route along with any params generated by the match.\\n   *\\n   * @param {Object} options\\n   * @param {URL} options.url\\n   * @param {Request} options.request The request to match.\\n   * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\\n   * @return {Object} An object with `route` and `params` properties.\\n   *     They are populated if a matching route was found or `undefined`\\n   *     otherwise.\\n   */\\n  findMatchingRoute({url, request, event}) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(url, URL, {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'findMatchingRoute',\\n        paramName: 'options.url',\\n      });\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'findMatchingRoute',\\n        paramName: 'options.request',\\n      });\\n    }\\n\\n    const routes = this._routes.get(request.method) || [];\\n    for (const route of routes) {\\n      let params;\\n      let matchResult = route.match({url, request, event});\\n      if (matchResult) {\\n        if (Array.isArray(matchResult) && matchResult.length > 0) {\\n          // Instead of passing an empty array in as params, use undefined.\\n          params = matchResult;\\n        } else if ((matchResult.constructor === Object &&\\n            Object.keys(matchResult).length > 0)) {\\n          // Instead of passing an empty object in as params, use undefined.\\n          params = matchResult;\\n        }\\n\\n        // Return early if have a match.\\n        return {route, params};\\n      }\\n    }\\n    // If no match was found above, return and empty object.\\n    return {};\\n  }\\n\\n  /**\\n   * Define a default `handler` that's called when no routes explicitly\\n   * match the incoming request.\\n   *\\n   * Without a default handler, unmatched requests will go against the\\n   * network as if there were no service worker present.\\n   *\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   */\\n  setDefaultHandler(handler) {\\n    this._defaultHandler = normalizeHandler(handler);\\n  }\\n\\n  /**\\n   * If a Route throws an error while handling a request, this `handler`\\n   * will be called and given a chance to provide a response.\\n   *\\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\\n   * function that returns a Promise resulting in a Response.\\n   */\\n  setCatchHandler(handler) {\\n    this._catchHandler = normalizeHandler(handler);\\n  }\\n\\n  /**\\n   * Registers a route with the router.\\n   *\\n   * @param {workbox.routing.Route} route The route to register.\\n   */\\n  registerRoute(route) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isType(route, 'object', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route',\\n      });\\n\\n      assert.hasMethod(route, 'match', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route',\\n      });\\n\\n      assert.isType(route.handler, 'object', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route',\\n      });\\n\\n      assert.hasMethod(route.handler, 'handle', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route.handler',\\n      });\\n\\n      assert.isType(route.method, 'string', {\\n        moduleName: 'workbox-routing',\\n        className: 'Router',\\n        funcName: 'registerRoute',\\n        paramName: 'route.method',\\n      });\\n    }\\n\\n    if (!this._routes.has(route.method)) {\\n      this._routes.set(route.method, []);\\n    }\\n\\n    // Give precedence to all of the earlier routes by adding this additional\\n    // route to the end of the array.\\n    this._routes.get(route.method).push(route);\\n  }\\n\\n  /**\\n   * Unregisters a route with the router.\\n   *\\n   * @param {workbox.routing.Route} route The route to unregister.\\n   */\\n  unregisterRoute(route) {\\n    if (!this._routes.has(route.method)) {\\n      throw new WorkboxError(\\n          'unregister-route-but-not-found-with-method', {\\n            method: route.method,\\n          }\\n      );\\n    }\\n\\n    const routeIndex = this._routes.get(route.method).indexOf(route);\\n    if (routeIndex > -1) {\\n      this._routes.get(route.method).splice(routeIndex, 1);\\n    } else {\\n      throw new WorkboxError('unregister-route-route-not-registered');\\n    }\\n  }\\n}\\n\\nexport {Router};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {Router} from '../Router.mjs';\\nimport '../_version.mjs';\\n\\nlet defaultRouter;\\n\\n/**\\n * Creates a new, singleton Router instance if one does not exist. If one\\n * does already exist, that instance is returned.\\n *\\n * @private\\n * @return {Router}\\n */\\nexport const getOrCreateDefaultRouter = () => {\\n  if (!defaultRouter) {\\n    defaultRouter = new Router();\\n\\n    // The helpers that use the default Router assume these listeners exist.\\n    defaultRouter.addFetchListener();\\n    defaultRouter.addCacheListener();\\n  }\\n  return defaultRouter;\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {NavigationRoute} from './NavigationRoute.mjs';\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Registers a route that will return a precached file for a navigation\\n * request. This is useful for the\\n * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\\n *\\n * When determining the URL of the precached HTML document, you will likely need\\n * to call `workbox.precaching.getCacheKeyForURL(originalUrl)`, to account for\\n * the fact that Workbox's precaching naming conventions often results in URL\\n * cache keys that contain extra revisioning info.\\n *\\n * This method will generate a\\n * [NavigationRoute]{@link workbox.routing.NavigationRoute}\\n * and call\\n * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute} on a\\n * singleton Router instance.\\n *\\n * @param {string} cachedAssetUrl The cache key to use for the HTML file.\\n * @param {Object} [options]\\n * @param {string} [options.cacheName] Cache name to store and retrieve\\n * requests. Defaults to precache cache name provided by\\n * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\\n * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\\n * match, the route will not handle the request (even if a whitelist entry\\n * matches).\\n * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\\n * match the URL's pathname and search parameter, the route will handle the\\n * request (assuming the blacklist doesn't match).\\n * @return {workbox.routing.NavigationRoute} Returns the generated\\n * Route.\\n *\\n * @alias workbox.routing.registerNavigationRoute\\n */\\nexport const registerNavigationRoute = (cachedAssetUrl, options = {}) => {\\n  if (process.env.NODE_ENV !== 'production') {\\n    assert.isType(cachedAssetUrl, 'string', {\\n      moduleName: 'workbox-routing',\\n      funcName: 'registerNavigationRoute',\\n      paramName: 'cachedAssetUrl',\\n    });\\n  }\\n\\n  const cacheName = cacheNames.getPrecacheName(options.cacheName);\\n  const handler = async () => {\\n    try {\\n      const response = await caches.match(cachedAssetUrl, {cacheName});\\n\\n      if (response) {\\n        return response;\\n      }\\n\\n      // This shouldn't normally happen, but there are edge cases:\\n      // https://github.com/GoogleChrome/workbox/issues/1441\\n      throw new Error(`The cache ${cacheName} did not have an entry for ` +\\n          `${cachedAssetUrl}.`);\\n    } catch (error) {\\n      // If there's either a cache miss, or the caches.match() call threw\\n      // an exception, then attempt to fulfill the navigation request with\\n      // a response from the network rather than leaving the user with a\\n      // failed navigation.\\n      if (process.env.NODE_ENV !== 'production') {\\n        logger.debug(`Unable to respond to navigation request with ` +\\n            `cached response. Falling back to network.`, error);\\n      }\\n\\n      // This might still fail if the browser is offline...\\n      return fetch(cachedAssetUrl);\\n    }\\n  };\\n\\n  const route = new NavigationRoute(handler, {\\n    whitelist: options.whitelist,\\n    blacklist: options.blacklist,\\n  });\\n\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.registerRoute(route);\\n\\n  return route;\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\nimport {Route} from './Route.mjs';\\nimport {RegExpRoute} from './RegExpRoute.mjs';\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * Easily register a RegExp, string, or function with a caching\\n * strategy to a singleton Router instance.\\n *\\n * This method will generate a Route for you if needed and\\n * call [Router.registerRoute()]{@link\\n * workbox.routing.Router#registerRoute}.\\n *\\n * @param {\\n * RegExp|\\n * string|\\n * workbox.routing.Route~matchCallback|\\n * workbox.routing.Route\\n * } capture\\n * If the capture param is a `Route`, all other arguments will be ignored.\\n * @param {workbox.routing.Route~handlerCallback} handler A callback\\n * function that returns a Promise resulting in a Response.\\n * @param {string} [method='GET'] The HTTP method to match the Route\\n * against.\\n * @return {workbox.routing.Route} The generated `Route`(Useful for\\n * unregistering).\\n *\\n * @alias workbox.routing.registerRoute\\n */\\nexport const registerRoute = (capture, handler, method = 'GET') => {\\n  let route;\\n\\n  if (typeof capture === 'string') {\\n    const captureUrl = new URL(capture, location);\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (!(capture.startsWith('/') || capture.startsWith('http'))) {\\n        throw new WorkboxError('invalid-string', {\\n          moduleName: 'workbox-routing',\\n          funcName: 'registerRoute',\\n          paramName: 'capture',\\n        });\\n      }\\n\\n      // We want to check if Express-style wildcards are in the pathname only.\\n      // TODO: Remove this log message in v4.\\n      const valueToCheck = capture.startsWith('http') ?\\n          captureUrl.pathname : capture;\\n\\n      // See https://github.com/pillarjs/path-to-regexp#parameters\\n      const wildcards = '[*:?+]';\\n      if (valueToCheck.match(new RegExp(`${wildcards}`))) {\\n        logger.debug(\\n            `The '$capture' parameter contains an Express-style wildcard ` +\\n          `character (${wildcards}). Strings are now always interpreted as ` +\\n          `exact matches; use a RegExp for partial or wildcard matches.`\\n        );\\n      }\\n    }\\n\\n    const matchCallback = ({url}) => {\\n      if (process.env.NODE_ENV !== 'production') {\\n        if ((url.pathname === captureUrl.pathname) &&\\n            (url.origin !== captureUrl.origin)) {\\n          logger.debug(\\n              `${capture} only partially matches the cross-origin URL ` +\\n              `${url}. This route will only handle cross-origin requests ` +\\n              `if they match the entire URL.`);\\n        }\\n      }\\n\\n      return url.href === captureUrl.href;\\n    };\\n\\n    route = new Route(matchCallback, handler, method);\\n  } else if (capture instanceof RegExp) {\\n    route = new RegExpRoute(capture, handler, method);\\n  } else if (typeof capture === 'function') {\\n    route = new Route(capture, handler, method);\\n  } else if (capture instanceof Route) {\\n    route = capture;\\n  } else {\\n    throw new WorkboxError('unsupported-route-type', {\\n      moduleName: 'workbox-routing',\\n      funcName: 'registerRoute',\\n      paramName: 'capture',\\n    });\\n  }\\n\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.registerRoute(route);\\n\\n  return route;\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\n\\nimport './_version.mjs';\\n\\n/**\\n * If a Route throws an error while handling a request, this `handler`\\n * will be called and given a chance to provide a response.\\n *\\n * @param {workbox.routing.Route~handlerCallback} handler A callback\\n * function that returns a Promise resulting in a Response.\\n *\\n * @alias workbox.routing.setCatchHandler\\n */\\nexport const setCatchHandler = (handler) => {\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.setCatchHandler(handler);\\n};\\n\",\"/*\\n  Copyright 2019 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {getOrCreateDefaultRouter} from './utils/getOrCreateDefaultRouter.mjs';\\n\\nimport './_version.mjs';\\n\\n/**\\n * Define a default `handler` that's called when no routes explicitly\\n * match the incoming request.\\n *\\n * Without a default handler, unmatched requests will go against the\\n * network as if there were no service worker present.\\n *\\n * @param {workbox.routing.Route~handlerCallback} handler A callback\\n * function that returns a Promise resulting in a Response.\\n *\\n * @alias workbox.routing.setDefaultHandler\\n */\\nexport const setDefaultHandler = (handler) => {\\n  const defaultRouter = getOrCreateDefaultRouter();\\n  defaultRouter.setDefaultHandler(handler);\\n};\\n\"],\"names\":[\"self\",\"_\",\"e\",\"defaultMethod\",\"normalizeHandler\",\"handler\",\"handle\",\"Route\",\"constructor\",\"match\",\"method\",\"NavigationRoute\",\"whitelist\",\"blacklist\",\"options\",\"this\",\"_match\",\"_whitelist\",\"_blacklist\",\"url\",\"request\",\"mode\",\"pathnameAndSearch\",\"pathname\",\"search\",\"regExp\",\"test\",\"some\",\"RegExpRoute\",\"result\",\"exec\",\"href\",\"origin\",\"location\",\"index\",\"slice\",\"Router\",\"_routes\",\"Map\",\"addFetchListener\",\"addEventListener\",\"event\",\"responsePromise\",\"handleRequest\",\"respondWith\",\"addCacheListener\",\"async\",\"data\",\"type\",\"payload\",\"requestPromises\",\"Promise\",\"all\",\"urlsToCache\",\"map\",\"entry\",\"Request\",\"waitUntil\",\"ports\",\"postMessage\",\"URL\",\"protocol\",\"startsWith\",\"params\",\"route\",\"findMatchingRoute\",\"_defaultHandler\",\"err\",\"reject\",\"_catchHandler\",\"catch\",\"routes\",\"get\",\"matchResult\",\"Array\",\"isArray\",\"length\",\"Object\",\"keys\",\"setDefaultHandler\",\"setCatchHandler\",\"registerRoute\",\"has\",\"set\",\"push\",\"unregisterRoute\",\"WorkboxError\",\"routeIndex\",\"indexOf\",\"splice\",\"defaultRouter\",\"getOrCreateDefaultRouter\",\"cachedAssetUrl\",\"cacheName\",\"cacheNames\",\"getPrecacheName\",\"response\",\"caches\",\"Error\",\"error\",\"fetch\",\"capture\",\"captureUrl\",\"RegExp\",\"moduleName\",\"funcName\",\"paramName\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
    },
    {
      "sha": "e88a65d8b76aafe64679bbe17d82c8204138fd5d",
      "filename": "public/javascripts/workbox/workbox-strategies.dev.js",
      "status": "added",
      "additions": 1138,
      "deletions": 0,
      "changes": 1138,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.dev.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.dev.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-strategies.dev.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,1138 @@\n+this.workbox = this.workbox || {};\n+this.workbox.strategies = (function (exports, logger_mjs, assert_mjs, cacheNames_mjs, cacheWrapper_mjs, fetchWrapper_mjs, getFriendlyURL_mjs, WorkboxError_mjs) {\n+  'use strict';\n+\n+  try {\n+    self['workbox:strategies:4.3.1'] && _();\n+  } catch (e) {} // eslint-disable-line\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+\n+  const getFriendlyURL = url => {\n+    const urlObj = new URL(url, location);\n+\n+    if (urlObj.origin === location.origin) {\n+      return urlObj.pathname;\n+    }\n+\n+    return urlObj.href;\n+  };\n+\n+  const messages = {\n+    strategyStart: (strategyName, request) => `Using ${strategyName} to ` + `respond to '${getFriendlyURL(request.url)}'`,\n+    printFinalResponse: response => {\n+      if (response) {\n+        logger_mjs.logger.groupCollapsed(`View the final response here.`);\n+        logger_mjs.logger.log(response);\n+        logger_mjs.logger.groupEnd();\n+      }\n+    }\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n+   * request strategy.\n+   *\n+   * A cache first strategy is useful for assets that have been revisioned,\n+   * such as URLs like `/styles/example.a8f5f1.css`, since they\n+   * can be cached for long periods of time.\n+   *\n+   * If the network request fails, and there is no cache match, this will throw\n+   * a `WorkboxError` exception.\n+   *\n+   * @memberof workbox.strategies\n+   */\n+\n+  class CacheFirst {\n+    /**\n+     * @param {Object} options\n+     * @param {string} options.cacheName Cache name to store and retrieve\n+     * requests. Defaults to cache names provided by\n+     * [workbox-core]{@link workbox.core.cacheNames}.\n+     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n+     * to use in conjunction with this caching strategy.\n+     * @param {Object} options.fetchOptions Values passed along to the\n+     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n+     * of all fetch() requests made by this strategy.\n+     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n+     */\n+    constructor(options = {}) {\n+      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n+      this._plugins = options.plugins || [];\n+      this._fetchOptions = options.fetchOptions || null;\n+      this._matchOptions = options.matchOptions || null;\n+    }\n+    /**\n+     * This method will perform a request strategy and follows an API that\n+     * will work with the\n+     * [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * @param {Object} options\n+     * @param {Request} options.request The request to run this strategy for.\n+     * @param {Event} [options.event] The event that triggered the request.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async handle({\n+      event,\n+      request\n+    }) {\n+      return this.makeRequest({\n+        event,\n+        request: request || event.request\n+      });\n+    }\n+    /**\n+     * This method can be used to perform a make a standalone request outside the\n+     * context of the [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n+     * for more usage information.\n+     *\n+     * @param {Object} options\n+     * @param {Request|string} options.request Either a\n+     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n+     *     object, or a string URL, corresponding to the request to be made.\n+     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n+           be called automatically to extend the service worker's lifetime.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async makeRequest({\n+      event,\n+      request\n+    }) {\n+      const logs = [];\n+\n+      if (typeof request === 'string') {\n+        request = new Request(request);\n+      }\n+\n+      {\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-strategies',\n+          className: 'CacheFirst',\n+          funcName: 'makeRequest',\n+          paramName: 'request'\n+        });\n+      }\n+\n+      let response = await cacheWrapper_mjs.cacheWrapper.match({\n+        cacheName: this._cacheName,\n+        request,\n+        event,\n+        matchOptions: this._matchOptions,\n+        plugins: this._plugins\n+      });\n+      let error;\n+\n+      if (!response) {\n+        {\n+          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will respond with a network request.`);\n+        }\n+\n+        try {\n+          response = await this._getFromNetwork(request, event);\n+        } catch (err) {\n+          error = err;\n+        }\n+\n+        {\n+          if (response) {\n+            logs.push(`Got response from network.`);\n+          } else {\n+            logs.push(`Unable to get a response from the network.`);\n+          }\n+        }\n+      } else {\n+        {\n+          logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n+        }\n+      }\n+\n+      {\n+        logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n+\n+        for (let log of logs) {\n+          logger_mjs.logger.log(log);\n+        }\n+\n+        messages.printFinalResponse(response);\n+        logger_mjs.logger.groupEnd();\n+      }\n+\n+      if (!response) {\n+        throw new WorkboxError_mjs.WorkboxError('no-response', {\n+          url: request.url,\n+          error\n+        });\n+      }\n+\n+      return response;\n+    }\n+    /**\n+     * Handles the network and cache part of CacheFirst.\n+     *\n+     * @param {Request} request\n+     * @param {FetchEvent} [event]\n+     * @return {Promise<Response>}\n+     *\n+     * @private\n+     */\n+\n+\n+    async _getFromNetwork(request, event) {\n+      const response = await fetchWrapper_mjs.fetchWrapper.fetch({\n+        request,\n+        event,\n+        fetchOptions: this._fetchOptions,\n+        plugins: this._plugins\n+      }); // Keep the service worker while we put the request to the cache\n+\n+      const responseClone = response.clone();\n+      const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({\n+        cacheName: this._cacheName,\n+        request,\n+        response: responseClone,\n+        event,\n+        plugins: this._plugins\n+      });\n+\n+      if (event) {\n+        try {\n+          event.waitUntil(cachePutPromise);\n+        } catch (error) {\n+          {\n+            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n+          }\n+        }\n+      }\n+\n+      return response;\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * An implementation of a\n+   * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n+   * request strategy.\n+   *\n+   * This class is useful if you want to take advantage of any\n+   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n+   *\n+   * If there is no cache match, this will throw a `WorkboxError` exception.\n+   *\n+   * @memberof workbox.strategies\n+   */\n+\n+  class CacheOnly {\n+    /**\n+     * @param {Object} options\n+     * @param {string} options.cacheName Cache name to store and retrieve\n+     * requests. Defaults to cache names provided by\n+     * [workbox-core]{@link workbox.core.cacheNames}.\n+     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n+     * to use in conjunction with this caching strategy.\n+     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n+     */\n+    constructor(options = {}) {\n+      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n+      this._plugins = options.plugins || [];\n+      this._matchOptions = options.matchOptions || null;\n+    }\n+    /**\n+     * This method will perform a request strategy and follows an API that\n+     * will work with the\n+     * [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * @param {Object} options\n+     * @param {Request} options.request The request to run this strategy for.\n+     * @param {Event} [options.event] The event that triggered the request.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async handle({\n+      event,\n+      request\n+    }) {\n+      return this.makeRequest({\n+        event,\n+        request: request || event.request\n+      });\n+    }\n+    /**\n+     * This method can be used to perform a make a standalone request outside the\n+     * context of the [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n+     * for more usage information.\n+     *\n+     * @param {Object} options\n+     * @param {Request|string} options.request Either a\n+     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n+     *     object, or a string URL, corresponding to the request to be made.\n+     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n+     *     be called automatically to extend the service worker's lifetime.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async makeRequest({\n+      event,\n+      request\n+    }) {\n+      if (typeof request === 'string') {\n+        request = new Request(request);\n+      }\n+\n+      {\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-strategies',\n+          className: 'CacheOnly',\n+          funcName: 'makeRequest',\n+          paramName: 'request'\n+        });\n+      }\n+\n+      const response = await cacheWrapper_mjs.cacheWrapper.match({\n+        cacheName: this._cacheName,\n+        request,\n+        event,\n+        matchOptions: this._matchOptions,\n+        plugins: this._plugins\n+      });\n+\n+      {\n+        logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n+\n+        if (response) {\n+          logger_mjs.logger.log(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n+          messages.printFinalResponse(response);\n+        } else {\n+          logger_mjs.logger.log(`No response found in the '${this._cacheName}' cache.`);\n+        }\n+\n+        logger_mjs.logger.groupEnd();\n+      }\n+\n+      if (!response) {\n+        throw new WorkboxError_mjs.WorkboxError('no-response', {\n+          url: request.url\n+        });\n+      }\n+\n+      return response;\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const cacheOkAndOpaquePlugin = {\n+    /**\n+     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n+     * 0 (opaque).\n+     *\n+     * @param {Object} options\n+     * @param {Response} options.response\n+     * @return {Response|null}\n+     *\n+     * @private\n+     */\n+    cacheWillUpdate: ({\n+      response\n+    }) => {\n+      if (response.status === 200 || response.status === 0) {\n+        return response;\n+      }\n+\n+      return null;\n+    }\n+  };\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * An implementation of a\n+   * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n+   * request strategy.\n+   *\n+   * By default, this strategy will cache responses with a 200 status code as\n+   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n+   * Opaque responses are are cross-origin requests where the response doesn't\n+   * support [CORS]{@link https://enable-cors.org/}.\n+   *\n+   * If the network request fails, and there is no cache match, this will throw\n+   * a `WorkboxError` exception.\n+   *\n+   * @memberof workbox.strategies\n+   */\n+\n+  class NetworkFirst {\n+    /**\n+     * @param {Object} options\n+     * @param {string} options.cacheName Cache name to store and retrieve\n+     * requests. Defaults to cache names provided by\n+     * [workbox-core]{@link workbox.core.cacheNames}.\n+     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n+     * to use in conjunction with this caching strategy.\n+     * @param {Object} options.fetchOptions Values passed along to the\n+     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n+     * of all fetch() requests made by this strategy.\n+     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n+     * @param {number} options.networkTimeoutSeconds If set, any network requests\n+     * that fail to respond within the timeout will fallback to the cache.\n+     *\n+     * This option can be used to combat\n+     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n+     * scenarios.\n+     */\n+    constructor(options = {}) {\n+      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n+\n+      if (options.plugins) {\n+        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n+        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n+      } else {\n+        // No plugins passed in, use the default plugin.\n+        this._plugins = [cacheOkAndOpaquePlugin];\n+      }\n+\n+      this._networkTimeoutSeconds = options.networkTimeoutSeconds;\n+\n+      {\n+        if (this._networkTimeoutSeconds) {\n+          assert_mjs.assert.isType(this._networkTimeoutSeconds, 'number', {\n+            moduleName: 'workbox-strategies',\n+            className: 'NetworkFirst',\n+            funcName: 'constructor',\n+            paramName: 'networkTimeoutSeconds'\n+          });\n+        }\n+      }\n+\n+      this._fetchOptions = options.fetchOptions || null;\n+      this._matchOptions = options.matchOptions || null;\n+    }\n+    /**\n+     * This method will perform a request strategy and follows an API that\n+     * will work with the\n+     * [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * @param {Object} options\n+     * @param {Request} options.request The request to run this strategy for.\n+     * @param {Event} [options.event] The event that triggered the request.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async handle({\n+      event,\n+      request\n+    }) {\n+      return this.makeRequest({\n+        event,\n+        request: request || event.request\n+      });\n+    }\n+    /**\n+     * This method can be used to perform a make a standalone request outside the\n+     * context of the [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n+     * for more usage information.\n+     *\n+     * @param {Object} options\n+     * @param {Request|string} options.request Either a\n+     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n+     *     object, or a string URL, corresponding to the request to be made.\n+     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n+     *     be called automatically to extend the service worker's lifetime.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async makeRequest({\n+      event,\n+      request\n+    }) {\n+      const logs = [];\n+\n+      if (typeof request === 'string') {\n+        request = new Request(request);\n+      }\n+\n+      {\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-strategies',\n+          className: 'NetworkFirst',\n+          funcName: 'handle',\n+          paramName: 'makeRequest'\n+        });\n+      }\n+\n+      const promises = [];\n+      let timeoutId;\n+\n+      if (this._networkTimeoutSeconds) {\n+        const {\n+          id,\n+          promise\n+        } = this._getTimeoutPromise({\n+          request,\n+          event,\n+          logs\n+        });\n+\n+        timeoutId = id;\n+        promises.push(promise);\n+      }\n+\n+      const networkPromise = this._getNetworkPromise({\n+        timeoutId,\n+        request,\n+        event,\n+        logs\n+      });\n+\n+      promises.push(networkPromise); // Promise.race() will resolve as soon as the first promise resolves.\n+\n+      let response = await Promise.race(promises); // If Promise.race() resolved with null, it might be due to a network\n+      // timeout + a cache miss. If that were to happen, we'd rather wait until\n+      // the networkPromise resolves instead of returning null.\n+      // Note that it's fine to await an already-resolved promise, so we don't\n+      // have to check to see if it's still \"in flight\".\n+\n+      if (!response) {\n+        response = await networkPromise;\n+      }\n+\n+      {\n+        logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n+\n+        for (let log of logs) {\n+          logger_mjs.logger.log(log);\n+        }\n+\n+        messages.printFinalResponse(response);\n+        logger_mjs.logger.groupEnd();\n+      }\n+\n+      if (!response) {\n+        throw new WorkboxError_mjs.WorkboxError('no-response', {\n+          url: request.url\n+        });\n+      }\n+\n+      return response;\n+    }\n+    /**\n+     * @param {Object} options\n+     * @param {Request} options.request\n+     * @param {Array} options.logs A reference to the logs array\n+     * @param {Event} [options.event]\n+     * @return {Promise<Response>}\n+     *\n+     * @private\n+     */\n+\n+\n+    _getTimeoutPromise({\n+      request,\n+      logs,\n+      event\n+    }) {\n+      let timeoutId;\n+      const timeoutPromise = new Promise(resolve => {\n+        const onNetworkTimeout = async () => {\n+          {\n+            logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);\n+          }\n+\n+          resolve((await this._respondFromCache({\n+            request,\n+            event\n+          })));\n+        };\n+\n+        timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n+      });\n+      return {\n+        promise: timeoutPromise,\n+        id: timeoutId\n+      };\n+    }\n+    /**\n+     * @param {Object} options\n+     * @param {number|undefined} options.timeoutId\n+     * @param {Request} options.request\n+     * @param {Array} options.logs A reference to the logs Array.\n+     * @param {Event} [options.event]\n+     * @return {Promise<Response>}\n+     *\n+     * @private\n+     */\n+\n+\n+    async _getNetworkPromise({\n+      timeoutId,\n+      request,\n+      logs,\n+      event\n+    }) {\n+      let error;\n+      let response;\n+\n+      try {\n+        response = await fetchWrapper_mjs.fetchWrapper.fetch({\n+          request,\n+          event,\n+          fetchOptions: this._fetchOptions,\n+          plugins: this._plugins\n+        });\n+      } catch (err) {\n+        error = err;\n+      }\n+\n+      if (timeoutId) {\n+        clearTimeout(timeoutId);\n+      }\n+\n+      {\n+        if (response) {\n+          logs.push(`Got response from network.`);\n+        } else {\n+          logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);\n+        }\n+      }\n+\n+      if (error || !response) {\n+        response = await this._respondFromCache({\n+          request,\n+          event\n+        });\n+\n+        {\n+          if (response) {\n+            logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n+          } else {\n+            logs.push(`No response found in the '${this._cacheName}' cache.`);\n+          }\n+        }\n+      } else {\n+        // Keep the service worker alive while we put the request in the cache\n+        const responseClone = response.clone();\n+        const cachePut = cacheWrapper_mjs.cacheWrapper.put({\n+          cacheName: this._cacheName,\n+          request,\n+          response: responseClone,\n+          event,\n+          plugins: this._plugins\n+        });\n+\n+        if (event) {\n+          try {\n+            // The event has been responded to so we can keep the SW alive to\n+            // respond to the request\n+            event.waitUntil(cachePut);\n+          } catch (err) {\n+            {\n+              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n+            }\n+          }\n+        }\n+      }\n+\n+      return response;\n+    }\n+    /**\n+     * Used if the network timeouts or fails to make the request.\n+     *\n+     * @param {Object} options\n+     * @param {Request} request The request to match in the cache\n+     * @param {Event} [options.event]\n+     * @return {Promise<Object>}\n+     *\n+     * @private\n+     */\n+\n+\n+    _respondFromCache({\n+      event,\n+      request\n+    }) {\n+      return cacheWrapper_mjs.cacheWrapper.match({\n+        cacheName: this._cacheName,\n+        request,\n+        event,\n+        matchOptions: this._matchOptions,\n+        plugins: this._plugins\n+      });\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * An implementation of a\n+   * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n+   * request strategy.\n+   *\n+   * This class is useful if you want to take advantage of any\n+   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n+   *\n+   * If the network request fails, this will throw a `WorkboxError` exception.\n+   *\n+   * @memberof workbox.strategies\n+   */\n+\n+  class NetworkOnly {\n+    /**\n+     * @param {Object} options\n+     * @param {string} options.cacheName Cache name to store and retrieve\n+     * requests. Defaults to cache names provided by\n+     * [workbox-core]{@link workbox.core.cacheNames}.\n+     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n+     * to use in conjunction with this caching strategy.\n+     * @param {Object} options.fetchOptions Values passed along to the\n+     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n+     * of all fetch() requests made by this strategy.\n+     */\n+    constructor(options = {}) {\n+      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n+      this._plugins = options.plugins || [];\n+      this._fetchOptions = options.fetchOptions || null;\n+    }\n+    /**\n+     * This method will perform a request strategy and follows an API that\n+     * will work with the\n+     * [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * @param {Object} options\n+     * @param {Request} options.request The request to run this strategy for.\n+     * @param {Event} [options.event] The event that triggered the request.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async handle({\n+      event,\n+      request\n+    }) {\n+      return this.makeRequest({\n+        event,\n+        request: request || event.request\n+      });\n+    }\n+    /**\n+     * This method can be used to perform a make a standalone request outside the\n+     * context of the [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n+     * for more usage information.\n+     *\n+     * @param {Object} options\n+     * @param {Request|string} options.request Either a\n+     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n+     *     object, or a string URL, corresponding to the request to be made.\n+     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n+     *     be called automatically to extend the service worker's lifetime.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async makeRequest({\n+      event,\n+      request\n+    }) {\n+      if (typeof request === 'string') {\n+        request = new Request(request);\n+      }\n+\n+      {\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-strategies',\n+          className: 'NetworkOnly',\n+          funcName: 'handle',\n+          paramName: 'request'\n+        });\n+      }\n+\n+      let error;\n+      let response;\n+\n+      try {\n+        response = await fetchWrapper_mjs.fetchWrapper.fetch({\n+          request,\n+          event,\n+          fetchOptions: this._fetchOptions,\n+          plugins: this._plugins\n+        });\n+      } catch (err) {\n+        error = err;\n+      }\n+\n+      {\n+        logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n+\n+        if (response) {\n+          logger_mjs.logger.log(`Got response from network.`);\n+        } else {\n+          logger_mjs.logger.log(`Unable to get a response from the network.`);\n+        }\n+\n+        messages.printFinalResponse(response);\n+        logger_mjs.logger.groupEnd();\n+      }\n+\n+      if (!response) {\n+        throw new WorkboxError_mjs.WorkboxError('no-response', {\n+          url: request.url,\n+          error\n+        });\n+      }\n+\n+      return response;\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  /**\n+   * An implementation of a\n+   * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n+   * request strategy.\n+   *\n+   * Resources are requested from both the cache and the network in parallel.\n+   * The strategy will respond with the cached version if available, otherwise\n+   * wait for the network response. The cache is updated with the network response\n+   * with each successful request.\n+   *\n+   * By default, this strategy will cache responses with a 200 status code as\n+   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n+   * Opaque responses are are cross-origin requests where the response doesn't\n+   * support [CORS]{@link https://enable-cors.org/}.\n+   *\n+   * If the network request fails, and there is no cache match, this will throw\n+   * a `WorkboxError` exception.\n+   *\n+   * @memberof workbox.strategies\n+   */\n+\n+  class StaleWhileRevalidate {\n+    /**\n+     * @param {Object} options\n+     * @param {string} options.cacheName Cache name to store and retrieve\n+     * requests. Defaults to cache names provided by\n+     * [workbox-core]{@link workbox.core.cacheNames}.\n+     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n+     * to use in conjunction with this caching strategy.\n+     * @param {Object} options.fetchOptions Values passed along to the\n+     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n+     * of all fetch() requests made by this strategy.\n+     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n+     */\n+    constructor(options = {}) {\n+      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n+      this._plugins = options.plugins || [];\n+\n+      if (options.plugins) {\n+        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n+        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n+      } else {\n+        // No plugins passed in, use the default plugin.\n+        this._plugins = [cacheOkAndOpaquePlugin];\n+      }\n+\n+      this._fetchOptions = options.fetchOptions || null;\n+      this._matchOptions = options.matchOptions || null;\n+    }\n+    /**\n+     * This method will perform a request strategy and follows an API that\n+     * will work with the\n+     * [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * @param {Object} options\n+     * @param {Request} options.request The request to run this strategy for.\n+     * @param {Event} [options.event] The event that triggered the request.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async handle({\n+      event,\n+      request\n+    }) {\n+      return this.makeRequest({\n+        event,\n+        request: request || event.request\n+      });\n+    }\n+    /**\n+     * This method can be used to perform a make a standalone request outside the\n+     * context of the [Workbox Router]{@link workbox.routing.Router}.\n+     *\n+     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n+     * for more usage information.\n+     *\n+     * @param {Object} options\n+     * @param {Request|string} options.request Either a\n+     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n+     *     object, or a string URL, corresponding to the request to be made.\n+     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n+     *     be called automatically to extend the service worker's lifetime.\n+     * @return {Promise<Response>}\n+     */\n+\n+\n+    async makeRequest({\n+      event,\n+      request\n+    }) {\n+      const logs = [];\n+\n+      if (typeof request === 'string') {\n+        request = new Request(request);\n+      }\n+\n+      {\n+        assert_mjs.assert.isInstance(request, Request, {\n+          moduleName: 'workbox-strategies',\n+          className: 'StaleWhileRevalidate',\n+          funcName: 'handle',\n+          paramName: 'request'\n+        });\n+      }\n+\n+      const fetchAndCachePromise = this._getFromNetwork({\n+        request,\n+        event\n+      });\n+\n+      let response = await cacheWrapper_mjs.cacheWrapper.match({\n+        cacheName: this._cacheName,\n+        request,\n+        event,\n+        matchOptions: this._matchOptions,\n+        plugins: this._plugins\n+      });\n+      let error;\n+\n+      if (response) {\n+        {\n+          logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache. Will update with the network response in the background.`);\n+        }\n+\n+        if (event) {\n+          try {\n+            event.waitUntil(fetchAndCachePromise);\n+          } catch (error) {\n+            {\n+              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n+            }\n+          }\n+        }\n+      } else {\n+        {\n+          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will wait for the network response.`);\n+        }\n+\n+        try {\n+          response = await fetchAndCachePromise;\n+        } catch (err) {\n+          error = err;\n+        }\n+      }\n+\n+      {\n+        logger_mjs.logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n+\n+        for (let log of logs) {\n+          logger_mjs.logger.log(log);\n+        }\n+\n+        messages.printFinalResponse(response);\n+        logger_mjs.logger.groupEnd();\n+      }\n+\n+      if (!response) {\n+        throw new WorkboxError_mjs.WorkboxError('no-response', {\n+          url: request.url,\n+          error\n+        });\n+      }\n+\n+      return response;\n+    }\n+    /**\n+     * @param {Object} options\n+     * @param {Request} options.request\n+     * @param {Event} [options.event]\n+     * @return {Promise<Response>}\n+     *\n+     * @private\n+     */\n+\n+\n+    async _getFromNetwork({\n+      request,\n+      event\n+    }) {\n+      const response = await fetchWrapper_mjs.fetchWrapper.fetch({\n+        request,\n+        event,\n+        fetchOptions: this._fetchOptions,\n+        plugins: this._plugins\n+      });\n+      const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({\n+        cacheName: this._cacheName,\n+        request,\n+        response: response.clone(),\n+        event,\n+        plugins: this._plugins\n+      });\n+\n+      if (event) {\n+        try {\n+          event.waitUntil(cachePutPromise);\n+        } catch (error) {\n+          {\n+            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(request.url)}'.`);\n+          }\n+        }\n+      }\n+\n+      return response;\n+    }\n+\n+  }\n+\n+  /*\n+    Copyright 2018 Google LLC\n+\n+    Use of this source code is governed by an MIT-style\n+    license that can be found in the LICENSE file or at\n+    https://opensource.org/licenses/MIT.\n+  */\n+  const mapping = {\n+    cacheFirst: CacheFirst,\n+    cacheOnly: CacheOnly,\n+    networkFirst: NetworkFirst,\n+    networkOnly: NetworkOnly,\n+    staleWhileRevalidate: StaleWhileRevalidate\n+  };\n+\n+  const deprecate = strategy => {\n+    const StrategyCtr = mapping[strategy];\n+    return options => {\n+      {\n+        const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\n+        logger_mjs.logger.warn(`The 'workbox.strategies.${strategy}()' function has been ` + `deprecated and will be removed in a future version of Workbox.\\n` + `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\n+      }\n+\n+      return new StrategyCtr(options);\n+    };\n+  };\n+  /**\n+   * @function workbox.strategies.cacheFirst\n+   * @param {Object} options See the {@link workbox.strategies.CacheFirst}\n+   * constructor for more info.\n+   * @deprecated since v4.0.0\n+   */\n+\n+\n+  const cacheFirst = deprecate('cacheFirst');\n+  /**\n+   * @function workbox.strategies.cacheOnly\n+   * @param {Object} options See the {@link workbox.strategies.CacheOnly}\n+   * constructor for more info.\n+   * @deprecated since v4.0.0\n+   */\n+\n+  const cacheOnly = deprecate('cacheOnly');\n+  /**\n+   * @function workbox.strategies.networkFirst\n+   * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\n+   * constructor for more info.\n+   * @deprecated since v4.0.0\n+   */\n+\n+  const networkFirst = deprecate('networkFirst');\n+  /**\n+   * @function workbox.strategies.networkOnly\n+   * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\n+   * constructor for more info.\n+   * @deprecated since v4.0.0\n+   */\n+\n+  const networkOnly = deprecate('networkOnly');\n+  /**\n+   * @function workbox.strategies.staleWhileRevalidate\n+   * @param {Object} options See the\n+   * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\n+   * @deprecated since v4.0.0\n+   */\n+\n+  const staleWhileRevalidate = deprecate('staleWhileRevalidate');\n+\n+  exports.CacheFirst = CacheFirst;\n+  exports.CacheOnly = CacheOnly;\n+  exports.NetworkFirst = NetworkFirst;\n+  exports.NetworkOnly = NetworkOnly;\n+  exports.StaleWhileRevalidate = StaleWhileRevalidate;\n+  exports.cacheFirst = cacheFirst;\n+  exports.cacheOnly = cacheOnly;\n+  exports.networkFirst = networkFirst;\n+  exports.networkOnly = networkOnly;\n+  exports.staleWhileRevalidate = staleWhileRevalidate;\n+\n+  return exports;\n+\n+}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private));\n+//# sourceMappingURL=workbox-strategies.dev.js.map"
    },
    {
      "sha": "12df5e64982d5be64528a20e0b6b2da2356ee59e",
      "filename": "public/javascripts/workbox/workbox-strategies.dev.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.dev.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.dev.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-strategies.dev.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-strategies.dev.js\",\"sources\":[\"../_version.mjs\",\"../utils/messages.mjs\",\"../CacheFirst.mjs\",\"../CacheOnly.mjs\",\"../plugins/cacheOkAndOpaquePlugin.mjs\",\"../NetworkFirst.mjs\",\"../NetworkOnly.mjs\",\"../StaleWhileRevalidate.mjs\",\"../index.mjs\"],\"sourcesContent\":[\"try{self['workbox:strategies:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport '../_version.mjs';\\n\\nconst getFriendlyURL = (url) => {\\n  const urlObj = new URL(url, location);\\n  if (urlObj.origin === location.origin) {\\n    return urlObj.pathname;\\n  }\\n  return urlObj.href;\\n};\\n\\nexport const messages = {\\n  strategyStart: (strategyName, request) => `Using ${strategyName} to ` +\\n    `respond to '${getFriendlyURL(request.url)}'`,\\n  printFinalResponse: (response) => {\\n    if (response) {\\n      logger.groupCollapsed(`View the final response here.`);\\n      logger.log(response);\\n      logger.groupEnd();\\n    }\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\\n * request strategy.\\n *\\n * A cache first strategy is useful for assets that have been revisioned,\\n * such as URLs like `/styles/example.a8f5f1.css`, since they\\n * can be cached for long periods of time.\\n *\\n * If the network request fails, and there is no cache match, this will throw\\n * a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass CacheFirst {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n    this._fetchOptions = options.fetchOptions || null;\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n         be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    const logs = [];\\n\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'CacheFirst',\\n        funcName: 'makeRequest',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    let response = await cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    let error;\\n    if (!response) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(\\n            `No response found in the '${this._cacheName}' cache. ` +\\n          `Will respond with a network request.`);\\n      }\\n      try {\\n        response = await this._getFromNetwork(request, event);\\n      } catch (err) {\\n        error = err;\\n      }\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (response) {\\n          logs.push(`Got response from network.`);\\n        } else {\\n          logs.push(`Unable to get a response from the network.`);\\n        }\\n      }\\n    } else {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(\\n            `Found a cached response in the '${this._cacheName}' cache.`);\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('CacheFirst', request));\\n      for (let log of logs) {\\n        logger.log(log);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url, error});\\n    }\\n    return response;\\n  }\\n\\n  /**\\n   * Handles the network and cache part of CacheFirst.\\n   *\\n   * @param {Request} request\\n   * @param {FetchEvent} [event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  async _getFromNetwork(request, event) {\\n    const response = await fetchWrapper.fetch({\\n      request,\\n      event,\\n      fetchOptions: this._fetchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    // Keep the service worker while we put the request to the cache\\n    const responseClone = response.clone();\\n    const cachePutPromise = cacheWrapper.put({\\n      cacheName: this._cacheName,\\n      request,\\n      response: responseClone,\\n      event,\\n      plugins: this._plugins,\\n    });\\n\\n    if (event) {\\n      try {\\n        event.waitUntil(cachePutPromise);\\n      } catch (error) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.warn(`Unable to ensure service worker stays alive when ` +\\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n\\nexport {CacheFirst};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * An implementation of a\\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\\n * request strategy.\\n *\\n * This class is useful if you want to take advantage of any\\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\\n *\\n * If there is no cache match, this will throw a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass CacheOnly {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'CacheOnly',\\n        funcName: 'makeRequest',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    const response = await cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('CacheOnly', request));\\n      if (response) {\\n        logger.log(`Found a cached response in the '${this._cacheName}'` +\\n          ` cache.`);\\n        messages.printFinalResponse(response);\\n      } else {\\n        logger.log(`No response found in the '${this._cacheName}' cache.`);\\n      }\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url});\\n    }\\n    return response;\\n  }\\n}\\n\\nexport {CacheOnly};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\nexport const cacheOkAndOpaquePlugin = {\\n  /**\\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\\n   * 0 (opaque).\\n   *\\n   * @param {Object} options\\n   * @param {Response} options.response\\n   * @return {Response|null}\\n   *\\n   * @private\\n   */\\n  cacheWillUpdate: ({response}) => {\\n    if (response.status === 200 || response.status === 0) {\\n      return response;\\n    }\\n    return null;\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a\\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\\n * request strategy.\\n *\\n * By default, this strategy will cache responses with a 200 status code as\\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\\n * Opaque responses are are cross-origin requests where the response doesn't\\n * support [CORS]{@link https://enable-cors.org/}.\\n *\\n * If the network request fails, and there is no cache match, this will throw\\n * a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass NetworkFirst {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   * @param {number} options.networkTimeoutSeconds If set, any network requests\\n   * that fail to respond within the timeout will fallback to the cache.\\n   *\\n   * This option can be used to combat\\n   * \\\"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\\\"\\n   * scenarios.\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n\\n    if (options.plugins) {\\n      let isUsingCacheWillUpdate =\\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\\n      this._plugins = isUsingCacheWillUpdate ?\\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\\n    } else {\\n      // No plugins passed in, use the default plugin.\\n      this._plugins = [cacheOkAndOpaquePlugin];\\n    }\\n\\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds;\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (this._networkTimeoutSeconds) {\\n        assert.isType(this._networkTimeoutSeconds, 'number', {\\n          moduleName: 'workbox-strategies',\\n          className: 'NetworkFirst',\\n          funcName: 'constructor',\\n          paramName: 'networkTimeoutSeconds',\\n        });\\n      }\\n    }\\n\\n    this._fetchOptions = options.fetchOptions || null;\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    const logs = [];\\n\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'NetworkFirst',\\n        funcName: 'handle',\\n        paramName: 'makeRequest',\\n      });\\n    }\\n\\n    const promises = [];\\n    let timeoutId;\\n\\n    if (this._networkTimeoutSeconds) {\\n      const {id, promise} = this._getTimeoutPromise({request, event, logs});\\n      timeoutId = id;\\n      promises.push(promise);\\n    }\\n\\n    const networkPromise =\\n        this._getNetworkPromise({timeoutId, request, event, logs});\\n    promises.push(networkPromise);\\n\\n    // Promise.race() will resolve as soon as the first promise resolves.\\n    let response = await Promise.race(promises);\\n    // If Promise.race() resolved with null, it might be due to a network\\n    // timeout + a cache miss. If that were to happen, we'd rather wait until\\n    // the networkPromise resolves instead of returning null.\\n    // Note that it's fine to await an already-resolved promise, so we don't\\n    // have to check to see if it's still \\\"in flight\\\".\\n    if (!response) {\\n      response = await networkPromise;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('NetworkFirst', request));\\n      for (let log of logs) {\\n        logger.log(log);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url});\\n    }\\n    return response;\\n  }\\n\\n  /**\\n   * @param {Object} options\\n   * @param {Request} options.request\\n   * @param {Array} options.logs A reference to the logs array\\n   * @param {Event} [options.event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  _getTimeoutPromise({request, logs, event}) {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((resolve) => {\\n      const onNetworkTimeout = async () => {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logs.push(`Timing out the network response at ` +\\n            `${this._networkTimeoutSeconds} seconds.`);\\n        }\\n\\n        resolve(await this._respondFromCache({request, event}));\\n      };\\n\\n      timeoutId = setTimeout(\\n          onNetworkTimeout,\\n          this._networkTimeoutSeconds * 1000,\\n      );\\n    });\\n\\n    return {\\n      promise: timeoutPromise,\\n      id: timeoutId,\\n    };\\n  }\\n\\n  /**\\n   * @param {Object} options\\n   * @param {number|undefined} options.timeoutId\\n   * @param {Request} options.request\\n   * @param {Array} options.logs A reference to the logs Array.\\n   * @param {Event} [options.event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  async _getNetworkPromise({timeoutId, request, logs, event}) {\\n    let error;\\n    let response;\\n    try {\\n      response = await fetchWrapper.fetch({\\n        request,\\n        event,\\n        fetchOptions: this._fetchOptions,\\n        plugins: this._plugins,\\n      });\\n    } catch (err) {\\n      error = err;\\n    }\\n\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (response) {\\n        logs.push(`Got response from network.`);\\n      } else {\\n        logs.push(`Unable to get a response from the network. Will respond ` +\\n          `with a cached response.`);\\n      }\\n    }\\n\\n    if (error || !response) {\\n      response = await this._respondFromCache({request, event});\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (response) {\\n          logs.push(`Found a cached response in the '${this._cacheName}'` +\\n            ` cache.`);\\n        } else {\\n          logs.push(`No response found in the '${this._cacheName}' cache.`);\\n        }\\n      }\\n    } else {\\n      // Keep the service worker alive while we put the request in the cache\\n      const responseClone = response.clone();\\n      const cachePut = cacheWrapper.put({\\n        cacheName: this._cacheName,\\n        request,\\n        response: responseClone,\\n        event,\\n        plugins: this._plugins,\\n      });\\n\\n      if (event) {\\n        try {\\n          // The event has been responded to so we can keep the SW alive to\\n          // respond to the request\\n          event.waitUntil(cachePut);\\n        } catch (err) {\\n          if (process.env.NODE_ENV !== 'production') {\\n            logger.warn(`Unable to ensure service worker stays alive when ` +\\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\\n          }\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n\\n  /**\\n   * Used if the network timeouts or fails to make the request.\\n   *\\n   * @param {Object} options\\n   * @param {Request} request The request to match in the cache\\n   * @param {Event} [options.event]\\n   * @return {Promise<Object>}\\n   *\\n   * @private\\n   */\\n  _respondFromCache({event, request}) {\\n    return cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n  }\\n}\\n\\nexport {NetworkFirst};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a\\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\\n * request strategy.\\n *\\n * This class is useful if you want to take advantage of any\\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\\n *\\n * If the network request fails, this will throw a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass NetworkOnly {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n    this._fetchOptions = options.fetchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'NetworkOnly',\\n        funcName: 'handle',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    let error;\\n    let response;\\n    try {\\n      response = await fetchWrapper.fetch({\\n        request,\\n        event,\\n        fetchOptions: this._fetchOptions,\\n        plugins: this._plugins,\\n      });\\n    } catch (err) {\\n      error = err;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('NetworkOnly', request));\\n      if (response) {\\n        logger.log(`Got response from network.`);\\n      } else {\\n        logger.log(`Unable to get a response from the network.`);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url, error});\\n    }\\n    return response;\\n  }\\n}\\n\\nexport {NetworkOnly};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a\\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\\n * request strategy.\\n *\\n * Resources are requested from both the cache and the network in parallel.\\n * The strategy will respond with the cached version if available, otherwise\\n * wait for the network response. The cache is updated with the network response\\n * with each successful request.\\n *\\n * By default, this strategy will cache responses with a 200 status code as\\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\\n * Opaque responses are are cross-origin requests where the response doesn't\\n * support [CORS]{@link https://enable-cors.org/}.\\n *\\n * If the network request fails, and there is no cache match, this will throw\\n * a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass StaleWhileRevalidate {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n\\n    if (options.plugins) {\\n      let isUsingCacheWillUpdate =\\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\\n      this._plugins = isUsingCacheWillUpdate ?\\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\\n    } else {\\n      // No plugins passed in, use the default plugin.\\n      this._plugins = [cacheOkAndOpaquePlugin];\\n    }\\n\\n    this._fetchOptions = options.fetchOptions || null;\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    const logs = [];\\n\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'StaleWhileRevalidate',\\n        funcName: 'handle',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\\n\\n    let response = await cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n    let error;\\n    if (response) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\\n          ` cache. Will update with the network response in the background.`);\\n      }\\n\\n      if (event) {\\n        try {\\n          event.waitUntil(fetchAndCachePromise);\\n        } catch (error) {\\n          if (process.env.NODE_ENV !== 'production') {\\n            logger.warn(`Unable to ensure service worker stays alive when ` +\\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\\n          }\\n        }\\n      }\\n    } else {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\\n          `Will wait for the network response.`);\\n      }\\n      try {\\n        response = await fetchAndCachePromise;\\n      } catch (err) {\\n        error = err;\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('StaleWhileRevalidate', request));\\n      for (let log of logs) {\\n        logger.log(log);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url, error});\\n    }\\n    return response;\\n  }\\n\\n  /**\\n   * @param {Object} options\\n   * @param {Request} options.request\\n   * @param {Event} [options.event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  async _getFromNetwork({request, event}) {\\n    const response = await fetchWrapper.fetch({\\n      request,\\n      event,\\n      fetchOptions: this._fetchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    const cachePutPromise = cacheWrapper.put({\\n      cacheName: this._cacheName,\\n      request,\\n      response: response.clone(),\\n      event,\\n      plugins: this._plugins,\\n    });\\n\\n    if (event) {\\n      try {\\n        event.waitUntil(cachePutPromise);\\n      } catch (error) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.warn(`Unable to ensure service worker stays alive when ` +\\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n\\nexport {StaleWhileRevalidate};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {CacheFirst} from './CacheFirst.mjs';\\nimport {CacheOnly} from './CacheOnly.mjs';\\nimport {NetworkFirst} from './NetworkFirst.mjs';\\nimport {NetworkOnly} from './NetworkOnly.mjs';\\nimport {StaleWhileRevalidate} from './StaleWhileRevalidate.mjs';\\nimport './_version.mjs';\\n\\n\\nconst mapping = {\\n  cacheFirst: CacheFirst,\\n  cacheOnly: CacheOnly,\\n  networkFirst: NetworkFirst,\\n  networkOnly: NetworkOnly,\\n  staleWhileRevalidate: StaleWhileRevalidate,\\n};\\n\\nconst deprecate = (strategy) => {\\n  const StrategyCtr = mapping[strategy];\\n\\n  return (options) => {\\n    if (process.env.NODE_ENV !== 'production') {\\n      const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\\n      logger.warn(`The 'workbox.strategies.${strategy}()' function has been ` +\\n          `deprecated and will be removed in a future version of Workbox.\\\\n` +\\n          `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\\n    }\\n    return new StrategyCtr(options);\\n  };\\n};\\n\\n/**\\n * @function workbox.strategies.cacheFirst\\n * @param {Object} options See the {@link workbox.strategies.CacheFirst}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst cacheFirst = deprecate('cacheFirst');\\n\\n/**\\n * @function workbox.strategies.cacheOnly\\n * @param {Object} options See the {@link workbox.strategies.CacheOnly}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst cacheOnly = deprecate('cacheOnly');\\n\\n/**\\n * @function workbox.strategies.networkFirst\\n * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst networkFirst = deprecate('networkFirst');\\n\\n/**\\n * @function workbox.strategies.networkOnly\\n * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst networkOnly = deprecate('networkOnly');\\n\\n/**\\n * @function workbox.strategies.staleWhileRevalidate\\n * @param {Object} options See the\\n * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst staleWhileRevalidate = deprecate('staleWhileRevalidate');\\n\\n/**\\n * There are common caching strategies that most service workers will need\\n * and use. This module provides simple implementations of these strategies.\\n *\\n * @namespace workbox.strategies\\n */\\n\\nexport {\\n  CacheFirst,\\n  CacheOnly,\\n  NetworkFirst,\\n  NetworkOnly,\\n  StaleWhileRevalidate,\\n\\n  // Deprecated...\\n  cacheFirst,\\n  cacheOnly,\\n  networkFirst,\\n  networkOnly,\\n  staleWhileRevalidate,\\n};\\n\\n\"],\"names\":[\"self\",\"_\",\"e\",\"getFriendlyURL\",\"url\",\"urlObj\",\"URL\",\"location\",\"origin\",\"pathname\",\"href\",\"messages\",\"strategyStart\",\"strategyName\",\"request\",\"printFinalResponse\",\"response\",\"logger\",\"groupCollapsed\",\"log\",\"groupEnd\",\"CacheFirst\",\"constructor\",\"options\",\"_cacheName\",\"cacheNames\",\"getRuntimeName\",\"cacheName\",\"_plugins\",\"plugins\",\"_fetchOptions\",\"fetchOptions\",\"_matchOptions\",\"matchOptions\",\"handle\",\"event\",\"makeRequest\",\"logs\",\"Request\",\"assert\",\"isInstance\",\"moduleName\",\"className\",\"funcName\",\"paramName\",\"cacheWrapper\",\"match\",\"error\",\"push\",\"_getFromNetwork\",\"err\",\"WorkboxError\",\"fetchWrapper\",\"fetch\",\"responseClone\",\"clone\",\"cachePutPromise\",\"put\",\"waitUntil\",\"warn\",\"CacheOnly\",\"cacheOkAndOpaquePlugin\",\"cacheWillUpdate\",\"status\",\"NetworkFirst\",\"isUsingCacheWillUpdate\",\"some\",\"plugin\",\"_networkTimeoutSeconds\",\"networkTimeoutSeconds\",\"isType\",\"promises\",\"timeoutId\",\"id\",\"promise\",\"_getTimeoutPromise\",\"networkPromise\",\"_getNetworkPromise\",\"Promise\",\"race\",\"timeoutPromise\",\"resolve\",\"onNetworkTimeout\",\"_respondFromCache\",\"setTimeout\",\"clearTimeout\",\"cachePut\",\"NetworkOnly\",\"StaleWhileRevalidate\",\"fetchAndCachePromise\",\"mapping\",\"cacheFirst\",\"cacheOnly\",\"networkFirst\",\"networkOnly\",\"staleWhileRevalidate\",\"deprecate\",\"strategy\",\"StrategyCtr\",\"strategyCtrName\",\"toUpperCase\",\"slice\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
    },
    {
      "sha": "29909af3024744cd575bb8d2b2a993e88cba1783",
      "filename": "public/javascripts/workbox/workbox-strategies.prod.js",
      "status": "added",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.prod.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.prod.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-strategies.prod.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,2 @@\n+this.workbox=this.workbox||{},this.workbox.strategies=function(e,t,s,n,r){\"use strict\";try{self[\"workbox:strategies:4.3.1\"]&&_()}catch(e){}class i{constructor(e={}){this.t=t.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.i=e.fetchOptions||null,this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){\"string\"==typeof t&&(t=new Request(t));let n,i=await s.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(!i)try{i=await this.u(t,e)}catch(e){n=e}if(!i)throw new r.WorkboxError(\"no-response\",{url:t.url,error:n});return i}async u(e,t){const r=await n.fetchWrapper.fetch({request:e,event:t,fetchOptions:this.i,plugins:this.s}),i=r.clone(),h=s.cacheWrapper.put({cacheName:this.t,request:e,response:i,event:t,plugins:this.s});if(t)try{t.waitUntil(h)}catch(e){}return r}}class h{constructor(e={}){this.t=t.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){\"string\"==typeof t&&(t=new Request(t));const n=await s.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(!n)throw new r.WorkboxError(\"no-response\",{url:t.url});return n}}const u={cacheWillUpdate:({response:e})=>200===e.status||0===e.status?e:null};class a{constructor(e={}){if(this.t=t.cacheNames.getRuntimeName(e.cacheName),e.plugins){let t=e.plugins.some(e=>!!e.cacheWillUpdate);this.s=t?e.plugins:[u,...e.plugins]}else this.s=[u];this.o=e.networkTimeoutSeconds,this.i=e.fetchOptions||null,this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){const s=[];\"string\"==typeof t&&(t=new Request(t));const n=[];let i;if(this.o){const{id:r,promise:h}=this.l({request:t,event:e,logs:s});i=r,n.push(h)}const h=this.q({timeoutId:i,request:t,event:e,logs:s});n.push(h);let u=await Promise.race(n);if(u||(u=await h),!u)throw new r.WorkboxError(\"no-response\",{url:t.url});return u}l({request:e,logs:t,event:s}){let n;return{promise:new Promise(t=>{n=setTimeout(async()=>{t(await this.p({request:e,event:s}))},1e3*this.o)}),id:n}}async q({timeoutId:e,request:t,logs:r,event:i}){let h,u;try{u=await n.fetchWrapper.fetch({request:t,event:i,fetchOptions:this.i,plugins:this.s})}catch(e){h=e}if(e&&clearTimeout(e),h||!u)u=await this.p({request:t,event:i});else{const e=u.clone(),n=s.cacheWrapper.put({cacheName:this.t,request:t,response:e,event:i,plugins:this.s});if(i)try{i.waitUntil(n)}catch(e){}}return u}p({event:e,request:t}){return s.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s})}}class c{constructor(e={}){this.t=t.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.i=e.fetchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){let s,i;\"string\"==typeof t&&(t=new Request(t));try{i=await n.fetchWrapper.fetch({request:t,event:e,fetchOptions:this.i,plugins:this.s})}catch(e){s=e}if(!i)throw new r.WorkboxError(\"no-response\",{url:t.url,error:s});return i}}class o{constructor(e={}){if(this.t=t.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],e.plugins){let t=e.plugins.some(e=>!!e.cacheWillUpdate);this.s=t?e.plugins:[u,...e.plugins]}else this.s=[u];this.i=e.fetchOptions||null,this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){\"string\"==typeof t&&(t=new Request(t));const n=this.u({request:t,event:e});let i,h=await s.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(h){if(e)try{e.waitUntil(n)}catch(i){}}else try{h=await n}catch(e){i=e}if(!h)throw new r.WorkboxError(\"no-response\",{url:t.url,error:i});return h}async u({request:e,event:t}){const r=await n.fetchWrapper.fetch({request:e,event:t,fetchOptions:this.i,plugins:this.s}),i=s.cacheWrapper.put({cacheName:this.t,request:e,response:r.clone(),event:t,plugins:this.s});if(t)try{t.waitUntil(i)}catch(e){}return r}}const l={cacheFirst:i,cacheOnly:h,networkFirst:a,networkOnly:c,staleWhileRevalidate:o},q=e=>{const t=l[e];return e=>new t(e)},w=q(\"cacheFirst\"),p=q(\"cacheOnly\"),v=q(\"networkFirst\"),y=q(\"networkOnly\"),m=q(\"staleWhileRevalidate\");return e.CacheFirst=i,e.CacheOnly=h,e.NetworkFirst=a,e.NetworkOnly=c,e.StaleWhileRevalidate=o,e.cacheFirst=w,e.cacheOnly=p,e.networkFirst=v,e.networkOnly=y,e.staleWhileRevalidate=m,e}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);\n+//# sourceMappingURL=workbox-strategies.prod.js.map"
    },
    {
      "sha": "6ad0b3e3776fcbdc5cb962a9c7fdee14e704dbb0",
      "filename": "public/javascripts/workbox/workbox-strategies.prod.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.prod.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-strategies.prod.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-strategies.prod.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-strategies.prod.js\",\"sources\":[\"../_version.mjs\",\"../CacheFirst.mjs\",\"../CacheOnly.mjs\",\"../plugins/cacheOkAndOpaquePlugin.mjs\",\"../NetworkFirst.mjs\",\"../NetworkOnly.mjs\",\"../StaleWhileRevalidate.mjs\",\"../index.mjs\"],\"sourcesContent\":[\"try{self['workbox:strategies:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\\n * request strategy.\\n *\\n * A cache first strategy is useful for assets that have been revisioned,\\n * such as URLs like `/styles/example.a8f5f1.css`, since they\\n * can be cached for long periods of time.\\n *\\n * If the network request fails, and there is no cache match, this will throw\\n * a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass CacheFirst {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n    this._fetchOptions = options.fetchOptions || null;\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n         be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    const logs = [];\\n\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'CacheFirst',\\n        funcName: 'makeRequest',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    let response = await cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    let error;\\n    if (!response) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(\\n            `No response found in the '${this._cacheName}' cache. ` +\\n          `Will respond with a network request.`);\\n      }\\n      try {\\n        response = await this._getFromNetwork(request, event);\\n      } catch (err) {\\n        error = err;\\n      }\\n\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (response) {\\n          logs.push(`Got response from network.`);\\n        } else {\\n          logs.push(`Unable to get a response from the network.`);\\n        }\\n      }\\n    } else {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(\\n            `Found a cached response in the '${this._cacheName}' cache.`);\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('CacheFirst', request));\\n      for (let log of logs) {\\n        logger.log(log);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url, error});\\n    }\\n    return response;\\n  }\\n\\n  /**\\n   * Handles the network and cache part of CacheFirst.\\n   *\\n   * @param {Request} request\\n   * @param {FetchEvent} [event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  async _getFromNetwork(request, event) {\\n    const response = await fetchWrapper.fetch({\\n      request,\\n      event,\\n      fetchOptions: this._fetchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    // Keep the service worker while we put the request to the cache\\n    const responseClone = response.clone();\\n    const cachePutPromise = cacheWrapper.put({\\n      cacheName: this._cacheName,\\n      request,\\n      response: responseClone,\\n      event,\\n      plugins: this._plugins,\\n    });\\n\\n    if (event) {\\n      try {\\n        event.waitUntil(cachePutPromise);\\n      } catch (error) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.warn(`Unable to ensure service worker stays alive when ` +\\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n\\nexport {CacheFirst};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport './_version.mjs';\\n\\n\\n/**\\n * An implementation of a\\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\\n * request strategy.\\n *\\n * This class is useful if you want to take advantage of any\\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\\n *\\n * If there is no cache match, this will throw a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass CacheOnly {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'CacheOnly',\\n        funcName: 'makeRequest',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    const response = await cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('CacheOnly', request));\\n      if (response) {\\n        logger.log(`Found a cached response in the '${this._cacheName}'` +\\n          ` cache.`);\\n        messages.printFinalResponse(response);\\n      } else {\\n        logger.log(`No response found in the '${this._cacheName}' cache.`);\\n      }\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url});\\n    }\\n    return response;\\n  }\\n}\\n\\nexport {CacheOnly};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\nexport const cacheOkAndOpaquePlugin = {\\n  /**\\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\\n   * 0 (opaque).\\n   *\\n   * @param {Object} options\\n   * @param {Response} options.response\\n   * @return {Response|null}\\n   *\\n   * @private\\n   */\\n  cacheWillUpdate: ({response}) => {\\n    if (response.status === 200 || response.status === 0) {\\n      return response;\\n    }\\n    return null;\\n  },\\n};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a\\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\\n * request strategy.\\n *\\n * By default, this strategy will cache responses with a 200 status code as\\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\\n * Opaque responses are are cross-origin requests where the response doesn't\\n * support [CORS]{@link https://enable-cors.org/}.\\n *\\n * If the network request fails, and there is no cache match, this will throw\\n * a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass NetworkFirst {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   * @param {number} options.networkTimeoutSeconds If set, any network requests\\n   * that fail to respond within the timeout will fallback to the cache.\\n   *\\n   * This option can be used to combat\\n   * \\\"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\\\"\\n   * scenarios.\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n\\n    if (options.plugins) {\\n      let isUsingCacheWillUpdate =\\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\\n      this._plugins = isUsingCacheWillUpdate ?\\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\\n    } else {\\n      // No plugins passed in, use the default plugin.\\n      this._plugins = [cacheOkAndOpaquePlugin];\\n    }\\n\\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds;\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (this._networkTimeoutSeconds) {\\n        assert.isType(this._networkTimeoutSeconds, 'number', {\\n          moduleName: 'workbox-strategies',\\n          className: 'NetworkFirst',\\n          funcName: 'constructor',\\n          paramName: 'networkTimeoutSeconds',\\n        });\\n      }\\n    }\\n\\n    this._fetchOptions = options.fetchOptions || null;\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    const logs = [];\\n\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'NetworkFirst',\\n        funcName: 'handle',\\n        paramName: 'makeRequest',\\n      });\\n    }\\n\\n    const promises = [];\\n    let timeoutId;\\n\\n    if (this._networkTimeoutSeconds) {\\n      const {id, promise} = this._getTimeoutPromise({request, event, logs});\\n      timeoutId = id;\\n      promises.push(promise);\\n    }\\n\\n    const networkPromise =\\n        this._getNetworkPromise({timeoutId, request, event, logs});\\n    promises.push(networkPromise);\\n\\n    // Promise.race() will resolve as soon as the first promise resolves.\\n    let response = await Promise.race(promises);\\n    // If Promise.race() resolved with null, it might be due to a network\\n    // timeout + a cache miss. If that were to happen, we'd rather wait until\\n    // the networkPromise resolves instead of returning null.\\n    // Note that it's fine to await an already-resolved promise, so we don't\\n    // have to check to see if it's still \\\"in flight\\\".\\n    if (!response) {\\n      response = await networkPromise;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('NetworkFirst', request));\\n      for (let log of logs) {\\n        logger.log(log);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url});\\n    }\\n    return response;\\n  }\\n\\n  /**\\n   * @param {Object} options\\n   * @param {Request} options.request\\n   * @param {Array} options.logs A reference to the logs array\\n   * @param {Event} [options.event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  _getTimeoutPromise({request, logs, event}) {\\n    let timeoutId;\\n    const timeoutPromise = new Promise((resolve) => {\\n      const onNetworkTimeout = async () => {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logs.push(`Timing out the network response at ` +\\n            `${this._networkTimeoutSeconds} seconds.`);\\n        }\\n\\n        resolve(await this._respondFromCache({request, event}));\\n      };\\n\\n      timeoutId = setTimeout(\\n          onNetworkTimeout,\\n          this._networkTimeoutSeconds * 1000,\\n      );\\n    });\\n\\n    return {\\n      promise: timeoutPromise,\\n      id: timeoutId,\\n    };\\n  }\\n\\n  /**\\n   * @param {Object} options\\n   * @param {number|undefined} options.timeoutId\\n   * @param {Request} options.request\\n   * @param {Array} options.logs A reference to the logs Array.\\n   * @param {Event} [options.event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  async _getNetworkPromise({timeoutId, request, logs, event}) {\\n    let error;\\n    let response;\\n    try {\\n      response = await fetchWrapper.fetch({\\n        request,\\n        event,\\n        fetchOptions: this._fetchOptions,\\n        plugins: this._plugins,\\n      });\\n    } catch (err) {\\n      error = err;\\n    }\\n\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      if (response) {\\n        logs.push(`Got response from network.`);\\n      } else {\\n        logs.push(`Unable to get a response from the network. Will respond ` +\\n          `with a cached response.`);\\n      }\\n    }\\n\\n    if (error || !response) {\\n      response = await this._respondFromCache({request, event});\\n      if (process.env.NODE_ENV !== 'production') {\\n        if (response) {\\n          logs.push(`Found a cached response in the '${this._cacheName}'` +\\n            ` cache.`);\\n        } else {\\n          logs.push(`No response found in the '${this._cacheName}' cache.`);\\n        }\\n      }\\n    } else {\\n      // Keep the service worker alive while we put the request in the cache\\n      const responseClone = response.clone();\\n      const cachePut = cacheWrapper.put({\\n        cacheName: this._cacheName,\\n        request,\\n        response: responseClone,\\n        event,\\n        plugins: this._plugins,\\n      });\\n\\n      if (event) {\\n        try {\\n          // The event has been responded to so we can keep the SW alive to\\n          // respond to the request\\n          event.waitUntil(cachePut);\\n        } catch (err) {\\n          if (process.env.NODE_ENV !== 'production') {\\n            logger.warn(`Unable to ensure service worker stays alive when ` +\\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\\n          }\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n\\n  /**\\n   * Used if the network timeouts or fails to make the request.\\n   *\\n   * @param {Object} options\\n   * @param {Request} request The request to match in the cache\\n   * @param {Event} [options.event]\\n   * @return {Promise<Object>}\\n   *\\n   * @private\\n   */\\n  _respondFromCache({event, request}) {\\n    return cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n  }\\n}\\n\\nexport {NetworkFirst};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a\\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\\n * request strategy.\\n *\\n * This class is useful if you want to take advantage of any\\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\\n *\\n * If the network request fails, this will throw a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass NetworkOnly {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n    this._fetchOptions = options.fetchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'NetworkOnly',\\n        funcName: 'handle',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    let error;\\n    let response;\\n    try {\\n      response = await fetchWrapper.fetch({\\n        request,\\n        event,\\n        fetchOptions: this._fetchOptions,\\n        plugins: this._plugins,\\n      });\\n    } catch (err) {\\n      error = err;\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('NetworkOnly', request));\\n      if (response) {\\n        logger.log(`Got response from network.`);\\n      } else {\\n        logger.log(`Unable to get a response from the network.`);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url, error});\\n    }\\n    return response;\\n  }\\n}\\n\\nexport {NetworkOnly};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {assert} from 'workbox-core/_private/assert.mjs';\\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\\n\\nimport {messages} from './utils/messages.mjs';\\nimport {cacheOkAndOpaquePlugin} from './plugins/cacheOkAndOpaquePlugin.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * An implementation of a\\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\\n * request strategy.\\n *\\n * Resources are requested from both the cache and the network in parallel.\\n * The strategy will respond with the cached version if available, otherwise\\n * wait for the network response. The cache is updated with the network response\\n * with each successful request.\\n *\\n * By default, this strategy will cache responses with a 200 status code as\\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\\n * Opaque responses are are cross-origin requests where the response doesn't\\n * support [CORS]{@link https://enable-cors.org/}.\\n *\\n * If the network request fails, and there is no cache match, this will throw\\n * a `WorkboxError` exception.\\n *\\n * @memberof workbox.strategies\\n */\\nclass StaleWhileRevalidate {\\n  /**\\n   * @param {Object} options\\n   * @param {string} options.cacheName Cache name to store and retrieve\\n   * requests. Defaults to cache names provided by\\n   * [workbox-core]{@link workbox.core.cacheNames}.\\n   * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\\n   * to use in conjunction with this caching strategy.\\n   * @param {Object} options.fetchOptions Values passed along to the\\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\\n   * of all fetch() requests made by this strategy.\\n   * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\\n   */\\n  constructor(options = {}) {\\n    this._cacheName = cacheNames.getRuntimeName(options.cacheName);\\n    this._plugins = options.plugins || [];\\n\\n    if (options.plugins) {\\n      let isUsingCacheWillUpdate =\\n        options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\\n      this._plugins = isUsingCacheWillUpdate ?\\n        options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\\n    } else {\\n      // No plugins passed in, use the default plugin.\\n      this._plugins = [cacheOkAndOpaquePlugin];\\n    }\\n\\n    this._fetchOptions = options.fetchOptions || null;\\n    this._matchOptions = options.matchOptions || null;\\n  }\\n\\n  /**\\n   * This method will perform a request strategy and follows an API that\\n   * will work with the\\n   * [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * @param {Object} options\\n   * @param {Request} options.request The request to run this strategy for.\\n   * @param {Event} [options.event] The event that triggered the request.\\n   * @return {Promise<Response>}\\n   */\\n  async handle({event, request}) {\\n    return this.makeRequest({\\n      event,\\n      request: request || event.request,\\n    });\\n  }\\n  /**\\n   * This method can be used to perform a make a standalone request outside the\\n   * context of the [Workbox Router]{@link workbox.routing.Router}.\\n   *\\n   * See \\\"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\\\"\\n   * for more usage information.\\n   *\\n   * @param {Object} options\\n   * @param {Request|string} options.request Either a\\n   *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\\n   *     object, or a string URL, corresponding to the request to be made.\\n   * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\\n   *     be called automatically to extend the service worker's lifetime.\\n   * @return {Promise<Response>}\\n   */\\n  async makeRequest({event, request}) {\\n    const logs = [];\\n\\n    if (typeof request === 'string') {\\n      request = new Request(request);\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      assert.isInstance(request, Request, {\\n        moduleName: 'workbox-strategies',\\n        className: 'StaleWhileRevalidate',\\n        funcName: 'handle',\\n        paramName: 'request',\\n      });\\n    }\\n\\n    const fetchAndCachePromise = this._getFromNetwork({request, event});\\n\\n    let response = await cacheWrapper.match({\\n      cacheName: this._cacheName,\\n      request,\\n      event,\\n      matchOptions: this._matchOptions,\\n      plugins: this._plugins,\\n    });\\n    let error;\\n    if (response) {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(`Found a cached response in the '${this._cacheName}'` +\\n          ` cache. Will update with the network response in the background.`);\\n      }\\n\\n      if (event) {\\n        try {\\n          event.waitUntil(fetchAndCachePromise);\\n        } catch (error) {\\n          if (process.env.NODE_ENV !== 'production') {\\n            logger.warn(`Unable to ensure service worker stays alive when ` +\\n              `updating cache for '${getFriendlyURL(request.url)}'.`);\\n          }\\n        }\\n      }\\n    } else {\\n      if (process.env.NODE_ENV !== 'production') {\\n        logs.push(`No response found in the '${this._cacheName}' cache. ` +\\n          `Will wait for the network response.`);\\n      }\\n      try {\\n        response = await fetchAndCachePromise;\\n      } catch (err) {\\n        error = err;\\n      }\\n    }\\n\\n    if (process.env.NODE_ENV !== 'production') {\\n      logger.groupCollapsed(\\n          messages.strategyStart('StaleWhileRevalidate', request));\\n      for (let log of logs) {\\n        logger.log(log);\\n      }\\n      messages.printFinalResponse(response);\\n      logger.groupEnd();\\n    }\\n\\n    if (!response) {\\n      throw new WorkboxError('no-response', {url: request.url, error});\\n    }\\n    return response;\\n  }\\n\\n  /**\\n   * @param {Object} options\\n   * @param {Request} options.request\\n   * @param {Event} [options.event]\\n   * @return {Promise<Response>}\\n   *\\n   * @private\\n   */\\n  async _getFromNetwork({request, event}) {\\n    const response = await fetchWrapper.fetch({\\n      request,\\n      event,\\n      fetchOptions: this._fetchOptions,\\n      plugins: this._plugins,\\n    });\\n\\n    const cachePutPromise = cacheWrapper.put({\\n      cacheName: this._cacheName,\\n      request,\\n      response: response.clone(),\\n      event,\\n      plugins: this._plugins,\\n    });\\n\\n    if (event) {\\n      try {\\n        event.waitUntil(cachePutPromise);\\n      } catch (error) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          logger.warn(`Unable to ensure service worker stays alive when ` +\\n            `updating cache for '${getFriendlyURL(request.url)}'.`);\\n        }\\n      }\\n    }\\n\\n    return response;\\n  }\\n}\\n\\nexport {StaleWhileRevalidate};\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {logger} from 'workbox-core/_private/logger.mjs';\\nimport {CacheFirst} from './CacheFirst.mjs';\\nimport {CacheOnly} from './CacheOnly.mjs';\\nimport {NetworkFirst} from './NetworkFirst.mjs';\\nimport {NetworkOnly} from './NetworkOnly.mjs';\\nimport {StaleWhileRevalidate} from './StaleWhileRevalidate.mjs';\\nimport './_version.mjs';\\n\\n\\nconst mapping = {\\n  cacheFirst: CacheFirst,\\n  cacheOnly: CacheOnly,\\n  networkFirst: NetworkFirst,\\n  networkOnly: NetworkOnly,\\n  staleWhileRevalidate: StaleWhileRevalidate,\\n};\\n\\nconst deprecate = (strategy) => {\\n  const StrategyCtr = mapping[strategy];\\n\\n  return (options) => {\\n    if (process.env.NODE_ENV !== 'production') {\\n      const strategyCtrName = strategy[0].toUpperCase() + strategy.slice(1);\\n      logger.warn(`The 'workbox.strategies.${strategy}()' function has been ` +\\n          `deprecated and will be removed in a future version of Workbox.\\\\n` +\\n          `Please use 'new workbox.strategies.${strategyCtrName}()' instead.`);\\n    }\\n    return new StrategyCtr(options);\\n  };\\n};\\n\\n/**\\n * @function workbox.strategies.cacheFirst\\n * @param {Object} options See the {@link workbox.strategies.CacheFirst}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst cacheFirst = deprecate('cacheFirst');\\n\\n/**\\n * @function workbox.strategies.cacheOnly\\n * @param {Object} options See the {@link workbox.strategies.CacheOnly}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst cacheOnly = deprecate('cacheOnly');\\n\\n/**\\n * @function workbox.strategies.networkFirst\\n * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst networkFirst = deprecate('networkFirst');\\n\\n/**\\n * @function workbox.strategies.networkOnly\\n * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\\n * constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst networkOnly = deprecate('networkOnly');\\n\\n/**\\n * @function workbox.strategies.staleWhileRevalidate\\n * @param {Object} options See the\\n * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\\n * @deprecated since v4.0.0\\n */\\nconst staleWhileRevalidate = deprecate('staleWhileRevalidate');\\n\\n/**\\n * There are common caching strategies that most service workers will need\\n * and use. This module provides simple implementations of these strategies.\\n *\\n * @namespace workbox.strategies\\n */\\n\\nexport {\\n  CacheFirst,\\n  CacheOnly,\\n  NetworkFirst,\\n  NetworkOnly,\\n  StaleWhileRevalidate,\\n\\n  // Deprecated...\\n  cacheFirst,\\n  cacheOnly,\\n  networkFirst,\\n  networkOnly,\\n  staleWhileRevalidate,\\n};\\n\\n\"],\"names\":[\"self\",\"_\",\"e\",\"CacheFirst\",\"constructor\",\"options\",\"_cacheName\",\"cacheNames\",\"getRuntimeName\",\"cacheName\",\"_plugins\",\"plugins\",\"_fetchOptions\",\"fetchOptions\",\"_matchOptions\",\"matchOptions\",\"event\",\"request\",\"this\",\"makeRequest\",\"Request\",\"error\",\"response\",\"cacheWrapper\",\"match\",\"_getFromNetwork\",\"err\",\"WorkboxError\",\"url\",\"fetchWrapper\",\"fetch\",\"responseClone\",\"clone\",\"cachePutPromise\",\"put\",\"waitUntil\",\"CacheOnly\",\"cacheOkAndOpaquePlugin\",\"cacheWillUpdate\",\"status\",\"NetworkFirst\",\"isUsingCacheWillUpdate\",\"some\",\"plugin\",\"_networkTimeoutSeconds\",\"networkTimeoutSeconds\",\"logs\",\"promises\",\"timeoutId\",\"id\",\"promise\",\"_getTimeoutPromise\",\"push\",\"networkPromise\",\"_getNetworkPromise\",\"Promise\",\"race\",\"resolve\",\"setTimeout\",\"async\",\"_respondFromCache\",\"clearTimeout\",\"cachePut\",\"NetworkOnly\",\"StaleWhileRevalidate\",\"fetchAndCachePromise\",\"mapping\",\"cacheFirst\",\"cacheOnly\",\"networkFirst\",\"networkOnly\",\"staleWhileRevalidate\",\"deprecate\",\"strategy\",\"StrategyCtr\"],\"mappings\":\"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\"}\n\\ No newline at end of file"
    },
    {
      "sha": "61b3289a81a12f15841f55e57ace9063bafa3e51",
      "filename": "public/javascripts/workbox/workbox-sw.js",
      "status": "added",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-sw.js",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-sw.js",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-sw.js?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1,2 @@\n+!function(){\"use strict\";try{self[\"workbox:sw:4.3.1\"]&&_()}catch(t){}const t=\"https://storage.googleapis.com/workbox-cdn/releases/4.3.1\",e={backgroundSync:\"background-sync\",broadcastUpdate:\"broadcast-update\",cacheableResponse:\"cacheable-response\",core:\"core\",expiration:\"expiration\",googleAnalytics:\"offline-ga\",navigationPreload:\"navigation-preload\",precaching:\"precaching\",rangeRequests:\"range-requests\",routing:\"routing\",strategies:\"strategies\",streams:\"streams\"};self.workbox=new class{constructor(){return this.v={},this.t={debug:\"localhost\"===self.location.hostname,modulePathPrefix:null,modulePathCb:null},this.s=this.t.debug?\"dev\":\"prod\",this.o=!1,new Proxy(this,{get(t,s){if(t[s])return t[s];const o=e[s];return o&&t.loadModule(`workbox-${o}`),t[s]}})}setConfig(t={}){if(this.o)throw new Error(\"Config must be set before accessing workbox.* modules\");Object.assign(this.t,t),this.s=this.t.debug?\"dev\":\"prod\"}loadModule(t){const e=this.i(t);try{importScripts(e),this.o=!0}catch(s){throw console.error(`Unable to import module '${t}' from '${e}'.`),s}}i(e){if(this.t.modulePathCb)return this.t.modulePathCb(e,this.t.debug);let s=[t];const o=`${e}.${this.s}.js`,r=this.t.modulePathPrefix;return r&&\"\"===(s=r.split(\"/\"))[s.length-1]&&s.splice(s.length-1,1),s.push(o),s.join(\"/\")}}}();\n+//# sourceMappingURL=workbox-sw.js.map"
    },
    {
      "sha": "efb3c3655edd0d751252ce8c3979ea11bb94c9f9",
      "filename": "public/javascripts/workbox/workbox-sw.js.map",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-sw.js.map",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/public/javascripts/workbox/workbox-sw.js.map",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/public/javascripts/workbox/workbox-sw.js.map?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -0,0 +1 @@\n+{\"version\":3,\"file\":\"workbox-sw.js\",\"sources\":[\"../_version.mjs\",\"../controllers/WorkboxSW.mjs\",\"../index.mjs\"],\"sourcesContent\":[\"try{self['workbox:sw:4.3.1']&&_()}catch(e){}// eslint-disable-line\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport '../_version.mjs';\\n\\nconst CDN_PATH = `WORKBOX_CDN_ROOT_URL`;\\n\\nconst MODULE_KEY_TO_NAME_MAPPING = {\\n  // TODO(philipwalton): add jsdoc tags to associate these with their module.\\n  // @name backgroundSync\\n  // @memberof workbox\\n  // @see module:workbox-background-sync\\n  backgroundSync: 'background-sync',\\n  broadcastUpdate: 'broadcast-update',\\n  cacheableResponse: 'cacheable-response',\\n  core: 'core',\\n  expiration: 'expiration',\\n  googleAnalytics: 'offline-ga',\\n  navigationPreload: 'navigation-preload',\\n  precaching: 'precaching',\\n  rangeRequests: 'range-requests',\\n  routing: 'routing',\\n  strategies: 'strategies',\\n  streams: 'streams',\\n};\\n\\n/**\\n * This class can be used to make it easy to use the various parts of\\n * Workbox.\\n *\\n * @private\\n */\\nexport class WorkboxSW {\\n  /**\\n   * Creates a proxy that automatically loads workbox namespaces on demand.\\n   *\\n   * @private\\n   */\\n  constructor() {\\n    this.v = {};\\n    this._options = {\\n      debug: self.location.hostname === 'localhost',\\n      modulePathPrefix: null,\\n      modulePathCb: null,\\n    };\\n\\n    this._env = this._options.debug ? 'dev' : 'prod';\\n    this._modulesLoaded = false;\\n\\n    return new Proxy(this, {\\n      get(target, key) {\\n        if (target[key]) {\\n          return target[key];\\n        }\\n\\n        const moduleName = MODULE_KEY_TO_NAME_MAPPING[key];\\n        if (moduleName) {\\n          target.loadModule(`workbox-${moduleName}`);\\n        }\\n\\n        return target[key];\\n      },\\n    });\\n  }\\n\\n  /**\\n   * Updates the configuration options. You can specify whether to treat as a\\n   * debug build and whether to use a CDN or a specific path when importing\\n   * other workbox-modules\\n   *\\n   * @param {Object} [options]\\n   * @param {boolean} [options.debug] If true, `dev` builds are using, otherwise\\n   * `prod` builds are used. By default, `prod` is used unless on localhost.\\n   * @param {Function} [options.modulePathPrefix] To avoid using the CDN with\\n   * `workbox-sw` set the path prefix of where modules should be loaded from.\\n   * For example `modulePathPrefix: '/third_party/workbox/v3.0.0/'`.\\n   * @param {workbox~ModulePathCallback} [options.modulePathCb] If defined,\\n   * this callback will be responsible for determining the path of each\\n   * workbox module.\\n   *\\n   * @alias workbox.setConfig\\n   */\\n  setConfig(options = {}) {\\n    if (!this._modulesLoaded) {\\n      Object.assign(this._options, options);\\n      this._env = this._options.debug ? 'dev' : 'prod';\\n    } else {\\n      throw new Error('Config must be set before accessing workbox.* modules');\\n    }\\n  }\\n\\n  /**\\n   * Load a Workbox module by passing in the appropriate module name.\\n   *\\n   * This is not generally needed unless you know there are modules that are\\n   * dynamically used and you want to safe guard use of the module while the\\n   * user may be offline.\\n   *\\n   * @param {string} moduleName\\n   *\\n   * @alias workbox.loadModule\\n   */\\n  loadModule(moduleName) {\\n    const modulePath = this._getImportPath(moduleName);\\n    try {\\n      importScripts(modulePath);\\n      this._modulesLoaded = true;\\n    } catch (err) {\\n      // TODO Add context of this error if using the CDN vs the local file.\\n\\n      // We can't rely on workbox-core being loaded so using console\\n      // eslint-disable-next-line\\n      console.error(\\n          `Unable to import module '${moduleName}' from '${modulePath}'.`);\\n      throw err;\\n    }\\n  }\\n\\n  /**\\n   * This method will get the path / CDN URL to be used for importScript calls.\\n   *\\n   * @param {string} moduleName\\n   * @return {string} URL to the desired module.\\n   *\\n   * @private\\n   */\\n  _getImportPath(moduleName) {\\n    if (this._options.modulePathCb) {\\n      return this._options.modulePathCb(moduleName, this._options.debug);\\n    }\\n\\n    // TODO: This needs to be dynamic some how.\\n    let pathParts = [CDN_PATH];\\n\\n    const fileName = `${moduleName}.${this._env}.js`;\\n\\n    const pathPrefix = this._options.modulePathPrefix;\\n    if (pathPrefix) {\\n      // Split to avoid issues with developers ending / not ending with slash\\n      pathParts = pathPrefix.split('/');\\n\\n      // We don't need a slash at the end as we will be adding\\n      // a filename regardless\\n      if (pathParts[pathParts.length - 1] === '') {\\n        pathParts.splice(pathParts.length - 1, 1);\\n      }\\n    }\\n\\n    pathParts.push(fileName);\\n\\n    return pathParts.join('/');\\n  }\\n}\\n\",\"/*\\n  Copyright 2018 Google LLC\\n\\n  Use of this source code is governed by an MIT-style\\n  license that can be found in the LICENSE file or at\\n  https://opensource.org/licenses/MIT.\\n*/\\n\\nimport {WorkboxSW} from './controllers/WorkboxSW.mjs';\\nimport './_version.mjs';\\n\\n/**\\n * @namespace workbox\\n */\\n\\n// Don't export anything, just expose a global.\\nself.workbox = new WorkboxSW();\\n\"],\"names\":[\"self\",\"_\",\"e\",\"CDN_PATH\",\"MODULE_KEY_TO_NAME_MAPPING\",\"backgroundSync\",\"broadcastUpdate\",\"cacheableResponse\",\"core\",\"expiration\",\"googleAnalytics\",\"navigationPreload\",\"precaching\",\"rangeRequests\",\"routing\",\"strategies\",\"streams\",\"workbox\",\"constructor\",\"v\",\"_options\",\"debug\",\"location\",\"hostname\",\"modulePathPrefix\",\"modulePathCb\",\"_env\",\"this\",\"_modulesLoaded\",\"Proxy\",\"get\",\"target\",\"key\",\"moduleName\",\"loadModule\",\"setConfig\",\"options\",\"Error\",\"Object\",\"assign\",\"modulePath\",\"_getImportPath\",\"importScripts\",\"err\",\"console\",\"error\",\"pathParts\",\"fileName\",\"pathPrefix\",\"split\",\"length\",\"splice\",\"push\",\"join\"],\"mappings\":\"yBAAA,IAAIA,KAAK,qBAAqBC,IAAI,MAAMC,ICUxC,MAAMC,EAAY,4DAEZC,EAA6B,CAKjCC,eAAgB,kBAChBC,gBAAiB,mBACjBC,kBAAmB,qBACnBC,KAAM,OACNC,WAAY,aACZC,gBAAiB,aACjBC,kBAAmB,qBACnBC,WAAY,aACZC,cAAe,iBACfC,QAAS,UACTC,WAAY,aACZC,QAAS,WCZXhB,KAAKiB,QAAU,IDqBR,MAMLC,0BACOC,EAAI,QACJC,EAAW,CACdC,MAAkC,cAA3BrB,KAAKsB,SAASC,SACrBC,iBAAkB,KAClBC,aAAc,WAGXC,EAAOC,KAAKP,EAASC,MAAQ,MAAQ,YACrCO,GAAiB,EAEf,IAAIC,MAAMF,KAAM,CACrBG,IAAIC,EAAQC,MACND,EAAOC,UACFD,EAAOC,SAGVC,EAAa7B,EAA2B4B,UAC1CC,GACFF,EAAOG,sBAAsBD,KAGxBF,EAAOC,MAsBpBG,UAAUC,EAAU,OACbT,KAAKC,QAIF,IAAIS,MAAM,yDAHhBC,OAAOC,OAAOZ,KAAKP,EAAUgB,QACxBV,EAAOC,KAAKP,EAASC,MAAQ,MAAQ,OAiB9Ca,WAAWD,SACHO,EAAab,KAAKc,EAAeR,OAErCS,cAAcF,QACTZ,GAAiB,EACtB,MAAOe,SAKPC,QAAQC,kCACwBZ,YAAqBO,OAC/CG,GAYVF,EAAeR,MACTN,KAAKP,EAASK,oBACTE,KAAKP,EAASK,aAAaQ,EAAYN,KAAKP,EAASC,WAI1DyB,EAAY,CAAC3C,SAEX4C,KAAcd,KAAcN,KAAKD,OAEjCsB,EAAarB,KAAKP,EAASI,wBAC7BwB,GAMsC,MAJxCF,EAAYE,EAAWC,MAAM,MAIfH,EAAUI,OAAS,IAC/BJ,EAAUK,OAAOL,EAAUI,OAAS,EAAG,GAI3CJ,EAAUM,KAAKL,GAERD,EAAUO,KAAK\"}\n\\ No newline at end of file"
    },
    {
      "sha": "a0b4ec517bc59f175ec45d4d909b5fbbaf9e0b8a",
      "filename": "yarn.lock",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/discourse/discourse/blob/1221d342849f54dd20f58391a4b1d542398d9116/yarn.lock",
      "raw_url": "https://github.com/discourse/discourse/raw/1221d342849f54dd20f58391a4b1d542398d9116/yarn.lock",
      "contents_url": "https://api.github.com/repos/discourse/discourse/contents/yarn.lock?ref=1221d342849f54dd20f58391a4b1d542398d9116",
      "patch": "@@ -2584,6 +2584,37 @@ wordwrap@~1.0.0:\n   resolved \"https://registry.yarnpkg.com/wordwrap/-/wordwrap-1.0.0.tgz#27584810891456a4171c8d0226441ade90cbcaeb\"\n   integrity sha1-J1hIEIkUVqQXHI0CJkQa3pDLyus=\n \n+workbox-core@^4.3.1:\n+  version \"4.3.1\"\n+  resolved \"https://registry.yarnpkg.com/workbox-core/-/workbox-core-4.3.1.tgz#005d2c6a06a171437afd6ca2904a5727ecd73be6\"\n+  integrity sha512-I3C9jlLmMKPxAC1t0ExCq+QoAMd0vAAHULEgRZ7kieCdUd919n53WC0AfvokHNwqRhGn+tIIj7vcb5duCjs2Kg==\n+\n+workbox-expiration@^4.3.1:\n+  version \"4.3.1\"\n+  resolved \"https://registry.yarnpkg.com/workbox-expiration/-/workbox-expiration-4.3.1.tgz#d790433562029e56837f341d7f553c4a78ebe921\"\n+  integrity sha512-vsJLhgQsQouv9m0rpbXubT5jw0jMQdjpkum0uT+d9tTwhXcEZks7qLfQ9dGSaufTD2eimxbUOJfWLbNQpIDMPw==\n+  dependencies:\n+    workbox-core \"^4.3.1\"\n+\n+workbox-routing@^4.3.1:\n+  version \"4.3.1\"\n+  resolved \"https://registry.yarnpkg.com/workbox-routing/-/workbox-routing-4.3.1.tgz#a675841af623e0bb0c67ce4ed8e724ac0bed0cda\"\n+  integrity sha512-FkbtrODA4Imsi0p7TW9u9MXuQ5P4pVs1sWHK4dJMMChVROsbEltuE79fBoIk/BCztvOJ7yUpErMKa4z3uQLX+g==\n+  dependencies:\n+    workbox-core \"^4.3.1\"\n+\n+workbox-strategies@^4.3.1:\n+  version \"4.3.1\"\n+  resolved \"https://registry.yarnpkg.com/workbox-strategies/-/workbox-strategies-4.3.1.tgz#d2be03c4ef214c115e1ab29c9c759c9fe3e9e646\"\n+  integrity sha512-F/+E57BmVG8dX6dCCopBlkDvvhg/zj6VDs0PigYwSN23L8hseSRwljrceU2WzTvk/+BSYICsWmRq5qHS2UYzhw==\n+  dependencies:\n+    workbox-core \"^4.3.1\"\n+\n+workbox-sw@^4.3.1:\n+  version \"4.3.1\"\n+  resolved \"https://registry.yarnpkg.com/workbox-sw/-/workbox-sw-4.3.1.tgz#df69e395c479ef4d14499372bcd84c0f5e246164\"\n+  integrity sha512-0jXdusCL2uC5gM3yYFT6QMBzKfBr2XTk0g5TPAV4y8IZDyVNDyj1a8uSXy3/XrvkVTmQvLN4O5k3JawGReXr9w==\n+\n wrappy@1:\n   version \"1.0.2\"\n   resolved \"https://registry.yarnpkg.com/wrappy/-/wrappy-1.0.2.tgz#b5243d8f3ec1aa35f1364605bc0d1036e30ab69f\""
    }
  ]
}
