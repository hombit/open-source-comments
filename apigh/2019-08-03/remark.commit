{
  "sha": "f0750c24335742da2b04cee6e38bbb67f972c44b",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOmYwNzUwYzI0MzM1NzQyZGEyYjA0Y2VlNmUzOGJiYjY3Zjk3MmM0NGI=",
  "commit": {
    "author": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-08-01T07:08:26Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2019-08-01T07:08:26Z"
    },
    "message": "Merge pull request #401 from umputun/rpc-example\n\nRPC example",
    "tree": {
      "sha": "1fa217513d7fa71e4caf77c7b113e0bfd605f3c2",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/1fa217513d7fa71e4caf77c7b113e0bfd605f3c2"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/f0750c24335742da2b04cee6e38bbb67f972c44b",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdQo/qCRBK7hj4Ov3rIwAAdHIIADYCwv7gIy0fwLn5T4YK2ndN\nYmSajdrLO/XS3Vf4UTN8nXzK7pcrQNtWdOou0J/6Y1ymALgarDtTEqDaqPVlr1zC\nxtfMZwUNB6FSZXc7fWirTQcDSqTLRwQ2k3RqsP0BFr8BHS2A4DxbZ5jgf0q055rz\ndSfzCtRl3pObp2RPwKvNGGjWKYsrOvGammfH2OI6aoEFR/WjKPIm8t8vHa/PLX/M\nCm/Srk6kbyCWg+KVfJjBBVUo11oDGOAyFLUF88/tQFRmSSju1WbD5AAR4D2nkdv7\nbJDQneN+zK70Mo6nS01dtUUlAeQCgINuM+w26BXejxs/L2bFq6C9iWKGHrj3wL4=\n=15OR\n-----END PGP SIGNATURE-----\n",
      "payload": "tree 1fa217513d7fa71e4caf77c7b113e0bfd605f3c2\nparent 159f4d4fafbe61700c944ab44b82ed56e0bfa371\nparent 5b173a05df387c81ccbf116e03814fb691ffd0ce\nauthor Umputun <umputun@gmail.com> 1564643306 -0500\ncommitter GitHub <noreply@github.com> 1564643306 -0500\n\nMerge pull request #401 from umputun/rpc-example\n\nRPC example"
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/f0750c24335742da2b04cee6e38bbb67f972c44b",
  "html_url": "https://github.com/umputun/remark/commit/f0750c24335742da2b04cee6e38bbb67f972c44b",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/f0750c24335742da2b04cee6e38bbb67f972c44b/comments",
  "author": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "159f4d4fafbe61700c944ab44b82ed56e0bfa371",
      "url": "https://api.github.com/repos/umputun/remark/commits/159f4d4fafbe61700c944ab44b82ed56e0bfa371",
      "html_url": "https://github.com/umputun/remark/commit/159f4d4fafbe61700c944ab44b82ed56e0bfa371"
    },
    {
      "sha": "5b173a05df387c81ccbf116e03814fb691ffd0ce",
      "url": "https://api.github.com/repos/umputun/remark/commits/5b173a05df387c81ccbf116e03814fb691ffd0ce",
      "html_url": "https://github.com/umputun/remark/commit/5b173a05df387c81ccbf116e03814fb691ffd0ce"
    }
  ],
  "stats": {
    "total": 3060,
    "additions": 2579,
    "deletions": 481
  },
  "files": [
    {
      "sha": "ed8c2e564ce526ca38896e788c08daee7e313a69",
      "filename": ".gitignore",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/.gitignore",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/.gitignore?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -20,3 +20,4 @@ remark42\n /bin/\n /backend/var/\n compose-private-backend.yml\n+/backend/_example/*/vendor"
    },
    {
      "sha": "2eda2e85d8770bba3d70b624131a93203a3e1bd1",
      "filename": "backend/_example/memory_store/Dockerfile",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/Dockerfile",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/Dockerfile",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/Dockerfile?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,22 @@\n+FROM umputun/baseimage:buildgo-latest as build-backend\n+\n+#ADD . /build/memory_store\n+#WORKDIR /build/memory_store\n+\n+ADD backend /build/backend\n+WORKDIR /build/backend/_example/memory_store\n+\n+RUN go build -o /build/bin/memory_store -ldflags \"-X main.revision=0.0.0 -s -w\"\n+\n+\n+FROM umputun/baseimage:app-latest\n+\n+WORKDIR /srv\n+COPY --from=build-backend /build/bin/memory_store /srv/memory_store\n+RUN chown -R app:app /srv\n+\n+EXPOSE 8080\n+HEALTHCHECK --interval=30s --timeout=3s CMD curl --fail http://localhost:8080/ping || exit 1\n+USER app\n+\n+CMD [\"/srv/memory_store\"]"
    },
    {
      "sha": "475703a4f0eb766febe0359f8f10bc7c9da66e95",
      "filename": "backend/_example/memory_store/README.md",
      "status": "added",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/README.md?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,13 @@\n+# sample store implementation \n+\n+`memory_store` illustrates how to make a custom storage plugin for remark42. \n+\n+In order to run remark42 with memory_store copy provided `compose-dev-memstore.yml` to the root directory and run:\n+\n+1. docker-compose -f compose-dev-memstore.yml build\n+1. docker-compose -f compose-dev-memstore.yml up\n+\n+As usual, demo site will run on http://127.0.0.1:8080/web/\n+\n+note: in order to work with the latest (current) version of master `go.mod` uses replacement directive for the backend package\n+. In real-life usage `replace github.com/umputun/remark/backend => ../../`  should not be used. \n\\ No newline at end of file"
    },
    {
      "sha": "6e375dfd6a831f65956190dff0df33919cc8996e",
      "filename": "backend/_example/memory_store/accessor/admin.go",
      "status": "added",
      "additions": 61,
      "deletions": 0,
      "changes": 61,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/admin.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/admin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/accessor/admin.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2019 Umputun. All rights reserved.\n+ * Use of this source code is governed by a MIT-style\n+ * license that can be found in the LICENSE file.\n+ */\n+\n+package accessor\n+\n+import (\n+\tlog \"github.com/go-pkgz/lgr\"\n+\t\"github.com/pkg/errors\"\n+)\n+\n+// MemAdmin implements admin.Store with memory backend\n+type MemAdmin struct {\n+\tdata map[string]AdminRec // admin info per site\n+\tkey  string\n+}\n+\n+// AdminRec is a records per site with all admin info in\n+type AdminRec struct {\n+\tSiteID string   `bson:\"site\"`\n+\tIDs    []string `bson:\"ids\"`   // admin ids\n+\tEmail  string   `bson:\"email\"` // admin email\n+}\n+\n+// NewMemAdminStore makes admin Store in memory\n+func NewMemAdminStore(key string) *MemAdmin {\n+\tlog.Print(\"[DEBUG] make memory admin store\")\n+\treturn &MemAdmin{data: map[string]AdminRec{}, key: key}\n+}\n+\n+// Key executes find by siteID and returns substructure with secret key\n+func (m *MemAdmin) Key() (key string, err error) {\n+\treturn m.key, nil\n+}\n+\n+// Admins executes find by siteID and returns admins ids\n+func (m *MemAdmin) Admins(siteID string) (ids []string, err error) {\n+\tresp, ok := m.data[siteID]\n+\tif !ok {\n+\t\treturn nil, errors.Errorf(\"site %s not found\", siteID)\n+\t}\n+\tlog.Printf(\"[DEBUG] admins for %s, %+v\", siteID, resp.IDs)\n+\treturn resp.IDs, nil\n+}\n+\n+// Email executes find by siteID and returns admin's email\n+func (m *MemAdmin) Email(siteID string) (email string, err error) {\n+\tresp, ok := m.data[siteID]\n+\tif !ok {\n+\t\treturn \"\", errors.Errorf(\"site %s not found\", siteID)\n+\t}\n+\n+\treturn resp.Email, nil\n+}\n+\n+// Set admin data for siteID\n+func (m *MemAdmin) Set(siteID string, arec AdminRec) {\n+\tm.data[siteID] = arec\n+}"
    },
    {
      "sha": "1fe18688eda3ca5e9d568d857cef15626dda738a",
      "filename": "backend/_example/memory_store/accessor/admin_test.go",
      "status": "added",
      "additions": 52,
      "deletions": 0,
      "changes": 52,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/admin_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/admin_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/accessor/admin_test.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2019 Umputun. All rights reserved.\n+ * Use of this source code is governed by a MIT-style\n+ * license that can be found in the LICENSE file.\n+ */\n+\n+package accessor\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\n+\t\"github.com/umputun/remark/backend/app/store/admin\"\n+)\n+\n+func TestMemAdmin_Get(t *testing.T) {\n+\n+\tadm := NewMemAdminStore(\"secret\")\n+\tvar ms admin.Store = adm\n+\n+\tadm.data = map[string]AdminRec{\n+\t\t\"site1\": {\"site1\", []string{\"i11\", \"i12\"}, \"e1\"},\n+\t\t\"site2\": {\"site2\", []string{\"i21\", \"i22\"}, \"e2\"},\n+\t}\n+\n+\tadmins, err := ms.Admins(\"site1\")\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []string{\"i11\", \"i12\"}, admins)\n+\temail, err := ms.Email(\"site1\")\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"e1\", email)\n+\tkey, err := ms.Key()\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"secret\", key)\n+\n+\tadmins, err = ms.Admins(\"site2\")\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []string{\"i21\", \"i22\"}, admins)\n+\temail, err = ms.Email(\"site2\")\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"e2\", email)\n+\tkey, err = ms.Key()\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"secret\", key)\n+\n+\tadmins, err = ms.Admins(\"no-site-in-db\")\n+\tassert.EqualError(t, err, \"site no-site-in-db not found\")\n+\n+\temail, err = ms.Email(\"no-site-in-db\")\n+\tassert.EqualError(t, err, \"site no-site-in-db not found\")\n+}"
    },
    {
      "sha": "0773f09f88bc8a788e05b92d82eec735ad51efbe",
      "filename": "backend/_example/memory_store/accessor/data.go",
      "status": "added",
      "additions": 441,
      "deletions": 0,
      "changes": 441,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/data.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/data.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/accessor/data.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,441 @@\n+/*\n+ * Copyright 2019 Umputun. All rights reserved.\n+ * Use of this source code is governed by a MIT-style\n+ * license that can be found in the LICENSE file.\n+ */\n+\n+package accessor\n+\n+import (\n+\t\"log\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/pkg/errors\"\n+\n+\t\"github.com/umputun/remark/backend/app/store/engine\"\n+\n+\t\"github.com/umputun/remark/backend/app/store\"\n+)\n+\n+const lastLimit = 1000\n+\n+// MemData implements in-memory data store\n+type MemData struct {\n+\tposts     map[string][]store.Comment // key is siteID\n+\tmetaUsers map[string]metaUser        // key is userID\n+\tmetaPosts map[store.Locator]metaPost // key is post's locator\n+\tsync.RWMutex\n+}\n+\n+type metaPost struct {\n+\tPostURL  string\n+\tSiteID   string\n+\tReadOnly bool\n+}\n+\n+type metaUser struct {\n+\tUserID       string\n+\tSiteID       string\n+\tVerified     bool\n+\tBlocked      bool\n+\tBlockedUntil time.Time\n+}\n+\n+// NewMemData makes in-memory engine.\n+func NewMemData() *MemData {\n+\n+\tresult := &MemData{\n+\t\tposts:     map[string][]store.Comment{},\n+\t\tmetaUsers: map[string]metaUser{},\n+\t\tmetaPosts: map[store.Locator]metaPost{},\n+\t}\n+\treturn result\n+}\n+\n+// Create new comment\n+func (m *MemData) Create(comment store.Comment) (commentID string, err error) {\n+\n+\tif ro, e := m.Flag(engine.FlagRequest{Flag: engine.ReadOnly, Locator: comment.Locator}); e == nil && ro {\n+\t\treturn \"\", errors.Errorf(\"post %s is read-only\", comment.Locator.URL)\n+\t}\n+\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\tcomments := m.posts[comment.Locator.SiteID]\n+\tfor _, c := range comments { // don't allow duplicated IDs\n+\t\tif c.ID == comment.ID {\n+\t\t\treturn \"\", errors.New(\"dup key\")\n+\t\t}\n+\t}\n+\tcomments = append(comments, comment)\n+\tm.posts[comment.Locator.SiteID] = comments\n+\treturn comment.ID, nil\n+}\n+\n+// Find returns all comments for post and sorts results\n+func (m *MemData) Find(req engine.FindRequest) (comments []store.Comment, err error) {\n+\tm.RLock()\n+\tdefer m.RUnlock()\n+\n+\tcomments = []store.Comment{}\n+\n+\tif req.Sort == \"\" {\n+\t\treq.Sort = \"time\"\n+\t}\n+\n+\tswitch {\n+\n+\tcase req.Locator.SiteID != \"\" && req.Locator.URL != \"\": // find comments for site and url\n+\t\tcomments = m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n+\t\t\treturn c.Locator == req.Locator && (req.Since.IsZero() || c.Timestamp.After(req.Since))\n+\t\t})\n+\n+\tcase req.Locator.SiteID != \"\" && req.Locator.URL == \"\" && req.UserID == \"\": // find last comments for site\n+\t\tif req.Limit > lastLimit || req.Limit == 0 {\n+\t\t\treq.Limit = lastLimit\n+\t\t}\n+\t\tif req.Since.IsZero() {\n+\t\t\treq.Since = time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)\n+\t\t}\n+\n+\t\tcomments = m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n+\t\t\treturn !c.Deleted && c.Timestamp.After(req.Since)\n+\t\t})\n+\t\tcomments = engine.SortComments(comments, \"-time\")\n+\t\tif len(comments) > req.Limit {\n+\t\t\tcomments = comments[:req.Limit]\n+\t\t}\n+\t\treturn comments, nil\n+\n+\tcase req.Locator.SiteID != \"\" && req.UserID != \"\": // find comments for user\n+\t\tcomments = m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n+\t\t\treturn c.User.ID == req.UserID\n+\t\t})\n+\t}\n+\n+\tcomments = engine.SortComments(comments, req.Sort)\n+\tif req.Skip > 0 && req.Skip > len(comments) {\n+\t\treturn []store.Comment{}, nil\n+\t}\n+\tif req.Skip > 0 && req.Skip < len(comments) {\n+\t\tcomments = comments[req.Skip:]\n+\t}\n+\n+\tif req.Limit > 0 && req.Limit < len(comments) {\n+\t\tcomments = comments[:req.Limit]\n+\t}\n+\n+\treturn comments, err\n+}\n+\n+// Get returns comment for locator.URL and commentID string\n+func (m *MemData) Get(req engine.GetRequest) (comment store.Comment, err error) {\n+\tm.RLock()\n+\tdefer m.RUnlock()\n+\treturn m.get(req.Locator, req.CommentID)\n+}\n+\n+// Update updates comment for locator.URL with mutable part of comment\n+func (m *MemData) Update(comment store.Comment) error {\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\treturn m.updateComment(comment)\n+}\n+\n+// Count returns number of comments for post or user\n+func (m *MemData) Count(req engine.FindRequest) (count int, err error) {\n+\tm.RLock()\n+\tdefer m.RUnlock()\n+\n+\tswitch {\n+\tcase req.Locator.URL != \"\": // comment's count for post\n+\t\tcomments := m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n+\t\t\treturn c.Locator == req.Locator && !c.Deleted\n+\t\t})\n+\t\treturn len(comments), nil\n+\tcase req.UserID != \"\":\n+\t\tcomments := m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n+\t\t\treturn c.User.ID == req.UserID && !c.Deleted\n+\t\t})\n+\t\treturn len(comments), nil\n+\tdefault:\n+\t\treturn 0, errors.Errorf(\"invalid count request %+v\", req)\n+\t}\n+}\n+\n+// Info get post(s) meta info\n+func (m *MemData) Info(req engine.InfoRequest) (res []store.PostInfo, err error) {\n+\tm.RLock()\n+\tdefer m.RUnlock()\n+\tres = []store.PostInfo{}\n+\n+\tif req.Locator.URL != \"\" { // post info\n+\t\tcomments := m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n+\t\t\treturn c.Locator == req.Locator\n+\t\t})\n+\t\tif len(comments) == 0 {\n+\t\t\treturn nil, errors.New(\"not found\")\n+\t\t}\n+\t\tinfo := store.PostInfo{\n+\t\t\tURL:      req.Locator.URL,\n+\t\t\tCount:    len(comments),\n+\t\t\tReadOnly: false,\n+\t\t\tFirstTS:  comments[0].Timestamp.UTC(),\n+\t\t\tLastTS:   comments[len(comments)-1].Timestamp.UTC(),\n+\t\t}\n+\t\t// set read-only from age and manual bucket\n+\t\tinfo.ReadOnly = req.ReadOnlyAge > 0 && !info.FirstTS.IsZero() &&\n+\t\t\tinfo.FirstTS.AddDate(0, 0, req.ReadOnlyAge).Before(time.Now())\n+\t\tif !info.ReadOnly {\n+\t\t\tv := m.checkFlag(engine.FlagRequest{Flag: engine.ReadOnly, Locator: req.Locator})\n+\t\t\tinfo.ReadOnly = v\n+\t\t}\n+\t\treturn []store.PostInfo{info}, nil\n+\t}\n+\n+\tif req.Locator.URL == \"\" && req.Locator.SiteID != \"\" { // site info (list)\n+\t\tif req.Limit <= 0 {\n+\t\t\treq.Limit = 1000\n+\t\t}\n+\t\tif req.Skip < 0 {\n+\t\t\treq.Skip = 0\n+\t\t}\n+\n+\t\tinfoAll := map[store.Locator]store.PostInfo{}\n+\t\tfor _, c := range m.posts[req.Locator.SiteID] {\n+\t\t\tvar info store.PostInfo\n+\t\t\tvar ok bool\n+\t\t\tif info, ok = infoAll[c.Locator]; !ok {\n+\t\t\t\tinfo = store.PostInfo{URL: c.Locator.URL, FirstTS: c.Timestamp.UTC()}\n+\t\t\t}\n+\t\t\tinfo.Count++\n+\t\t\tinfo.LastTS = c.Timestamp.UTC()\n+\t\t\tinfoAll[c.Locator] = info\n+\t\t}\n+\n+\t\tfor _, v := range infoAll {\n+\t\t\tres = append(res, v)\n+\t\t}\n+\t\tsort.Slice(res, func(i, j int) bool {\n+\t\t\treturn res[i].URL > res[j].URL\n+\t\t})\n+\n+\t\tif req.Skip > 0 {\n+\t\t\tif req.Skip >= len(res) {\n+\t\t\t\treturn []store.PostInfo{}, nil\n+\t\t\t}\n+\t\t\tres = res[req.Skip:]\n+\t\t}\n+\n+\t\tif req.Limit > 0 && req.Limit < len(res) {\n+\t\t\tres = res[:req.Limit]\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\n+\treturn nil, errors.Errorf(\"invalid info request %+v\", req)\n+}\n+\n+// Flag sets and gets flag values\n+func (m *MemData) Flag(req engine.FlagRequest) (val bool, err error) {\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\n+\tif req.Update == engine.FlagNonSet { // read flag value, no update requested\n+\t\treturn m.checkFlag(req), nil\n+\t}\n+\t// write flag value\n+\treturn m.setFlag(req)\n+}\n+\n+// ListFlags get list of flagged keys, like blocked & verified user\n+// works for full locator (post flags) or with userID\n+func (m *MemData) ListFlags(req engine.FlagRequest) (res []interface{}, err error) {\n+\tm.RLock()\n+\tdefer m.RUnlock()\n+\n+\tres = []interface{}{}\n+\n+\tswitch req.Flag {\n+\tcase engine.Verified:\n+\t\tfor _, u := range m.metaUsers {\n+\t\t\tif u.SiteID == req.Locator.SiteID {\n+\t\t\t\tres = append(res, u.UserID)\n+\t\t\t}\n+\t\t}\n+\t\treturn res, nil\n+\n+\tcase engine.Blocked:\n+\t\tlog.Printf(\"%+v\", m.metaUsers)\n+\t\tfor _, u := range m.metaUsers {\n+\t\t\tif u.SiteID == req.Locator.SiteID && u.Blocked && u.BlockedUntil.After(time.Now()) {\n+\t\t\t\tres = append(res, store.BlockedUser{ID: u.UserID, Until: u.BlockedUntil})\n+\t\t\t}\n+\t\t}\n+\t\treturn res, nil\n+\t}\n+\n+\treturn nil, errors.Errorf(\"flag %s not listable\", req.Flag)\n+}\n+\n+// Delete post(s) by id or by userID\n+func (m *MemData) Delete(req engine.DeleteRequest) error {\n+\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\n+\tswitch {\n+\tcase req.Locator.URL != \"\" && req.CommentID != \"\": // delete comment\n+\t\treturn m.deleteComment(req.Locator, req.CommentID, req.DeleteMode)\n+\n+\tcase req.Locator.SiteID != \"\" && req.UserID != \"\" && req.CommentID == \"\": // delete user\n+\t\tcomments := m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n+\t\t\treturn c.User.ID == req.UserID && !c.Deleted\n+\t\t})\n+\t\tfor _, c := range comments {\n+\t\t\tif e := m.deleteComment(c.Locator, c.ID, req.DeleteMode); e != nil {\n+\t\t\t\treturn e\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\n+\tcase req.Locator.SiteID != \"\" && req.Locator.URL == \"\" && req.CommentID == \"\" && req.UserID == \"\": // delete site\n+\t\tif _, ok := m.posts[req.Locator.SiteID]; !ok {\n+\t\t\treturn errors.New(\"not found\")\n+\t\t}\n+\t\tm.posts[req.Locator.SiteID] = []store.Comment{}\n+\t\treturn nil\n+\t}\n+\n+\treturn errors.Errorf(\"invalid delete request %+v\", req)\n+}\n+\n+func (m *MemData) deleteComment(loc store.Locator, id string, mode store.DeleteMode) error {\n+\n+\tcomments := m.match(m.posts[loc.SiteID], func(c store.Comment) bool {\n+\t\treturn c.Locator == loc && c.ID == id\n+\t})\n+\tif len(comments) == 0 {\n+\t\treturn errors.New(\"not found\")\n+\t}\n+\n+\tcomments[0].SetDeleted(mode)\n+\treturn m.updateComment(comments[0])\n+}\n+\n+// Close store\n+func (m *MemData) Close() error {\n+\treturn nil\n+}\n+\n+func (m *MemData) checkFlag(req engine.FlagRequest) (val bool) {\n+\tswitch req.Flag {\n+\tcase engine.Blocked:\n+\t\tif meta, ok := m.metaUsers[req.UserID]; ok {\n+\t\t\tif meta.SiteID != req.Locator.SiteID {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\treturn meta.Blocked && meta.BlockedUntil.After(time.Now())\n+\t\t}\n+\tcase engine.Verified:\n+\t\tif meta, ok := m.metaUsers[req.UserID]; ok {\n+\t\t\tif meta.SiteID != req.Locator.SiteID {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\treturn meta.Verified\n+\t\t}\n+\tcase engine.ReadOnly:\n+\t\tif meta, ok := m.metaPosts[req.Locator]; ok {\n+\t\t\treturn meta.ReadOnly\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func (m *MemData) setFlag(req engine.FlagRequest) (res bool, err error) {\n+\n+\tstatus := false\n+\tif req.Update == engine.FlagTrue {\n+\t\tstatus = true\n+\t}\n+\n+\tswitch req.Flag {\n+\n+\tcase engine.Blocked:\n+\t\tuntil := time.Time{}\n+\t\tif status {\n+\t\t\tuntil = time.Now().AddDate(100, 0, 0) // permanent is 100years\n+\t\t\tif req.TTL > 0 {\n+\t\t\t\tuntil = time.Now().Add(req.TTL)\n+\t\t\t}\n+\t\t}\n+\t\tmeta := m.metaUsers[req.UserID]\n+\t\tmeta = metaUser{\n+\t\t\tUserID:       req.UserID,\n+\t\t\tSiteID:       req.Locator.SiteID,\n+\t\t\tBlocked:      status,\n+\t\t\tBlockedUntil: until,\n+\t\t}\n+\t\tm.metaUsers[req.UserID] = meta\n+\n+\tcase engine.Verified:\n+\t\tmeta := m.metaUsers[req.UserID]\n+\t\tmeta = metaUser{\n+\t\t\tUserID:   req.UserID,\n+\t\t\tSiteID:   req.Locator.SiteID,\n+\t\t\tVerified: status,\n+\t\t}\n+\t\tm.metaUsers[req.UserID] = meta\n+\n+\tcase engine.ReadOnly:\n+\t\tinfo, ok := m.metaPosts[req.Locator]\n+\t\tif !ok {\n+\t\t\tinfo.SiteID = req.Locator.SiteID\n+\t\t\tinfo.PostURL = req.Locator.URL\n+\t\t}\n+\t\tinfo.ReadOnly = status\n+\t\tm.metaPosts[req.Locator] = info\n+\t}\n+\treturn status, errors.Wrapf(err, \"failed to set flag %+v\", req)\n+}\n+\n+func (m *MemData) get(loc store.Locator, commentID string) (store.Comment, error) {\n+\tcomments := m.match(m.posts[loc.SiteID], func(c store.Comment) bool {\n+\t\treturn c.Locator == loc && c.ID == commentID\n+\t})\n+\tif len(comments) == 0 {\n+\t\treturn store.Comment{}, errors.New(\"not found\")\n+\t}\n+\treturn comments[0], nil\n+}\n+\n+func (m *MemData) updateComment(comment store.Comment) error {\n+\tcomments := m.posts[comment.Locator.SiteID]\n+\tfor i, c := range comments {\n+\t\tif c.ID == comment.ID && c.Locator == comment.Locator {\n+\t\t\tc.Text = comment.Text\n+\t\t\tc.Orig = comment.Orig\n+\t\t\tc.Score = comment.Score\n+\t\t\tc.Votes = comment.Votes\n+\t\t\tc.Pin = comment.Pin\n+\t\t\tc.Deleted = comment.Deleted\n+\t\t\tc.User = comment.User\n+\t\t\tcomments[i] = c\n+\t\t\tm.posts[comment.Locator.SiteID] = comments\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn errors.New(\"not found\")\n+}\n+\n+func (m *MemData) match(comments []store.Comment, fn func(c store.Comment) bool) (res []store.Comment) {\n+\tres = []store.Comment{}\n+\tfor _, c := range comments {\n+\t\tif fn(c) {\n+\t\t\tres = append(res, c)\n+\t\t}\n+\t}\n+\treturn res\n+}"
    },
    {
      "sha": "e95b15bfd1e9e258fb64f4ec34668591af540e57",
      "filename": "backend/_example/memory_store/accessor/data_test.go",
      "status": "added",
      "additions": 727,
      "deletions": 0,
      "changes": 727,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/data_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/accessor/data_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/accessor/data_test.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2019 Umputun. All rights reserved.\n+ * Use of this source code is governed by a MIT-style\n+ * license that can be found in the LICENSE file.\n+ */\n+\n+package accessor\n+\n+import (\n+\t\"fmt\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/umputun/remark/backend/app/store\"\n+\t\"github.com/umputun/remark/backend/app/store/engine\"\n+)\n+\n+func TestMem_CreateAndFind(t *testing.T) {\n+\tm := prepMem(t) // adds two comments\n+\n+\treq := engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, Sort: \"time\"}\n+\tres, err := m.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res))\n+\tassert.Equal(t, `some text, <a href=\"http://radio-t.com\">link</a>`, res[0].Text)\n+\tassert.Equal(t, \"user1\", res[0].User.ID)\n+\tt.Log(res[0].ID)\n+\n+\t_, err = m.Create(store.Comment{ID: res[0].ID, Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}})\n+\trequire.NotNil(t, err)\n+\tassert.True(t, strings.Contains(err.Error(), \"dup key\"), err.Error())\n+\n+\tid, err := m.Create(store.Comment{ID: \"id-3\", Locator: store.Locator{URL: \"https://radio-t2.com\", SiteID: \"radio-t2\"}})\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, \"id-3\", id)\n+\treq = engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t2.com\", SiteID: \"radio-t2\"}, Sort: \"time\"}\n+\tres, err = m.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 1, len(res))\n+}\n+\n+func TestMem_CreateFailedReadOnly(t *testing.T) {\n+\tb := prepMem(t)\n+\tcomment := store.Comment{\n+\t\tID:        \"id-ro\",\n+\t\tText:      `some text, <a href=\"http://radio-t.com\">link</a>`,\n+\t\tTimestamp: time.Date(2017, 12, 20, 15, 18, 22, 0, time.Local),\n+\t\tLocator:   store.Locator{URL: \"https://radio-t.com/ro\", SiteID: \"radio-t\"},\n+\t\tUser:      store.User{ID: \"user1\", Name: \"user name\"},\n+\t}\n+\n+\tflagReq := engine.FlagRequest{Locator: comment.Locator, Flag: engine.ReadOnly, Update: engine.FlagTrue}\n+\tv, err := b.Flag(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, true, v)\n+\n+\t_, err = b.Create(comment)\n+\tassert.NotNil(t, err)\n+\tassert.Equal(t, \"post https://radio-t.com/ro is read-only\", err.Error())\n+\n+\tflagReq = engine.FlagRequest{Locator: comment.Locator, Flag: engine.ReadOnly, Update: engine.FlagFalse}\n+\tv, err = b.Flag(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, false, v)\n+\n+\t_, err = b.Create(comment)\n+\tassert.NoError(t, err)\n+}\n+\n+func TestMem_Get(t *testing.T) {\n+\tb := prepMem(t)\n+\treq := engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, Sort: \"time\"}\n+\tres, err := b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res), \"2 records initially\")\n+\n+\tcomment, err := b.Get(getReq(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[1].ID))\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"some text2\", comment.Text)\n+\n+\t_, err = b.Get(getReq(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, \"1234567\"))\n+\tassert.EqualError(t, err, `not found`)\n+\n+\t_, err = b.Get(getReq(store.Locator{URL: \"https://radio-t.com\", SiteID: \"bad\"}, res[1].ID))\n+\tassert.EqualError(t, err, `not found`)\n+}\n+\n+func TestMem_Update(t *testing.T) {\n+\tb := prepMem(t)\n+\treq := engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, Sort: \"time\"}\n+\tres, err := b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res), \"2 records initially\")\n+\n+\tcomment := res[0]\n+\tcomment.Text = \"abc 123\"\n+\tcomment.Score = 100\n+\terr = b.Update(comment)\n+\tassert.NoError(t, err)\n+\n+\tcomment, err = b.Get(getReq(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, res[0].ID))\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"abc 123\", comment.Text)\n+\tassert.Equal(t, res[0].ID, comment.ID)\n+\tassert.Equal(t, 100, comment.Score)\n+\n+\tcomment.Locator.SiteID = \"bad\"\n+\terr = b.Update(comment)\n+\tassert.EqualError(t, err, `not found`)\n+\n+\tcomment.Locator.SiteID = \"https://radio-t.com\"\n+\tcomment.Locator.URL = \"https://radio-t.com-bad\"\n+\terr = b.Update(comment)\n+\tassert.EqualError(t, err, `not found`)\n+}\n+\n+func TestMem_FindLast(t *testing.T) {\n+\tb := prepMem(t)\n+\treq := engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"-time\"}\n+\tres, err := b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res))\n+\tassert.Equal(t, \"some text2\", res[0].Text)\n+\n+\treq.Limit = 1\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 1, len(res))\n+\tassert.Equal(t, \"some text2\", res[0].Text)\n+\n+\treq.Locator.SiteID = \"bad\"\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(res))\n+}\n+\n+func TestMem_FindLastSince(t *testing.T) {\n+\tb := prepMem(t)\n+\tts := time.Date(2017, 12, 20, 15, 18, 21, 0, time.Local)\n+\treq := engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"-time\", Since: ts}\n+\tres, err := b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res))\n+\tassert.Equal(t, \"some text2\", res[0].Text)\n+\n+\treq.Since = time.Date(2017, 12, 20, 15, 18, 22, 0, time.Local)\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 1, len(res))\n+\tassert.Equal(t, \"some text2\", res[0].Text)\n+\n+\treq.Since = time.Date(2017, 12, 20, 16, 18, 22, 0, time.Local)\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(res))\n+}\n+\n+func TestMem_FindForUser(t *testing.T) {\n+\tb := prepMem(t)\n+\treq := engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"-time\", UserID: \"user1\", Limit: 5}\n+\tres, err := b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res))\n+\tassert.Equal(t, \"some text2\", res[0].Text, \"sorted by -time\")\n+\n+\treq = engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"-time\", UserID: \"user1\", Limit: 1}\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 1, len(res), \"allow 1 comment\")\n+\tassert.Equal(t, \"some text2\", res[0].Text, \"sorted by -time\")\n+\n+\treq = engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"-time\", UserID: \"user1\", Limit: 1, Skip: 1}\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 1, len(res), \"allow 1 comment\")\n+\tassert.Equal(t, `some text, <a href=\"http://radio-t.com\">link</a>`, res[0].Text, \"second comment\")\n+\n+\treq = engine.FindRequest{Locator: store.Locator{SiteID: \"bad\"}, Sort: \"-time\", UserID: \"user1\", Limit: 1, Skip: 1}\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(res), \"no comments\")\n+\n+\treq = engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"-time\", UserID: \"userZ\", Limit: 1, Skip: 1}\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(res), \"no comments\")\n+}\n+\n+func TestMem_FindForUserPagination(t *testing.T) {\n+\tb := NewMemData()\n+\n+\tc := store.Comment{\n+\t\tLocator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"},\n+\t\tUser:    store.User{ID: \"user1\", Name: \"user name\"},\n+\t}\n+\n+\t// write 200 comments\n+\tfor i := 0; i < 200; i++ {\n+\t\tc.ID = fmt.Sprintf(\"idd-%d\", i)\n+\t\tc.Text = fmt.Sprintf(\"text #%d\", i)\n+\t\tc.Timestamp = time.Date(2017, 12, 20, 15, 18, i, 0, time.Local)\n+\t\t_, err := b.Create(c)\n+\t\trequire.Nil(t, err)\n+\t}\n+\n+\t// get all comments\n+\treq := engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"-time\", UserID: \"user1\"}\n+\tres, err := b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 200, len(res))\n+\tassert.Equal(t, \"idd-199\", res[0].ID)\n+\n+\t// seek 0, 5 comments\n+\treq.Limit = 5\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 5, len(res))\n+\tassert.Equal(t, \"idd-199\", res[0].ID)\n+\tassert.Equal(t, \"idd-195\", res[4].ID)\n+\n+\t// seek 10, 3 comments\n+\treq.Skip, req.Limit = 10, 3\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 3, len(res))\n+\tassert.Equal(t, \"idd-189\", res[0].ID)\n+\tassert.Equal(t, \"idd-187\", res[2].ID)\n+\n+\t// seek 195, ask 10 comments\n+\treq.Skip, req.Limit = 195, 10\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 5, len(res))\n+\tassert.Equal(t, \"idd-4\", res[0].ID)\n+\tassert.Equal(t, \"idd-0\", res[4].ID)\n+\n+\t// seek 255, ask 10 comments\n+\treq.Skip, req.Limit = 255, 10\n+\tres, err = b.Find(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(res))\n+}\n+\n+func TestMem_CountPost(t *testing.T) {\n+\tb := prepMem(t)\n+\treq := engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}}\n+\tc, err := b.Count(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, c)\n+\n+\treq = engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com-xxx\", SiteID: \"radio-t\"}}\n+\tc, err = b.Count(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, c)\n+\n+\treq = engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"bad\"}}\n+\tc, err = b.Count(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, c)\n+}\n+\n+func TestMem_CountUser(t *testing.T) {\n+\tb := prepMem(t)\n+\treq := engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\"}\n+\tc, err := b.Count(req)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, c)\n+\n+\treq = engine.FindRequest{Locator: store.Locator{SiteID: \"bad\"}, UserID: \"user1\"}\n+\tc, err = b.Count(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, c)\n+\n+\treq = engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"userZ\"}\n+\tc, err = b.Count(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, c)\n+}\n+\n+func TestMem_InfoPost(t *testing.T) {\n+\tb := prepMem(t)\n+\tts := func(min int) time.Time { return time.Date(2017, 12, 20, 15, 18, min, 0, time.Local).In(time.UTC) }\n+\n+\t// add one more for https://radio-t.com/2\n+\tcomment := store.Comment{\n+\t\tID:        \"12345\",\n+\t\tText:      `some text, <a href=\"http://radio-t.com\">link</a>`,\n+\t\tTimestamp: time.Date(2017, 12, 20, 15, 18, 24, 0, time.Local),\n+\t\tLocator:   store.Locator{URL: \"https://radio-t.com/2\", SiteID: \"radio-t\"},\n+\t\tUser:      store.User{ID: \"user1\", Name: \"user name\"},\n+\t}\n+\t_, err := b.Create(comment)\n+\tassert.NoError(t, err)\n+\n+\treq := engine.InfoRequest{Locator: store.Locator{URL: \"https://radio-t.com/2\", SiteID: \"radio-t\"}, ReadOnlyAge: 0}\n+\tr, err := b.Info(req)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, []store.PostInfo{{URL: \"https://radio-t.com/2\", Count: 1, FirstTS: ts(24), LastTS: ts(24)}}, r)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{URL: \"https://radio-t.com/2\", SiteID: \"radio-t\"}, ReadOnlyAge: 10}\n+\tr, err = b.Info(req)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, []store.PostInfo{{URL: \"https://radio-t.com/2\", Count: 1,\n+\t\tFirstTS: ts(24), LastTS: ts(24), ReadOnly: true}}, r)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, ReadOnlyAge: 0}\n+\tr, err = b.Info(req)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, []store.PostInfo{{URL: \"https://radio-t.com\", Count: 2, FirstTS: ts(22), LastTS: ts(23)}}, r)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{URL: \"https://radio-t.com/error\", SiteID: \"radio-t\"}, ReadOnlyAge: 0}\n+\t_, err = b.Info(req)\n+\trequire.NotNil(t, err)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t-error\"}, ReadOnlyAge: 0}\n+\t_, err = b.Info(req)\n+\trequire.NotNil(t, err)\n+\n+\tfr := engine.FlagRequest{Flag: engine.ReadOnly,\n+\t\tLocator: store.Locator{URL: \"https://radio-t.com/2\", SiteID: \"radio-t\"}, Update: engine.FlagTrue}\n+\t_, err = b.Flag(fr)\n+\trequire.NoError(t, err)\n+\treq = engine.InfoRequest{Locator: store.Locator{URL: \"https://radio-t.com/2\", SiteID: \"radio-t\"}, ReadOnlyAge: 0}\n+\tr, err = b.Info(req)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, []store.PostInfo{{URL: \"https://radio-t.com/2\", Count: 1, FirstTS: ts(24), LastTS: ts(24),\n+\t\tReadOnly: true}}, r)\n+}\n+\n+func TestMem_InfoList(t *testing.T) {\n+\tb := prepMem(t)\n+\t// add one more for https://radio-t.com/2\n+\tcomment := store.Comment{\n+\t\tID:        \"12345\",\n+\t\tText:      `some text, <a href=\"http://radio-t.com\">link</a>`,\n+\t\tTimestamp: time.Date(2017, 12, 20, 15, 18, 22, 0, time.Local),\n+\t\tLocator:   store.Locator{URL: \"https://radio-t.com/2\", SiteID: \"radio-t\"},\n+\t\tUser:      store.User{ID: \"user1\", Name: \"user name\"},\n+\t}\n+\t_, err := b.Create(comment)\n+\tassert.NoError(t, err)\n+\n+\tts := func(sec int) time.Time { return time.Date(2017, 12, 20, 15, 18, sec, 0, time.Local).In(time.UTC) }\n+\n+\treq := engine.InfoRequest{Locator: store.Locator{SiteID: \"radio-t\"}}\n+\tres, err := b.Info(req)\n+\tassert.NoError(t, err)\n+\tassert.EqualValues(t, []store.PostInfo{{URL: \"https://radio-t.com/2\", Count: 1, FirstTS: ts(22), LastTS: ts(22)},\n+\t\t{URL: \"https://radio-t.com\", Count: 2, FirstTS: ts(22), LastTS: ts(23)}}, res)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Limit: -1, Skip: -1}\n+\tres, err = b.Info(req)\n+\tassert.NoError(t, err)\n+\tassert.EqualValues(t, []store.PostInfo{{URL: \"https://radio-t.com/2\", Count: 1, FirstTS: ts(22), LastTS: ts(22)},\n+\t\t{URL: \"https://radio-t.com\", Count: 2, FirstTS: ts(22), LastTS: ts(23)}}, res)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Limit: 1}\n+\tres, err = b.Info(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []store.PostInfo{{URL: \"https://radio-t.com/2\", Count: 1, FirstTS: ts(22), LastTS: ts(22)}}, res)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Limit: 1, Skip: 1}\n+\tres, err = b.Info(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []store.PostInfo{{URL: \"https://radio-t.com\", Count: 2, FirstTS: ts(22), LastTS: ts(23)}}, res)\n+\n+\treq = engine.InfoRequest{Locator: store.Locator{SiteID: \"bad\"}, Limit: 1, Skip: 1}\n+\tres, err = b.Info(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []store.PostInfo{}, res)\n+}\n+\n+func TestMem_FlagBlockedUser(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\treq := engine.FlagRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\"}\n+\tval, err := b.Flag(req)\n+\tassert.NoError(t, err)\n+\tassert.False(t, val, \"nothing blocked yet\")\n+\n+\treq = engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\",\n+\t\tUpdate: engine.FlagTrue}\n+\t_, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\tval, err = b.Flag(engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\"})\n+\tassert.NoError(t, err)\n+\tassert.True(t, val, \"user1 blocked\")\n+\n+\treq = engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\",\n+\t\tUpdate: engine.FlagTrue}\n+\t_, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\tval, err = b.Flag(engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\"})\n+\tassert.NoError(t, err)\n+\tassert.True(t, val, \"user1 still blocked\")\n+\n+\treq = engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\",\n+\t\tUpdate: engine.FlagFalse}\n+\t_, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\tval, err = b.Flag(engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\"})\n+\tassert.NoError(t, err)\n+\tassert.False(t, val, \"user1 unblocked\")\n+}\n+\n+func TestMem_FlagReadOnlyPost(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\treq := engine.FlagRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"url-1\"}, Flag: engine.ReadOnly}\n+\tval, err := b.Flag(req)\n+\tassert.NoError(t, err)\n+\tassert.False(t, val, \"nothing ro\")\n+\n+\treq = engine.FlagRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"url-1\"}, Flag: engine.ReadOnly,\n+\t\tUpdate: engine.FlagTrue}\n+\tval, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\treq = engine.FlagRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"url-1\"}, Flag: engine.ReadOnly}\n+\tval, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\tassert.True(t, val, \"url-1 ro\")\n+\n+\treq = engine.FlagRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"url-2\"}, Flag: engine.ReadOnly}\n+\tval, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\tassert.False(t, val, \"url-2 still writable\")\n+\n+\treq = engine.FlagRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"url-1\"}, Flag: engine.ReadOnly,\n+\t\tUpdate: engine.FlagFalse}\n+\t_, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\treq = engine.FlagRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"url-1\"}, Flag: engine.ReadOnly}\n+\tval, err = b.Flag(req)\n+\tassert.NoError(t, err)\n+\tassert.False(t, val, \"url-1 writable\")\n+}\n+\n+func TestMem_FlagVerified(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\tisVerified := func(site, user string) bool {\n+\t\treq := engine.FlagRequest{Flag: engine.Verified, Locator: store.Locator{SiteID: site}, UserID: user}\n+\t\tv, err := b.Flag(req)\n+\t\trequire.NoError(t, err)\n+\t\treturn v\n+\t}\n+\n+\tsetVerified := func(site, user string, status engine.FlagStatus) error {\n+\t\treq := engine.FlagRequest{Flag: engine.Verified, Locator: store.Locator{SiteID: site}, UserID: user, Update: status}\n+\t\t_, err := b.Flag(req)\n+\t\treturn err\n+\t}\n+\n+\tassert.False(t, isVerified(\"radio-t\", \"u1\"), \"nothing verified\")\n+\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u1\", engine.FlagTrue))\n+\tassert.True(t, isVerified(\"radio-t\", \"u1\"), \"u1 verified\")\n+\n+\tassert.False(t, isVerified(\"radio-t\", \"u2\"), \"u2 still not verified\")\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u1\", engine.FlagFalse))\n+\tassert.False(t, isVerified(\"radio-t\", \"u1\"), \"u1 not verified anymore\")\n+\n+\tassert.NoError(t, setVerified(\"bad\", \"u1\", engine.FlagTrue))\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u1xyz\", engine.FlagFalse))\n+\n+\tassert.False(t, isVerified(\"radio-t-bad\", \"u1\"), \"nothing verified on wrong site\")\n+\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u1\", engine.FlagTrue))\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u2\", engine.FlagTrue))\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u3\", engine.FlagFalse))\n+}\n+\n+func TestMem_FlagListVerified(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\ttoIDs := func(inp []interface{}) (res []string) {\n+\t\tres = make([]string, len(inp))\n+\t\tfor i, v := range inp {\n+\t\t\tvv, ok := v.(string)\n+\t\t\trequire.True(t, ok)\n+\t\t\tres[i] = vv\n+\t\t}\n+\t\tsort.Strings(res)\n+\t\treturn res\n+\t}\n+\n+\tsetVerified := func(site, user string, status engine.FlagStatus) error {\n+\t\treq := engine.FlagRequest{Flag: engine.Verified, Locator: store.Locator{SiteID: site}, UserID: user, Update: status}\n+\t\t_, err := b.Flag(req)\n+\t\treturn err\n+\t}\n+\n+\tids, err := b.ListFlags(engine.FlagRequest{Flag: engine.Verified, Locator: store.Locator{SiteID: \"radio-t\"}})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []string{}, toIDs(ids), \"verified list empty\")\n+\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u1\", engine.FlagTrue))\n+\tassert.NoError(t, setVerified(\"radio-t\", \"u2\", engine.FlagTrue))\n+\tids, err = b.ListFlags(engine.FlagRequest{Flag: engine.Verified, Locator: store.Locator{SiteID: \"radio-t\"}})\n+\tassert.NoError(t, err)\n+\tassert.EqualValues(t, []string{\"u1\", \"u2\"}, toIDs(ids), \"verified 2 ids\")\n+\n+\tids, err = b.ListFlags(engine.FlagRequest{Flag: engine.Verified, Locator: store.Locator{SiteID: \"radio-t-bad\"}})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(ids))\n+}\n+\n+func TestMem_FlagListBlocked(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\tsetBlocked := func(site, user string, status engine.FlagStatus, ttl time.Duration) error {\n+\t\treq := engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: site}, UserID: user, Update: status,\n+\t\t\tTTL: ttl}\n+\t\t_, err := b.Flag(req)\n+\t\treturn err\n+\t}\n+\n+\ttoBlocked := func(inp []interface{}) (res []store.BlockedUser) {\n+\t\tres = make([]store.BlockedUser, len(inp))\n+\t\tfor i, v := range inp {\n+\t\t\tvv, ok := v.(store.BlockedUser)\n+\t\t\trequire.True(t, ok)\n+\t\t\tres[i] = vv\n+\t\t}\n+\t\treturn res\n+\t}\n+\tassert.NoError(t, setBlocked(\"radio-t\", \"user1\", engine.FlagTrue, 0))\n+\tassert.NoError(t, setBlocked(\"radio-t\", \"user2\", engine.FlagTrue, 50*time.Millisecond))\n+\tassert.NoError(t, setBlocked(\"radio-t\", \"user3\", engine.FlagFalse, 0))\n+\n+\tvv, err := b.ListFlags(engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}})\n+\tassert.NoError(t, err)\n+\n+\tblockedList := toBlocked(vv)\n+\trequire.Equal(t, 2, len(blockedList), b.metaUsers)\n+\tassert.Equal(t, \"user1\", blockedList[0].ID)\n+\tassert.Equal(t, \"user2\", blockedList[1].ID)\n+\tt.Logf(\"%+v\", blockedList)\n+\n+\t// check block expiration\n+\ttime.Sleep(50 * time.Millisecond)\n+\tvv, err = b.ListFlags(engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"radio-t\"}})\n+\tassert.NoError(t, err)\n+\tblockedList = toBlocked(vv)\n+\trequire.Equal(t, 1, len(blockedList))\n+\tassert.Equal(t, \"user1\", blockedList[0].ID)\n+\n+\tvv, err = b.ListFlags(engine.FlagRequest{Flag: engine.Blocked, Locator: store.Locator{SiteID: \"bad\"}})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(vv))\n+}\n+\n+func TestMem_DeleteComment(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\treqReq := engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, Sort: \"time\"}\n+\tres, err := b.Find(reqReq)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res), \"initially 2 comments\")\n+\n+\tcount, err := b.Count(reqReq)\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, 2, count, \"count=2 initially\")\n+\n+\tdelReq := engine.DeleteRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"},\n+\t\tCommentID: res[0].ID, DeleteMode: store.SoftDelete}\n+\n+\terr = b.Delete(delReq)\n+\tassert.NoError(t, err)\n+\n+\tres, err = b.Find(reqReq)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res))\n+\tassert.Equal(t, \"\", res[0].Text)\n+\tassert.True(t, res[0].Deleted, \"marked deleted\")\n+\tassert.Equal(t, store.User{Name: \"user name\", ID: \"user1\", Picture: \"\", Admin: false, Blocked: false, IP: \"\"}, res[0].User)\n+\n+\tassert.Equal(t, \"some text2\", res[1].Text)\n+\tassert.False(t, res[1].Deleted)\n+\n+\tcomments, err := b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Limit: 10})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 1, len(comments), \"1 in last, 1 removed\")\n+\n+\tcount, err = b.Count(reqReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 1, count)\n+\n+\tdelReq.CommentID = \"123456\"\n+\terr = b.Delete(delReq)\n+\tassert.NotNil(t, err)\n+\n+\tdelReq.Locator.SiteID = \"bad\"\n+\tdelReq.CommentID = res[0].ID\n+\terr = b.Delete(delReq)\n+\tassert.EqualError(t, err, `not found`)\n+\n+\tdelReq.Locator = store.Locator{URL: \"https://radio-t.com/bad\", SiteID: \"radio-t\"}\n+\terr = b.Delete(delReq)\n+\tassert.EqualError(t, err, `not found`)\n+}\n+\n+func TestMem_DeleteHard(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\treqReq := engine.FindRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, Sort: \"time\"}\n+\tres, err := b.Find(reqReq)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 2, len(res), \"initially 2 comments\")\n+\n+\tdelReq := engine.DeleteRequest{Locator: store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"},\n+\t\tCommentID: res[0].ID, DeleteMode: store.HardDelete}\n+\terr = b.Delete(delReq)\n+\tassert.NoError(t, err)\n+\n+\tres, err = b.Find(reqReq)\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(res))\n+\tassert.Equal(t, \"\", res[0].Text)\n+\tassert.True(t, res[0].Deleted, \"marked deleted\")\n+\tassert.Equal(t, store.User{Name: \"deleted\", ID: \"deleted\", Picture: \"\", Admin: false, Blocked: false, IP: \"\"}, res[0].User)\n+}\n+\n+func TestMem_DeleteAll(t *testing.T) {\n+\tb := prepMem(t)\n+\tdelReq := engine.DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}}\n+\terr := b.Delete(delReq)\n+\tassert.NoError(t, err)\n+\n+\tcomments, err := b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Limit: 10})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(comments), \"nothing left\")\n+}\n+\n+func TestBoltAdmin_DeleteUserHard(t *testing.T) {\n+\tb := prepMem(t)\n+\terr := b.Delete(engine.DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\",\n+\t\tDeleteMode: store.HardDelete})\n+\trequire.NoError(t, err)\n+\n+\tcomments, err := b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com\"},\n+\t\tSort: \"time\"})\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(comments), \"2 comments with deleted info\")\n+\tassert.Equal(t, store.User{Name: \"deleted\", ID: \"deleted\", Picture: \"\", Admin: false, Blocked: false, IP: \"\"}, comments[0].User)\n+\tassert.Equal(t, store.User{Name: \"deleted\", ID: \"deleted\", Picture: \"\", Admin: false, Blocked: false, IP: \"\"}, comments[1].User)\n+\n+\tc, err := b.Count(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com\"}})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, c, \"0 count\")\n+\n+\t_, err = b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", Limit: 5})\n+\tassert.NoError(t, err, \"no comments for user user1 in store\")\n+\n+\tcomments, err = b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"time\"})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(comments), \"nothing left\")\n+}\n+\n+func TestBoltAdmin_DeleteUserSoft(t *testing.T) {\n+\n+\tb := prepMem(t)\n+\terr := b.Delete(engine.DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\",\n+\t\tDeleteMode: store.SoftDelete})\n+\trequire.NoError(t, err)\n+\n+\tcomments, err := b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com\"},\n+\t\tSort: \"time\"})\n+\tassert.NoError(t, err)\n+\trequire.Equal(t, 2, len(comments), \"2 comments with deleted info\")\n+\tassert.Equal(t, store.User{Name: \"user name\", ID: \"user1\", Picture: \"\", Admin: false, Blocked: false, IP: \"\"}, comments[0].User)\n+\tassert.Equal(t, store.User{Name: \"user name\", ID: \"user1\", Picture: \"\", Admin: false, Blocked: false, IP: \"\"}, comments[1].User)\n+\n+\tc, err := b.Count(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com\"}})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, c, \"0 count\")\n+\n+\tcomments, err = b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", Limit: 5})\n+\tassert.NoError(t, err, \"no comments for user user1 in store\")\n+\trequire.Equal(t, 2, len(comments), \"2 comments with deleted info\")\n+\tassert.True(t, comments[0].Deleted)\n+\tassert.True(t, comments[1].Deleted)\n+\tassert.Equal(t, \"\", comments[0].Text)\n+\tassert.Equal(t, \"\", comments[1].Text)\n+\n+\tcomments, err = b.Find(engine.FindRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Sort: \"time\"})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 0, len(comments), \"nothing left\")\n+}\n+\n+func prepMem(t *testing.T) *MemData {\n+\n+\tm := NewMemData()\n+\n+\tcomment := store.Comment{\n+\t\tID:        \"id-1\",\n+\t\tText:      `some text, <a href=\"http://radio-t.com\">link</a>`,\n+\t\tTimestamp: time.Date(2017, 12, 20, 15, 18, 22, 0, time.Local),\n+\t\tLocator:   store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"},\n+\t\tUser:      store.User{ID: \"user1\", Name: \"user name\"},\n+\t}\n+\t_, err := m.Create(comment)\n+\trequire.NoError(t, err)\n+\n+\tcomment = store.Comment{\n+\t\tID:        \"id-2\",\n+\t\tText:      \"some text2\",\n+\t\tTimestamp: time.Date(2017, 12, 20, 15, 18, 23, 0, time.Local),\n+\t\tLocator:   store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"},\n+\t\tUser:      store.User{ID: \"user1\", Name: \"user name\"},\n+\t}\n+\t_, err = m.Create(comment)\n+\trequire.NoError(t, err)\n+\treturn m\n+}\n+\n+func getReq(locator store.Locator, commentID string) engine.GetRequest {\n+\treturn engine.GetRequest{\n+\t\tLocator:   locator,\n+\t\tCommentID: commentID,\n+\t}\n+}"
    },
    {
      "sha": "3392ecaebf13da63d68205ac75fc33e1f0c91679",
      "filename": "backend/_example/memory_store/compose-dev-memstore.yml",
      "status": "added",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/compose-dev-memstore.yml",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/compose-dev-memstore.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/compose-dev-memstore.yml?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,47 @@\n+# compose file demonstrating custom storage use. The memory_store (see backend/_example/memory_store) starts\n+# in a separate container and remark42 communicates to mem_store.r42 via STORE_RPC_API url\n+\n+version: '2'\n+\n+services:\n+\n+  remark42:\n+    build:\n+      context: .\n+      dockerfile: Dockerfile\n+      args:\n+        - SKIP_BACKEND_TEST=true\n+        - SKIP_FRONTEND_TEST=true\n+    image: umputun/remark42:dev\n+    container_name: \"remark42\"\n+    hostname: \"remark42\"\n+    restart: always\n+\n+    ports:\n+      - \"8080:8080\" # primary rest server\n+      - \"8084:8084\" # local oauth2 server\n+\n+    environment:\n+      - REMARK_URL=http://127.0.0.1:8080\n+      - SECRET=123456\n+      - BACKUP_PATH=/srv/var/backup\n+      - DEBUG=true\n+      - EMOJI=true\n+      - AUTH_ANON=true\n+      - AUTH_DEV=true\n+      - ADMIN_TYPE=rpc\n+      - ADMIN_RPC_API=http://mem_store.r42:8080/cmd\n+      - STORE_TYPE=rpc\n+      - STORE_RPC_API=http://mem_store.r42:8080/cmd\n+\n+  mem_store.r42:\n+    image: umputun/mem_store.r42\n+    build:\n+      context: .\n+      dockerfile: backend/_example/memory_store/Dockerfile\n+    container_name: \"mem_store.r42\"\n+    hostname: \"mem_store.r42\"\n+    environment:\n+      - API=/cmd\n+      - SECRET=123456\n+      - DEBUG=true"
    },
    {
      "sha": "ddabb0b52f73cb749ab88901d9bfc361bdffa205",
      "filename": "backend/_example/memory_store/go.mod",
      "status": "added",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/go.mod?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,17 @@\n+module github.com/umputun/remark/memory_store\n+\n+go 1.12\n+\n+require (\n+\tgithub.com/go-pkgz/jrpc v0.1.0\n+\tgithub.com/go-pkgz/lgr v0.6.3\n+\tgithub.com/jessevdk/go-flags v1.4.0\n+\tgithub.com/pkg/errors v0.8.1\n+\tgithub.com/stretchr/testify v1.3.0\n+\tgithub.com/umputun/remark/backend v1.4.0\n+\tgolang.org/x/sys v0.0.0-20190801041406-cbf593c0f2f3 // indirect\n+)\n+\n+replace github.com/umputun/remark/backend => ../../\n+\n+replace gopkg.in/russross/blackfriday.v2 => github.com/russross/blackfriday/v2 v2.0.1"
    },
    {
      "sha": "ab5ff9e59681dc38cc535a6a7f93bffcce197a41",
      "filename": "backend/_example/memory_store/go.sum",
      "status": "added",
      "additions": 191,
      "deletions": 0,
      "changes": 191,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/go.sum?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,191 @@\n+cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\n+cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\n+cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\n+cloud.google.com/go v0.40.0/go.mod h1:Tk58MuI9rbLMKlAjeO/bDnteAx7tX2gJIXw4T5Jwlro=\n+cloud.google.com/go v0.41.0/go.mod h1:OauMR7DV8fzvZIl2qg6rkaIhD/vmgk4iwEw/h6ercmg=\n+github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\n+github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\n+github.com/PuerkitoBio/goquery v1.5.0 h1:uGvmFXOA73IKluu/F84Xd1tt/z07GYm8X49XKHP7EJk=\n+github.com/PuerkitoBio/goquery v1.5.0/go.mod h1:qD2PgZ9lccMbQlc7eEOjaeRlFQON7xY8kdmcsrnKqMg=\n+github.com/andybalholm/cascadia v1.0.0 h1:hOCXnnZ5A+3eVDX8pvgl4kofXv2ELss0bKcqRySc45o=\n+github.com/andybalholm/cascadia v1.0.0/go.mod h1:GsXiBklL0woXo1j/WYWtSYYC4ouU9PqHO0sqidkEA4Y=\n+github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\n+github.com/coreos/bbolt v1.3.3 h1:n6AiVyVRKQFNb6mJlwESEvvLoDyiTzXX7ORAUlkeBdY=\n+github.com/coreos/bbolt v1.3.3/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\n+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\n+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\n+github.com/didip/tollbooth v4.0.2+incompatible h1:fVSa33JzSz0hoh2NxpwZtksAzAgd7zjmGO20HCZtF4M=\n+github.com/didip/tollbooth v4.0.2+incompatible/go.mod h1:A9b0665CE6l1KmzpDws2++elm/CsuWBMa5Jv4WY0PEY=\n+github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d h1:vs5Nf6IE0N/PwGJ8//zRed4gpCdcr99K2HzX7RuLOQ8=\n+github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d/go.mod h1:YWyIfq3y4ArRfWZ9XksmuusP+7Mad+T0iFZ0kv0XG/M=\n+github.com/globalsign/mgo v0.0.0-20180615134936-113d3961e731/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\n+github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8 h1:DujepqpGd1hyOd7aW59XpK7Qymp8iy83xq74fLr21is=\n+github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\n+github.com/go-chi/chi v4.0.2+incompatible h1:maB6vn6FqCxrpz4FqWdh4+lwpyZIQS7YEAUcHlgXVRs=\n+github.com/go-chi/chi v4.0.2+incompatible/go.mod h1:eB3wogJHnLi3x/kFX2A+IbTBlXxmMeXJVKy9tTv1XzQ=\n+github.com/go-chi/cors v1.0.0/go.mod h1:K2Yje0VW/SJzxiyMYu6iPQYa7hMjQX2i/F491VChg1I=\n+github.com/go-chi/render v1.0.1 h1:4/5tis2cKaNdnv9zFLfXzcquC9HbeZgCnxGnKrltBS8=\n+github.com/go-chi/render v1.0.1/go.mod h1:pq4Rr7HbnsdaeHagklXub+p6Wd16Af5l9koip1OvJns=\n+github.com/go-pkgz/auth v0.7.2/go.mod h1:ibOpZYISiaOvAHe2bsKj2s3v4AkMam2WxxIFn+zhulo=\n+github.com/go-pkgz/jrpc v0.1.0 h1:hNg/IyfEqJcSWOKkuHw0ZwcuGc9TDp7QZREsD2ycmiM=\n+github.com/go-pkgz/jrpc v0.1.0/go.mod h1:JxZsvoBklA50DNhELVJnJ567Rt+KrMH9rR3u515wvE8=\n+github.com/go-pkgz/lcw v0.3.1/go.mod h1:k+PY1CkCMTLXILtFoJOyK65Qqi9rkoTYunFH1vE/C0I=\n+github.com/go-pkgz/lgr v0.2.2/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n+github.com/go-pkgz/lgr v0.6.2/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n+github.com/go-pkgz/lgr v0.6.3 h1:n9pGk2paBV8w/Y/FVEq5MkwDmP33dnUPKbY4CyyygwM=\n+github.com/go-pkgz/lgr v0.6.3/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n+github.com/go-pkgz/mongo v1.1.2 h1:2Vqn3CWQJkkx4gxxDiQUitAW2FN/CH26lKHkipmpKcc=\n+github.com/go-pkgz/mongo v1.1.2/go.mod h1:0NkWnzpiUxoL5fYZuttCtJrpC67oNDidfYxcdPqHTf0=\n+github.com/go-pkgz/repeater v1.1.2/go.mod h1:QfNR/a+xqjs+f9wSxWqOQlw9aQhmKlUaSwXCiZ+Ko2w=\n+github.com/go-pkgz/rest v1.4.1 h1:DmaVLPH2O7yLehrWOW0uz01d2mVHz9fBR/iuTiPRzaw=\n+github.com/go-pkgz/rest v1.4.1/go.mod h1:COazNj35u3RXAgQNBr6neR599tYP3URiOpsu9p0rOtk=\n+github.com/go-pkgz/syncs v1.1.1/go.mod h1:bt9lxWRRJ9vOCMGc8Big8ttjYHLKP88ofj1y38UlaHE=\n+github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\n+github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\n+github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\n+github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\n+github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\n+github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\n+github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\n+github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\n+github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\n+github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\n+github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\n+github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\n+github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\n+github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\n+github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\n+github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\n+github.com/gorilla/feeds v1.1.1/go.mod h1:Nk0jZrvPFZX1OBe5NPiddPw7CfwF6Q9eqzaBbaightA=\n+github.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/UYA=\n+github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\n+github.com/hashicorp/go-multierror v1.0.0 h1:iVjPR7a6H0tWELX5NxNe7bYopibicUzc7uPribsnS6o=\n+github.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=\n+github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n+github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n+github.com/jessevdk/go-flags v0.0.0-20180331124232-1c38ed7ad0cc/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\n+github.com/jessevdk/go-flags v1.4.0 h1:4IU2WS7AumrZ/40jfhf4QVDMsQwqA7VEHozFRrGARJA=\n+github.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\n+github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\n+github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\n+github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\n+github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\n+github.com/kyokomi/emoji v2.1.0+incompatible/go.mod h1:mZ6aGCD7yk8j6QY6KICwnZ2pxoszVseX1DNoGtU2tBA=\n+github.com/microcosm-cc/bluemonday v1.0.2 h1:5lPfLTTAvAbtS0VqT+94yOtFnGfUWYyx0+iToC3Os3s=\n+github.com/microcosm-cc/bluemonday v1.0.2/go.mod h1:iVP4YcDBq+n/5fb23BhYFvIMq/leAFZyRl6bYmGDlGc=\n+github.com/nullrocks/identicon v0.0.0-20180626043057-7875f45b0022/go.mod h1:x4NsS+uc7ecH/Cbm9xKQ6XzmJM57rWTkjywjfB2yQ18=\n+github.com/patrickmn/go-cache v2.1.0+incompatible h1:HRMgzkcYKYpi3C8ajMPV8OFXaaRUnok+kx1WdO15EQc=\n+github.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=\n+github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\n+github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n+github.com/rakyll/statik v0.1.6/go.mod h1:OEi9wJV/fMUAGx1eNjq75DKDsJVuEv1U0oYdX6GX8Zs=\n+github.com/rs/xid v1.2.1/go.mod h1:+uKXf+4Djp6Md1KODXJxgGQPKngRmWyn10oCKFzNHOQ=\n+github.com/russross/blackfriday/v2 v2.0.1 h1:lPqVAte+HuHNfhJ/0LC98ESWRz8afy9tM/0RK8m9o+Q=\n+github.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\n+github.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=\n+github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\n+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\n+github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\n+github.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=\n+github.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=\n+github.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\n+github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\n+github.com/umputun/remark v1.4.0 h1:rJf4ndpvRDS7tOrtIpVkacItTxF5pVpXvDqtb1dX40M=\n+go.etcd.io/bbolt v1.3.3 h1:MUGmc65QhB3pIlaQ5bB4LwqSj6GIonVJXpZiaKNyaKk=\n+go.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\n+go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\n+go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\n+golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\n+golang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\n+golang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\n+golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\n+golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\n+golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\n+golang.org/x/image v0.0.0-20190523035834-f03afa92d3ff/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\n+golang.org/x/image v0.0.0-20190703141733-d6a02ce849c9/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\n+golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\n+golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\n+golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\n+golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\n+golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\n+golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\n+golang.org/x/net v0.0.0-20180218175443-cbe0f9307d01/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\n+golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\n+golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\n+golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\n+golang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\n+golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\n+golang.org/x/net v0.0.0-20190611141213-3f473d35a33a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n+golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n+golang.org/x/net v0.0.0-20190724013045-ca1201d0de80 h1:Ao/3l156eZf2AW5wK8a7/smtodRU+gha3+BeqJ69lRk=\n+golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n+golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\n+golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\n+golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\n+golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\n+golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n+golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n+golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190610200419-93c9922d18ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190626221950-04f50cda93cb/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/sys v0.0.0-20190801041406-cbf593c0f2f3 h1:4y9KwBHBgBNwDbtu44R5o1fdOCQUEXhbk/P4A9WmJq0=\n+golang.org/x/sys v0.0.0-20190801041406-cbf593c0f2f3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\n+golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n+golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n+golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=\n+golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\n+golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n+golang.org/x/time v0.0.0-20190308202827-9d24e82272b4 h1:SvFZT6jyqRaOeXpc5h/JSfZenJ2O330aBsf7JfSUXmQ=\n+golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\n+golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\n+golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\n+golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\n+golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\n+golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\n+golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\n+golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\n+golang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\n+golang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\n+golang.org/x/tools v0.0.0-20190624190245-7f2218787638/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\n+google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\n+google.golang.org/api v0.6.0/go.mod h1:btoxGiFvQNVUZQ8W08zLtrVS08CNpINPEfxXxgJL1Q4=\n+google.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\n+google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\n+google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\n+google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\n+google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\n+google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\n+google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\n+google.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\n+google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\n+google.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\n+google.golang.org/genproto v0.0.0-20190530194941-fb225487d101/go.mod h1:z3L6/3dTEVtUr6QSP8miRzeRqwQOioJ9I66odjN4I7s=\n+google.golang.org/genproto v0.0.0-20190626174449-989357319d63/go.mod h1:z3L6/3dTEVtUr6QSP8miRzeRqwQOioJ9I66odjN4I7s=\n+google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\n+google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=\n+google.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\n+gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\n+honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n+honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n+honnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\n+rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8="
    },
    {
      "sha": "07f2e85f3c07084030d9e553059a382f56da1752",
      "filename": "backend/_example/memory_store/main.go",
      "status": "added",
      "additions": 73,
      "deletions": 0,
      "changes": 73,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/main.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/main.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/main.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2019 Umputun. All rights reserved.\n+ * Use of this source code is governed by a MIT-style\n+ * license that can be found in the LICENSE file.\n+ */\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\n+\t\"github.com/go-pkgz/jrpc\"\n+\tlog \"github.com/go-pkgz/lgr\"\n+\t\"github.com/jessevdk/go-flags\"\n+\n+\t\"github.com/umputun/remark/memory_store/accessor\"\n+\t\"github.com/umputun/remark/memory_store/server\"\n+)\n+\n+// opts with all cli commands and flags\n+var opts struct {\n+\tAPI        string `long:\"api\" env:\"API\" default:\"/\" description:\"api root url\"`\n+\tPort       int    `long:\"port\" env:\"PORT\" default:\"8080\" description:\"rpc server port\"`\n+\tAuthUser   string `long:\"auth-user\" env:\"AUTH_USER\" default:\"\" description:\"rpc auth user name\"`\n+\tAuthPasswd string `long:\"auth-passwd\" env:\"AUTH_PASSWD\" default:\"\" description:\"rpc auth password\"`\n+\n+\tSecret string `long:\"secret\" env:\"SECRET\" required:\"true\" description:\"secret key\"`\n+\tDbg    bool   `long:\"dbg\" env:\"DEBUG\" description:\"debug mode\"`\n+}\n+\n+var revision = \"unknown\"\n+\n+func main() {\n+\tfmt.Printf(\"remark42-memory module %s\\n\", revision)\n+\n+\tif _, err := flags.Parse(&opts); err != nil {\n+\t\tos.Exit(2)\n+\t}\n+\tsetupLog(opts.Dbg)\n+\n+\tdataStore := accessor.NewMemData()\n+\tadminStore := accessor.NewMemAdminStore(opts.Secret)\n+\n+\trpcServer := jrpc.Server{\n+\t\tAPI:        opts.API,\n+\t\tAuthUser:   opts.AuthUser,\n+\t\tAuthPasswd: opts.AuthPasswd,\n+\t\tVersion:    revision,\n+\t\tAppName:    \"remark42-memory\",\n+\t\tLogger:     log.Default(),\n+\t}\n+\n+\tsrv := server.NewRPC(dataStore, adminStore, &rpcServer)\n+\n+\tadmRec := accessor.AdminRec{\n+\t\tSiteID: \"remark\",\n+\t\tIDs:    []string{\"dev_user\"},\n+\t\tEmail:  \"admin@example.com\",\n+\t}\n+\tadminStore.Set(\"remark\", admRec)\n+\n+\terr := srv.Run(opts.Port)\n+\tlog.Printf(\"[ERROR] server failed or terminated, %+v\", err)\n+}\n+\n+func setupLog(dbg bool) {\n+\tif dbg {\n+\t\tlog.Setup(log.Debug, log.CallerFile, log.CallerFunc, log.Msec, log.LevelBraces)\n+\t\treturn\n+\t}\n+\tlog.Setup(log.Msec, log.LevelBraces)\n+}"
    },
    {
      "sha": "47bcc8248c7da4408a7a46eedcd691ea645e0a3d",
      "filename": "backend/_example/memory_store/server/rpc.go",
      "status": "added",
      "additions": 183,
      "deletions": 0,
      "changes": 183,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/server/rpc.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/server/rpc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/server/rpc.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,183 @@\n+package server\n+\n+import (\n+\t\"encoding/json\"\n+\n+\t\"github.com/go-pkgz/jrpc\"\n+\n+\t\"github.com/umputun/remark/backend/app/store\"\n+\t\"github.com/umputun/remark/backend/app/store/admin\"\n+\t\"github.com/umputun/remark/backend/app/store/engine\"\n+)\n+\n+// RPC handler wraps both engine and remote server and implements all handlers for data store and admin store\n+// Note: this file can be used as-is in any custom jrpc plugin\n+type RPC struct {\n+\t*jrpc.Server\n+\teng engine.Interface\n+\tadm admin.Store\n+}\n+\n+// NewRPC makes RPC instance and register handlers\n+func NewRPC(e engine.Interface, a admin.Store, r *jrpc.Server) *RPC {\n+\tres := &RPC{eng: e, adm: a, Server: r}\n+\tres.addHandlers()\n+\treturn res\n+}\n+\n+func (s *RPC) addHandlers() {\n+\t// data store handlers\n+\ts.Group(\"store\", jrpc.HandlersGroup{\n+\t\t\"create\":     s.createHndl,\n+\t\t\"find\":       s.findHndl,\n+\t\t\"get\":        s.getHndl,\n+\t\t\"update\":     s.updateHndl,\n+\t\t\"count\":      s.countHndl,\n+\t\t\"info\":       s.infoHndl,\n+\t\t\"flag\":       s.flagHndl,\n+\t\t\"list_flags\": s.listFlagsHndl,\n+\t\t\"delete\":     s.deleteHndl,\n+\t\t\"close\":      s.closeHndl,\n+\t})\n+\n+\t// admin store handlers\n+\ts.Group(\"admin\", jrpc.HandlersGroup{\n+\t\t\"key\":    s.admKeyHndl,\n+\t\t\"admins\": s.admAdminsHndl,\n+\t\t\"email\":  s.admEmailHndl,\n+\t})\n+}\n+\n+func (s *RPC) createHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\tcomment := store.Comment{}\n+\tif err := json.Unmarshal(params, &comment); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tcommentID, err := s.eng.Create(comment)\n+\treturn jrpc.EncodeResponse(id, commentID, err)\n+}\n+\n+// Find comments\n+func (s *RPC) findHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.FindRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tresp, err := s.eng.Find(req)\n+\treturn jrpc.EncodeResponse(id, resp, err)\n+}\n+\n+// Get comment\n+func (s *RPC) getHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.GetRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tcomment, err := s.eng.Get(req)\n+\treturn jrpc.EncodeResponse(id, comment, err)\n+}\n+\n+// Update comment\n+func (s *RPC) updateHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\tcomment := store.Comment{}\n+\tif err := json.Unmarshal(params, &comment); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\terr := s.eng.Update(comment)\n+\treturn jrpc.EncodeResponse(id, nil, err)\n+}\n+\n+// counts for site and users\n+func (s *RPC) countHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.FindRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tcount, err := s.eng.Count(req)\n+\treturn jrpc.EncodeResponse(id, count, err)\n+}\n+\n+// info get post meta info\n+func (s *RPC) infoHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.InfoRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tinfo, err := s.eng.Info(req)\n+\treturn jrpc.EncodeResponse(id, info, err)\n+}\n+\n+// flagHndl get and sets flag value\n+func (s *RPC) flagHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.FlagRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tstatus, err := s.eng.Flag(req)\n+\treturn jrpc.EncodeResponse(id, status, err)\n+}\n+\n+// listFlagsHndl list flags for given request\n+func (s *RPC) listFlagsHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.FlagRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tflags, err := s.eng.ListFlags(req)\n+\treturn jrpc.EncodeResponse(id, flags, err)\n+}\n+\n+// deleteHndl remove comment(s)\n+func (s *RPC) deleteHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.DeleteRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\terr := s.eng.Delete(req)\n+\treturn jrpc.EncodeResponse(id, nil, err)\n+}\n+\n+// close store\n+func (s *RPC) closeHndl(id uint64, _ json.RawMessage) (rr jrpc.Response) {\n+\tif err := s.eng.Close(); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\treturn jrpc.Response{}\n+}\n+\n+// get admin key\n+func (s *RPC) admKeyHndl(id uint64, _ json.RawMessage) (rr jrpc.Response) {\n+\tkey, err := s.adm.Key()\n+\tif err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\treturn jrpc.EncodeResponse(id, key, err)\n+}\n+\n+// get admins list\n+func (s *RPC) admAdminsHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\tvar siteID string\n+\tif err := json.Unmarshal(params, &siteID); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\n+\tadmins, err := s.adm.Admins(siteID)\n+\tif err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\treturn jrpc.EncodeResponse(id, admins, err)\n+}\n+\n+// get admin email\n+func (s *RPC) admEmailHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\tvar siteID string\n+\tif err := json.Unmarshal(params, &siteID); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\n+\temail, err := s.adm.Email(siteID)\n+\tif err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\treturn jrpc.EncodeResponse(id, email, err)\n+}"
    },
    {
      "sha": "30f3942cff69343a91d4a17579b209e5450aecee",
      "filename": "backend/_example/memory_store/server/rpc_test.go",
      "status": "added",
      "additions": 318,
      "deletions": 0,
      "changes": 318,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/server/rpc_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/_example/memory_store/server/rpc_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/server/rpc_test.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2019 Umputun. All rights reserved.\n+ * Use of this source code is governed by a MIT-style\n+ * license that can be found in the LICENSE file.\n+ */\n+\n+package server\n+\n+import (\n+\t\"fmt\"\n+\t\"math/rand\"\n+\t\"net/http\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/go-pkgz/jrpc\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\n+\t\"github.com/umputun/remark/backend/app/store\"\n+\t\"github.com/umputun/remark/backend/app/store/admin\"\n+\t\"github.com/umputun/remark/backend/app/store/engine\"\n+\t\"github.com/umputun/remark/memory_store/accessor\"\n+)\n+\n+func TestRPC_createHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\tid, err := re.Create(store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"123456\", id)\n+}\n+\n+func TestRPC_findHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\tfindReq := engine.FindRequest{Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"}}\n+\tcomments, err := re.Find(findReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 0, len(comments))\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\tid, err := re.Create(c)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"123456\", id)\n+\n+\tcomments, err = re.Find(findReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 1, len(comments))\n+\tassert.Equal(t, c, comments[0])\n+}\n+\n+func TestRPC_getHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\treq := engine.GetRequest{\n+\t\tLocator:   store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tCommentID: \"123456\",\n+\t}\n+\n+\t_, err := re.Get(req)\n+\tassert.EqualError(t, err, \"not found\")\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\t_, err = re.Create(c)\n+\tassert.NoError(t, err)\n+\n+\tcomment, err := re.Get(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, c, comment)\n+}\n+\n+func TestRPC_updateHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\terr := re.Update(c)\n+\tassert.EqualError(t, err, \"not found\")\n+\n+\t_, err = re.Create(c)\n+\tassert.NoError(t, err)\n+\n+\tc.Text = \"updates\"\n+\terr = re.Update(c)\n+\tassert.NoError(t, err)\n+\n+\treq := engine.GetRequest{\n+\t\tLocator:   store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tCommentID: \"123456\",\n+\t}\n+\tcomment, err := re.Get(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, c, comment)\n+}\n+\n+func TestRPC_countHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\tfindReq := engine.FindRequest{Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"}}\n+\tcount, err := re.Count(findReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 0, count)\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\tid, err := re.Create(c)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"123456\", id)\n+\n+\tcount, err = re.Count(findReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 1, count)\n+}\n+\n+func TestRPC_infoHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\tid, err := re.Create(c)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"123456\", id)\n+\n+\tinfoReq := engine.InfoRequest{Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"}}\n+\tinfo, err := re.Info(infoReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, 1, len(info))\n+\ti := info[0]\n+\tassert.Equal(t, store.PostInfo{URL: \"http://example.com/post1\", Count: 1}, i)\n+}\n+\n+func TestRPC_flagHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\tid, err := re.Create(c)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"123456\", id)\n+\n+\tflagReq := engine.FlagRequest{\n+\t\tFlag: engine.Verified,\n+\t\tLocator: store.Locator{\n+\t\t\tSiteID: \"test-site\",\n+\t\t},\n+\t\tUserID: \"u1\",\n+\t}\n+\tstatus, err := re.Flag(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, false, status)\n+\n+\tflagReq.Update = engine.FlagTrue\n+\tstatus, err = re.Flag(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, true, status)\n+\n+\tflagReq.Update = engine.FlagNonSet\n+\tstatus, err = re.Flag(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, true, status)\n+}\n+\n+func TestRPC_listFlagsHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\tid, err := re.Create(c)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"123456\", id)\n+\n+\tflagReq := engine.FlagRequest{\n+\t\tFlag:   engine.Verified,\n+\t\tUserID: \"u1\",\n+\t\tLocator: store.Locator{\n+\t\t\tSiteID: \"test-site\",\n+\t\t},\n+\t}\n+\tflags, err := re.ListFlags(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, []interface{}{}, flags)\n+\n+\tflagReq.Update = engine.FlagTrue\n+\tstatus, err := re.Flag(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, true, status)\n+\n+\tflags, err = re.ListFlags(flagReq)\n+\trequire.NoError(t, err)\n+\tassert.Equal(t, []interface{}{\"u1\"}, flags)\n+}\n+\n+func TestRPC_deleteHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\treq := engine.DeleteRequest{\n+\t\tLocator:   store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tCommentID: \"123456\",\n+\t}\n+\n+\terr := re.Delete(req)\n+\tassert.EqualError(t, err, \"not found\")\n+\n+\tc := store.Comment{ID: \"123456\", Locator: store.Locator{SiteID: \"test-site\", URL: \"http://example.com/post1\"},\n+\t\tText: \"text 123\", User: store.User{ID: \"u1\", Name: \"user1\"}}\n+\t_, err = re.Create(c)\n+\tassert.NoError(t, err)\n+\n+\terr = re.Delete(req)\n+\tassert.NoError(t, err)\n+}\n+\n+func TestRPC_closeHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\terr := re.Close()\n+\tassert.NoError(t, err)\n+}\n+func TestRPC_admKeyHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tra := admin.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\tkey, err := ra.Key()\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"secret\", key)\n+}\n+\n+func TestRPC_admAdminsHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tra := admin.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\t_, err := ra.Admins(\"bad site\")\n+\tassert.EqualError(t, err, \"site bad site not found\")\n+\n+\tadmins, err := ra.Admins(\"test-site\")\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []string{\"id1\", \"id2\"}, admins)\n+}\n+\n+func TestRPC_admEmailHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tra := admin.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\t_, err := ra.Admins(\"bad site\")\n+\tassert.EqualError(t, err, \"site bad site not found\")\n+\n+\temail, err := ra.Email(\"test-site\")\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, \"admin@example.com\", email)\n+}\n+\n+func prepTestStore(t *testing.T) (s *RPC, port int, teardown func()) {\n+\tport = 40000 + int(rand.Int31n(10000))\n+\n+\tmg := accessor.NewMemData()\n+\tadm := accessor.NewMemAdminStore(\"secret\")\n+\ts = NewRPC(mg, adm, &jrpc.Server{API: \"/test\", Logger: jrpc.NoOpLogger})\n+\n+\tadmRec := accessor.AdminRec{\n+\t\tSiteID: \"test-site\",\n+\t\tIDs:    []string{\"id1\", \"id2\"},\n+\t\tEmail:  \"admin@example.com\",\n+\t}\n+\tadm.Set(\"test-site\", admRec)\n+\n+\tgo func() {\n+\t\tt.Log(s.Run(port))\n+\t}()\n+\ttime.Sleep(time.Millisecond * 10)\n+\n+\treturn s, port, func() {\n+\t\trequire.NoError(t, s.Shutdown())\n+\t}\n+}"
    },
    {
      "sha": "ffdc5092a436d2541447633e77cd0a18a2faccba",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/cmd/server.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/cmd/server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/cmd/server.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -14,6 +14,7 @@ import (\n \t\"time\"\n \n \tbolt \"github.com/coreos/bbolt\"\n+\t\"github.com/go-pkgz/jrpc\"\n \tlog \"github.com/go-pkgz/lgr\"\n \t\"github.com/kyokomi/emoji\"\n \tauthcache \"github.com/patrickmn/go-cache\"\n@@ -30,7 +31,6 @@ import (\n \t\"github.com/umputun/remark/backend/app/notify\"\n \t\"github.com/umputun/remark/backend/app/rest/api\"\n \t\"github.com/umputun/remark/backend/app/rest/proxy\"\n-\t\"github.com/umputun/remark/backend/app/rpc\"\n \t\"github.com/umputun/remark/backend/app/store\"\n \t\"github.com/umputun/remark/backend/app/store/admin\"\n \t\"github.com/umputun/remark/backend/app/store/engine\"\n@@ -108,7 +108,7 @@ type StoreGroup struct {\n \t\tPath    string        `long:\"path\" env:\"PATH\" default:\"./var\" description:\"parent dir for bolt files\"`\n \t\tTimeout time.Duration `long:\"timeout\" env:\"TIMEOUT\" default:\"30s\" description:\"bolt timeout\"`\n \t} `group:\"bolt\" namespace:\"bolt\" env-namespace:\"BOLT\"`\n-\tRPC RPCGroup `group:\"rpc\" namespace:\"rpc\" env-namespace:\"TPC\"`\n+\tRPC RPCGroup `group:\"rpc\" namespace:\"rpc\" env-namespace:\"RPC\"`\n }\n \n // ImageGroup defines options group for store pictures\n@@ -438,7 +438,7 @@ func (s *ServerCommand) makeDataStore() (result engine.Interface, err error) {\n \t\t}\n \t\tresult, err = engine.NewBoltDB(bolt.Options{Timeout: s.Store.Bolt.Timeout}, sites...)\n \tcase \"rpc\":\n-\t\tr := &engine.RPC{Client: rpc.Client{\n+\t\tr := &engine.RPC{Client: jrpc.Client{\n \t\t\tAPI:        s.Store.RPC.API,\n \t\t\tClient:     http.Client{Timeout: s.Store.RPC.TimeOut},\n \t\t\tAuthUser:   s.Store.RPC.AuthUser,\n@@ -503,7 +503,7 @@ func (s *ServerCommand) makeAdminStore() (admin.Store, error) {\n \t\t}\n \t\treturn admin.NewStaticStore(s.SharedSecret, s.Admin.Shared.Admins, s.Admin.Shared.Email), nil\n \tcase \"rpc\":\n-\t\tr := &admin.RPC{Client: rpc.Client{\n+\t\tr := &admin.RPC{Client: jrpc.Client{\n \t\t\tAPI:        s.Admin.RPC.API,\n \t\t\tClient:     http.Client{Timeout: s.Admin.RPC.TimeOut},\n \t\t\tAuthUser:   s.Admin.RPC.AuthUser,"
    },
    {
      "sha": "12b718ce3d59f6bbfedca4bb33e1fa6795fa710a",
      "filename": "backend/app/rpc/client_test.go",
      "status": "removed",
      "additions": 0,
      "deletions": 97,
      "changes": 97,
      "blob_url": "https://github.com/umputun/remark/blob/159f4d4fafbe61700c944ab44b82ed56e0bfa371/backend/app/rpc/client_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/159f4d4fafbe61700c944ab44b82ed56e0bfa371/backend/app/rpc/client_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rpc/client_test.go?ref=159f4d4fafbe61700c944ab44b82ed56e0bfa371",
      "patch": "@@ -1,97 +0,0 @@\n-package rpc\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"net/http\"\n-\t\"net/http/httptest\"\n-\t\"testing\"\n-\t\"time\"\n-\n-\t\"github.com/stretchr/testify/assert\"\n-\t\"github.com/stretchr/testify/require\"\n-)\n-\n-func TestClient_Call(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"test\",\"params\":[123,\"abc\"],\"id\":1}`, `{\"result\":\"12345\"}`)\n-\tdefer ts.Close()\n-\tc := Client{API: ts.URL, Client: http.Client{}}\n-\tresp, err := c.Call(\"test\", 123, \"abc\")\n-\tassert.NoError(t, err)\n-\tres := \"\"\n-\terr = json.Unmarshal(*resp.Result, &res)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"12345\", res)\n-\tt.Logf(\"%v %T\", res, res)\n-}\n-\n-func TestClient_CallWithObject(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"test\",\"params\":{\"F1\":123,\"F2\":\"abc\",\"F3\":\"2019-06-09T23:03:55Z\"},\"id\":1}`, `{\"result\":\"12345\"}`)\n-\tdefer ts.Close()\n-\tc := Client{API: ts.URL, Client: http.Client{}}\n-\tobj := struct {\n-\t\tF1 int\n-\t\tF2 string\n-\t\tF3 time.Time\n-\t}{\n-\t\tF1: 123,\n-\t\tF2: \"abc\",\n-\t\tF3: time.Date(2019, 6, 9, 23, 3, 55, 0, time.UTC),\n-\t}\n-\n-\tresp, err := c.Call(\"test\", obj)\n-\tassert.NoError(t, err)\n-\tres := \"\"\n-\terr = json.Unmarshal(*resp.Result, &res)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"12345\", res)\n-\tt.Logf(\"%v %T\", res, res)\n-}\n-\n-func TestClient_CallWithNoParams(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"test\",\"id\":1}`, `{\"result\":\"12345\"}`)\n-\tdefer ts.Close()\n-\tc := Client{API: ts.URL, Client: http.Client{}}\n-\tresp, err := c.Call(\"test\")\n-\tassert.NoError(t, err)\n-\tres := \"\"\n-\terr = json.Unmarshal(*resp.Result, &res)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"12345\", res)\n-\tt.Logf(\"%v %T\", res, res)\n-}\n-\n-func TestClient_CallError(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"test\",\"params\":[123,\"abc\"],\"id\":1}`, `{\"error\":\"some error\"}`)\n-\tdefer ts.Close()\n-\tc := Client{API: ts.URL, Client: http.Client{}}\n-\t_, err := c.Call(\"test\", 123, \"abc\")\n-\tassert.EqualError(t, err, \"some error\")\n-}\n-\n-func TestClient_CallBadResponse(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"test\",\"params\":[123,\"abc\"],\"id\":1}`, `{\"result\":\"12345 invalid}`)\n-\tdefer ts.Close()\n-\tc := Client{API: ts.URL, Client: http.Client{}}\n-\t_, err := c.Call(\"test\", 123, \"abc\")\n-\tassert.NotNil(t, err)\n-}\n-\n-func TestClient_CallBadRemote(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"test\",\"params\":[123,\"abc\"],\"id\":1}`, `{\"result\":\"12345\"}`)\n-\tdefer ts.Close()\n-\tc := Client{API: \"http://127.0.0.2\", Client: http.Client{Timeout: 10 * time.Millisecond}}\n-\t_, err := c.Call(\"test\", 123)\n-\tassert.NotNil(t, err)\n-}\n-\n-func testServer(t *testing.T, req, resp string) *httptest.Server {\n-\treturn httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n-\t\tbody, err := ioutil.ReadAll(r.Body)\n-\t\trequire.NoError(t, err)\n-\t\tassert.Equal(t, req, string(body))\n-\t\tt.Logf(\"req: %s\", string(body))\n-\t\tfmt.Fprintf(w, resp)\n-\t}))\n-}"
    },
    {
      "sha": "48d8ac50ad221a9e6e4dbdaf29af72a8d20ef014",
      "filename": "backend/app/rpc/remote.go",
      "status": "removed",
      "additions": 0,
      "deletions": 23,
      "changes": 23,
      "blob_url": "https://github.com/umputun/remark/blob/159f4d4fafbe61700c944ab44b82ed56e0bfa371/backend/app/rpc/remote.go",
      "raw_url": "https://github.com/umputun/remark/raw/159f4d4fafbe61700c944ab44b82ed56e0bfa371/backend/app/rpc/remote.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rpc/remote.go?ref=159f4d4fafbe61700c944ab44b82ed56e0bfa371",
      "patch": "@@ -1,23 +0,0 @@\n-// Package rpc implements client ans server for RPC-like communication with remote storage.\n-// The protocol is somewhat simplified version of json-rpc with a single POST call sending\n-// Request json (method name and the list of parameters) and receiving back json Response with \"result\" json\n-// and error string\n-package rpc\n-\n-import (\n-\t\"encoding/json\"\n-)\n-\n-// Request encloses method name and all params\n-type Request struct {\n-\tMethod string      `json:\"method\"`\n-\tParams interface{} `json:\"params,omitempty\"`\n-\tID     uint64      `json:\"id\"`\n-}\n-\n-// Response encloses result and error received from remote server\n-type Response struct {\n-\tResult *json.RawMessage `json:\"result,omitempty\"`\n-\tError  string           `json:\"error,omitempty\"`\n-\tID     uint64           `json:\"id\"`\n-}"
    },
    {
      "sha": "c39fe51a72fefb8b23a0c6152f96a80bda938bed",
      "filename": "backend/app/rpc/server_test.go",
      "status": "removed",
      "additions": 0,
      "deletions": 245,
      "changes": 245,
      "blob_url": "https://github.com/umputun/remark/blob/159f4d4fafbe61700c944ab44b82ed56e0bfa371/backend/app/rpc/server_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/159f4d4fafbe61700c944ab44b82ed56e0bfa371/backend/app/rpc/server_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rpc/server_test.go?ref=159f4d4fafbe61700c944ab44b82ed56e0bfa371",
      "patch": "@@ -1,245 +0,0 @@\n-package rpc\n-\n-import (\n-\t\"bytes\"\n-\t\"encoding/json\"\n-\t\"io/ioutil\"\n-\t\"net/http\"\n-\t\"net/http/httptest\"\n-\t\"testing\"\n-\t\"time\"\n-\n-\t\"github.com/pkg/errors\"\n-\t\"github.com/stretchr/testify/assert\"\n-\t\"github.com/stretchr/testify/require\"\n-)\n-\n-func TestServerPrimitiveTypes(t *testing.T) {\n-\ts := Server{API: \"/v1/cmd\"}\n-\n-\ttype respData struct {\n-\t\tRes1 string\n-\t\tRes2 bool\n-\t}\n-\n-\ts.Add(\"test\", func(id uint64, params json.RawMessage) Response {\n-\t\targs := []interface{}{}\n-\t\tif err := json.Unmarshal(params, &args); err != nil {\n-\t\t\treturn Response{Error: err.Error()}\n-\t\t}\n-\t\tt.Logf(\"%+v\", args)\n-\n-\t\tassert.Equal(t, 3, len(args))\n-\t\tassert.Equal(t, \"blah\", args[0].(string))\n-\t\tassert.Equal(t, 42., args[1].(float64))\n-\t\tassert.Equal(t, true, args[2].(bool))\n-\n-\t\tr, err := s.EncodeResponse(id, respData{\"res blah\", true}, nil)\n-\t\tassert.NoError(t, err)\n-\t\treturn r\n-\t})\n-\n-\tgo func() { _ = s.Run(9091) }()\n-\tdefer func() { assert.NoError(t, s.Shutdown()) }()\n-\ttime.Sleep(10 * time.Millisecond)\n-\n-\t// check with direct http call\n-\tclientReq := Request{Method: \"test\", Params: []interface{}{\"blah\", 42, true}, ID: 123}\n-\tb := bytes.Buffer{}\n-\trequire.NoError(t, json.NewEncoder(&b).Encode(clientReq))\n-\tresp, err := http.Post(\"http://127.0.0.1:9091/v1/cmd\", \"application/json\", &b)\n-\trequire.NoError(t, err)\n-\tdefer resp.Body.Close()\n-\tassert.Equal(t, 200, resp.StatusCode)\n-\tdata, err := ioutil.ReadAll(resp.Body)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, `{\"result\":{\"Res1\":\"res blah\",\"Res2\":true},\"id\":123}`+\"\\n\", string(data))\n-\n-\t// check with client call\n-\tc := Client{API: \"http://127.0.0.1:9091/v1/cmd\", Client: http.Client{}}\n-\tr, err := c.Call(\"test\", \"blah\", 42, true)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"\", r.Error)\n-\n-\tres := respData{}\n-\terr = json.Unmarshal(*r.Result, &res)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, respData{Res1: \"res blah\", Res2: true}, res)\n-\tassert.Equal(t, uint64(1), r.ID)\n-}\n-\n-func TestServerWithObject(t *testing.T) {\n-\ts := Server{API: \"/v1/cmd\"}\n-\n-\ttype respData struct {\n-\t\tRes1 string\n-\t\tRes2 bool\n-\t}\n-\n-\ttype reqData struct {\n-\t\tTime time.Time\n-\t\tF1   string\n-\t\tF2   time.Duration\n-\t}\n-\n-\ts.Add(\"test\", func(id uint64, params json.RawMessage) Response {\n-\t\targ := reqData{}\n-\t\tif err := json.Unmarshal(params, &arg); err != nil {\n-\t\t\treturn Response{Error: err.Error()}\n-\t\t}\n-\t\tt.Logf(\"%+v\", arg)\n-\n-\t\tr, err := s.EncodeResponse(id, respData{\"res blah\", true}, nil)\n-\t\tassert.NoError(t, err)\n-\t\treturn r\n-\t})\n-\n-\tgo func() { _ = s.Run(9091) }()\n-\tdefer func() { assert.NoError(t, s.Shutdown()) }()\n-\ttime.Sleep(10 * time.Millisecond)\n-\n-\tc := Client{API: \"http://127.0.0.1:9091/v1/cmd\", Client: http.Client{}}\n-\tr, err := c.Call(\"test\", reqData{Time: time.Now(), F1: \"sawert\", F2: time.Minute})\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"\", r.Error)\n-\n-\tres := respData{}\n-\terr = json.Unmarshal(*r.Result, &res)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, respData{Res1: \"res blah\", Res2: true}, res)\n-}\n-\n-func TestServerMethodNotImplemented(t *testing.T) {\n-\ts := Server{}\n-\tts := httptest.NewServer(http.HandlerFunc(s.handler))\n-\tdefer ts.Close()\n-\ts.Add(\"test\", func(id uint64, params json.RawMessage) Response {\n-\t\treturn Response{}\n-\t})\n-\n-\tr := Request{Method: \"blah\"}\n-\tbuf := bytes.Buffer{}\n-\tassert.NoError(t, json.NewEncoder(&buf).Encode(r))\n-\tresp, err := http.Post(ts.URL, \"application/json\", &buf)\n-\trequire.NoError(t, err)\n-\tassert.Equal(t, http.StatusNotImplemented, resp.StatusCode)\n-\n-\tassert.EqualError(t, s.Shutdown(), \"http server is not running\")\n-}\n-\n-func TestServerWithAuth(t *testing.T) {\n-\ts := Server{API: \"/v1/cmd\", AuthUser: \"user\", AuthPasswd: \"passwd\"}\n-\n-\ts.Add(\"test\", func(id uint64, params json.RawMessage) Response {\n-\t\targs := []interface{}{}\n-\t\tif err := json.Unmarshal(params, &args); err != nil {\n-\t\t\treturn Response{Error: err.Error()}\n-\t\t}\n-\t\tt.Logf(\"%+v\", args)\n-\n-\t\tassert.Equal(t, 3, len(args))\n-\t\tassert.Equal(t, \"blah\", args[0].(string))\n-\t\tassert.Equal(t, 42., args[1].(float64))\n-\t\tassert.Equal(t, true, args[2].(bool))\n-\n-\t\tr, err := s.EncodeResponse(id, \"res blah\", nil)\n-\t\tassert.NoError(t, err)\n-\t\treturn r\n-\t})\n-\n-\tgo func() { _ = s.Run(9091) }()\n-\ttime.Sleep(10 * time.Millisecond)\n-\tdefer func() { assert.NoError(t, s.Shutdown()) }()\n-\n-\tc := Client{API: \"http://127.0.0.1:9091/v1/cmd\", Client: http.Client{}, AuthUser: \"user\", AuthPasswd: \"passwd\"}\n-\tr, err := c.Call(\"test\", \"blah\", 42, true)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"\", r.Error)\n-\tval := \"\"\n-\terr = json.Unmarshal(*r.Result, &val)\n-\tassert.NoError(t, err)\n-\tassert.Equal(t, \"res blah\", val)\n-\n-\tc = Client{API: \"http://127.0.0.1:9091/v1/cmd\", Client: http.Client{}}\n-\t_, err = c.Call(\"test\", \"blah\", 42, true)\n-\tassert.EqualError(t, err, \"bad status 401 Unauthorized for test\")\n-}\n-\n-func TestServerErrReturn(t *testing.T) {\n-\ts := Server{API: \"/v1/cmd\", AuthUser: \"user\", AuthPasswd: \"passwd\"}\n-\n-\ts.Add(\"test\", func(id uint64, params json.RawMessage) Response {\n-\t\targs := []interface{}{}\n-\t\tif err := json.Unmarshal(params, &args); err != nil {\n-\t\t\treturn Response{Error: err.Error()}\n-\t\t}\n-\t\tt.Logf(\"%+v\", args)\n-\n-\t\tassert.Equal(t, 3, len(args))\n-\t\tassert.Equal(t, \"blah\", args[0].(string))\n-\t\tassert.Equal(t, 42., args[1].(float64))\n-\t\tassert.Equal(t, true, args[2].(bool))\n-\n-\t\tr, err := s.EncodeResponse(id, \"res blah\", errors.New(\"some error\"))\n-\t\tassert.NoError(t, err)\n-\t\treturn r\n-\t})\n-\n-\tgo func() { _ = s.Run(9091) }()\n-\tdefer func() { assert.NoError(t, s.Shutdown()) }()\n-\ttime.Sleep(10 * time.Millisecond)\n-\n-\tc := Client{API: \"http://127.0.0.1:9091/v1/cmd\", Client: http.Client{}, AuthUser: \"user\", AuthPasswd: \"passwd\"}\n-\t_, err := c.Call(\"test\", \"blah\", 42, true)\n-\tassert.EqualError(t, err, \"some error\")\n-}\n-\n-func TestServerGroup(t *testing.T) {\n-\ts := Server{API: \"/v1/cmd\"}\n-\ts.Group(\"pre\", HandlersGroup{\n-\t\t\"fn1\": func(id uint64, params json.RawMessage) Response {\n-\t\t\treturn Response{}\n-\t\t},\n-\t\t\"fn2\": func(id uint64, params json.RawMessage) Response {\n-\t\t\treturn Response{}\n-\t\t},\n-\t})\n-\tgo func() { _ = s.Run(9091) }()\n-\tdefer func() { assert.NoError(t, s.Shutdown()) }()\n-\ttime.Sleep(10 * time.Millisecond)\n-\n-\tc := Client{API: \"http://127.0.0.1:9091/v1/cmd\", Client: http.Client{}}\n-\t_, err := c.Call(\"fn1\")\n-\tassert.EqualError(t, err, \"bad status 501 Not Implemented for fn1\")\n-\n-\t_, err = c.Call(\"pre.fn1\")\n-\tassert.NoError(t, err)\n-\t_, err = c.Call(\"pre.fn2\")\n-\tassert.NoError(t, err)\n-}\n-\n-func TestServerAddLate(t *testing.T) {\n-\ts := Server{API: \"/v1/cmd\"}\n-\ts.Add(\"fn1\", func(id uint64, params json.RawMessage) Response {\n-\t\treturn Response{}\n-\t})\n-\tgo func() { _ = s.Run(9091) }()\n-\tdefer func() { assert.NoError(t, s.Shutdown()) }()\n-\ttime.Sleep(10 * time.Millisecond)\n-\n-\t// too late, ignored after run\n-\ts.Add(\"fn2\", func(id uint64, params json.RawMessage) Response {\n-\t\treturn Response{}\n-\t})\n-\n-\tc := Client{API: \"http://127.0.0.1:9091/v1/cmd\", Client: http.Client{}}\n-\t_, err := c.Call(\"fn1\")\n-\tassert.NoError(t, err)\n-\t_, err = c.Call(\"fn2\")\n-\tassert.EqualError(t, err, \"bad status 501 Not Implemented for fn2\")\n-}\n-\n-func TestServerNoHandlers(t *testing.T) {\n-\ts := Server{API: \"/v1/cmd\", AuthUser: \"user\", AuthPasswd: \"passwd\"}\n-\tassert.EqualError(t, s.Run(9091), \"nothing mapped for dispatch, Add has to be called prior to Run\")\n-}"
    },
    {
      "sha": "08a9fccdc3a5009934d8a63ba4abad2ba26fe15a",
      "filename": "backend/app/store/admin/remote.go",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/admin/remote.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/admin/remote.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/admin/remote.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -9,12 +9,12 @@ package admin\n import (\n \t\"encoding/json\"\n \n-\t\"github.com/umputun/remark/backend/app/rpc\"\n+\t\"github.com/go-pkgz/jrpc\"\n )\n \n // RPC implements remote engine and delegates all Calls to remote http server\n type RPC struct {\n-\trpc.Client\n+\tjrpc.Client\n }\n \n // Key returns the key, same for all sites"
    },
    {
      "sha": "ebf4bb38c2a9308d29919eb2c05f953fe8e8db3f",
      "filename": "backend/app/store/admin/remote_test.go",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/admin/remote_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/admin/remote_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/admin/remote_test.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -13,17 +13,16 @@ import (\n \t\"net/http/httptest\"\n \t\"testing\"\n \n+\t\"github.com/go-pkgz/jrpc\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n-\n-\t\"github.com/umputun/remark/backend/app/rpc\"\n )\n \n func TestRemote_Key(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"admin.key\",\"id\":1}`,\n \t\t`{\"result\":\"12345\",\"id\":1}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tvar a Store = &c\n \t_ = a\n@@ -35,10 +34,10 @@ func TestRemote_Key(t *testing.T) {\n }\n \n func TestRemote_Admins(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"admin.admins\",\"params\":[\"site-1\"],\"id\":1}`,\n+\tts := testServer(t, `{\"method\":\"admin.admins\",\"params\":\"site-1\",\"id\":1}`,\n \t\t`{\"result\":[\"id1\",\"id2\"],\"id\":1}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tvar a Store = &c\n \t_ = a\n@@ -50,10 +49,10 @@ func TestRemote_Admins(t *testing.T) {\n }\n \n func TestRemote_Email(t *testing.T) {\n-\tts := testServer(t, `{\"method\":\"admin.email\",\"params\":[\"site-1\"],\"id\":1}`,\n+\tts := testServer(t, `{\"method\":\"admin.email\",\"params\":\"site-1\",\"id\":1}`,\n \t\t`{\"result\":\"bbb@example.com\",\"id\":1}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tvar a Store = &c\n \t_ = a"
    },
    {
      "sha": "186ff9f03561a0c33f72da3f2a05c24c9f9cd3a8",
      "filename": "backend/app/store/engine/remote.go",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/engine/remote.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/engine/remote.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/remote.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -3,13 +3,14 @@ package engine\n import (\n \t\"encoding/json\"\n \n-\t\"github.com/umputun/remark/backend/app/rpc\"\n+\t\"github.com/go-pkgz/jrpc\"\n+\n \t\"github.com/umputun/remark/backend/app/store\"\n )\n \n // RPC implements remote engine and delegates all Calls to remote http server\n type RPC struct {\n-\trpc.Client\n+\tjrpc.Client\n }\n \n // Create comment and return ID"
    },
    {
      "sha": "b97b637c34f2e3e10f8d0fc99945bfe3dd85bbe4",
      "filename": "backend/app/store/engine/remote_test.go",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/engine/remote_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/engine/remote_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/remote_test.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -9,18 +9,18 @@ import (\n \t\"testing\"\n \t\"time\"\n \n+\t\"github.com/go-pkgz/jrpc\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n \n-\t\"github.com/umputun/remark/backend/app/rpc\"\n \t\"github.com/umputun/remark/backend/app/store\"\n )\n \n func TestRemote_Create(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.create\",\"params\":{\"id\":\"123\",\"pid\":\"\",\"text\":\"msg\",\"user\":{\"name\":\"\",\"id\":\"\",\"picture\":\"\",\"admin\":false},\"locator\":{\"site\":\"site\",\"url\":\"http://example.com/url\"},\"score\":0,\"vote\":0,\"time\":\"0001-01-01T00:00:00Z\"},\"id\":1}`,\n \t\t`{\"result\":\"12345\",\"id\":1}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tvar eng Interface = &c\n \t_ = eng\n@@ -35,7 +35,7 @@ func TestRemote_Create(t *testing.T) {\n func TestRemote_Get(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.get\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"comment_id\":\"site\"},\"id\":1}`, `{\"result\":{\"id\":\"123\",\"pid\":\"\",\"text\":\"msg\",\"delete\":true}}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \treq := GetRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, CommentID: \"site\"}\n \tres, err := c.Get(req)\n@@ -47,7 +47,7 @@ func TestRemote_Get(t *testing.T) {\n func TestRemote_GetWithErrorResult(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.get\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"comment_id\":\"site\"},\"id\":1}`, `{\"error\":\"failed\"}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \treq := GetRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, CommentID: \"site\"}\n \t_, err := c.Get(req)\n@@ -57,15 +57,15 @@ func TestRemote_GetWithErrorResult(t *testing.T) {\n func TestRemote_GetWithErrorDecode(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.get\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"comment_id\":\"site\"},\"id\":1}`, ``)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \treq := GetRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, CommentID: \"site\"}\n \t_, err := c.Get(req)\n \tassert.EqualError(t, err, \"failed to decode response for store.get: EOF\")\n }\n \n func TestRemote_GetWithErrorRemote(t *testing.T) {\n-\tc := RPC{Client: rpc.Client{API: \"http://127.0.0.2\", Client: http.Client{Timeout: 10 * time.Millisecond}}}\n+\tc := RPC{Client: jrpc.Client{API: \"http://127.0.0.2\", Client: http.Client{Timeout: 10 * time.Millisecond}}}\n \n \treq := GetRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, CommentID: \"site\"}\n \t_, err := c.Get(req)\n@@ -81,7 +81,7 @@ func TestRemote_FailedStatus(t *testing.T) {\n \t\tw.WriteHeader(400)\n \t}))\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \treq := GetRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, CommentID: \"site\"}\n \t_, err := c.Get(req)\n@@ -91,7 +91,7 @@ func TestRemote_FailedStatus(t *testing.T) {\n func TestRemote_Update(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.update\",\"params\":{\"id\":\"123\",\"pid\":\"\",\"text\":\"msg\",\"user\":{\"name\":\"\",\"id\":\"\",\"picture\":\"\",\"admin\":false},\"locator\":{\"site\":\"site123\",\"url\":\"http://example.com/url\"},\"score\":0,\"vote\":0,\"time\":\"0001-01-01T00:00:00Z\"},\"id\":1}`, `{}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \terr := c.Update(store.Comment{ID: \"123\", Locator: store.Locator{URL: \"http://example.com/url\", SiteID: \"site123\"},\n \t\tText: \"msg\"})\n@@ -102,7 +102,7 @@ func TestRemote_Update(t *testing.T) {\n func TestRemote_Find(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.find\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"sort\":\"-time\",\"since\":\"0001-01-01T00:00:00Z\",\"limit\":10},\"id\":1}`, `{\"result\":[{\"text\":\"1\"},{\"text\":\"2\"}]}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tres, err := c.Find(FindRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, Sort: \"-time\", Limit: 10})\n \tassert.NoError(t, err)\n@@ -112,7 +112,7 @@ func TestRemote_Find(t *testing.T) {\n func TestRemote_Info(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.info\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"limit\":10,\"skip\":5,\"ro_age\":10},\"id\":1}`, `{\"result\":[{\"url\":\"u1\",\"count\":22},{\"url\":\"u2\",\"count\":33}]}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tres, err := c.Info(InfoRequest{Locator: store.Locator{URL: \"http://example.com/url\"},\n \t\tLimit: 10, Skip: 5, ReadOnlyAge: 10})\n@@ -123,7 +123,7 @@ func TestRemote_Info(t *testing.T) {\n func TestRemote_Flag(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.flag\",\"params\":{\"flag\":\"verified\",\"locator\":{\"url\":\"http://example.com/url\"}},\"id\":1}`, `{\"result\":false}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tres, err := c.Flag(FlagRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, Flag: Verified})\n \tassert.NoError(t, err)\n@@ -133,7 +133,7 @@ func TestRemote_Flag(t *testing.T) {\n func TestRemote_ListFlag(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.list_flags\",\"params\":{\"flag\":\"blocked\",\"locator\":{\"site\":\"site_id\",\"url\":\"\"}},\"id\":1}`, `{\"result\":[{\"ID\":\"id1\"},{\"ID\":\"id2\"}]}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \tres, err := c.ListFlags(FlagRequest{Locator: store.Locator{SiteID: \"site_id\"}, Flag: Blocked})\n \tassert.NoError(t, err)\n \tassert.Equal(t, []interface{}{map[string]interface{}{\"ID\": \"id1\"}, map[string]interface{}{\"ID\": \"id2\"}}, res)\n@@ -142,7 +142,7 @@ func TestRemote_ListFlag(t *testing.T) {\n func TestRemote_Count(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.count\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"since\":\"0001-01-01T00:00:00Z\"},\"id\":1}`, `{\"result\":11}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \tres, err := c.Count(FindRequest{Locator: store.Locator{URL: \"http://example.com/url\"}})\n \tassert.NoError(t, err)\n@@ -153,7 +153,7 @@ func TestRemote_Delete(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.delete\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"del_mode\":0},\"id\":1}`,\n \t\t`{}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \n \terr := c.Delete(DeleteRequest{Locator: store.Locator{URL: \"http://example.com/url\"}})\n \tassert.NoError(t, err)\n@@ -162,7 +162,7 @@ func TestRemote_Delete(t *testing.T) {\n func TestRemote_Close(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.close\",\"id\":1}`, `{}`)\n \tdefer ts.Close()\n-\tc := RPC{Client: rpc.Client{API: ts.URL, Client: http.Client{}}}\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n \terr := c.Close()\n \tassert.NoError(t, err)\n }"
    },
    {
      "sha": "820b37feb406dc5cc42dcc9acccb7e9cd278fcf2",
      "filename": "backend/app/store/service/service.go",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/service/service.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/app/store/service/service.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/service/service.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -469,6 +469,7 @@ func (s *DataStore) ValidateComment(c *store.Comment) error {\n func (s *DataStore) IsAdmin(siteID string, userID string) bool {\n \tadmins, err := s.AdminStore.Admins(siteID)\n \tif err != nil {\n+\t\tlog.Printf(\"[WARN] can't get admins for %s, %v\", siteID, err)\n \t\treturn false\n \t}\n \tfor _, a := range admins {"
    },
    {
      "sha": "4b78ea1ff13e3e455949325b951e7bf2b3b1170d",
      "filename": "backend/go.mod",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.mod?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -9,12 +9,13 @@ require (\n \tgithub.com/PuerkitoBio/goquery v1.5.0\n \tgithub.com/coreos/bbolt v1.3.3\n \tgithub.com/dgrijalva/jwt-go v3.2.0+incompatible\n-\tgithub.com/didip/tollbooth v4.0.0+incompatible\n+\tgithub.com/didip/tollbooth v4.0.2+incompatible\n \tgithub.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d\n \tgithub.com/go-chi/chi v4.0.2+incompatible\n \tgithub.com/go-chi/cors v1.0.0\n \tgithub.com/go-chi/render v1.0.1\n \tgithub.com/go-pkgz/auth v0.7.2\n+\tgithub.com/go-pkgz/jrpc v0.1.0\n \tgithub.com/go-pkgz/lcw v0.3.1\n \tgithub.com/go-pkgz/lgr v0.6.3\n \tgithub.com/go-pkgz/repeater v1.1.2\n@@ -35,7 +36,7 @@ require (\n \tgithub.com/stretchr/testify v1.3.0\n \tgolang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4\n \tgolang.org/x/image v0.0.0-20190703141733-d6a02ce849c9\n-\tgolang.org/x/net v0.0.0-20190628185345-da137c7871d7\n+\tgolang.org/x/net v0.0.0-20190724013045-ca1201d0de80\n \tgolang.org/x/sys v0.0.0-20190626221950-04f50cda93cb // indirect\n \tgopkg.in/russross/blackfriday.v2 v2.0.1\n )"
    },
    {
      "sha": "2936f18e7443c725a00b2aeed65ab4b572cbc0ea",
      "filename": "backend/go.sum",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/go.sum?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -21,6 +21,8 @@ github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumC\n github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\n github.com/didip/tollbooth v4.0.0+incompatible h1:ayQZYuF5QOxx3NdYRNuRVFLv9/2b64JtSUlewb+0TMo=\n github.com/didip/tollbooth v4.0.0+incompatible/go.mod h1:A9b0665CE6l1KmzpDws2++elm/CsuWBMa5Jv4WY0PEY=\n+github.com/didip/tollbooth v4.0.2+incompatible h1:fVSa33JzSz0hoh2NxpwZtksAzAgd7zjmGO20HCZtF4M=\n+github.com/didip/tollbooth v4.0.2+incompatible/go.mod h1:A9b0665CE6l1KmzpDws2++elm/CsuWBMa5Jv4WY0PEY=\n github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d h1:vs5Nf6IE0N/PwGJ8//zRed4gpCdcr99K2HzX7RuLOQ8=\n github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d/go.mod h1:YWyIfq3y4ArRfWZ9XksmuusP+7Mad+T0iFZ0kv0XG/M=\n github.com/globalsign/mgo v0.0.0-20180615134936-113d3961e731/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\n@@ -34,6 +36,8 @@ github.com/go-chi/render v1.0.1 h1:4/5tis2cKaNdnv9zFLfXzcquC9HbeZgCnxGnKrltBS8=\n github.com/go-chi/render v1.0.1/go.mod h1:pq4Rr7HbnsdaeHagklXub+p6Wd16Af5l9koip1OvJns=\n github.com/go-pkgz/auth v0.7.2 h1:+LvAgqwQtYuWphpZE8qLtspVd65+VgreJkFLsKrtmmk=\n github.com/go-pkgz/auth v0.7.2/go.mod h1:ibOpZYISiaOvAHe2bsKj2s3v4AkMam2WxxIFn+zhulo=\n+github.com/go-pkgz/jrpc v0.1.0 h1:hNg/IyfEqJcSWOKkuHw0ZwcuGc9TDp7QZREsD2ycmiM=\n+github.com/go-pkgz/jrpc v0.1.0/go.mod h1:JxZsvoBklA50DNhELVJnJ567Rt+KrMH9rR3u515wvE8=\n github.com/go-pkgz/lcw v0.3.1 h1:PhfB0xNUawLMlx5rXvOTIc7d5LMrr1GM9vIzmG96aUI=\n github.com/go-pkgz/lcw v0.3.1/go.mod h1:k+PY1CkCMTLXILtFoJOyK65Qqi9rkoTYunFH1vE/C0I=\n github.com/go-pkgz/lgr v0.2.2/go.mod h1:hBM1NM/SoYdlrykgdgJWGrZ/TM/XaZIjRbJfx7NkMm8=\n@@ -115,6 +119,7 @@ github.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=\n github.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=\n github.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\n github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\n+github.com/umputun/remark v1.4.0 h1:rJf4ndpvRDS7tOrtIpVkacItTxF5pVpXvDqtb1dX40M=\n go.etcd.io/bbolt v1.3.3 h1:MUGmc65QhB3pIlaQ5bB4LwqSj6GIonVJXpZiaKNyaKk=\n go.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\n go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\n@@ -153,6 +158,8 @@ golang.org/x/net v0.0.0-20190611141213-3f473d35a33a/go.mod h1:z5CRVTTTmAJ677TzLL\n golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n golang.org/x/net v0.0.0-20190628185345-da137c7871d7 h1:rTIdg5QFRR7XCaK4LCjBiPbx8j4DQRpdYMnGn/bJUEU=\n golang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n+golang.org/x/net v0.0.0-20190724013045-ca1201d0de80 h1:Ao/3l156eZf2AW5wK8a7/smtodRU+gha3+BeqJ69lRk=\n+golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\n golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\n golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45 h1:SVwTIAaPC2U/AvvLNZ2a7OVsmBpC8L5BlwK1whH3hm0="
    },
    {
      "sha": "32d96ec3de9a57e0b7ca90b34bc0f52b6736271e",
      "filename": "backend/nginx-proxy-example.conf",
      "status": "modified",
      "additions": 0,
      "deletions": 16,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/nginx-proxy-example.conf",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/nginx-proxy-example.conf",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/nginx-proxy-example.conf?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -14,22 +14,6 @@ server {\n     limit_conn perip 10;\n \n     location / {\n-\n-        #CORS\n-        add_header 'Access-Control-Allow-Origin' '*';\n-        add_header 'Access-Control-Allow-Methods' 'GET, PUT, POST, DELETE, OPTIONS';\n-        add_header Access-Control-Allow-Headers \"Content-Type, Authorization, X-Requested-With\";\n-        if ($request_method = 'OPTIONS') {\n-             add_header 'Access-Control-Allow-Origin' '*';\n-             add_header 'Access-Control-Allow-Methods' 'GET, PUT, POST, DELETE, OPTIONS';\n-             add_header 'Access-Control-Max-Age'        86400;\n-             add_header 'Access-Control-Allow-Credentials' 'true';\n-             add_header 'Access-Control-Allow-Headers' 'Authorization,DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type';\n-             add_header 'Content-Length' 0;\n-             add_header 'Content-Type' 'text/plain; charset=UTF-8';\n-             return 204;\n-         }\n-\n          proxy_redirect          off;\n          proxy_set_header        X-Real-IP $remote_addr;\n          proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;"
    },
    {
      "sha": "f61458797a305e48067d46e4a5ea34e27ef5d95e",
      "filename": "backend/vendor/github.com/didip/tollbooth/README.md",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/didip/tollbooth/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/didip/tollbooth/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/didip/tollbooth/README.md?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -7,9 +7,7 @@ This is a generic middleware to rate-limit HTTP requests.\n \n **NOTE 1:** This library is considered finished.\n \n-**NOTE 2:** In the coming weeks, I will be removing thirdparty modules and moving them to their own dedicated repos.\n-\n-**NOTE 3:** Major version changes are backward-incompatible. `v2.0.0` streamlines the ugliness of the old API.\n+**NOTE 2:** Major version changes are backward-incompatible. `v2.0.0` streamlines the ugliness of the old API.\n \n \n ## Versions\n@@ -21,7 +19,7 @@ This is a generic middleware to rate-limit HTTP requests.\n **v3.x.x:** Apparently we have been using golang.org/x/time/rate incorrectly. See issue #48. It always limit X number per 1 second. The time duration is not changeable, so it does not make sense to pass TTL to tollbooth.\n \n \n-## Five Minutes Tutorial\n+## Five Minute Tutorial\n ```go\n package main\n \n@@ -161,4 +159,6 @@ Sometimes, other frameworks require a little bit of shim to use Tollbooth. These\n \n * [Stopwatch](https://github.com/didip/stopwatch): A small library to measure latency of things. Useful if you want to report latency data to Graphite.\n \n+* [LaborUnion](https://github.com/didip/laborunion): A dynamic worker pool library.\n+\n * [Gomet](https://github.com/didip/gomet): Simple HTTP client & server long poll library for Go. Useful for receiving live updates without needing Websocket."
    },
    {
      "sha": "b4f7b3e89dbb8d56f63826682034f32f9940a731",
      "filename": "backend/vendor/github.com/didip/tollbooth/tollbooth.go",
      "status": "modified",
      "additions": 21,
      "deletions": 11,
      "changes": 32,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/didip/tollbooth/tollbooth.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/didip/tollbooth/tollbooth.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/didip/tollbooth/tollbooth.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -6,10 +6,11 @@ import (\n \t\"strings\"\n \n \t\"fmt\"\n+\t\"math\"\n+\n \t\"github.com/didip/tollbooth/errors\"\n \t\"github.com/didip/tollbooth/libstring\"\n \t\"github.com/didip/tollbooth/limiter\"\n-\t\"math\"\n )\n \n // setResponseHeaders configures X-Rate-Limit-Limit and X-Rate-Limit-Duration\n@@ -58,18 +59,21 @@ func BuildKeys(lmt *limiter.Limiter, r *http.Request) [][]string {\n \t\tif libstring.StringInSlice(lmtMethods, r.Method) {\n \t\t\tfor headerKey, headerValues := range lmtHeaders {\n \t\t\t\tif (headerValues == nil || len(headerValues) <= 0) && r.Header.Get(headerKey) != \"\" {\n-\t\t\t\t\t// If header values are empty, rate-limit all request with headerKey.\n+\t\t\t\t\t// If header values are empty, rate-limit all request containing headerKey.\n \t\t\t\t\tusername, _, ok := r.BasicAuth()\n \t\t\t\t\tif ok && libstring.StringInSlice(lmtBasicAuthUsers, username) {\n-\t\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey, username})\n+\t\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey, r.Header.Get(headerKey), username})\n \t\t\t\t\t}\n \n \t\t\t\t} else if len(headerValues) > 0 && r.Header.Get(headerKey) != \"\" {\n \t\t\t\t\t// If header values are not empty, rate-limit all request with headerKey and headerValues.\n \t\t\t\t\tfor _, headerValue := range headerValues {\n-\t\t\t\t\t\tusername, _, ok := r.BasicAuth()\n-\t\t\t\t\t\tif ok && libstring.StringInSlice(lmtBasicAuthUsers, username) {\n-\t\t\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey, headerValue, username})\n+\t\t\t\t\t\tif r.Header.Get(headerKey) == headerValue {\n+\t\t\t\t\t\t\tusername, _, ok := r.BasicAuth()\n+\t\t\t\t\t\t\tif ok && libstring.StringInSlice(lmtBasicAuthUsers, username) {\n+\t\t\t\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey, headerValue, username})\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -82,12 +86,15 @@ func BuildKeys(lmt *limiter.Limiter, r *http.Request) [][]string {\n \t\t\tfor headerKey, headerValues := range lmtHeaders {\n \t\t\t\tif (headerValues == nil || len(headerValues) <= 0) && r.Header.Get(headerKey) != \"\" {\n \t\t\t\t\t// If header values are empty, rate-limit all request with headerKey.\n-\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey})\n+\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey, r.Header.Get(headerKey)})\n \n \t\t\t\t} else if len(headerValues) > 0 && r.Header.Get(headerKey) != \"\" {\n-\t\t\t\t\t// If header values are not empty, rate-limit all request with headerKey and headerValues.\n+\t\t\t\t\t// We are only limiting if request's header value is defined inside `headerValues`.\n \t\t\t\t\tfor _, headerValue := range headerValues {\n-\t\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey, headerValue})\n+\t\t\t\t\t\tif r.Header.Get(headerKey) == headerValue {\n+\t\t\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, r.Method, headerKey, headerValue})\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -113,12 +120,15 @@ func BuildKeys(lmt *limiter.Limiter, r *http.Request) [][]string {\n \t\tfor headerKey, headerValues := range lmtHeaders {\n \t\t\tif (headerValues == nil || len(headerValues) <= 0) && r.Header.Get(headerKey) != \"\" {\n \t\t\t\t// If header values are empty, rate-limit all request with headerKey.\n-\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, headerKey})\n+\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, headerKey, r.Header.Get(headerKey)})\n \n \t\t\t} else if len(headerValues) > 0 && r.Header.Get(headerKey) != \"\" {\n \t\t\t\t// If header values are not empty, rate-limit all request with headerKey and headerValues.\n \t\t\t\tfor _, headerValue := range headerValues {\n-\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, headerKey, headerValue})\n+\t\t\t\t\tif r.Header.Get(headerKey) == headerValue {\n+\t\t\t\t\t\tsliceKeys = append(sliceKeys, []string{remoteIP, path, headerKey, headerValue})\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}"
    },
    {
      "sha": "f1c181ec9c5c921245027c6b452ecfc1d3626364",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/.gitignore",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/.gitignore",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/.gitignore",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/.gitignore?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,12 @@\n+# Binaries for programs and plugins\n+*.exe\n+*.exe~\n+*.dll\n+*.so\n+*.dylib\n+\n+# Test binary, build with `go test -c`\n+*.test\n+\n+# Output of the go coverage tool, specifically when used with LiteIDE\n+*.out"
    },
    {
      "sha": "bb83e9aef3de92f8986246354af00fda1f2ae753",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/.golangci.yml",
      "status": "added",
      "additions": 70,
      "deletions": 0,
      "changes": 70,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/.golangci.yml",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/.golangci.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/.golangci.yml?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,70 @@\n+linters-settings:\n+  govet:\n+    check-shadowing: true\n+  golint:\n+    min-confidence: 0\n+  gocyclo:\n+    min-complexity: 15\n+  maligned:\n+    suggest-new: true\n+  dupl:\n+    threshold: 100\n+  goconst:\n+    min-len: 2\n+    min-occurrences: 2\n+  misspell:\n+    locale: US\n+  lll:\n+    line-length: 140\n+  gocritic:\n+    enabled-tags:\n+      - performance\n+      - style\n+      - experimental\n+    disabled-checks:\n+      - wrapperFunc\n+\n+linters:\n+  disable-all: true\n+  enable:\n+    - megacheck\n+    - golint\n+    - govet\n+    - unconvert\n+    - megacheck\n+    - structcheck\n+    - gas\n+    - gocyclo\n+    - dupl\n+    - misspell\n+    - unparam\n+    - varcheck\n+    - deadcode\n+    - typecheck\n+    - ineffassign\n+    - varcheck\n+    - stylecheck\n+    - gochecknoinits\n+    - scopelint\n+    - gocritic\n+    - golint\n+    - nakedret\n+    - gosimple\n+    - prealloc\n+  fast: false\n+\n+\n+run:\n+#  modules-download-mode: vendor\n+  skip-dirs:\n+    - vendor\n+  tests: true\n+\n+issues:\n+  exclude-rules:\n+    - text: \"weak cryptographic primitive\"\n+      linters:\n+        - gosec\n+\n+service:\n+  golangci-lint-version: 1.17.x\n\\ No newline at end of file"
    },
    {
      "sha": "0f0c5bdca4574710328bcf3141cda62bc282c5d9",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/.travis.yml",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/.travis.yml",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/.travis.yml",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/.travis.yml?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,21 @@\n+language: go\n+\n+go:\n+  - \"1.12.x\"\n+\n+install: true\n+\n+before_install:\n+  - export TZ=America/Chicago\n+  - curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | sh -s -- -b $(go env GOPATH)/bin v1.17.1\n+  - go get github.com/mattn/goveralls\n+  - export PATH=$(pwd)/bin:$PATH\n+\n+script:\n+  - GO111MODULE=on go get ./...\n+  - GO111MODULE=on go mod vendor\n+  - GO111MODULE=on go test  -v -mod=vendor -covermode=count -coverprofile=profile.cov ./... || travis_terminate 1;\n+  - GO111MODULE=on go test -v -covermode=count -coverprofile=profile.cov ./... || travis_terminate 1;\n+  - golangci-lint run -v || travis_terminate 1;\n+  - $GOPATH/bin/goveralls -coverprofile=profile.cov -service=travis-ci\n+"
    },
    {
      "sha": "ac540250027fcbbda2f64479f6e3e155961beb5b",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/LICENSE",
      "status": "added",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/LICENSE",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/LICENSE",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/LICENSE?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,21 @@\n+MIT License\n+\n+Copyright (c) 2019 Umputun\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE."
    },
    {
      "sha": "a3e36c9b4ebf6d9ab8a0222bcbc6a9c21b495a32",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/README.md",
      "status": "added",
      "additions": 99,
      "deletions": 0,
      "changes": 99,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/README.md",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/README.md",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/README.md?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,99 @@\n+# jrpc - rpc with json [![Build Status](https://travis-ci.org/go-pkgz/jrpc.svg?branch=master)](https://travis-ci.org/go-pkgz/jrpc) [![Go Report Card](https://goreportcard.com/badge/github.com/go-pkgz/jrpc)](https://goreportcard.com/report/github.com/go-pkgz/jrpc) [![Coverage Status](https://coveralls.io/repos/github/go-pkgz/jrpc/badge.svg?branch=master)](https://coveralls.io/github/go-pkgz/jrpc?branch=master) [![godoc](https://godoc.org/github.com/go-pkgz/jrpc?status.svg)](https://godoc.org/github.com/go-pkgz/jrpc)\n+\n+jrpc library provides client and server for RPC-like communication over HTTP with json encoded messages.\n+The protocol is a somewhat simplified version of json-rpc with a single POST call sending Request json \n+(method name and the list of parameters) moreover, receiving json Response with result data and an error string.\n+\n+## Usage\n+\n+### Plugin (server)\n+\n+```go\n+// Server wraps jrpc.Server and adds synced map to store data\n+type Puglin struct {\n+\t*jrpc.Server\n+}\n+\n+// create plugin (jrpc server)\n+plugin := jrpcServer{\n+    Server: &jrpc.Server{\n+        API:        \"/command\",     // base url for rpc calls\n+        AuthUser:   \"user\",         // basic auth user name\n+        AuthPasswd: \"password\",     // basic auth password\n+        AppName:    \"jrpc-example\", // plugin name for headers\n+        Logger:     logger,\n+    },\n+}\n+\n+plugin.Add(\"mycommand\", func(id uint64, params json.RawMessage) Response {\n+    return jrpc.EncodeResponse(id, \"hello, it works\", nil)\n+})\n+```\n+\n+### Application (client)\n+\n+```go\n+// Client makes jrpc.Client and invoke remote call\n+rpcClient := jrpc.Client{\n+    API:        \"http://127.0.0.1:8080/command\",\n+    Client:     http.Client{},\n+    AuthUser:   \"user\",\n+    AuthPasswd: \"password\",\n+}\n+\n+resp, err := rpcClient.Call(\"mycommand\")\n+var message string\n+if err = json.Unmarshal(*resp.Result, &message); err != nil {\n+    panic(err)\n+}\n+```\n+\n+*for functional examples for both plugin and application see [_example](https://github.com/go-pkgz/jrpc/tree/master/_example)*\n+ \n+## Technical details\n+ \n+ * `jrpc.Server` runs on user-defined port as a regular http server\n+ * Server accepts a single POST request on user-defined url with [Request](https://github.com/go-pkgz/jrpc/blob/master/jrpc.go#L12) sent as json payload\n+ <details><summary>request details and an example:</summary>\n+ \n+     ```go\n+     type Request struct {\n+     \tMethod string      `json:\"method\"`\n+     \tParams interface{} `json:\"params,omitempty\"`\n+     \tID     uint64      `json:\"id\"`\n+     }\n+     ```\n+     example: \n+     \n+     ```json\n+       {\n+        \"method\":\"test\",\n+        \"params\":[123,\"abc\"],\n+        \"id\":1\n+        }\n+     ```\n+ </details>\n+* Params can be a struct, primitive type or slice of values, even with different types.\n+* Server defines `ServerFn` handler function to react on a POST request. The handler provided by the user.\n+* Communication between the server and the caller can be protected with basic auth.\n+* [Client](https://github.com/go-pkgz/jrpc/blob/master/client.go) provides a single method `Call` and return `Response`\n+\n+ <details><summary>response details:</summary>\n+ \n+   ```go\n+    // Response encloses result and error received from remote server\n+    type Response struct {\n+    \tResult *json.RawMessage `json:\"result,omitempty\"`\n+    \tError  string           `json:\"error,omitempty\"`\n+    \tID     uint64           `json:\"id\"`\n+    }\n+   ```\n+ </details>\n+* User should encode and decode json payloads on the application level, see provided [examples](https://github.com/go-pkgz/jrpc/tree/master/_example)\n+* `jrpc.Server` doesn't support https internally (yet). If used on exposed or non-private networks, should be proxied with something providing https termination (nginx and others). \n+\n+## Status\n+\n+The code was extracted from [remark42](https://github.com/umputun/remark) and still under development. Until v1.x released the\n+ API & protocol may change.\n+ \n\\ No newline at end of file"
    },
    {
      "sha": "b9a40573fde21ed3e09802df7fe15479a95f24e5",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/client.go",
      "status": "renamed",
      "additions": 12,
      "deletions": 9,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/client.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/client.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/client.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -1,26 +1,29 @@\n-package rpc\n+package jrpc\n \n import (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"net/http\"\n-\t\"reflect\"\n \t\"sync/atomic\"\n \n \t\"github.com/pkg/errors\"\n )\n \n // Client implements remote engine and delegates all calls to remote http server\n+// if AuthUser and AuthPasswd defined will be used for basic auth in each call to server\n type Client struct {\n-\tAPI        string\n-\tClient     http.Client\n-\tAuthUser   string\n-\tAuthPasswd string\n+\tAPI        string      // URL to jrpc server with entrypoint, i.e. http://127.0.0.1:8080/command\n+\tClient     http.Client // http client injected by user\n+\tAuthUser   string      // basic auth user name, should match Server.AuthUser, optional\n+\tAuthPasswd string      // basic auth password, should match Server.AuthPasswd, optional\n \n-\tid uint64\n+\tid uint64 // used with atomic to populate unique id to Request.ID\n }\n \n-// Call remote server with given method and arguments\n+// Call remote server with given method and arguments.\n+// Empty args will be ignored, single arg will be marshaled as-us and multiple args marshaled as []interface{}.\n+// Returns Response and error. Note: Response has it's own Error field, but that onw controlled by server.\n+// Returned error represent client-level errors, like failed http call, failed marshaling and so on.\n func (r *Client) Call(method string, args ...interface{}) (*Response, error) {\n \n \tvar b []byte\n@@ -32,7 +35,7 @@ func (r *Client) Call(method string, args ...interface{}) (*Response, error) {\n \t\tif err != nil {\n \t\t\treturn nil, errors.Wrapf(err, \"marshaling failed for %s\", method)\n \t\t}\n-\tcase len(args) == 1 && reflect.TypeOf(args[0]).Kind() == reflect.Struct:\n+\tcase len(args) == 1:\n \t\tb, err = json.Marshal(Request{Method: method, Params: args[0], ID: atomic.AddUint64(&r.id, 1)})\n \t\tif err != nil {\n \t\t\treturn nil, errors.Wrapf(err, \"marshaling failed for %s\", method)",
      "previous_filename": "backend/app/rpc/client.go"
    },
    {
      "sha": "1e3fdb2a98debc654e1cebae437ee341352db772",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/go.mod",
      "status": "added",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/go.mod",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/go.mod",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/go.mod?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,16 @@\n+module github.com/go-pkgz/jrpc\n+\n+go 1.12\n+\n+require (\n+\tgithub.com/didip/tollbooth v4.0.2+incompatible\n+\tgithub.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d\n+\tgithub.com/go-chi/chi v4.0.2+incompatible\n+\tgithub.com/go-chi/render v1.0.1\n+\tgithub.com/go-pkgz/rest v1.4.1\n+\tgithub.com/patrickmn/go-cache v2.1.0+incompatible // indirect\n+\tgithub.com/pkg/errors v0.8.1\n+\tgithub.com/stretchr/testify v1.3.0\n+\tgolang.org/x/net v0.0.0-20190724013045-ca1201d0de80 // indirect\n+\tgolang.org/x/time v0.0.0-20190308202827-9d24e82272b4 // indirect\n+)"
    },
    {
      "sha": "9a20171ceded87fbcf4eb5adf4bc012292c7c5ef",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/go.sum",
      "status": "added",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/go.sum",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/go.sum",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/go.sum?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,32 @@\n+github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\n+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\n+github.com/didip/tollbooth v4.0.2+incompatible h1:fVSa33JzSz0hoh2NxpwZtksAzAgd7zjmGO20HCZtF4M=\n+github.com/didip/tollbooth v4.0.2+incompatible/go.mod h1:A9b0665CE6l1KmzpDws2++elm/CsuWBMa5Jv4WY0PEY=\n+github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d h1:vs5Nf6IE0N/PwGJ8//zRed4gpCdcr99K2HzX7RuLOQ8=\n+github.com/didip/tollbooth_chi v0.0.0-20170928041846-6ab5f3083f3d/go.mod h1:YWyIfq3y4ArRfWZ9XksmuusP+7Mad+T0iFZ0kv0XG/M=\n+github.com/go-chi/chi v4.0.2+incompatible h1:maB6vn6FqCxrpz4FqWdh4+lwpyZIQS7YEAUcHlgXVRs=\n+github.com/go-chi/chi v4.0.2+incompatible/go.mod h1:eB3wogJHnLi3x/kFX2A+IbTBlXxmMeXJVKy9tTv1XzQ=\n+github.com/go-chi/render v1.0.1 h1:4/5tis2cKaNdnv9zFLfXzcquC9HbeZgCnxGnKrltBS8=\n+github.com/go-chi/render v1.0.1/go.mod h1:pq4Rr7HbnsdaeHagklXub+p6Wd16Af5l9koip1OvJns=\n+github.com/go-pkgz/rest v1.4.1 h1:DmaVLPH2O7yLehrWOW0uz01d2mVHz9fBR/iuTiPRzaw=\n+github.com/go-pkgz/rest v1.4.1/go.mod h1:COazNj35u3RXAgQNBr6neR599tYP3URiOpsu9p0rOtk=\n+github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\n+github.com/patrickmn/go-cache v2.1.0+incompatible h1:HRMgzkcYKYpi3C8ajMPV8OFXaaRUnok+kx1WdO15EQc=\n+github.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=\n+github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pkg/errors v0.8.1 h1:iURUrRGxPUNPdy5/HRSm+Yj6okJ6UtLINN0Q9M4+h3I=\n+github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\n+github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\n+github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\n+github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\n+github.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=\n+github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\n+golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\n+golang.org/x/net v0.0.0-20190724013045-ca1201d0de80 h1:Ao/3l156eZf2AW5wK8a7/smtodRU+gha3+BeqJ69lRk=\n+golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\n+golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n+golang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=\n+golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n+golang.org/x/time v0.0.0-20190308202827-9d24e82272b4 h1:SvFZT6jyqRaOeXpc5h/JSfZenJ2O330aBsf7JfSUXmQ=\n+golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ="
    },
    {
      "sha": "8606369065830cf0168d7649471018963562e748",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/jrpc.go",
      "status": "added",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/jrpc.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/jrpc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/jrpc.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -0,0 +1,40 @@\n+// Package jrpc implements client and server for RPC-like communication over HTTP with json encoded messages.\n+// The protocol is somewhat simplified version of json-rpc with a single POST call sending Request json\n+// (method name and the list of parameters) and receiving back json Response with \"result\" json\n+// and error string\n+package jrpc\n+\n+import (\n+\t\"encoding/json\"\n+)\n+\n+// Request encloses method name and all params\n+type Request struct {\n+\tMethod string      `json:\"method\"`           // method (function) name\n+\tParams interface{} `json:\"params,omitempty\"` // function arguments\n+\tID     uint64      `json:\"id\"`               // unique call id\n+}\n+\n+// Response encloses result and error received from remote server\n+type Response struct {\n+\tResult *json.RawMessage `json:\"result,omitempty\"` // response json\n+\tError  string           `json:\"error,omitempty\"`  // optional remote (server side / plugin side) error\n+\tID     uint64           `json:\"id\"`               // unique call id, echoed Request.ID to allow calls tracing\n+}\n+\n+// EncodeResponse convert anything (type interface{}) and incoming error (if any) to Response\n+func EncodeResponse(id uint64, resp interface{}, e error) Response {\n+\tv, err := json.Marshal(&resp)\n+\tif err != nil {\n+\t\treturn Response{Error: err.Error()}\n+\t}\n+\tif e != nil {\n+\t\treturn Response{ID: id, Result: nil, Error: e.Error()} // pass input error\n+\t}\n+\traw := json.RawMessage{}\n+\tif err := raw.UnmarshalJSON(v); err != nil {\n+\t\treturn Response{Error: err.Error()}\n+\t}\n+\n+\treturn Response{ID: id, Result: &raw}\n+}"
    },
    {
      "sha": "a52e1434a96e5ad38a48c81eee2b3390604228aa",
      "filename": "backend/vendor/github.com/go-pkgz/jrpc/server.go",
      "status": "renamed",
      "additions": 40,
      "deletions": 42,
      "changes": 82,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/server.go",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/github.com/go-pkgz/jrpc/server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/github.com/go-pkgz/jrpc/server.go?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -1,4 +1,4 @@\n-package rpc\n+package jrpc\n \n import (\n \t\"context\"\n@@ -13,21 +13,19 @@ import (\n \t\"github.com/go-chi/chi\"\n \t\"github.com/go-chi/chi/middleware\"\n \t\"github.com/go-chi/render\"\n-\tlog \"github.com/go-pkgz/lgr\"\n-\tR \"github.com/go-pkgz/rest\"\n+\t\"github.com/go-pkgz/rest\"\n \t\"github.com/go-pkgz/rest/logger\"\n \t\"github.com/pkg/errors\"\n-\n-\t\"github.com/umputun/remark/backend/app/rest\"\n )\n \n // Server is json-rpc server with an optional basic auth\n type Server struct {\n-\tAPI        string\n-\tAuthUser   string\n-\tAuthPasswd string\n-\tVersion    string\n-\tAppName    string\n+\tAPI        string // url path, i.e. \"/command\" or \"/rpc\" etc.\n+\tAuthUser   string // basic auth user name, should match Client.AuthUser, optional\n+\tAuthPasswd string // basic auth password, should match Client.AuthPasswd, optional\n+\tVersion    string // server version, injected from main and used for informational headers only\n+\tAppName    string // plugin name, injected from main and used for informational headers only\n+\tLogger     L      // logger, if nil will default to NoOpLogger\n \n \tfuncs struct {\n \t\tm    map[string]ServerFn\n@@ -40,26 +38,26 @@ type Server struct {\n \t}\n }\n \n-// Encoder is a function to encode call's result to Response\n-type Encoder func(id uint64, resp interface{}, e error) (Response, error)\n-\n-// ServerFn handler registered for each method with Add\n-// Implementations provided by consumer and define response logic.\n+// ServerFn handler registered for each method with Add or Group.\n+// Implementations provided by consumer and defines response logic.\n type ServerFn func(id uint64, params json.RawMessage) Response\n \n // Run http server on given port\n func (s *Server) Run(port int) error {\n+\tif s.Logger == nil {\n+\t\ts.Logger = NoOpLogger\n+\t}\n \tif s.AuthUser == \"\" || s.AuthPasswd == \"\" {\n-\t\tlog.Print(\"[WARN] extension server runs without auth\")\n+\t\ts.Logger.Logf(\"[WARN] extension server runs without auth\")\n \t}\n \tif s.funcs.m == nil && len(s.funcs.m) == 0 {\n \t\treturn errors.Errorf(\"nothing mapped for dispatch, Add has to be called prior to Run\")\n \t}\n \n \trouter := chi.NewRouter()\n-\trouter.Use(middleware.Throttle(1000), middleware.RealIP, R.Recoverer(log.Default()))\n-\trouter.Use(R.AppInfo(s.AppName, \"umputun\", s.Version), R.Ping)\n-\tlogInfoWithBody := logger.New(logger.Log(log.Default()), logger.WithBody, logger.Prefix(\"[INFO]\")).Handler\n+\trouter.Use(middleware.Throttle(1000), middleware.RealIP, rest.Recoverer(s.Logger))\n+\trouter.Use(rest.AppInfo(s.AppName, \"umputun\", s.Version), rest.Ping)\n+\tlogInfoWithBody := logger.New(logger.Log(s.Logger), logger.WithBody, logger.Prefix(\"[INFO]\")).Handler\n \trouter.Use(middleware.Timeout(5 * time.Second))\n \trouter.Use(logInfoWithBody, tollbooth_chi.LimitHandler(tollbooth.NewLimiter(1000, nil)), middleware.NoCache)\n \trouter.Use(s.basicAuth)\n@@ -76,26 +74,10 @@ func (s *Server) Run(port int) error {\n \t}\n \ts.httpServer.Unlock()\n \n-\tlog.Printf(\"[INFO] listen on %d\", port)\n+\ts.Logger.Logf(\"[INFO] listen on %d\", port)\n \treturn s.httpServer.ListenAndServe()\n }\n \n-// EncodeResponse convert anything to Response\n-func (s *Server) EncodeResponse(id uint64, resp interface{}, e error) (Response, error) {\n-\tv, err := json.Marshal(&resp)\n-\tif err != nil {\n-\t\treturn Response{}, err\n-\t}\n-\tif e != nil {\n-\t\treturn Response{ID: id, Result: nil, Error: e.Error()}, nil\n-\t}\n-\traw := json.RawMessage{}\n-\tif err = raw.UnmarshalJSON(v); err != nil {\n-\t\treturn Response{}, err\n-\t}\n-\treturn Response{ID: id, Result: &raw}, nil\n-}\n-\n // Shutdown http server\n func (s *Server) Shutdown() error {\n \ts.httpServer.Lock()\n@@ -108,12 +90,12 @@ func (s *Server) Shutdown() error {\n \treturn s.httpServer.Shutdown(ctx)\n }\n \n-// Add method handler\n+// Add method handler. Handler will be called on matching method (Request.Method)\n func (s *Server) Add(method string, fn ServerFn) {\n \ts.httpServer.Lock()\n \tdefer s.httpServer.Unlock()\n \tif s.httpServer.Server != nil {\n-\t\tlog.Printf(\"[WARN] ignored method %s, can't be added to activated server\", method)\n+\t\ts.Logger.Logf(\"[WARN] ignored method %s, can't be added to activated server\", method)\n \t\treturn\n \t}\n \n@@ -122,19 +104,20 @@ func (s *Server) Add(method string, fn ServerFn) {\n \t})\n \n \ts.funcs.m[method] = fn\n-\tlog.Printf(\"[INFO] add handler for %s\", method)\n+\ts.Logger.Logf(\"[INFO] add handler for %s\", method)\n }\n \n // HandlersGroup alias for map of handlers\n type HandlersGroup map[string]ServerFn\n \n-// Group of handlers with common prefix\n+// Group of handlers with common prefix, match on group.method\n func (s *Server) Group(prefix string, m HandlersGroup) {\n \tfor k, v := range m {\n \t\ts.Add(prefix+\".\"+k, v)\n \t}\n }\n \n+// handler is http handler multiplexing calls by req.Method\n func (s *Server) handler(w http.ResponseWriter, r *http.Request) {\n \treq := struct {\n \t\tID     uint64           `json:\"id\"`\n@@ -143,12 +126,12 @@ func (s *Server) handler(w http.ResponseWriter, r *http.Request) {\n \t}{}\n \n \tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n-\t\trest.SendErrorJSON(w, r, http.StatusBadRequest, err, req.Method, 0)\n+\t\trest.SendErrorJSON(w, r, s.Logger, http.StatusBadRequest, err, req.Method)\n \t\treturn\n \t}\n \tfn, ok := s.funcs.m[req.Method]\n \tif !ok {\n-\t\trest.SendErrorJSON(w, r, http.StatusNotImplemented, errors.New(\"unsupported method\"), req.Method, 0)\n+\t\trest.SendErrorJSON(w, r, s.Logger, http.StatusNotImplemented, errors.New(\"unsupported method\"), req.Method)\n \t\treturn\n \t}\n \n@@ -160,6 +143,7 @@ func (s *Server) handler(w http.ResponseWriter, r *http.Request) {\n \trender.JSON(w, r, fn(req.ID, params))\n }\n \n+// basicAuth middleware. enabled only if both AuthUser and AuthPasswd defined.\n func (s *Server) basicAuth(h http.Handler) http.Handler {\n \treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n \n@@ -177,3 +161,17 @@ func (s *Server) basicAuth(h http.Handler) http.Handler {\n \t\th.ServeHTTP(w, r)\n \t})\n }\n+\n+// L defined logger interface used for an optional rest logging\n+type L interface {\n+\tLogf(format string, args ...interface{})\n+}\n+\n+// LoggerFunc type is an adapter to allow the use of ordinary functions as Logger.\n+type LoggerFunc func(format string, args ...interface{})\n+\n+// Logf calls f(id)\n+func (f LoggerFunc) Logf(format string, args ...interface{}) { f(format, args...) }\n+\n+// NoOpLogger logger does nothing\n+var NoOpLogger = LoggerFunc(func(format string, args ...interface{}) {})",
      "previous_filename": "backend/app/rpc/server.go"
    },
    {
      "sha": "f501d4fb9ce112395aaeb5a94b277ff3a316e1d7",
      "filename": "backend/vendor/modules.txt",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/umputun/remark/blob/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/modules.txt",
      "raw_url": "https://github.com/umputun/remark/raw/f0750c24335742da2b04cee6e38bbb67f972c44b/backend/vendor/modules.txt",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/vendor/modules.txt?ref=f0750c24335742da2b04cee6e38bbb67f972c44b",
      "patch": "@@ -10,7 +10,7 @@ github.com/coreos/bbolt\n github.com/davecgh/go-spew/spew\n # github.com/dgrijalva/jwt-go v3.2.0+incompatible\n github.com/dgrijalva/jwt-go\n-# github.com/didip/tollbooth v4.0.0+incompatible\n+# github.com/didip/tollbooth v4.0.2+incompatible\n github.com/didip/tollbooth\n github.com/didip/tollbooth/errors\n github.com/didip/tollbooth/libstring\n@@ -38,6 +38,8 @@ github.com/go-pkgz/auth/provider/sender\n github.com/go-pkgz/auth/token\n github.com/go-pkgz/auth/logger\n github.com/go-pkgz/auth/middleware\n+# github.com/go-pkgz/jrpc v0.1.0\n+github.com/go-pkgz/jrpc\n # github.com/go-pkgz/lcw v0.3.1\n github.com/go-pkgz/lcw\n # github.com/go-pkgz/lgr v0.6.3\n@@ -98,7 +100,7 @@ golang.org/x/crypto/acme\n # golang.org/x/image v0.0.0-20190703141733-d6a02ce849c9\n golang.org/x/image/draw\n golang.org/x/image/math/f64\n-# golang.org/x/net v0.0.0-20190628185345-da137c7871d7\n+# golang.org/x/net v0.0.0-20190724013045-ca1201d0de80\n golang.org/x/net/html\n golang.org/x/net/idna\n golang.org/x/net/html/atom"
    }
  ]
}
