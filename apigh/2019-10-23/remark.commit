{
  "sha": "b7045d9771182bc109685e15038232f8d35daecc",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOmI3MDQ1ZDk3NzExODJiYzEwOTY4NWUxNTAzODIzMmY4ZDM1ZGFlY2M=",
  "commit": {
    "author": {
      "name": "Vdimir",
      "email": "Vdimir@users.noreply.github.com",
      "date": "2019-10-22T07:35:48Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-10-22T07:35:48Z"
    },
    "message": "Add bolt image storage (#449)\n\n* Add bolt image store support\r\n\r\n* Fix lint errors\r\n\r\n* Use separate bolt buckets for staging and commited\r\n\r\n* Comment bolt store public entities\r\n\r\n* Fix spelling",
    "tree": {
      "sha": "5c7940727173f8224c32b6349cec337f2cd10784",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/5c7940727173f8224c32b6349cec337f2cd10784"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/b7045d9771182bc109685e15038232f8d35daecc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/b7045d9771182bc109685e15038232f8d35daecc",
  "html_url": "https://github.com/umputun/remark/commit/b7045d9771182bc109685e15038232f8d35daecc",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/b7045d9771182bc109685e15038232f8d35daecc/comments",
  "author": {
    "login": "Vdimir",
    "id": 7023786,
    "node_id": "MDQ6VXNlcjcwMjM3ODY=",
    "avatar_url": "https://avatars2.githubusercontent.com/u/7023786?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Vdimir",
    "html_url": "https://github.com/Vdimir",
    "followers_url": "https://api.github.com/users/Vdimir/followers",
    "following_url": "https://api.github.com/users/Vdimir/following{/other_user}",
    "gists_url": "https://api.github.com/users/Vdimir/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Vdimir/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Vdimir/subscriptions",
    "organizations_url": "https://api.github.com/users/Vdimir/orgs",
    "repos_url": "https://api.github.com/users/Vdimir/repos",
    "events_url": "https://api.github.com/users/Vdimir/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Vdimir/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d7faf2df0e8d74d6fc6bc35afa7822fbc1231599",
      "url": "https://api.github.com/repos/umputun/remark/commits/d7faf2df0e8d74d6fc6bc35afa7822fbc1231599",
      "html_url": "https://github.com/umputun/remark/commit/d7faf2df0e8d74d6fc6bc35afa7822fbc1231599"
    }
  ],
  "stats": {
    "total": 369,
    "additions": 356,
    "deletions": 13
  },
  "files": [
    {
      "sha": "b63b9d8be9a754c479c23354d7c238f1b731c1c4",
      "filename": "backend/app/cmd/server.go",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/umputun/remark/blob/b7045d9771182bc109685e15038232f8d35daecc/backend/app/cmd/server.go",
      "raw_url": "https://github.com/umputun/remark/raw/b7045d9771182bc109685e15038232f8d35daecc/backend/app/cmd/server.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/cmd/server.go?ref=b7045d9771182bc109685e15038232f8d35daecc",
      "patch": "@@ -482,6 +482,22 @@ func (s *ServerCommand) makeAvatarStore() (avatar.Store, error) {\n \n func (s *ServerCommand) makePicturesStore() (*image.Service, error) {\n \tswitch s.Image.Type {\n+\tcase \"bolt\":\n+\t\tboltImageStore, err := image.NewBoltStorage(\n+\t\t\ts.Image.Bolt.File,\n+\t\t\ts.Image.MaxSize,\n+\t\t\ts.Image.ResizeHeight,\n+\t\t\ts.Image.ResizeWidth,\n+\t\t\tbolt.Options{},\n+\t\t)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn &image.Service{\n+\t\t\tStore: boltImageStore,\n+\t\t\tImageAPI: s.RemarkURL + \"/api/v1/picture/\",\n+\t\t\tTTL:      5 * s.EditDuration, // add extra time to image TTL for staging\n+\t\t}, nil\n \tcase \"fs\":\n \t\tif err := makeDirs(s.Image.FS.Path); err != nil {\n \t\t\treturn nil, err"
    },
    {
      "sha": "eb049b067ae090af9a6976e4b47d4fbfbc9738d8",
      "filename": "backend/app/store/image/bolt_store.go",
      "status": "added",
      "additions": 165,
      "deletions": 0,
      "changes": 165,
      "blob_url": "https://github.com/umputun/remark/blob/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/bolt_store.go",
      "raw_url": "https://github.com/umputun/remark/raw/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/bolt_store.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/bolt_store.go?ref=b7045d9771182bc109685e15038232f8d35daecc",
      "patch": "@@ -0,0 +1,165 @@\n+package image\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"encoding/binary\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"path\"\n+\t\"time\"\n+\n+\tbolt \"github.com/coreos/bbolt\"\n+\tlog \"github.com/go-pkgz/lgr\"\n+\t\"github.com/pkg/errors\"\n+)\n+\n+const imagesStagedBktName = \"imagesStaged\"\n+const imagesBktName = \"images\"\n+const insertTimeBktName = \"insertTimestamps\"\n+\n+// Bolt provides image Store for images keeping data in bolt DB, restricts max size.\n+// It uses 3 buckets to manage images data.\n+// Two buckets contains image data (staged and committed images). Third bucket holds insertion timestamps.\n+type Bolt struct {\n+\tfileName  string\n+\tdb        *bolt.DB\n+\tMaxSize   int\n+\tMaxHeight int\n+\tMaxWidth  int\n+}\n+\n+// Create Bolt Store.\n+func NewBoltStorage(fileName string, maxSize int, maxHeight int, maxWidth int, options bolt.Options) (*Bolt, error) {\n+\tdb, err := bolt.Open(fileName, 0600, &options)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"failed to make boltdb for %s\", fileName)\n+\t}\n+\n+\terr = db.Update(func(tx *bolt.Tx) error {\n+\t\tif _, e := tx.CreateBucketIfNotExists([]byte(imagesBktName)); e != nil {\n+\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", imagesBktName)\n+\t\t}\n+\t\tif _, e := tx.CreateBucketIfNotExists([]byte(imagesStagedBktName)); e != nil {\n+\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", imagesStagedBktName)\n+\t\t}\n+\t\tif _, e := tx.CreateBucketIfNotExists([]byte(insertTimeBktName)); e != nil {\n+\t\t\treturn errors.Wrapf(e, \"failed to create top level bucket %s\", insertTimeBktName)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"failed to initialize boltdb db %q buckets\", fileName)\n+\t}\n+\treturn &Bolt{\n+\t\tdb:        db,\n+\t\tfileName:  fileName,\n+\t\tMaxSize:   maxSize,\n+\t\tMaxHeight: maxHeight,\n+\t\tMaxWidth:  maxWidth,\n+\t}, nil\n+}\n+\n+// Save data from reader to staging bucket in DB\n+func (b *Bolt) Save(fileName string, userID string, r io.Reader) (id string, err error) {\n+\tdata, err := readAndValidateImage(r, b.MaxSize)\n+\tif err != nil {\n+\t\treturn \"\", errors.Wrapf(err, \"can't load image %s\", fileName)\n+\t}\n+\n+\tdata, _ = resize(data, b.MaxWidth, b.MaxHeight)\n+\n+\tid = path.Join(userID, guid())\n+\n+\terr = b.db.Update(func(tx *bolt.Tx) error {\n+\t\tif err = tx.Bucket([]byte(imagesStagedBktName)).Put([]byte(id), data); err != nil {\n+\t\t\treturn errors.Wrapf(err, \"can't put to bucket with %s\", id)\n+\t\t}\n+\t\ttsBuf := &bytes.Buffer{}\n+\t\tif err = binary.Write(tsBuf, binary.LittleEndian, time.Now().UnixNano()); err != nil {\n+\t\t\treturn errors.Wrapf(err, \"can't serialize timestamp for %s\", id)\n+\t\t}\n+\t\tif err = tx.Bucket([]byte(insertTimeBktName)).Put([]byte(id), tsBuf.Bytes()); err != nil {\n+\t\t\treturn errors.Wrapf(err, \"can't put to bucket with %s\", id)\n+\t\t}\n+\t\treturn err\n+\t})\n+\n+\treturn id, err\n+}\n+\n+// Commit file stored in staging bucket by copying it to permanent bucket\n+// Data from staging bucket not removed immediately, but would be removed on cleanup\n+func (b *Bolt) Commit(id string) error {\n+\terr := b.db.Update(func(tx *bolt.Tx) error {\n+\t\tdata := tx.Bucket([]byte(imagesStagedBktName)).Get([]byte(id))\n+\t\tif data == nil {\n+\t\t\treturn errors.Errorf(\"failed to commit %s, not found in staging\", id)\n+\t\t}\n+\t\terr := tx.Bucket([]byte(imagesBktName)).Put([]byte(id), data)\n+\t\treturn errors.Wrapf(err, \"can't put to bucket with %s\", id)\n+\t})\n+\treturn err\n+}\n+\n+// Load image from DB\n+// returns ReadCloser and caller should call close after processing completed.\n+func (b *Bolt) Load(id string) (io.ReadCloser, int64, error) {\n+\tbuf := &bytes.Buffer{}\n+\tvar size int = 0\n+\terr := b.db.View(func(tx *bolt.Tx) error {\n+\t\tdata := tx.Bucket([]byte(imagesBktName)).Get([]byte(id))\n+\t\tif data == nil {\n+\t\t\tdata = tx.Bucket([]byte(imagesStagedBktName)).Get([]byte(id))\n+\t\t}\n+\t\tif data == nil {\n+\t\t\treturn errors.Errorf(\"can't load image %s\", id)\n+\t\t}\n+\t\tvar err error\n+\t\tsize, err = buf.Write(data)\n+\t\treturn errors.Wrapf(err, \"failed to write for %s\", id)\n+\t})\n+\treturn ioutil.NopCloser(buf), int64(size), err\n+}\n+\n+// Cleanup runs scan of staging and removes old data based on ttl\n+func (b *Bolt) Cleanup(ctx context.Context, ttl time.Duration) error {\n+\terr := b.db.Update(func(tx *bolt.Tx) error {\n+\t\tc := tx.Bucket([]byte(insertTimeBktName)).Cursor()\n+\n+\t\tidsToRemove := [][]byte{}\n+\n+\t\tfor id, tsData := c.First(); id != nil; id, tsData = c.Next() {\n+\t\t\tvar ts int64\n+\t\t\terr := binary.Read(bytes.NewReader(tsData), binary.LittleEndian, &ts)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrapf(err, \"failed to deserialize timestamp for %s\", id)\n+\t\t\t}\n+\n+\t\t\tage := time.Since(time.Unix(0, ts))\n+\n+\t\t\tif age > ttl {\n+\t\t\t\tlog.Printf(\"[INFO] remove staging image %s, age %v\", id, age)\n+\t\t\t\tidsToRemove = append(idsToRemove, id)\n+\t\t\t\terr := c.Delete()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn errors.Wrapf(err, \"failed to remove timestamp for %s\", id)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\timgBkt := tx.Bucket([]byte(imagesStagedBktName))\n+\t\tfor _, id := range idsToRemove {\n+\t\t\terr := imgBkt.Delete(id)\n+\t\t\tif err != nil {\n+\t\t\t\treturn errors.Wrapf(err, \"failed to remove image for %s\", id)\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn err\n+}\n+\n+// SizeLimit returns max size of allowed image\n+func (b *Bolt) SizeLimit() int {\n+\treturn b.MaxSize\n+}"
    },
    {
      "sha": "0b7a6d563f929e76e6fcdd71488b18b46530b02e",
      "filename": "backend/app/store/image/bolt_store_test.go",
      "status": "added",
      "additions": 152,
      "deletions": 0,
      "changes": 152,
      "blob_url": "https://github.com/umputun/remark/blob/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/bolt_store_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/bolt_store_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/bolt_store_test.go?ref=b7045d9771182bc109685e15038232f8d35daecc",
      "patch": "@@ -0,0 +1,152 @@\n+package image\n+\n+import (\n+\t\"context\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\tbolt \"github.com/coreos/bbolt\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestBoltStore_SaveCommit(t *testing.T) {\n+\tsvc, teardown := prepareBoltImageStorageTest(t)\n+\tdefer teardown()\n+\n+\tid, err := svc.Save(\"file1.png\", \"user1\", gopherPNG())\n+\tassert.NoError(t, err)\n+\tassert.Contains(t, id, \"user1\")\n+\tt.Log(id)\n+\n+\terr = svc.db.View(func(tx *bolt.Tx) error {\n+\t\tdata := tx.Bucket([]byte(imagesStagedBktName)).Get([]byte(id))\n+\t\tassert.NotNil(t, data)\n+\t\tassert.Equal(t, 1462, len(data))\n+\t\treturn nil\n+\t})\n+\tassert.NoError(t, err)\n+\n+\terr = svc.Commit(id)\n+\trequire.NoError(t, err)\n+\n+\terr = svc.db.View(func(tx *bolt.Tx) error {\n+\t\tdata := tx.Bucket([]byte(imagesBktName)).Get([]byte(id))\n+\t\tassert.NotNil(t, data)\n+\t\tassert.Equal(t, 1462, len(data))\n+\t\treturn nil\n+\t})\n+\tassert.NoError(t, err)\n+\n+}\n+\n+func TestBoltStore_LoadAfterSave(t *testing.T) {\n+\tsvc, teardown := prepareBoltImageStorageTest(t)\n+\tdefer teardown()\n+\n+\tid, err := svc.Save(\"file1.png\", \"user1\", gopherPNG())\n+\tassert.NoError(t, err)\n+\tassert.Contains(t, id, \"user1\")\n+\tt.Log(id)\n+\n+\tr, sz, err := svc.Load(id)\n+\tassert.NoError(t, err)\n+\tdefer func() { assert.NoError(t, r.Close()) }()\n+\tdata, err := ioutil.ReadAll(r)\n+\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, 1462, len(data))\n+\tassert.Equal(t, int64(1462), sz)\n+\n+\t_, _, err = svc.Load(\"abcd\")\n+\tassert.NotNil(t, err)\n+}\n+\n+func TestBoltStore_Cleanup(t *testing.T) {\n+\tsvc, teardown := prepareBoltImageStorageTest(t)\n+\tdefer teardown()\n+\n+\tsave := func(file string, user string) (id string) {\n+\t\tid, err := svc.Save(file, user, gopherPNG())\n+\t\trequire.NoError(t, err)\n+\n+\t\tcheckBoltImgData(t, svc.db, imagesStagedBktName, id, func(data []byte) error {\n+\t\t\tassert.NotNil(t, data)\n+\t\t\tassert.Equal(t, 1462, len(data))\n+\t\t\treturn nil\n+\t\t})\n+\t\treturn id\n+\t}\n+\n+\t// save 3 images to staging\n+\timg1 := save(\"blah_ff1.png\", \"user1\")\n+\ttime.Sleep(100 * time.Millisecond)\n+\timg2 := save(\"blah_ff2.png\", \"user1\")\n+\ttime.Sleep(100 * time.Millisecond)\n+\timg3 := save(\"blah_ff3.png\", \"user2\")\n+\n+\ttime.Sleep(100 * time.Millisecond) // make first image expired\n+\terr := svc.Cleanup(context.Background(), time.Millisecond*300)\n+\tassert.NoError(t, err)\n+\n+\tassertBoltImgNil(t, svc.db, imagesStagedBktName, img1)\n+\tassertBoltImgNil(t, svc.db, imagesBktName, img1)\n+\tassertBoltImgNotNil(t, svc.db, imagesStagedBktName, img2)\n+\tassertBoltImgNotNil(t, svc.db, imagesStagedBktName, img3)\n+\n+\terr = svc.Commit(img3)\n+\trequire.NoError(t, err)\n+\n+\ttime.Sleep(200 * time.Millisecond) // make all images except commited expired\n+\terr = svc.Cleanup(context.Background(), time.Millisecond*300)\n+\tassert.NoError(t, err)\n+\n+\tassertBoltImgNil(t, svc.db, imagesStagedBktName, img2)\n+\tassertBoltImgNil(t, svc.db, imagesBktName, img2)\n+\tassertBoltImgNotNil(t, svc.db, imagesBktName, img3)\n+\tassert.NoError(t, err)\n+}\n+\n+func assertBoltImgNil(t *testing.T, db *bolt.DB, bucket string, id string) {\n+\tcheckBoltImgData(t, db, bucket, id, func(data []byte) error {\n+\t\tassert.Nil(t, data)\n+\t\treturn nil\n+\t})\n+}\n+\n+func assertBoltImgNotNil(t *testing.T, db *bolt.DB, bucket string, id string) {\n+\tcheckBoltImgData(t, db, bucket, id, func(data []byte) error {\n+\t\tassert.NotNil(t, data)\n+\t\treturn nil\n+\t})\n+}\n+\n+func checkBoltImgData(t *testing.T, db *bolt.DB, bucket string, id string, callback func([]byte) error) {\n+\terr := db.View(func(tx *bolt.Tx) error {\n+\t\tbkt := tx.Bucket([]byte(bucket))\n+\t\tassert.NotNil(t, bkt, \"bucket %s not found\", bucket)\n+\t\tdata := bkt.Get([]byte(id))\n+\t\treturn callback(data)\n+\t})\n+\tassert.NoError(t, err)\n+}\n+\n+func prepareBoltImageStorageTest(t *testing.T) (svc *Bolt, teardown func()) {\n+\tloc, err := ioutil.TempDir(\"\", \"test_image_r42\")\n+\trequire.NoError(t, err, \"failed to make temp dir\")\n+\n+\tsvc, err = NewBoltStorage(path.Join(loc, \"picture.db\"), 1500, 0, 0, bolt.Options{})\n+\tassert.NoError(t, err, \"new bolt storage\")\n+\n+\tteardown = func() {\n+\t\tdefer func() {\n+\t\t\tassert.NoError(t, os.RemoveAll(loc))\n+\t\t}()\n+\t}\n+\n+\treturn svc, teardown\n+}"
    },
    {
      "sha": "a1c218684acab599d93857404b19ca5e6ae0e926",
      "filename": "backend/app/store/image/fs_store.go",
      "status": "modified",
      "additions": 2,
      "deletions": 12,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark/blob/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/fs_store.go",
      "raw_url": "https://github.com/umputun/remark/raw/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/fs_store.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/fs_store.go?ref=b7045d9771182bc109685e15038232f8d35daecc",
      "patch": "@@ -39,19 +39,9 @@ type FileSystem struct {\n // Save data from reader for given file name to local FS, staging directory. Returns id as user/uuid.ext\n // Files partitioned across multiple subdirectories and the final path includes part, i.e. /location/user1/03/123-4567.png\n func (f *FileSystem) Save(fileName string, userID string, r io.Reader) (id string, err error) {\n-\n-\tlr := io.LimitReader(r, int64(f.MaxSize)+1)\n-\tdata, err := ioutil.ReadAll(lr)\n+\tdata, err := readAndValidateImage(r, f.MaxSize)\n \tif err != nil {\n-\t\treturn \"\", errors.Wrapf(err, \"can't read source data for image %s\", fileName)\n-\t}\n-\tif len(data) > f.MaxSize {\n-\t\treturn \"\", errors.Errorf(\"file %s is too large (limit=%d)\", fileName, f.MaxSize)\n-\t}\n-\n-\t// read header first, needs it to check if data is valid png/gif/jpeg\n-\tif !isValidImage(data[:512]) {\n-\t\treturn \"\", errors.Errorf(\"file %s is not in allowed format\", fileName)\n+\t\treturn \"\", errors.Wrapf(err, \"can't load image %s\", fileName)\n \t}\n \n \tdata, resized := resize(data, f.MaxWidth, f.MaxHeight)"
    },
    {
      "sha": "497d91a19af2bdf1b31d3b4070e65b66848b44e3",
      "filename": "backend/app/store/image/fs_store_test.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/fs_store_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/fs_store_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/fs_store_test.go?ref=b7045d9771182bc109685e15038232f8d35daecc",
      "patch": "@@ -124,7 +124,7 @@ func TestFsStore_WrongFormat(t *testing.T) {\n \tdefer teardown()\n \n \t_, err := svc.Save(\"file1.png\", \"user1\", strings.NewReader(\"blah blah bad image\"))\n-\tassert.EqualError(t, err, \"file file1.png is not in allowed format\")\n+\tassert.EqualError(t, err, \"can't load image file1.png: file format is not allowed\")\n }\n \n func TestFsStore_SaveAndCommit(t *testing.T) {"
    },
    {
      "sha": "0b9f32ce6943f054ce34b02be5c5c312b2e0a91a",
      "filename": "backend/app/store/image/image.go",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/umputun/remark/blob/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/image.go",
      "raw_url": "https://github.com/umputun/remark/raw/b7045d9771182bc109685e15038232f8d35daecc/backend/app/store/image/image.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/image/image.go?ref=b7045d9771182bc109685e15038232f8d35daecc",
      "patch": "@@ -13,6 +13,7 @@ import (\n \t_ \"image/jpeg\"\n \t\"image/png\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"net/http\"\n \t\"strings\"\n \t\"sync\"\n@@ -195,6 +196,25 @@ func isValidImage(b []byte) bool {\n \treturn ct == \"image/gif\" || ct == \"image/png\" || ct == \"image/jpeg\" || ct == \"image/webp\"\n }\n \n+func readAndValidateImage(r io.Reader, maxSize int) ([]byte, error) {\n+\tlr := io.LimitReader(r, int64(maxSize)+1)\n+\tdata, err := ioutil.ReadAll(lr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif len(data) > maxSize {\n+\t\treturn nil, errors.Errorf(\"file is too large (limit=%d)\", maxSize)\n+\t}\n+\n+\t// read header first, needs it to check if data is valid png/gif/jpeg\n+\tif !isValidImage(data[:512]) {\n+\t\treturn nil, errors.Errorf(\"file format is not allowed\")\n+\t}\n+\n+\treturn data, nil\n+}\n+\n // guid makes a globally unique id\n func guid() string {\n \treturn xid.New().String()"
    }
  ]
}
