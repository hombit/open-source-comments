{
  "sha": "ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOmRkZDQ2NmVjNDFmMDdhMWU3MjVjM2FjNzVmY2NmZjVmNWM1OTQzNWE=",
  "commit": {
    "author": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2019-11-22T08:24:26Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-11-22T08:24:26Z"
    },
    "message": "implement user details storage (#469)\n\n* implement (strings) user details storage\r\n\r\n* add rpc user details implementation\r\n\r\n* return error from getUserDetail, rewrite tests to table tests\r\n\r\n* make UserDetails store UserDetailEntry instead of strings\r\n\r\n* update comment about user_details\r\n\r\n* fix confusing return\r\n\r\n* add user details support for memory store\r\n\r\n* add engine.UserDetailEntry to service.UserMetaData\r\n\r\n* add ListDetails support to memory storage\r\n\r\n* add user details support to native migrator, ListDetails func to storage\r\n\r\n* go mod tidy for memory storage\r\n\r\n* increase memory storage test coverage, fix tests naming\r\n\r\n* add ListDetails tests to memory storage\r\n\r\n* add engine.ListDetails and  service.[Set]Metas tests\r\n\r\n* change Fprintf to Fprint (triggered by explicitly ignoring error)\r\n\r\n* remove Delete from engine.UserDetail, implement list via same method\r\n\r\n* adjust service.Metas to new engine.UserDetails signature\r\n\r\n* introduce engine.UserDetail(\"all\") consonant\r\n\r\n* fix Meta user detail retrieval\r\n\r\n* extend store implementations Delete method with UserDetail deletion\r\n\r\n* make UserDetail test answer order-independent\r\n\r\n* fix flaky test check in TestMemData_FlagListBlocked\r\n\r\n* delete user details alongside with comments on deleteme request\r\n\r\n* add tests to UserDetail store.Delete implementations\r\n\r\n* clarify engine module user details consonants names\r\n\r\n* update comments to reflect current state of code\r\n\r\n* check for value absence instead of it's length\r\n\r\n* revert unneeded code change\r\n\r\n* add extensive commentary on UserDetail return type\r\n\r\n* remove unused check condition\r\n\r\n* clarify UserDetail tests to be truly stateless\r\n\r\n* add clarifying comment for pre-table test",
    "tree": {
      "sha": "1f5d1eea7505b7e156270c0c6a58431f5e4addd3",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/1f5d1eea7505b7e156270c0c6a58431f5e4addd3"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
  "html_url": "https://github.com/umputun/remark/commit/ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/comments",
  "author": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars1.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "773da16649da8bc499cbb4c78f33466058e087e1",
      "url": "https://api.github.com/repos/umputun/remark/commits/773da16649da8bc499cbb4c78f33466058e087e1",
      "html_url": "https://github.com/umputun/remark/commit/773da16649da8bc499cbb4c78f33466058e087e1"
    }
  ],
  "stats": {
    "total": 715,
    "additions": 659,
    "deletions": 56
  },
  "files": [
    {
      "sha": "024520d000f876735e4e0481c5b2e13fcb24680f",
      "filename": "backend/_example/memory_store/accessor/data.go",
      "status": "modified",
      "additions": 129,
      "deletions": 5,
      "changes": 134,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/accessor/data.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/accessor/data.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/accessor/data.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -41,6 +41,7 @@ type metaUser struct {\n \tVerified     bool\n \tBlocked      bool\n \tBlockedUntil time.Time\n+\tDetails      engine.UserDetailEntry\n }\n \n // NewMemData makes in-memory engine.\n@@ -280,17 +281,51 @@ func (m *MemData) ListFlags(req engine.FlagRequest) (res []interface{}, err erro\n \treturn nil, errors.Errorf(\"flag %s not listable\", req.Flag)\n }\n \n-// Delete post(s), user, comment, or everything\n+// UserDetail sets or gets single detail value, or gets all details foÂ§r requested site.\n+// UserDetail returns list even for single entry request is a compromise in order to have both single detail getting and setting\n+// and all site's details listing under the same function (and not to extend engine interface by two separate functions).\n+func (m *MemData) UserDetail(req engine.UserDetailRequest) ([]engine.UserDetailEntry, error) {\n+\tswitch req.Detail {\n+\tcase engine.UserEmail:\n+\t\tif req.UserID == \"\" {\n+\t\t\treturn nil, errors.New(\"userid cannot be empty in request for single detail\")\n+\t\t}\n+\n+\t\tm.Lock()\n+\t\tdefer m.Unlock()\n+\n+\t\tif req.Update == \"\" { // read detail value, no update requested\n+\t\t\treturn m.getUserDetail(req)\n+\t\t}\n+\n+\t\treturn m.setUserDetail(req)\n+\tcase engine.AllUserDetails:\n+\t\t// list of all details returned in case request is a read request\n+\t\t// (Update is not set) and does not have UserID or Detail set\n+\t\tif req.Update == \"\" && req.UserID == \"\" { // read list of all details\n+\t\t\tm.Lock()\n+\t\t\tdefer m.Unlock()\n+\t\t\treturn m.listDetails(req.Locator)\n+\t\t}\n+\t\treturn nil, errors.New(\"unsupported request with userdetail all\")\n+\tdefault:\n+\t\treturn nil, errors.Errorf(\"unsupported detail %q\", req.Detail)\n+\t}\n+}\n+\n+// Delete post(s), user, comment, user details, or everything\n func (m *MemData) Delete(req engine.DeleteRequest) error {\n \n \tm.Lock()\n \tdefer m.Unlock()\n \n \tswitch {\n-\tcase req.Locator.URL != \"\" && req.CommentID != \"\": // delete comment\n+\tcase req.UserDetail != \"\": // delete user detail\n+\t\treturn m.deleteUserDetail(req.Locator, req.UserID, req.UserDetail)\n+\tcase req.Locator.URL != \"\" && req.CommentID != \"\" && req.UserDetail == \"\": // delete comment\n \t\treturn m.deleteComment(req.Locator, req.CommentID, req.DeleteMode)\n \n-\tcase req.Locator.SiteID != \"\" && req.UserID != \"\" && req.CommentID == \"\": // delete user\n+\tcase req.Locator.SiteID != \"\" && req.UserID != \"\" && req.CommentID == \"\" && req.UserDetail == \"\": // delete user\n \t\tcomments := m.match(m.posts[req.Locator.SiteID], func(c store.Comment) bool {\n \t\t\treturn c.User.ID == req.UserID && !c.Deleted\n \t\t})\n@@ -299,9 +334,9 @@ func (m *MemData) Delete(req engine.DeleteRequest) error {\n \t\t\t\treturn e\n \t\t\t}\n \t\t}\n-\t\treturn nil\n+\t\treturn m.deleteUserDetail(req.Locator, req.UserID, engine.AllUserDetails)\n \n-\tcase req.Locator.SiteID != \"\" && req.Locator.URL == \"\" && req.CommentID == \"\" && req.UserID == \"\": // delete site\n+\tcase req.Locator.SiteID != \"\" && req.Locator.URL == \"\" && req.CommentID == \"\" && req.UserID == \"\" && req.UserDetail == \"\": // delete site\n \t\tif _, ok := m.posts[req.Locator.SiteID]; !ok {\n \t\t\treturn errors.New(\"not found\")\n \t\t}\n@@ -401,6 +436,95 @@ func (m *MemData) setFlag(req engine.FlagRequest) (res bool, err error) {\n \treturn status, errors.Wrapf(err, \"failed to set flag %+v\", req)\n }\n \n+// getUserDetail returns UserDetailEntry with requested userDetail (omitting other details)\n+// as an only element of the slice.\n+func (m *MemData) getUserDetail(req engine.UserDetailRequest) ([]engine.UserDetailEntry, error) {\n+\tif meta, ok := m.metaUsers[req.UserID]; ok {\n+\t\tif meta.SiteID != req.Locator.SiteID {\n+\t\t\treturn []engine.UserDetailEntry{}, nil\n+\t\t}\n+\t\tswitch req.Detail {\n+\t\tcase engine.UserEmail:\n+\t\t\treturn []engine.UserDetailEntry{{UserID: req.UserID, Email: meta.Details.Email}}, nil\n+\t\t}\n+\t}\n+\n+\treturn []engine.UserDetailEntry{}, nil\n+}\n+\n+// setUserDetail sets requested userDetail, returning complete updated UserDetailEntry as an onlyIps\n+// element of the slice in case of success\n+func (m *MemData) setUserDetail(req engine.UserDetailRequest) ([]engine.UserDetailEntry, error) {\n+\tvar entry metaUser\n+\tif meta, ok := m.metaUsers[req.UserID]; ok {\n+\t\tif meta.SiteID != req.Locator.SiteID {\n+\t\t\treturn []engine.UserDetailEntry{}, nil\n+\t\t}\n+\t\tentry = meta\n+\t}\n+\n+\tif entry == (metaUser{}) {\n+\t\tentry = metaUser{\n+\t\t\tUserID:  req.UserID,\n+\t\t\tSiteID:  req.Locator.SiteID,\n+\t\t\tDetails: engine.UserDetailEntry{UserID: req.UserID},\n+\t\t}\n+\t}\n+\n+\tswitch req.Detail {\n+\tcase engine.UserEmail:\n+\t\tentry.Details.Email = req.Update\n+\t\tm.metaUsers[req.UserID] = entry\n+\t\treturn []engine.UserDetailEntry{{UserID: req.UserID, Email: req.Update}}, nil\n+\t}\n+\n+\treturn []engine.UserDetailEntry{}, nil\n+}\n+\n+// listDetails lists all available users details for given siteID\n+func (m *MemData) listDetails(loc store.Locator) ([]engine.UserDetailEntry, error) {\n+\tvar res []engine.UserDetailEntry\n+\tfor _, u := range m.metaUsers {\n+\t\tif u.SiteID == loc.SiteID {\n+\t\t\tres = append(res, u.Details)\n+\t\t}\n+\t}\n+\treturn res, nil\n+}\n+\n+// deleteUserDetail deletes requested UserDetail or whole UserDetailEntry,\n+// deletion of the absent entry doesn't produce error.\n+// Trying to delete user with wrong siteID doesn't to anything and doesn't produce error.\n+func (m *MemData) deleteUserDetail(locator store.Locator, userID string, userDetail engine.UserDetail) error {\n+\tvar entry metaUser\n+\tif meta, ok := m.metaUsers[userID]; ok {\n+\t\tif meta.SiteID != locator.SiteID {\n+\t\t\treturn nil\n+\t\t}\n+\t\tentry = meta\n+\t}\n+\n+\tif entry == (metaUser{}) || entry.Details == (engine.UserDetailEntry{}) {\n+\t\t// absent entry means that we should not do anything\n+\t\treturn nil\n+\t}\n+\n+\tswitch userDetail {\n+\tcase engine.UserEmail:\n+\t\tentry.Details.Email = \"\"\n+\tcase engine.AllUserDetails:\n+\t\tentry.Details = engine.UserDetailEntry{UserID: userID}\n+\t}\n+\n+\tif entry.Details == (engine.UserDetailEntry{UserID: userID}) {\n+\t\t// no user details are stored, empty details entry altogether\n+\t\tentry.Details = engine.UserDetailEntry{}\n+\t}\n+\n+\tm.metaUsers[userID] = entry\n+\treturn nil\n+}\n+\n func (m *MemData) get(loc store.Locator, commentID string) (store.Comment, error) {\n \tcomments := m.match(m.posts[loc.SiteID], func(c store.Comment) bool {\n \t\treturn c.Locator == loc && c.ID == commentID"
    },
    {
      "sha": "e1f4769d11dc40bdf1d514c2bd1e85ba54e2d230",
      "filename": "backend/_example/memory_store/accessor/data_test.go",
      "status": "modified",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/accessor/data_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/accessor/data_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/accessor/data_test.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -658,6 +658,43 @@ func TestMemData_DeleteAll(t *testing.T) {\n \tassert.Equal(t, 0, len(comments), \"nothing left\")\n }\n \n+func TestMemData_DeleteUserDetail(t *testing.T) {\n+\tvar (\n+\t\tcreateUser = engine.UserDetailRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"user1\", Detail: engine.UserEmail, Update: \"value1\"}\n+\t\treadUser   = engine.UserDetailRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"user1\", Detail: engine.UserEmail}\n+\t\temailSet   = []engine.UserDetailEntry{{UserID: \"user1\", Email: \"value1\"}}\n+\t\temailUnset = []engine.UserDetailEntry{{UserID: \"user1\", Email: \"\"}}\n+\t)\n+\n+\tb := prepMem(t)\n+\n+\tvar testData = []struct {\n+\t\tdelReq    engine.DeleteRequest\n+\t\tdetailReq engine.UserDetailRequest\n+\t\texpected  []engine.UserDetailEntry\n+\t}{\n+\t\t{delReq: engine.DeleteRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"user1\", UserDetail: engine.UserEmail},\n+\t\t\tdetailReq: createUser, expected: emailSet},\n+\t\t{delReq: engine.DeleteRequest{Locator: store.Locator{SiteID: \"bad\"}, UserID: \"user1\", UserDetail: engine.UserEmail},\n+\t\t\tdetailReq: readUser, expected: emailSet},\n+\t\t{delReq: engine.DeleteRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"user1\", UserDetail: engine.UserEmail},\n+\t\t\tdetailReq: readUser, expected: emailUnset},\n+\t\t{delReq: engine.DeleteRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"user1\", UserDetail: engine.AllUserDetails},\n+\t\t\tdetailReq: createUser, expected: emailSet},\n+\t\t{delReq: engine.DeleteRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"user1\", UserDetail: engine.AllUserDetails},\n+\t\t\tdetailReq: readUser, expected: emailUnset},\n+\t}\n+\n+\tfor i, x := range testData {\n+\t\terr := b.Delete(x.delReq)\n+\t\trequire.NoError(t, err, \"delete request #%d error\", i)\n+\n+\t\tval, err := b.UserDetail(x.detailReq)\n+\t\trequire.NoError(t, err, \"user request #%d error\", i)\n+\t\trequire.Equal(t, x.expected, val, \"user request #%d result\", i)\n+\t}\n+}\n+\n func TestMemAdmin_DeleteUserHard(t *testing.T) {\n \tb := prepMem(t)\n \terr := b.Delete(engine.DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\","
    },
    {
      "sha": "e5b1414d9d74028f5e87d272a676d606c5277454",
      "filename": "backend/_example/memory_store/server/rpc.go",
      "status": "modified",
      "additions": 24,
      "deletions": 11,
      "changes": 35,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/server/rpc.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/server/rpc.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/server/rpc.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -28,16 +28,17 @@ func NewRPC(e engine.Interface, a admin.Store, r *jrpc.Server) *RPC {\n func (s *RPC) addHandlers() {\n \t// data store handlers\n \ts.Group(\"store\", jrpc.HandlersGroup{\n-\t\t\"create\":     s.createHndl,\n-\t\t\"find\":       s.findHndl,\n-\t\t\"get\":        s.getHndl,\n-\t\t\"update\":     s.updateHndl,\n-\t\t\"count\":      s.countHndl,\n-\t\t\"info\":       s.infoHndl,\n-\t\t\"flag\":       s.flagHndl,\n-\t\t\"list_flags\": s.listFlagsHndl,\n-\t\t\"delete\":     s.deleteHndl,\n-\t\t\"close\":      s.closeHndl,\n+\t\t\"create\":      s.createHndl,\n+\t\t\"find\":        s.findHndl,\n+\t\t\"get\":         s.getHndl,\n+\t\t\"update\":      s.updateHndl,\n+\t\t\"count\":       s.countHndl,\n+\t\t\"info\":        s.infoHndl,\n+\t\t\"flag\":        s.flagHndl,\n+\t\t\"list_flags\":  s.listFlagsHndl,\n+\t\t\"user_detail\": s.userDetailHndl,\n+\t\t\"delete\":      s.deleteHndl,\n+\t\t\"close\":       s.closeHndl,\n \t})\n \n \t// admin store handlers\n@@ -129,7 +130,19 @@ func (s *RPC) listFlagsHndl(id uint64, params json.RawMessage) (rr jrpc.Response\n \treturn jrpc.EncodeResponse(id, flags, err)\n }\n \n-// deleteHndl delete post(s), user, comment, or everything\n+// userDetailHndl sets or gets single detail value, or gets all details for requested site.\n+// userDetailHndl returns list even for single entry request is a compromise in order to have both single detail getting and setting\n+// and all site's details listing under the same function (and not to extend engine interface by two separate functions).\n+func (s *RPC) userDetailHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n+\treq := engine.UserDetailRequest{}\n+\tif err := json.Unmarshal(params, &req); err != nil {\n+\t\treturn jrpc.Response{Error: err.Error()}\n+\t}\n+\tvalue, err := s.eng.UserDetail(req)\n+\treturn jrpc.EncodeResponse(id, value, err)\n+}\n+\n+// deleteHndl delete post(s), user, comment, user details, or everything\n func (s *RPC) deleteHndl(id uint64, params json.RawMessage) (rr jrpc.Response) {\n \treq := engine.DeleteRequest{}\n \tif err := json.Unmarshal(params, &req); err != nil {"
    },
    {
      "sha": "6879ca950e0dad3ef1b41fe477f1f6b407193f16",
      "filename": "backend/_example/memory_store/server/rpc_test.go",
      "status": "modified",
      "additions": 53,
      "deletions": 0,
      "changes": 53,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/server/rpc_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/_example/memory_store/server/rpc_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/_example/memory_store/server/rpc_test.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -223,6 +223,59 @@ func TestRPC_listFlagsHndl(t *testing.T) {\n \tassert.Equal(t, []interface{}{\"u1\"}, flags)\n }\n \n+func TestRPC_userDetailHndl(t *testing.T) {\n+\t_, port, teardown := prepTestStore(t)\n+\tdefer teardown()\n+\tapi := fmt.Sprintf(\"http://localhost:%d/test\", port)\n+\n+\tre := engine.RPC{Client: jrpc.Client{API: api, Client: http.Client{Timeout: 1 * time.Second}}}\n+\n+\t// add to entries to DB before we start\n+\tresult, err := re.UserDetail(engine.UserDetailRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"u1\", Detail: engine.UserEmail, Update: \"test@example.com\"})\n+\tassert.NoError(t, err, \"No error inserting entry expected\")\n+\tassert.ElementsMatch(t, []engine.UserDetailEntry{{UserID: \"u1\", Email: \"test@example.com\"}}, result)\n+\tresult, err = re.UserDetail(engine.UserDetailRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"u2\", Detail: engine.UserEmail, Update: \"other@example.com\"})\n+\tassert.NoError(t, err, \"No error inserting entry expected\")\n+\tassert.ElementsMatch(t, []engine.UserDetailEntry{{UserID: \"u2\", Email: \"other@example.com\"}}, result)\n+\n+\t// try to change existing entry with wrong SiteID\n+\tresult, err = re.UserDetail(engine.UserDetailRequest{Locator: store.Locator{SiteID: \"bad\"}, UserID: \"u2\", Detail: engine.UserEmail, Update: \"not_relevant\"})\n+\tassert.NoError(t, err, \"Updating existing entry with wrong SiteID doesn't produce error\")\n+\tassert.ElementsMatch(t, []engine.UserDetailEntry{}, result, \"Updating existing entry with wrong SiteID doesn't change anything\")\n+\n+\t// stateless tests without changing the state we set up before\n+\tvar testData = []struct {\n+\t\treq      engine.UserDetailRequest\n+\t\terror    string\n+\t\texpected []engine.UserDetailEntry\n+\t}{\n+\t\t{req: engine.UserDetailRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"u1\", Detail: engine.UserEmail},\n+\t\t\texpected: []engine.UserDetailEntry{{UserID: \"u1\", Email: \"test@example.com\"}}},\n+\t\t{req: engine.UserDetailRequest{Locator: store.Locator{SiteID: \"bad\"}, UserID: \"u1\", Detail: engine.UserEmail},\n+\t\t\texpected: []engine.UserDetailEntry{}},\n+\t\t{req: engine.UserDetailRequest{Locator: store.Locator{SiteID: \"test-site\"}, UserID: \"u1xyz\", Detail: engine.UserEmail},\n+\t\t\texpected: []engine.UserDetailEntry{}},\n+\t\t{req: engine.UserDetailRequest{Detail: engine.UserEmail, Update: \"new_value\"},\n+\t\t\terror: `userid cannot be empty in request for single detail`},\n+\t\t{req: engine.UserDetailRequest{Detail: engine.UserDetail(\"bad\")},\n+\t\t\terror: `unsupported detail \"bad\"`},\n+\t\t{req: engine.UserDetailRequest{Update: \"not_relevant\", Detail: engine.AllUserDetails},\n+\t\t\terror: `unsupported request with userdetail all`},\n+\t\t{req: engine.UserDetailRequest{Locator: store.Locator{SiteID: \"test-site\"}, Detail: engine.AllUserDetails},\n+\t\t\texpected: []engine.UserDetailEntry{{UserID: \"u1\", Email: \"test@example.com\"}, {UserID: \"u2\", Email: \"other@example.com\"}}},\n+\t}\n+\n+\tfor i, x := range testData {\n+\t\tresult, err := re.UserDetail(x.req)\n+\t\tif x.error != \"\" {\n+\t\t\tassert.EqualError(t, err, x.error, \"Error should match expected for case %d\", i)\n+\t\t} else {\n+\t\t\tassert.NoError(t, err, \"Error is not expected expected for case %d\", i)\n+\t\t}\n+\t\tassert.ElementsMatch(t, x.expected, result, \"Result should match expected for case %d\", i)\n+\t}\n+}\n+\n func TestRPC_deleteHndl(t *testing.T) {\n \t_, port, teardown := prepTestStore(t)\n \tdefer teardown()"
    },
    {
      "sha": "e18af8ab3d3330430f6261b424e85168c446b371",
      "filename": "backend/app/rest/api/admin.go",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/rest/api/admin.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/rest/api/admin.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/rest/api/admin.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -89,7 +89,7 @@ func (a *admin) getUserInfoCtrl(w http.ResponseWriter, r *http.Request) {\n \trender.JSON(w, r, ucomments[0].User)\n }\n \n-// GET /deleteme?token=jwt - delete all user comments by user's request. Gets info about deleted used from provided token\n+// GET /deleteme?token=jwt - delete all user comments and details by user's request. Gets info about deleted used from provided token\n // request made GET to allow direct click from the email sent by user\n func (a *admin) deleteMeRequestCtrl(w http.ResponseWriter, r *http.Request) {\n "
    },
    {
      "sha": "6cafebfa4eaa460ec0c235f6eeb5497c3658846d",
      "filename": "backend/app/store/engine/bolt.go",
      "status": "modified",
      "additions": 185,
      "deletions": 18,
      "changes": 203,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/bolt.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/bolt.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/bolt.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -16,12 +16,13 @@ import (\n )\n \n // BoltDB implements store.Interface, represents multiple sites with multiplexing to different bolt dbs. Thread safe.\n-// there are 5 types of top-level buckets:\n+// there are 6 types of top-level buckets:\n //  - comments for post in \"posts\" top-level bucket. Each url (post) makes its own bucket and each k:v pair is commentID:comment\n //  - history of all comments. They all in a single \"last\" bucket (per site) and key is defined by ref struct as ts+commentID\n //    value is not full comment but a reference combined from post-url+commentID\n //  - user to comment references in \"users\" bucket. It used to get comments for user. Key is userID and value\n //    is a nested bucket named userID with kv as ts:reference\n+//  - users details in \"user_details\" bucket. Key is userID, value - UserDetailEntry\n //  - blocking info sits in \"block\" bucket. Key is userID, value - ts\n //  - counts per post to keep number of comments. Key is post url, value - count\n //  - readonly per post to keep status of manually set RO posts. Key is post url, value - ts\n@@ -31,13 +32,14 @@ type BoltDB struct {\n \n const (\n \t// top level buckets\n-\tpostsBucketName    = \"posts\"\n-\tlastBucketName     = \"last\"\n-\tuserBucketName     = \"users\"\n-\tblocksBucketName   = \"block\"\n-\tinfoBucketName     = \"info\"\n-\treadonlyBucketName = \"readonly\"\n-\tverifiedBucketName = \"verified\"\n+\tpostsBucketName       = \"posts\"\n+\tlastBucketName        = \"last\"\n+\tuserBucketName        = \"users\"\n+\tuserDetailsBucketName = \"user_details\"\n+\tblocksBucketName      = \"block\"\n+\tinfoBucketName        = \"info\"\n+\treadonlyBucketName    = \"readonly\"\n+\tverifiedBucketName    = \"verified\"\n \n \ttsNano = \"2006-01-02T15:04:05.000000000Z07:00\"\n )\n@@ -59,8 +61,8 @@ func NewBoltDB(options bolt.Options, sites ...BoltSite) (*BoltDB, error) {\n \t\t}\n \n \t\t// make top-level buckets\n-\t\ttopBuckets := []string{postsBucketName, lastBucketName, userBucketName, blocksBucketName, infoBucketName,\n-\t\t\treadonlyBucketName, verifiedBucketName}\n+\t\ttopBuckets := []string{postsBucketName, lastBucketName, userBucketName, userDetailsBucketName,\n+\t\t\tblocksBucketName, infoBucketName, readonlyBucketName, verifiedBucketName}\n \t\terr = db.Update(func(tx *bolt.Tx) error {\n \t\t\tfor _, bktName := range topBuckets {\n \t\t\t\tif _, e := tx.CreateBucketIfNotExists([]byte(bktName)); e != nil {\n@@ -204,6 +206,33 @@ func (b *BoltDB) Flag(req FlagRequest) (val bool, err error) {\n \treturn b.setFlag(req)\n }\n \n+// UserDetail sets or gets single detail value, or gets all details for requested site.\n+// UserDetail returns list even for single entry request is a compromise in order to have both single detail getting and setting\n+// and all site's details listing under the same function (and not to extend interface by two separate functions).\n+func (b *BoltDB) UserDetail(req UserDetailRequest) ([]UserDetailEntry, error) {\n+\tswitch req.Detail {\n+\tcase UserEmail:\n+\t\tif req.UserID == \"\" {\n+\t\t\treturn nil, errors.New(\"userid cannot be empty in request for single detail\")\n+\t\t}\n+\n+\t\tif req.Update == \"\" { // read detail value, no update requested\n+\t\t\treturn b.getUserDetail(req)\n+\t\t}\n+\n+\t\treturn b.setUserDetail(req)\n+\tcase AllUserDetails:\n+\t\t// list of all details returned in case request is a read request\n+\t\t// (Update is not set) and does not have UserID\n+\t\tif req.Update == \"\" && req.UserID == \"\" { // read list of all details\n+\t\t\treturn b.listDetails(req.Locator)\n+\t\t}\n+\t\treturn nil, errors.New(\"unsupported request with userdetail all\")\n+\tdefault:\n+\t\treturn nil, errors.Errorf(\"unsupported detail %q\", req.Detail)\n+\t}\n+}\n+\n // Update for locator.URL with mutable part of comment\n func (b *BoltDB) Update(comment store.Comment) error {\n \n@@ -369,7 +398,7 @@ func (b *BoltDB) ListFlags(req FlagRequest) (res []interface{}, err error) {\n \treturn nil, errors.Errorf(\"flag %s not listable\", req.Flag)\n }\n \n-// Delete post(s) by id or by userID\n+// Delete post(s), user, comment, user details, or everything\n func (b *BoltDB) Delete(req DeleteRequest) error {\n \n \tbdb, e := b.db(req.Locator.SiteID)\n@@ -378,11 +407,13 @@ func (b *BoltDB) Delete(req DeleteRequest) error {\n \t}\n \n \tswitch {\n-\tcase req.Locator.URL != \"\" && req.CommentID != \"\":\n+\tcase req.UserDetail != \"\": // delete user detail\n+\t\treturn b.deleteUserDetail(bdb, req.UserID, req.UserDetail)\n+\tcase req.Locator.URL != \"\" && req.CommentID != \"\" && req.UserDetail == \"\": // delete comment\n \t\treturn b.deleteComment(bdb, req.Locator, req.CommentID, req.DeleteMode)\n-\tcase req.Locator.SiteID != \"\" && req.UserID != \"\" && req.CommentID == \"\":\n+\tcase req.Locator.SiteID != \"\" && req.UserID != \"\" && req.CommentID == \"\" && req.UserDetail == \"\": // delete user\n \t\treturn b.deleteUser(bdb, req.Locator.SiteID, req.UserID, req.DeleteMode)\n-\tcase req.Locator.SiteID != \"\" && req.Locator.URL == \"\" && req.CommentID == \"\" && req.UserID == \"\":\n+\tcase req.Locator.SiteID != \"\" && req.Locator.URL == \"\" && req.CommentID == \"\" && req.UserID == \"\" && req.UserDetail == \"\": // delete site\n \t\treturn b.deleteAll(bdb, req.Locator.SiteID)\n \t}\n \n@@ -617,6 +648,142 @@ func (b *BoltDB) flagBucket(tx *bolt.Tx, flag Flag) (bkt *bolt.Bucket, err error\n \treturn bkt, nil\n }\n \n+// getUserDetail returns UserDetailEntry with requested userDetail (omitting other details)\n+// as an only element of the slice.\n+func (b *BoltDB) getUserDetail(req UserDetailRequest) (result []UserDetailEntry, err error) {\n+\tbdb, e := b.db(req.Locator.SiteID)\n+\tif e != nil {\n+\t\treturn result, e\n+\t}\n+\n+\terr = bdb.View(func(tx *bolt.Tx) error {\n+\t\tvar entry UserDetailEntry\n+\t\tbucket := tx.Bucket([]byte(userDetailsBucketName))\n+\t\tvalue := bucket.Get([]byte(req.UserID))\n+\t\t// return no error in case of absent entry\n+\t\tif value != nil {\n+\t\t\tif err := json.Unmarshal(value, &entry); err != nil {\n+\t\t\t\treturn errors.Wrap(e, \"failed to unmarshal entry\")\n+\t\t\t}\n+\t\t\tswitch req.Detail {\n+\t\t\tcase UserEmail:\n+\t\t\t\tresult = []UserDetailEntry{{UserID: req.UserID, Email: entry.Email}}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n+\n+\treturn result, err\n+}\n+\n+// setUserDetail sets requested userDetail, returning complete updated UserDetailEntry as an onlyIps\n+// element of the slice in case of success\n+func (b *BoltDB) setUserDetail(req UserDetailRequest) (result []UserDetailEntry, err error) {\n+\tbdb, e := b.db(req.Locator.SiteID)\n+\tif e != nil {\n+\t\treturn result, e\n+\t}\n+\n+\tvar entry UserDetailEntry\n+\terr = bdb.View(func(tx *bolt.Tx) error {\n+\t\tbucket := tx.Bucket([]byte(userDetailsBucketName))\n+\t\tvalue := bucket.Get([]byte(req.UserID))\n+\t\t// return no error in case of absent entry\n+\t\tif value != nil {\n+\t\t\tif err := json.Unmarshal(value, &entry); err != nil {\n+\t\t\t\treturn errors.Wrap(e, \"failed to unmarshal entry\")\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn result, err\n+\t}\n+\n+\tif entry.UserID == \"\" {\n+\t\t// new entry to be created, need to set UserID for it\n+\t\tentry.UserID = req.UserID\n+\t}\n+\n+\tswitch req.Detail {\n+\tcase UserEmail:\n+\t\tentry.Email = req.Update\n+\t}\n+\n+\terr = bdb.Update(func(tx *bolt.Tx) error {\n+\t\terr := b.save(tx.Bucket([]byte(userDetailsBucketName)), req.UserID, entry)\n+\t\treturn errors.Wrapf(err, \"failed to update detail %s for %s in %s\", req.Detail, req.UserID, req.Locator.SiteID)\n+\t})\n+\n+\treturn []UserDetailEntry{entry}, err\n+}\n+\n+// listDetails lists all available users details for given site\n+func (b *BoltDB) listDetails(loc store.Locator) (result []UserDetailEntry, err error) {\n+\tbdb, e := b.db(loc.SiteID)\n+\tif e != nil {\n+\t\treturn result, e\n+\t}\n+\n+\terr = bdb.View(func(tx *bolt.Tx) error {\n+\t\tvar entry UserDetailEntry\n+\t\tbucket := tx.Bucket([]byte(userDetailsBucketName))\n+\t\treturn bucket.ForEach(func(userID, value []byte) error {\n+\t\t\tif err := json.Unmarshal(value, &entry); err != nil {\n+\t\t\t\treturn errors.Wrap(e, \"failed to unmarshal entry\")\n+\t\t\t}\n+\t\t\tresult = append(result, entry)\n+\t\t\treturn nil\n+\t\t})\n+\t})\n+\treturn result, err\n+}\n+\n+// deleteUserDetail deletes requested UserDetail or whole UserDetailEntry\n+func (b *BoltDB) deleteUserDetail(bdb *bolt.DB, userID string, userDetail UserDetail) error {\n+\tvar entry UserDetailEntry\n+\terr := bdb.View(func(tx *bolt.Tx) error {\n+\t\tbucket := tx.Bucket([]byte(userDetailsBucketName))\n+\t\tvalue := bucket.Get([]byte(userID))\n+\t\t// return no error in case of absent entry\n+\t\tif value != nil {\n+\t\t\tif err := json.Unmarshal(value, &entry); err != nil {\n+\t\t\t\treturn errors.Wrap(err, \"failed to unmarshal entry\")\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif entry == (UserDetailEntry{}) {\n+\t\t// absent entry means that we should not do anything\n+\t\treturn nil\n+\t}\n+\n+\tswitch userDetail {\n+\tcase UserEmail:\n+\t\tentry.Email = \"\"\n+\tcase AllUserDetails:\n+\t\tentry = UserDetailEntry{UserID: userID}\n+\t}\n+\n+\tif entry == (UserDetailEntry{UserID: userID}) {\n+\t\t// if entry doesn't have non-empty details, we should delete it\n+\t\treturn bdb.Update(func(tx *bolt.Tx) error {\n+\t\t\terr := tx.Bucket([]byte(userDetailsBucketName)).Delete([]byte(userID))\n+\t\t\treturn errors.Wrapf(err, \"failed to delete user detail %s for %s\", userDetail, userID)\n+\t\t})\n+\t}\n+\n+\treturn bdb.Update(func(tx *bolt.Tx) error {\n+\t\t// updated entry is not empty and we need to store it's updated copy\n+\t\terr := b.save(tx.Bucket([]byte(userDetailsBucketName)), userID, entry)\n+\t\treturn errors.Wrapf(err, \"failed to update detail %s for %s\", userDetail, userID)\n+\t})\n+}\n+\n func (b *BoltDB) deleteComment(bdb *bolt.DB, locator store.Locator, commentID string, mode store.DeleteMode) error {\n \n \treturn bdb.Update(func(tx *bolt.Tx) error {\n@@ -656,7 +823,7 @@ func (b *BoltDB) deleteComment(bdb *bolt.DB, locator store.Locator, commentID st\n func (b *BoltDB) deleteAll(bdb *bolt.DB, siteID string) error {\n \n \t// delete all buckets except blocked users\n-\ttoDelete := []string{postsBucketName, lastBucketName, userBucketName, infoBucketName}\n+\ttoDelete := []string{postsBucketName, lastBucketName, userBucketName, userDetailsBucketName, infoBucketName}\n \n \t// delete top-level buckets\n \terr := bdb.Update(func(tx *bolt.Tx) error {\n@@ -675,7 +842,7 @@ func (b *BoltDB) deleteAll(bdb *bolt.DB, siteID string) error {\n \treturn errors.Wrapf(err, \"failed to delete top level buckets from site %s\", siteID)\n }\n \n-// deleteUser removes all comments for given user. Everything will be market as deleted\n+// deleteUser removes all comments and details for given user. Everything will be market as deleted\n // and user name and userID will be changed to \"deleted\". Also removes from last and from user buckets.\n func (b *BoltDB) deleteUser(bdb *bolt.DB, siteID string, userID string, mode store.DeleteMode) error {\n \n@@ -722,7 +889,7 @@ func (b *BoltDB) deleteUser(bdb *bolt.DB, siteID string, userID string, mode sto\n \t\t}\n \t}\n \n-\t//  delete  user bucket in hard mode\n+\t// delete user bucket in hard mode\n \tif mode == store.HardDelete {\n \t\terr = bdb.Update(func(tx *bolt.Tx) error {\n \t\t\tusersBkt := tx.Bucket([]byte(userBucketName))\n@@ -743,7 +910,7 @@ func (b *BoltDB) deleteUser(bdb *bolt.DB, siteID string, userID string, mode sto\n \t\treturn errors.Errorf(\"unknown user %s\", userID)\n \t}\n \n-\treturn err\n+\treturn b.deleteUserDetail(bdb, userID, AllUserDetails)\n }\n \n // getPostBucket return bucket with all comments for postURL"
    },
    {
      "sha": "b33470b57b4aaf1221fe13f919e4c8754862e1bc",
      "filename": "backend/app/store/engine/bolt_test.go",
      "status": "modified",
      "additions": 89,
      "deletions": 0,
      "changes": 89,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/bolt_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/bolt_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/bolt_test.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -620,6 +620,53 @@ func TestBolt_FlagListBlocked(t *testing.T) {\n \n }\n \n+func TestBoltDB_UserDetail(t *testing.T) {\n+\n+\tb, teardown := prep(t)\n+\tdefer teardown()\n+\n+\t// add to entries to DB before we start\n+\tresult, err := b.UserDetail(UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"u1\", Detail: UserEmail, Update: \"test@example.com\"})\n+\tassert.NoError(t, err, \"No error inserting entry expected\")\n+\tassert.ElementsMatch(t, []UserDetailEntry{{UserID: \"u1\", Email: \"test@example.com\"}}, result)\n+\tresult, err = b.UserDetail(UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"u2\", Detail: UserEmail, Update: \"other@example.com\"})\n+\tassert.NoError(t, err, \"No error inserting entry expected\")\n+\tassert.ElementsMatch(t, []UserDetailEntry{{UserID: \"u2\", Email: \"other@example.com\"}}, result)\n+\n+\t// stateless tests without changing the state we set up before\n+\tvar testData = []struct {\n+\t\treq      UserDetailRequest\n+\t\terror    string\n+\t\texpected []UserDetailEntry\n+\t}{\n+\t\t{req: UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"u1\", Detail: UserEmail},\n+\t\t\texpected: []UserDetailEntry{{UserID: \"u1\", Email: \"test@example.com\"}}},\n+\t\t{req: UserDetailRequest{Locator: store.Locator{SiteID: \"bad\"}, UserID: \"u1\", Detail: UserEmail},\n+\t\t\terror: `site \"bad\" not found`},\n+\t\t{req: UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"u1xyz\", Detail: UserEmail}},\n+\t\t{req: UserDetailRequest{Detail: UserEmail, Update: \"new_value\"},\n+\t\t\terror: `userid cannot be empty in request for single detail`},\n+\t\t{req: UserDetailRequest{Detail: UserDetail(\"bad\")},\n+\t\t\terror: `unsupported detail \"bad\"`},\n+\t\t{req: UserDetailRequest{Update: \"not_relevant\", Detail: AllUserDetails},\n+\t\t\terror: `unsupported request with userdetail all`},\n+\t\t{req: UserDetailRequest{Locator: store.Locator{SiteID: \"bad\"}, Detail: AllUserDetails},\n+\t\t\terror: `site \"bad\" not found`},\n+\t\t{req: UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, Detail: AllUserDetails},\n+\t\t\texpected: []UserDetailEntry{{UserID: \"u1\", Email: \"test@example.com\"}, {UserID: \"u2\", Email: \"other@example.com\"}}},\n+\t}\n+\n+\tfor i, x := range testData {\n+\t\tresult, err := b.UserDetail(x.req)\n+\t\tif x.error != \"\" {\n+\t\t\tassert.EqualError(t, err, x.error, \"Error should match expected for case %d\", i)\n+\t\t} else {\n+\t\t\tassert.NoError(t, err, \"Error is not expected expected for case %d\", i)\n+\t\t}\n+\t\tassert.ElementsMatch(t, x.expected, result, \"Result should match expected for case %d\", i)\n+\t}\n+}\n+\n func TestBolt_DeleteComment(t *testing.T) {\n \n \tb, teardown := prep(t)\n@@ -713,6 +760,48 @@ func TestBolt_DeleteAll(t *testing.T) {\n \tassert.EqualError(t, err, `site \"bad\" not found`)\n }\n \n+func TestBolt_DeleteUserDetail(t *testing.T) {\n+\tvar (\n+\t\tcreateUser = UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", Detail: UserEmail, Update: \"value1\"}\n+\t\treadUser   = UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", Detail: UserEmail}\n+\t\temailSet   = []UserDetailEntry{{UserID: \"user1\", Email: \"value1\"}}\n+\t)\n+\n+\tb, teardown := prep(t)\n+\tdefer teardown()\n+\n+\tvar testData = []struct {\n+\t\tdelReq    DeleteRequest\n+\t\tdetailReq UserDetailRequest\n+\t\texpected  []UserDetailEntry\n+\t\terr       string\n+\t}{\n+\t\t{delReq: DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", UserDetail: UserEmail},\n+\t\t\tdetailReq: createUser, expected: emailSet},\n+\t\t{delReq: DeleteRequest{Locator: store.Locator{SiteID: \"bad\"}, UserID: \"user1\", UserDetail: UserEmail},\n+\t\t\tdetailReq: readUser, expected: emailSet, err: `site \"bad\" not found`},\n+\t\t{delReq: DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", UserDetail: UserEmail},\n+\t\t\tdetailReq: readUser},\n+\t\t{delReq: DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", UserDetail: AllUserDetails},\n+\t\t\tdetailReq: createUser, expected: emailSet},\n+\t\t{delReq: DeleteRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", UserDetail: AllUserDetails},\n+\t\t\tdetailReq: readUser},\n+\t}\n+\n+\tfor i, x := range testData {\n+\t\terr := b.Delete(x.delReq)\n+\t\tif x.err == \"\" {\n+\t\t\trequire.NoError(t, err, \"delete request #%d error\", i)\n+\t\t} else {\n+\t\t\trequire.EqualError(t, err, x.err, \"delete request #%d error\", i)\n+\t\t}\n+\n+\t\tval, err := b.UserDetail(x.detailReq)\n+\t\trequire.NoError(t, err, \"user request #%d error\", i)\n+\t\trequire.Equal(t, x.expected, val, \"user request #%d result\", i)\n+\t}\n+}\n+\n func TestBoltAdmin_DeleteUserHard(t *testing.T) {\n \n \tb, teardown := prep(t)"
    },
    {
      "sha": "abfaea6b347ca746c95bc1df6c46050ab84e9af1",
      "filename": "backend/app/store/engine/engine.go",
      "status": "modified",
      "additions": 36,
      "deletions": 10,
      "changes": 46,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/engine.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/engine.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/engine.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -16,16 +16,19 @@ import (\n \n // Interface defines methods provided by low-level storage engine\n type Interface interface {\n-\tCreate(comment store.Comment) (commentID string, err error) // create new comment, avoid dups by id\n-\tUpdate(comment store.Comment) error                         // update comment, mutable parts only\n-\tGet(req GetRequest) (store.Comment, error)                  // get comment by id\n-\tFind(req FindRequest) ([]store.Comment, error)              // find comments for locator or site\n-\tInfo(req InfoRequest) ([]store.PostInfo, error)             // get post(s) meta info\n-\tCount(req FindRequest) (int, error)                         // get count for post or user\n-\tDelete(req DeleteRequest) error                             // delete post(s) by id or by userID\n-\tFlag(req FlagRequest) (bool, error)                         // set and get flags\n-\tListFlags(req FlagRequest) ([]interface{}, error)           // get list of flagged keys, like blocked & verified user\n-\tClose() error                                               // close storage engine\n+\tCreate(comment store.Comment) (commentID string, err error)  // create new comment, avoid dups by id\n+\tUpdate(comment store.Comment) error                          // update comment, mutable parts only\n+\tGet(req GetRequest) (store.Comment, error)                   // get comment by id\n+\tFind(req FindRequest) ([]store.Comment, error)               // find comments for locator or site\n+\tInfo(req InfoRequest) ([]store.PostInfo, error)              // get post(s) meta info\n+\tCount(req FindRequest) (int, error)                          // get count for post or user\n+\tDelete(req DeleteRequest) error                              // Delete post(s), user, comment, user details, or everything\n+\tFlag(req FlagRequest) (bool, error)                          // set and get flags\n+\tListFlags(req FlagRequest) ([]interface{}, error)            // get list of flagged keys, like blocked & verified user\n+\tUserDetail(req UserDetailRequest) ([]UserDetailEntry, error) // sets or gets single detail value, or gets all details for requested site.\n+\t// UserDetail returns list even for single entry request is a compromise in order to have both single detail getting and setting\n+\t// and all site's details listing under the same function (and not to extend interface by two separate functions).\n+\tClose() error // close storage engine\n }\n \n // GetRequest is the input for Get func\n@@ -57,6 +60,7 @@ type DeleteRequest struct {\n \tLocator    store.Locator    `json:\"locator\"` // lack of URL means site operation\n \tCommentID  string           `json:\"comment_id,omitempty\"`\n \tUserID     string           `json:\"user_id,omitempty\"`\n+\tUserDetail UserDetail       `json:\"user_detail,omitempty\"`\n \tDeleteMode store.DeleteMode `json:\"del_mode\"`\n }\n \n@@ -79,6 +83,11 @@ const (\n \tVerified = Flag(\"verified\")\n \tBlocked  = Flag(\"blocked\")\n )\n+const (\n+\t// All possible user details\n+\tUserEmail      = UserDetail(\"email\")\n+\tAllUserDetails = UserDetail(\"all\") // used for listing and deletion requests\n+)\n \n // FlagRequest is the input for both get/set for flags, like blocked, verified and so on\n type FlagRequest struct {\n@@ -89,6 +98,23 @@ type FlagRequest struct {\n \tTTL     time.Duration `json:\"ttl,omitempty\"`     // ttl for time-sensitive flags only, like blocked for some period\n }\n \n+// UserDetail defines name of the user detail\n+type UserDetail string\n+\n+// UserDetailEntry contains single user details entry\n+type UserDetailEntry struct {\n+\tUserID string `json:\"user_id\"`         // duplicate user's id to use this structure not only embedded but separately\n+\tEmail  string `json:\"email,omitempty\"` // UserEmail\n+}\n+\n+// UserDetailRequest is the input for both get/set for details, like email\n+type UserDetailRequest struct {\n+\tDetail  UserDetail    `json:\"detail\"`           // detail name\n+\tLocator store.Locator `json:\"locator\"`          // post locator\n+\tUserID  string        `json:\"user_id\"`          // user id for get\\set\n+\tUpdate  string        `json:\"update,omitempty\"` // update value\n+}\n+\n const (\n \t// limits\n \tlastLimit = 1000"
    },
    {
      "sha": "47a66e3bae62a590c9ace1d6d1fce93d27f2cd0d",
      "filename": "backend/app/store/engine/engine_mock.go",
      "status": "modified",
      "additions": 26,
      "deletions": 4,
      "changes": 30,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/engine_mock.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/engine_mock.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/engine_mock.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -1,10 +1,9 @@\n // Code generated by mockery v1.0.0. DO NOT EDIT.\n+\n package engine\n \n-import (\n-\tmock \"github.com/stretchr/testify/mock\"\n-\tstore \"github.com/umputun/remark/backend/app/store\"\n-)\n+import mock \"github.com/stretchr/testify/mock\"\n+import store \"github.com/umputun/remark/backend/app/store\"\n \n // MockInterface is an autogenerated mock type for the Interface type\n type MockInterface struct {\n@@ -205,3 +204,26 @@ func (_m *MockInterface) Update(comment store.Comment) error {\n \n \treturn r0\n }\n+\n+// UserDetail provides a mock function with given fields: req\n+func (_m *MockInterface) UserDetail(req UserDetailRequest) ([]UserDetailEntry, error) {\n+\tret := _m.Called(req)\n+\n+\tvar r0 []UserDetailEntry\n+\tif rf, ok := ret.Get(0).(func(UserDetailRequest) []UserDetailEntry); ok {\n+\t\tr0 = rf(req)\n+\t} else {\n+\t\tif ret.Get(0) != nil {\n+\t\t\tr0 = ret.Get(0).([]UserDetailEntry)\n+\t\t}\n+\t}\n+\n+\tvar r1 error\n+\tif rf, ok := ret.Get(1).(func(UserDetailRequest) error); ok {\n+\t\tr1 = rf(req)\n+\t} else {\n+\t\tr1 = ret.Error(1)\n+\t}\n+\n+\treturn r0, r1\n+}"
    },
    {
      "sha": "5f8647378ad884a82f5ccfea9c25c55615ecfb03",
      "filename": "backend/app/store/engine/remote.go",
      "status": "modified",
      "additions": 13,
      "deletions": 1,
      "changes": 14,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/remote.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/remote.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/remote.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -82,6 +82,18 @@ func (r *RPC) ListFlags(req FlagRequest) (list []interface{}, err error) {\n \treturn list, err\n }\n \n+// UserDetail sets or gets single detail value, or gets all details for requested site.\n+// UserDetail returns list even for single entry request is a compromise in order to have both single detail getting and setting\n+// and all site's details listing under the same function (and not to extend interface by two separate functions).\n+func (r *RPC) UserDetail(req UserDetailRequest) (result []UserDetailEntry, err error) {\n+\tresp, err := r.Call(\"store.user_detail\", req)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\terr = json.Unmarshal(*resp.Result, &result)\n+\treturn result, err\n+}\n+\n // Count gets comments count by user or site\n func (r *RPC) Count(req FindRequest) (count int, err error) {\n \tresp, err := r.Call(\"store.count\", req)\n@@ -92,7 +104,7 @@ func (r *RPC) Count(req FindRequest) (count int, err error) {\n \treturn count, err\n }\n \n-// Delete post(s) by id or by userID\n+// Delete post(s), user, comment, user details, or everything\n func (r *RPC) Delete(req DeleteRequest) error {\n \t_, err := r.Call(\"store.delete\", req)\n \treturn err"
    },
    {
      "sha": "e9ae692b550c88ae1619321fcd7496e868f6ea89",
      "filename": "backend/app/store/engine/remote_test.go",
      "status": "modified",
      "additions": 23,
      "deletions": 1,
      "changes": 24,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/remote_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/engine/remote_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/engine/remote_test.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -139,6 +139,28 @@ func TestRemote_ListFlag(t *testing.T) {\n \tassert.Equal(t, []interface{}{map[string]interface{}{\"ID\": \"id1\"}, map[string]interface{}{\"ID\": \"id2\"}}, res)\n }\n \n+func TestRemote_UserDetail(t *testing.T) {\n+\tts := testServer(t, `{\"method\":\"store.user_detail\",\"params\":{\"detail\":\"email\",\"locator\":{\"url\":\"http://example.com/url\"},\"user_id\":\"username\"},\"id\":1}`, `{\"result\":[{\"user_id\":\"u1\",\"email\":\"test_email@example.com\"}]}`)\n+\tdefer ts.Close()\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n+\n+\treq := UserDetailRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, UserID: \"username\", Detail: UserEmail}\n+\tres, err := c.UserDetail(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []UserDetailEntry{{UserID: \"u1\", Email: \"test_email@example.com\"}}, res)\n+\tt.Logf(\"%v %T\", res, res)\n+}\n+\n+func TestRemote_UserDetailWithErrorResult(t *testing.T) {\n+\tts := testServer(t, `{\"method\":\"store.user_detail\",\"params\":{\"detail\":\"email\",\"locator\":{\"url\":\"http://example.com/url\"},\"user_id\":\"username\",\"update\":\"new_value@example.com\"},\"id\":1}`, `{\"error\":\"failed\"}`)\n+\tdefer ts.Close()\n+\tc := RPC{Client: jrpc.Client{API: ts.URL, Client: http.Client{}}}\n+\n+\treq := UserDetailRequest{Locator: store.Locator{URL: \"http://example.com/url\"}, UserID: \"username\", Detail: UserEmail, Update: \"new_value@example.com\"}\n+\t_, err := c.UserDetail(req)\n+\tassert.EqualError(t, err, \"failed\")\n+}\n+\n func TestRemote_Count(t *testing.T) {\n \tts := testServer(t, `{\"method\":\"store.count\",\"params\":{\"locator\":{\"url\":\"http://example.com/url\"},\"since\":\"0001-01-01T00:00:00Z\"},\"id\":1}`, `{\"result\":11}`)\n \tdefer ts.Close()\n@@ -173,6 +195,6 @@ func testServer(t *testing.T, req, resp string) *httptest.Server {\n \t\trequire.NoError(t, err)\n \t\tassert.Equal(t, req, string(body))\n \t\tt.Logf(\"req: %s\", string(body))\n-\t\tfmt.Fprintf(w, resp)\n+\t\t_, _ = fmt.Fprint(w, resp)\n \t}))\n }"
    },
    {
      "sha": "2defb9bb72d20fbbc97f96c3d93fba2c890746aa",
      "filename": "backend/app/store/service/service.go",
      "status": "modified",
      "additions": 24,
      "deletions": 3,
      "changes": 27,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/service/service.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/service/service.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/service/service.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -51,14 +51,15 @@ type DataStore struct {\n \t}\n }\n \n-// UserMetaData keeps info about user flags\n+// UserMetaData keeps info about user flags and details\n type UserMetaData struct {\n \tID      string `json:\"id\"`\n \tBlocked struct {\n \t\tStatus bool      `json:\"status\"`\n \t\tUntil  time.Time `json:\"until\"`\n \t} `json:\"blocked\"`\n-\tVerified bool `json:\"verified\"`\n+\tVerified bool                   `json:\"verified\"`\n+\tDetails  engine.UserDetailEntry `json:\"details,omitempty\"`\n }\n \n // PostMetaData keeps info about post flags\n@@ -665,7 +666,7 @@ func (s *DataStore) Metas(siteID string) (umetas []UserMetaData, pmetas []PostMe\n \t\t}\n \t}\n \n-\t// set users meta\n+\t// set users meta, key is userID\n \tm := map[string]UserMetaData{}\n \n \t// process blocked users\n@@ -698,6 +699,20 @@ func (s *DataStore) Metas(siteID string) (umetas []UserMetaData, pmetas []PostMe\n \t\tm[v] = val\n \t}\n \n+\t// process users details\n+\tusersDetails, err := s.Engine.UserDetail(engine.UserDetailRequest{Locator: store.Locator{SiteID: siteID}, Detail: engine.AllUserDetails})\n+\tif err != nil {\n+\t\treturn nil, nil, errors.Wrapf(err, \"can't get user details for %s\", siteID)\n+\t}\n+\tfor _, entry := range usersDetails {\n+\t\tval, ok := m[entry.UserID]\n+\t\tif !ok {\n+\t\t\tval = UserMetaData{ID: entry.UserID}\n+\t\t}\n+\t\tval.Details = entry\n+\t\tm[entry.UserID] = val\n+\t}\n+\n \tfor _, u := range m {\n \t\tumetas = append(umetas, u)\n \t}\n@@ -725,6 +740,12 @@ func (s *DataStore) SetMetas(siteID string, umetas []UserMetaData, pmetas []Post\n \t\tif um.Verified {\n \t\t\terrs = multierror.Append(errs, s.SetVerified(siteID, um.ID, true))\n \t\t}\n+\t\t// this code doesn't delete user details in case they are not set in import but present in DB already\n+\t\tif um.Details.Email != \"\" {\n+\t\t\treq := engine.UserDetailRequest{Locator: store.Locator{SiteID: siteID}, UserID: um.ID, Detail: engine.UserEmail, Update: um.Details.Email}\n+\t\t\t_, err := s.Engine.UserDetail(req)\n+\t\t\terrs = multierror.Append(errs, err)\n+\t\t}\n \t}\n \n \treturn errs.ErrorOrNil()"
    },
    {
      "sha": "8777fde93ef9f6a3d1fffd2366775f08e4a3e070",
      "filename": "backend/app/store/service/service_test.go",
      "status": "modified",
      "additions": 19,
      "deletions": 2,
      "changes": 21,
      "blob_url": "https://github.com/umputun/remark/blob/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/service/service_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/ddd466ec41f07a1e725c3ac75fccff5f5c59435a/backend/app/store/service/service_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/store/service/service_test.go?ref=ddd466ec41f07a1e725c3ac75fccff5f5c59435a",
      "patch": "@@ -718,15 +718,29 @@ func TestService_GetMetas(t *testing.T) {\n \tassert.NoError(t, b.SetBlock(\"radio-t\", \"user2\", true, time.Hour))\n \tassert.NoError(t, b.SetReadOnly(store.Locator{URL: \"https://radio-t.com\", SiteID: \"radio-t\"}, true))\n \n+\t// set email for one existing and one non-existing user\n+\treq := engine.UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user2\", Detail: engine.UserEmail, Update: \"test@example.org\"}\n+\tvalue, err := b.Engine.UserDetail(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []engine.UserDetailEntry{{UserID: \"user2\", Email: \"test@example.org\"}}, value)\n+\treq.UserID = \"user3\"\n+\tvalue, err = b.Engine.UserDetail(req)\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []engine.UserDetailEntry{{UserID: \"user3\", Email: \"test@example.org\"}}, value)\n+\n \tum, pm, err = b.Metas(\"radio-t\")\n \trequire.NoError(t, err)\n \n-\tassert.Equal(t, 2, len(um))\n+\tassert.Equal(t, 3, len(um))\n \tassert.Equal(t, \"user1\", um[0].ID)\n \tassert.Equal(t, true, um[0].Verified)\n+\tassert.Equal(t, engine.UserDetailEntry{Email: \"\"}, um[0].Details)\n \tassert.Equal(t, true, um[0].Blocked.Status)\n \tassert.Equal(t, false, um[1].Verified)\n \tassert.Equal(t, true, um[1].Blocked.Status)\n+\tassert.Equal(t, \"test@example.org\", um[1].Details.Email)\n+\tassert.Equal(t, \"user3\", um[2].ID)\n+\tassert.Equal(t, \"test@example.org\", um[2].Details.Email)\n \n \tassert.Equal(t, 1, len(pm))\n \tassert.Equal(t, \"https://radio-t.com\", pm[0].URL)\n@@ -743,7 +757,7 @@ func TestService_SetMetas(t *testing.T) {\n \terr := b.SetMetas(\"radio-t\", umetas, pmetas)\n \tassert.NoError(t, err, \"empty metas\")\n \n-\tum1 := UserMetaData{ID: \"user1\", Verified: true}\n+\tum1 := UserMetaData{ID: \"user1\", Verified: true, Details: engine.UserDetailEntry{Email: \"test@example.org\"}}\n \tum2 := UserMetaData{ID: \"user2\"}\n \tum2.Blocked.Status = true\n \tum2.Blocked.Until = time.Now().AddDate(0, 1, 1)\n@@ -755,6 +769,9 @@ func TestService_SetMetas(t *testing.T) {\n \tassert.True(t, b.IsReadOnly(store.Locator{SiteID: \"radio-t\", URL: \"https://radio-t.com\"}))\n \tassert.True(t, b.IsVerified(\"radio-t\", \"user1\"))\n \tassert.True(t, b.IsBlocked(\"radio-t\", \"user2\"))\n+\tval, err := b.Engine.UserDetail(engine.UserDetailRequest{Locator: store.Locator{SiteID: \"radio-t\"}, UserID: \"user1\", Detail: engine.UserEmail})\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, []engine.UserDetailEntry{{UserID: \"user1\", Email: \"test@example.org\"}}, val)\n }\n \n func TestService_IsAdmin(t *testing.T) {"
    }
  ]
}
