{
  "sha": "b40cb7866b9c4b39e2c352e929a0bead26db1369",
  "node_id": "MDY6Q29tbWl0MTE0ODI5NTAzOmI0MGNiNzg2NmI5YzRiMzllMmMzNTJlOTI5YTBiZWFkMjZkYjEzNjk=",
  "commit": {
    "author": {
      "name": "Dmitry Verkhoturov",
      "email": "paskal.07@gmail.com",
      "date": "2019-12-03T00:59:32Z"
    },
    "committer": {
      "name": "Umputun",
      "email": "umputun@gmail.com",
      "date": "2019-12-03T00:59:32Z"
    },
    "message": "Email sender implementation (#471)\n\n* email sender initial implementation\r\n\r\n* add VerificationMetadata into notify.Request\r\n\r\n* multiple review fixes\r\n\r\n- customizable verification notification message subject\r\n- clarify autoFlush nature in its commentary\r\n- defer writer.Close in Email.sendEmail instead of calling it manually,\r\n  potentially missing the call if error happened between the creation and\r\n  closing.\r\n\r\n* add explanatory commentary to notify.Request structure\r\n\r\n* fix TCP connection timout commentary typo\r\n\r\n* improve table tests presence\r\n\r\n* introduce parallelism to tests\r\n\r\n* abstract smtpClientWithMaker away\r\n\r\n* fix incorrect Email reference in Email.sendMessages\r\n\r\n* naming fixes, remove t.Parallel() from tests\r\n\r\n* consistent space in commentary\r\n\r\n* rename sendEmail to smtpSend, rearrange variables definitions\r\n\r\n* switch Email to create new connection for every Send request\r\n\r\n* fix tests for connection-per-submit email sending\r\n\r\n* fix tests\r\n\r\n* simplify sender object",
    "tree": {
      "sha": "6a6d55c6651766cc234062db98384cbeb9f3733b",
      "url": "https://api.github.com/repos/umputun/remark/git/trees/6a6d55c6651766cc234062db98384cbeb9f3733b"
    },
    "url": "https://api.github.com/repos/umputun/remark/git/commits/b40cb7866b9c4b39e2c352e929a0bead26db1369",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/umputun/remark/commits/b40cb7866b9c4b39e2c352e929a0bead26db1369",
  "html_url": "https://github.com/umputun/remark/commit/b40cb7866b9c4b39e2c352e929a0bead26db1369",
  "comments_url": "https://api.github.com/repos/umputun/remark/commits/b40cb7866b9c4b39e2c352e929a0bead26db1369/comments",
  "author": {
    "login": "paskal",
    "id": 712534,
    "node_id": "MDQ6VXNlcjcxMjUzNA==",
    "avatar_url": "https://avatars1.githubusercontent.com/u/712534?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/paskal",
    "html_url": "https://github.com/paskal",
    "followers_url": "https://api.github.com/users/paskal/followers",
    "following_url": "https://api.github.com/users/paskal/following{/other_user}",
    "gists_url": "https://api.github.com/users/paskal/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/paskal/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/paskal/subscriptions",
    "organizations_url": "https://api.github.com/users/paskal/orgs",
    "repos_url": "https://api.github.com/users/paskal/repos",
    "events_url": "https://api.github.com/users/paskal/events{/privacy}",
    "received_events_url": "https://api.github.com/users/paskal/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "umputun",
    "id": 535880,
    "node_id": "MDQ6VXNlcjUzNTg4MA==",
    "avatar_url": "https://avatars0.githubusercontent.com/u/535880?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/umputun",
    "html_url": "https://github.com/umputun",
    "followers_url": "https://api.github.com/users/umputun/followers",
    "following_url": "https://api.github.com/users/umputun/following{/other_user}",
    "gists_url": "https://api.github.com/users/umputun/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/umputun/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/umputun/subscriptions",
    "organizations_url": "https://api.github.com/users/umputun/orgs",
    "repos_url": "https://api.github.com/users/umputun/repos",
    "events_url": "https://api.github.com/users/umputun/events{/privacy}",
    "received_events_url": "https://api.github.com/users/umputun/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ea8ac08c72a82a2ce8699ccd1ab049f565da4d25",
      "url": "https://api.github.com/repos/umputun/remark/commits/ea8ac08c72a82a2ce8699ccd1ab049f565da4d25",
      "html_url": "https://github.com/umputun/remark/commit/ea8ac08c72a82a2ce8699ccd1ab049f565da4d25"
    }
  ],
  "stats": {
    "total": 663,
    "additions": 657,
    "deletions": 6
  },
  "files": [
    {
      "sha": "158b7bdb26ab272d02cf331c48a7f28ecac2e7c3",
      "filename": "backend/app/notify/email.go",
      "status": "added",
      "additions": 339,
      "deletions": 0,
      "changes": 339,
      "blob_url": "https://github.com/umputun/remark/blob/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/email.go",
      "raw_url": "https://github.com/umputun/remark/raw/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/email.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/email.go?ref=b40cb7866b9c4b39e2c352e929a0bead26db1369",
      "patch": "@@ -0,0 +1,339 @@\n+package notify\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net\"\n+\t\"net/smtp\"\n+\t\"text/template\"\n+\t\"time\"\n+\n+\tlog \"github.com/go-pkgz/lgr\"\n+\t\"github.com/go-pkgz/repeater\"\n+\t\"github.com/hashicorp/go-multierror\"\n+\t\"github.com/pkg/errors\"\n+)\n+\n+// EmailParams contain settings for email notifications\n+type EmailParams struct {\n+\tFrom                 string        // From email field\n+\tMsgTemplate          string        // request message template\n+\tVerificationSubject  string        // verification message subject\n+\tVerificationTemplate string        // verification message template\n+\tBufferSize           int           // email send buffer size\n+\tFlushDuration        time.Duration // maximum time after which email will me sent, 30s by default\n+}\n+\n+// SmtpParams contain settings for smtp server connection\n+type SmtpParams struct {\n+\tHost     string        // SMTP host\n+\tPort     int           // SMTP port\n+\tTLS      bool          // TLS auth\n+\tUsername string        // user name\n+\tPassword string        // password\n+\tTimeOut  time.Duration // TCP connection timeout\n+}\n+\n+// Email implements notify.Destination for email\n+type Email struct {\n+\tEmailParams\n+\tSmtpParams\n+\n+\tsmtp       smtpClientCreator\n+\tmsgTmpl    *template.Template // parsed request message template\n+\tverifyTmpl *template.Template // parsed verification message template\n+}\n+\n+// default email client implementation\n+type emailClient struct{ smtpClientCreator }\n+\n+// smtpClient interface defines subset of net/smtp used by email client\n+type smtpClient interface {\n+\tMail(string) error\n+\tAuth(smtp.Auth) error\n+\tRcpt(string) error\n+\tData() (io.WriteCloser, error)\n+\tQuit() error\n+\tClose() error\n+}\n+\n+// smtpClientCreator interface defines function for creating new smtpClients\n+type smtpClientCreator interface {\n+\tCreate(SmtpParams) (smtpClient, error)\n+}\n+\n+type emailMessage struct {\n+\tfrom    string\n+\tto      string\n+\tmessage string\n+}\n+\n+// msgTmplData store data for message from request template execution\n+type msgTmplData struct {\n+\tFrom      string\n+\tTo        string\n+\tOrig      string\n+\tLink      string\n+\tPostTitle string\n+}\n+\n+// verifyTmplData store data for verification message template execution\n+type verifyTmplData struct {\n+\tUser  string\n+\tEmail string\n+\tToken string\n+\tSite  string\n+}\n+\n+const (\n+\tdefaultVerificationSubject = \"Email verification\"\n+\tdefaultEmailTimeout        = 10 * time.Second\n+\tdefaultFlushDuration       = time.Second * 30\n+\tdefaultEmailTemplate       = `{{.From}}{{if .To}} → {{.To}}{{end}}\n+\n+{{.Orig}}\n+\n+↦ <a href=\"{{.Link}}\">{{if .PostTitle}}{{.PostTitle}}{{else}}original comment{{end}}</a>\n+`\n+\tdefaultEmailVerificationTemplate = `Confirmation for {{.User}} {{.Email}}, site {{.Site}}\n+\n+Token: {{.Token}}\n+`\n+)\n+\n+// NewEmail makes new Email object, returns it even in case of problems\n+// (e.MsgTemplate parsing error or error while testing smtp connection by credentials provided in emailParams)\n+func NewEmail(emailParams EmailParams, smtpParams SmtpParams) (*Email, error) {\n+\tvar err error\n+\t// set up Email emailParams\n+\tres := Email{EmailParams: emailParams}\n+\tif res.FlushDuration <= 0 {\n+\t\tres.FlushDuration = defaultFlushDuration\n+\t}\n+\tif res.BufferSize <= 0 {\n+\t\tres.BufferSize = 1\n+\t}\n+\tif res.MsgTemplate == \"\" {\n+\t\tres.MsgTemplate = defaultEmailTemplate\n+\t}\n+\tif res.VerificationTemplate == \"\" {\n+\t\tres.VerificationTemplate = defaultEmailVerificationTemplate\n+\t}\n+\tif res.VerificationSubject == \"\" {\n+\t\tres.VerificationSubject = defaultVerificationSubject\n+\t}\n+\n+\t// set up SMTP emailParams\n+\tres.smtp = &emailClient{}\n+\tres.SmtpParams = smtpParams\n+\tif res.TimeOut <= 0 {\n+\t\tres.TimeOut = defaultEmailTimeout\n+\t}\n+\n+\tlog.Printf(\"[DEBUG] Create new email notifier for server %s with user %s, timeout=%s\",\n+\t\tres.Host, res.Username, res.TimeOut)\n+\n+\t// initialise templates\n+\tres.msgTmpl, err = template.New(\"messageFromRequest\").Parse(res.MsgTemplate)\n+\tif err != nil {\n+\t\treturn &res, errors.Wrapf(err, \"can't parse message template\")\n+\t}\n+\tres.verifyTmpl, err = template.New(\"messageFromRequest\").Parse(res.VerificationTemplate)\n+\tif err != nil {\n+\t\treturn &res, errors.Wrapf(err, \"can't parse verification template\")\n+\t}\n+\n+\t// establish test connection\n+\ttestSmtpClient, err := res.smtp.Create(res.SmtpParams)\n+\tif err != nil {\n+\t\treturn &res, errors.Wrapf(err, \"can't establish test connection\")\n+\t}\n+\tif err = testSmtpClient.Quit(); err != nil {\n+\t\tlog.Printf(\"[WARN] failed to send quit command to %s:%d, %v\", res.Host, res.Port, err)\n+\t\tif err = testSmtpClient.Close(); err != nil {\n+\t\t\treturn &res, errors.Wrapf(err, \"can't close test smtp connection\")\n+\t\t}\n+\t}\n+\treturn &res, err\n+}\n+\n+// Send email about reply to Request.Email if it's set, otherwise do nothing and return nil, thread safe\n+// do not returns sending error, only following:\n+// 1. (likely impossible) template execution error from email message creation from Request\n+// 2. message dropped without sending in case of closed ctx\n+func (e *Email) Send(ctx context.Context, req Request) (err error) {\n+\tif req.Email == \"\" {\n+\t\t// this means we can't send this request via Email\n+\t\treturn nil\n+\t}\n+\tselect {\n+\tcase <-ctx.Done():\n+\t\treturn errors.Errorf(\"sending message to %q aborted due to canceled context\", req.Email)\n+\tdefault:\n+\t}\n+\tvar msg string\n+\n+\tif req.Verification.Token != \"\" {\n+\t\tlog.Printf(\"[DEBUG] send verification via %s, user %s\", e, req.Verification.User)\n+\t\tmsg, err = e.buildVerificationMessage(req.Verification.User, req.Email, req.Verification.Token, req.Verification.Locator.SiteID)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tif req.Comment.ID != \"\" {\n+\t\tif req.parent.User == req.Comment.User {\n+\t\t\t// don't send anything if if user replied to their own Comment\n+\t\t\treturn nil\n+\t\t}\n+\t\tlog.Printf(\"[DEBUG] send notification via %s, comment id %s\", e, req.Comment.ID)\n+\t\tmsg, err = e.buildMessageFromRequest(req, req.Email)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn e.sendMessage(ctx, emailMessage{from: e.From, to: req.Email, message: msg})\n+}\n+\n+// buildVerificationMessage generates verification email message based on given input\n+func (e *Email) buildVerificationMessage(user, address, token, site string) (string, error) {\n+\tsubject := e.VerificationSubject\n+\tmsg := bytes.Buffer{}\n+\terr := e.verifyTmpl.Execute(&msg, verifyTmplData{user, address, token, site})\n+\tif err != nil {\n+\t\treturn \"\", errors.Wrapf(err, \"error executing template to build verifying message from request\")\n+\t}\n+\treturn e.buildMessage(subject, msg.String(), address, \"text/html\"), nil\n+}\n+\n+// buildMessage generates email message to send using net/smtp.Data()\n+func (e *Email) buildMessage(subject, body, to, contentType string) (message string) {\n+\tmessage += fmt.Sprintf(\"From: %s\\n\", e.From)\n+\tmessage += fmt.Sprintf(\"To: %s\\n\", to)\n+\tmessage += fmt.Sprintf(\"Subject: %s\\n\", subject)\n+\tif contentType != \"\" {\n+\t\tmessage += fmt.Sprintf(\"MIME-version: 1.0;\\nContent-Type: %s; charset=\\\"UTF-8\\\";\\n\", contentType)\n+\t}\n+\tmessage += \"\\n\" + body\n+\treturn message\n+}\n+\n+// buildMessageFromRequest generates email message based on Request using e.MsgTemplate\n+func (e *Email) buildMessageFromRequest(req Request, to string) (string, error) {\n+\tsubject := \"New comment\"\n+\tif req.Comment.PostTitle != \"\" {\n+\t\tsubject += fmt.Sprintf(\" for \\\"%s\\\"\", req.Comment.PostTitle)\n+\t}\n+\tmsg := bytes.Buffer{}\n+\terr := e.msgTmpl.Execute(&msg, msgTmplData{\n+\t\treq.Comment.User.Name,\n+\t\treq.parent.User.Name,\n+\t\treq.Comment.Orig,\n+\t\treq.Comment.Locator.URL + uiNav + req.Comment.ID,\n+\t\treq.Comment.PostTitle,\n+\t})\n+\tif err != nil {\n+\t\treturn \"\", errors.Wrapf(err, \"error executing template to build message from request\")\n+\t}\n+\treturn e.buildMessage(subject, msg.String(), to, \"text/html\"), nil\n+}\n+\n+// sendMessage sends messages to server in a new connection, closing the connection after finishing.\n+// Thread safe.\n+func (e *Email) sendMessage(ctx context.Context, m emailMessage) error {\n+\tif e.smtp == nil {\n+\t\treturn errors.New(\"sendMessage called without smtpClient set\")\n+\t}\n+\tsmtpClient, err := e.smtp.Create(e.SmtpParams)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"failed to make smtp Create\")\n+\t}\n+\n+\terrs := new(multierror.Error)\n+\n+\terr = repeater.NewDefault(5, time.Millisecond*250).Do(ctx, func() error {\n+\t\tif err := smtpClient.Mail(m.from); err != nil {\n+\t\t\treturn errors.Wrapf(err, \"bad from address %q\", m.from)\n+\t\t}\n+\t\tif err := smtpClient.Rcpt(m.to); err != nil {\n+\t\t\treturn errors.Wrapf(err, \"bad to address %q\", m.to)\n+\t\t}\n+\n+\t\twriter, err := smtpClient.Data()\n+\t\tif err != nil {\n+\t\t\treturn errors.Wrap(err, \"can't make email writer\")\n+\t\t}\n+\t\tdefer func() {\n+\t\t\tif err = writer.Close(); err != nil {\n+\t\t\t\tlog.Printf(\"[WARN] can't close smtp body writer, %v\", err)\n+\t\t\t}\n+\t\t}()\n+\n+\t\tbuf := bytes.NewBufferString(m.message)\n+\t\tif _, err = buf.WriteTo(writer); err != nil {\n+\t\t\treturn errors.Wrapf(err, \"failed to send email body to %q\", m.to)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\tif err != nil {\n+\t\terrs = multierror.Append(errs, errors.Wrapf(err, \"can't send message to %s\", m.to))\n+\t}\n+\n+\tif err := smtpClient.Quit(); err != nil {\n+\t\tlog.Printf(\"[WARN] failed to send quit command to %s:%d, %v\", e.Host, e.Port, err)\n+\t\tif err := smtpClient.Close(); err != nil {\n+\t\t\tlog.Printf(\"[WARN] can't close smtp connection, %v\", err)\n+\t\t\terrs = multierror.Append(errs, err)\n+\t\t}\n+\t}\n+\treturn errors.Wrapf(errs.ErrorOrNil(), \"problems with sending message\")\n+}\n+\n+// String representation of Email object\n+func (e *Email) String() string {\n+\treturn fmt.Sprintf(\"email: from %q using '%s'@'%s':%d\", e.From, e.Username, e.Host, e.Port)\n+}\n+\n+// Create establish SMTP connection with server using credentials in smtpClientWithCreator.SmtpParams\n+// and returns pointer to it. Thread safe.\n+func (s *emailClient) Create(params SmtpParams) (smtpClient, error) {\n+\tvar c *smtp.Client\n+\tsrvAddress := fmt.Sprintf(\"%s:%d\", params.Host, params.Port)\n+\tif params.TLS {\n+\t\ttlsConf := &tls.Config{\n+\t\t\tInsecureSkipVerify: false,\n+\t\t\tServerName:         params.Host,\n+\t\t}\n+\t\tconn, err := tls.Dial(\"tcp\", srvAddress, tlsConf)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrapf(err, \"failed to dial smtp tls to %s\", srvAddress)\n+\t\t}\n+\t\tif c, err = smtp.NewClient(conn, params.Host); err != nil {\n+\t\t\treturn nil, errors.Wrapf(err, \"failed to make smtp client for %s\", srvAddress)\n+\t\t}\n+\t\treturn c, nil\n+\t}\n+\n+\tconn, err := net.DialTimeout(\"tcp\", srvAddress, params.TimeOut)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrapf(err, \"timeout connecting to %s\", srvAddress)\n+\t}\n+\n+\tc, err = smtp.NewClient(conn, srvAddress)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrap(err, \"failed to dial\")\n+\t}\n+\n+\tif params.Username != \"\" && params.Password != \"\" {\n+\t\tauth := smtp.PlainAuth(\"\", params.Username, params.Password, params.Host)\n+\t\tif err := c.Auth(auth); err != nil {\n+\t\t\treturn nil, errors.Wrapf(err, \"failed to auth to smtp %s:%d\", params.Host, params.Port)\n+\t\t}\n+\t}\n+\n+\treturn c, nil\n+}"
    },
    {
      "sha": "7c977a795a4819d75fc3fb8985594ab1c8a57bd0",
      "filename": "backend/app/notify/email_test.go",
      "status": "added",
      "additions": 295,
      "deletions": 0,
      "changes": 295,
      "blob_url": "https://github.com/umputun/remark/blob/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/email_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/email_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/email_test.go?ref=b40cb7866b9c4b39e2c352e929a0bead26db1369",
      "patch": "@@ -0,0 +1,295 @@\n+package notify\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"net/smtp\"\n+\t\"sync\"\n+\t\"testing\"\n+\t\"text/template\"\n+\t\"time\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\n+\t\"github.com/umputun/remark/backend/app/store\"\n+)\n+\n+func TestEmailNew(t *testing.T) {\n+\tvar testSet = []struct {\n+\t\tname        string\n+\t\ttemplate    bool\n+\t\terr         bool\n+\t\terrText     string\n+\t\temailParams EmailParams\n+\t\tsmtpParams  SmtpParams\n+\t}{\n+\t\t{name: \"with connection error\", template: true, err: true},\n+\t\t{name: \"with template parse error\",\n+\t\t\terr: true, errText: \"can't parse message template: template: messageFromRequest:1: unexpected unclosed action in command\",\n+\t\t\temailParams: EmailParams{\n+\t\t\t\tFrom:          \"test@from\",\n+\t\t\t\tMsgTemplate:   \"{{\",\n+\t\t\t\tBufferSize:    10,\n+\t\t\t\tFlushDuration: time.Second,\n+\t\t\t}},\n+\t\t{name: \"with verification template parse error\",\n+\t\t\terr: true, errText: \"can't parse verification template: template: messageFromRequest:1: unexpected unclosed action in command\",\n+\t\t\ttemplate: true,\n+\t\t\temailParams: EmailParams{\n+\t\t\t\tVerificationTemplate: \"{{\",\n+\t\t\t},\n+\t\t\tsmtpParams: SmtpParams{\n+\t\t\t\tHost:     \"test@host\",\n+\t\t\t\tPort:     1000,\n+\t\t\t\tTLS:      true,\n+\t\t\t\tUsername: \"test@username\",\n+\t\t\t\tPassword: \"test@password\",\n+\t\t\t\tTimeOut:  time.Second,\n+\t\t\t},\n+\t\t},\n+\t}\n+\tfor _, d := range testSet {\n+\t\td := d // capture range variable\n+\t\tt.Run(d.name, func(t *testing.T) {\n+\t\t\temail, err := NewEmail(d.emailParams, d.smtpParams)\n+\n+\t\t\tif d.err && d.errText == \"\" {\n+\t\t\t\tassert.Error(t, err)\n+\t\t\t} else if d.err && d.errText != \"\" {\n+\t\t\t\tassert.EqualError(t, err, d.errText)\n+\t\t\t} else {\n+\t\t\t\tassert.NoError(t, err)\n+\t\t\t}\n+\n+\t\t\tassert.NotNil(t, email, \"email returned\")\n+\t\t\tif d.template {\n+\t\t\t\tassert.NotNil(t, email.msgTmpl, \"e.template is set\")\n+\t\t\t} else {\n+\t\t\t\tassert.Nil(t, email.msgTmpl, \"e.template is not set\")\n+\t\t\t}\n+\t\t\tif d.emailParams.MsgTemplate == \"\" {\n+\t\t\t\tassert.Equal(t, defaultEmailTemplate, email.EmailParams.MsgTemplate, \"empty emailParams.MsgTemplate changed to default\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, d.emailParams.MsgTemplate, email.EmailParams.MsgTemplate, \"emailParams.MsgTemplate unchanged after creation\")\n+\t\t\t}\n+\t\t\tif d.emailParams.FlushDuration == 0 {\n+\t\t\t\tassert.Equal(t, defaultFlushDuration, email.EmailParams.FlushDuration, \"empty emailParams.FlushDuration changed to default\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, d.emailParams.FlushDuration, email.EmailParams.FlushDuration, \"emailParams.FlushDuration unchanged after creation\")\n+\t\t\t}\n+\t\t\tif d.emailParams.BufferSize == 0 {\n+\t\t\t\tassert.Equal(t, 1, email.EmailParams.BufferSize, \"empty emailParams.BufferSize changed to default\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, d.emailParams.BufferSize, email.EmailParams.BufferSize, \"emailParams.BufferSize unchanged after creation\")\n+\t\t\t}\n+\t\t\tassert.Equal(t, d.emailParams.From, email.EmailParams.From, \"emailParams.From unchanged after creation\")\n+\t\t\tif d.smtpParams.TimeOut == 0 {\n+\t\t\t\tassert.Equal(t, defaultEmailTimeout, email.TimeOut, \"empty emailParams.TimeOut changed to default\")\n+\t\t\t} else {\n+\t\t\t\tassert.Equal(t, d.smtpParams.TimeOut, email.TimeOut, \"emailParams.TimOut unchanged after creation\")\n+\t\t\t}\n+\t\t\tassert.Equal(t, d.smtpParams.Host, email.Host, \"emailParams.Host unchanged after creation\")\n+\t\t\tassert.Equal(t, d.smtpParams.Username, email.Username, \"emailParams.Username unchanged after creation\")\n+\t\t\tassert.Equal(t, d.smtpParams.Password, email.Password, \"emailParams.Password unchanged after creation\")\n+\t\t\tassert.Equal(t, d.smtpParams.Port, email.Port, \"emailParams.Port unchanged after creation\")\n+\t\t\tassert.Equal(t, d.smtpParams.TLS, email.TLS, \"emailParams.TLS unchanged after creation\")\n+\t\t})\n+\t}\n+}\n+\n+func TestEmailSendErrors(t *testing.T) {\n+\tvar err error\n+\te := Email{EmailParams: EmailParams{FlushDuration: time.Second}}\n+\n+\te.verifyTmpl, err = template.New(\"test\").Parse(\"{{.Test}}\")\n+\tassert.NoError(t, err)\n+\tassert.EqualError(t, e.Send(context.Background(), Request{Email: \"bad@example.org\", Verification: VerificationMetadata{Token: \"some\"}}),\n+\t\t\"error executing template to build verifying message from request: template: test:1:2: executing \\\"test\\\" at <.Test>: can't evaluate field Test in type notify.verifyTmplData\")\n+\te.verifyTmpl, err = template.New(\"test\").Parse(defaultEmailVerificationTemplate)\n+\tassert.NoError(t, err)\n+\n+\te.msgTmpl, err = template.New(\"test\").Parse(\"{{.Test}}\")\n+\tassert.NoError(t, err)\n+\tassert.EqualError(t, e.Send(context.Background(), Request{Comment: store.Comment{ID: \"999\"}, parent: store.Comment{User: store.User{ID: \"test\"}}, Email: \"bad@example.org\"}),\n+\t\t\"error executing template to build message from request: template: test:1:2: executing \\\"test\\\" at <.Test>: can't evaluate field Test in type notify.msgTmplData\")\n+\te.msgTmpl, err = template.New(\"test\").Parse(defaultEmailTemplate)\n+\tassert.NoError(t, err)\n+\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tcancel()\n+\tassert.EqualError(t, e.Send(ctx, Request{Comment: store.Comment{ID: \"999\"}, parent: store.Comment{User: store.User{ID: \"test\"}}, Email: \"bad@example.org\"}),\n+\t\t\"sending message to \\\"bad@example.org\\\" aborted due to canceled context\")\n+}\n+\n+func TestEmailSend_ExitConditions(t *testing.T) {\n+\temail, err := NewEmail(EmailParams{}, SmtpParams{})\n+\tassert.Error(t, err, \"error match expected\")\n+\tassert.NotNil(t, email, \"expecting email returned\")\n+\t// prevent triggering e.autoFlush creation\n+\temptyRequest := Request{Comment: store.Comment{ID: \"999\"}}\n+\tassert.Nil(t, email.Send(context.Background(), emptyRequest),\n+\t\t\"Message without parent comment User.Email is not sent and returns nil\")\n+\trequestWithEqualUsersWithEmails := Request{Comment: store.Comment{ID: \"999\"}, Email: \"good_example@example.org\"}\n+\tassert.Nil(t, email.Send(context.Background(), requestWithEqualUsersWithEmails),\n+\t\t\"Message with parent comment User equals comment User is not sent and returns nil\")\n+}\n+\n+func TestEmailSendClientError(t *testing.T) {\n+\tvar testSet = []struct {\n+\t\tname string\n+\t\tsmtp *fakeTestSMTP\n+\t\terr  string\n+\t}{\n+\t\t{name: \"failed to verify receiver\", smtp: &fakeTestSMTP{fail: map[string]bool{\"mail\": true}},\n+\t\t\terr: \"problems with sending message: 1 error occurred:\\n\\t* can't send message to : bad from address \\\"\\\": failed to verify sender\\n\\n\"},\n+\t\t{name: \"failed to verify sender\", smtp: &fakeTestSMTP{fail: map[string]bool{\"rcpt\": true}},\n+\t\t\terr: \"problems with sending message: 1 error occurred:\\n\\t* can't send message to : bad to address \\\"\\\": failed to verify receiver\\n\\n\"},\n+\t\t{name: \"failed to close connection\", smtp: &fakeTestSMTP{fail: map[string]bool{\"quit\": true, \"close\": true}},\n+\t\t\terr: \"problems with sending message: 1 error occurred:\\n\\t* failed to close\\n\\n\"},\n+\t\t{name: \"failed to make email writer\", smtp: &fakeTestSMTP{fail: map[string]bool{\"data\": true}},\n+\t\t\terr: \"problems with sending message: 1 error occurred:\\n\\t* can't send message to : can't make email writer: failed to send\\n\\n\"},\n+\t}\n+\tfor _, d := range testSet {\n+\t\td := d // capture range variable\n+\t\tt.Run(d.name, func(t *testing.T) {\n+\t\t\te := Email{smtp: d.smtp}\n+\t\t\tassert.EqualError(t, e.sendMessage(context.Background(), emailMessage{}), d.err,\n+\t\t\t\t\"expected error for e.sendMessage\")\n+\t\t})\n+\t}\n+\te := Email{}\n+\te.smtp = nil\n+\tassert.Error(t, e.sendMessage(context.Background(), emailMessage{}),\n+\t\t\"nil e.smtp should return error\")\n+\te.smtp = &fakeTestSMTP{}\n+\tassert.NoError(t, e.sendMessage(context.Background(), emailMessage{}), \"\",\n+\t\t\"no error expected for e.sendMessage in normal flow\")\n+\te.smtp = &fakeTestSMTP{fail: map[string]bool{\"quit\": true}}\n+\tassert.NoError(t, e.sendMessage(context.Background(), emailMessage{}), \"\",\n+\t\t\"no error expected for e.sendMessage with failed smtpClient.Quit but successful smtpClient.Close\")\n+\te.smtp = &fakeTestSMTP{fail: map[string]bool{\"create\": true}}\n+\tassert.EqualError(t, e.sendMessage(context.Background(), emailMessage{}), \"failed to make smtp Create: failed to create client\",\n+\t\t\"e.send called without smtpClient set returns error\")\n+}\n+\n+func TestEmail_Send(t *testing.T) {\n+\tconst expectedAnswer = `From: from@example.org\n+To: test@example.org\n+Subject: New comment for \"test_title\"\n+MIME-version: 1.0;\n+Content-Type: text/html; charset=\"UTF-8\";\n+\n+test_user\n+\n+\n+\n+↦ <a href=\"#remark42__comment-999\">test_title</a>\n+`\n+\treq := Request{Comment: store.Comment{ID: \"999\", User: store.User{Name: \"test_user\"}, PostTitle: \"test_title\"}, Email: \"test@example.org\"}\n+\te, err := NewEmail(EmailParams{From: \"from@example.org\"}, SmtpParams{})\n+\tassert.Error(t, err, \"connection error expected\")\n+\tassert.NotNil(t, e)\n+\tfakeSmtp := fakeTestSMTP{}\n+\te.smtp = &fakeSmtp\n+\tassert.NoError(t, e.Send(context.TODO(), req))\n+\tassert.Equal(t, \"from@example.org\", fakeSmtp.readMail())\n+\tassert.Equal(t, 1, fakeSmtp.readQuitCount())\n+\tassert.Equal(t, \"test@example.org\", fakeSmtp.readRcpt())\n+\t// test buildMessageFromRequest separately for message text\n+\tres, err := e.buildMessageFromRequest(req, \"test@example.org\")\n+\tassert.NoError(t, err)\n+\tassert.Equal(t, expectedAnswer, res)\n+}\n+\n+type fakeTestSMTP struct {\n+\tfail map[string]bool\n+\n+\tbuff       bytes.Buffer\n+\tmail, rcpt string\n+\tauth       bool\n+\tclose      bool\n+\tquitCount  int\n+\tlock       sync.RWMutex\n+}\n+\n+func (f *fakeTestSMTP) Create(SmtpParams) (smtpClient, error) {\n+\tif f.fail[\"create\"] {\n+\t\treturn nil, errors.New(\"failed to create client\")\n+\t}\n+\treturn f, nil\n+}\n+\n+func (f *fakeTestSMTP) Auth(smtp.Auth) error { f.auth = true; return nil }\n+\n+func (f *fakeTestSMTP) Mail(m string) error {\n+\tf.lock.Lock()\n+\tf.mail = m\n+\tf.lock.Unlock()\n+\tif f.fail[\"mail\"] {\n+\t\treturn errors.New(\"failed to verify sender\")\n+\t}\n+\treturn nil\n+}\n+\n+func (f *fakeTestSMTP) Rcpt(r string) error {\n+\tf.lock.Lock()\n+\tf.rcpt = r\n+\tf.lock.Unlock()\n+\tif f.fail[\"rcpt\"] {\n+\t\treturn errors.New(\"failed to verify receiver\")\n+\t}\n+\treturn nil\n+}\n+\n+func (f *fakeTestSMTP) Quit() error {\n+\tf.lock.Lock()\n+\tf.quitCount++\n+\tf.lock.Unlock()\n+\tif f.fail[\"quit\"] {\n+\t\treturn errors.New(\"failed to quit\")\n+\t}\n+\treturn nil\n+}\n+\n+func (f *fakeTestSMTP) Close() error {\n+\tf.close = true\n+\tif f.fail[\"close\"] {\n+\t\treturn errors.New(\"failed to close\")\n+\t}\n+\treturn nil\n+}\n+\n+func (f *fakeTestSMTP) Data() (io.WriteCloser, error) {\n+\tif f.fail[\"data\"] {\n+\t\treturn nil, errors.New(\"failed to send\")\n+\t}\n+\treturn nopCloser{&f.buff}, nil\n+}\n+\n+func (f *fakeTestSMTP) readRcpt() string {\n+\tf.lock.RLock()\n+\tdefer f.lock.RUnlock()\n+\treturn f.rcpt\n+}\n+\n+func (f *fakeTestSMTP) readMail() string {\n+\tf.lock.RLock()\n+\tdefer f.lock.RUnlock()\n+\treturn f.mail\n+}\n+\n+func (f *fakeTestSMTP) readQuitCount() int {\n+\tf.lock.RLock()\n+\tdefer f.lock.RUnlock()\n+\treturn f.quitCount\n+}\n+\n+type nopCloser struct {\n+\tio.Writer\n+}\n+\n+func (nopCloser) Close() error {\n+\treturn nil\n+}"
    },
    {
      "sha": "7d07da8ce73cc45829c7a120054413bf1616d63e",
      "filename": "backend/app/notify/notify.go",
      "status": "modified",
      "additions": 15,
      "deletions": 4,
      "changes": 19,
      "blob_url": "https://github.com/umputun/remark/blob/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/notify.go",
      "raw_url": "https://github.com/umputun/remark/raw/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/notify.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/notify.go?ref=b40cb7866b9c4b39e2c352e929a0bead26db1369",
      "patch": "@@ -34,9 +34,19 @@ type Store interface {\n \tGet(locator store.Locator, id string, user store.User) (store.Comment, error)\n }\n \n+// Request notification either about comment or about particular user verification\n type Request struct {\n-\tComment store.Comment\n-\tparent  store.Comment\n+\tComment      store.Comment        // if set sent notifications about new comment\n+\tparent       store.Comment        // fetched only in case Comment is set\n+\tEmail        string               // if set (also) send email\n+\tVerification VerificationMetadata // if set sent verification notification\n+}\n+\n+// VerificationMetadata required to send notify method verification message\n+type VerificationMetadata struct {\n+\tLocator store.Locator // only SiteID is used\n+\tUser    string\n+\tToken   string\n }\n \n const defaultQueueSize = 100\n@@ -67,15 +77,16 @@ func (s *Service) Submit(req Request) {\n \tif len(s.destinations) == 0 || atomic.LoadUint32(&s.closed) != 0 {\n \t\treturn\n \t}\n-\tif s.dataService != nil {\n+\t// parent comment is fetched only if comment is present in the Request\n+\tif s.dataService != nil && req.Comment.ParentID != \"\" {\n \t\tif p, err := s.dataService.Get(req.Comment.Locator, req.Comment.ParentID, store.User{}); err == nil {\n \t\t\treq.parent = p\n \t\t}\n \t}\n \tselect {\n \tcase s.queue <- req:\n \tdefault:\n-\t\tlog.Printf(\"[WARN] can't send comment notification to queue, %+v\", req.Comment)\n+\t\tlog.Printf(\"[WARN] can't send notification to queue, %+v\", req.Comment)\n \t}\n }\n "
    },
    {
      "sha": "3927d3a71d4708ab2ed0da370f15e53bfc91ddb2",
      "filename": "backend/app/notify/notify_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark/blob/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/notify_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/notify_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/notify_test.go?ref=b40cb7866b9c4b39e2c352e929a0bead26db1369",
      "patch": "@@ -17,7 +17,8 @@ import (\n )\n \n func TestService_NoDestinations(t *testing.T) {\n-\ts := NewService(nil, 1)\n+\ts := NewService(nil, 0)\n+\tassert.Equal(t, defaultQueueSize, cap(s.queue))\n \tassert.NotNil(t, s)\n \ts.Submit(Request{Comment: store.Comment{ID: \"123\"}})\n \ts.Submit(Request{Comment: store.Comment{ID: \"123\"}})"
    },
    {
      "sha": "4d2537116556a32dd0af0fcc68295cb3ebf25bf2",
      "filename": "backend/app/notify/telegram.go",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/umputun/remark/blob/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/telegram.go",
      "raw_url": "https://github.com/umputun/remark/raw/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/telegram.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/telegram.go?ref=b40cb7866b9c4b39e2c352e929a0bead26db1369",
      "patch": "@@ -86,6 +86,10 @@ func NewTelegram(token string, channelID string, timeout time.Duration, api stri\n \n // Send to telegram channel\n func (t *Telegram) Send(ctx context.Context, req Request) error {\n+\tif req.Comment.ID == \"\" {\n+\t\t// verification request received, send nothing\n+\t\treturn nil\n+\t}\n \tclient := http.Client{Timeout: telegramTimeOut}\n \tlog.Printf(\"[DEBUG] send telegram notification to %s, comment id %s\", t.channelID, req.Comment.ID)\n "
    },
    {
      "sha": "e10e096c73b230b6eac7246b97b8077d63a2b00f",
      "filename": "backend/app/notify/telegram_test.go",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/umputun/remark/blob/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/telegram_test.go",
      "raw_url": "https://github.com/umputun/remark/raw/b40cb7866b9c4b39e2c352e929a0bead26db1369/backend/app/notify/telegram_test.go",
      "contents_url": "https://api.github.com/repos/umputun/remark/contents/backend/app/notify/telegram_test.go?ref=b40cb7866b9c4b39e2c352e929a0bead26db1369",
      "patch": "@@ -58,7 +58,7 @@ func TestTelegram_Send(t *testing.T) {\n \ttb, err := NewTelegram(\"good-token\", \"remark_test\", 2*time.Second, ts.URL+\"/\")\n \tassert.NoError(t, err)\n \tassert.NotNil(t, tb)\n-\tc := store.Comment{Text: \"some text\", ParentID: \"1\"}\n+\tc := store.Comment{Text: \"some text\", ParentID: \"1\", ID: \"999\"}\n \tc.User.Name = \"from\"\n \tcp := store.Comment{Text: \"some parent text\"}\n \tcp.User.Name = \"to\"\n@@ -76,6 +76,7 @@ func TestTelegram_Send(t *testing.T) {\n \tassert.Contains(t, err.Error(), \"unexpected telegram status code 404\", \"send on broken tg\")\n \n \tassert.Equal(t, \"telegram: @remark_test\", tb.String())\n+\trequire.Nil(t, tb.Send(context.TODO(), Request{}), \"Empty Comment doesn't send anything\")\n }\n \n func mockTelegramServer() *httptest.Server {"
    }
  ]
}
