{
  "sha": "a8f97bdb048e97fbf1bfab69040720f42be7a91a",
  "node_id": "MDY6Q29tbWl0MTI2ODkxODQ6YThmOTdiZGIwNDhlOTdmYmYxYmZhYjY5MDQwNzIwZjQyYmU3YTkxYQ==",
  "commit": {
    "author": {
      "name": "Pelle Wessman",
      "email": "pelle@kodfabrik.se",
      "date": "2019-11-09T18:57:57Z"
    },
    "committer": {
      "name": "Pelle Wessman",
      "email": "pelle@kodfabrik.se",
      "date": "2019-11-09T19:03:41Z"
    },
    "message": "Split functional tests in two",
    "tree": {
      "sha": "e0ed734b7e07fe1bf00e571c71de0fd66ae8e879",
      "url": "https://api.github.com/repos/voxpelli/webpage-webmentions/git/trees/e0ed734b7e07fe1bf00e571c71de0fd66ae8e879"
    },
    "url": "https://api.github.com/repos/voxpelli/webpage-webmentions/git/commits/a8f97bdb048e97fbf1bfab69040720f42be7a91a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/voxpelli/webpage-webmentions/commits/a8f97bdb048e97fbf1bfab69040720f42be7a91a",
  "html_url": "https://github.com/voxpelli/webpage-webmentions/commit/a8f97bdb048e97fbf1bfab69040720f42be7a91a",
  "comments_url": "https://api.github.com/repos/voxpelli/webpage-webmentions/commits/a8f97bdb048e97fbf1bfab69040720f42be7a91a/comments",
  "author": {
    "login": "voxpelli",
    "id": 34457,
    "node_id": "MDQ6VXNlcjM0NDU3",
    "avatar_url": "https://avatars1.githubusercontent.com/u/34457?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/voxpelli",
    "html_url": "https://github.com/voxpelli",
    "followers_url": "https://api.github.com/users/voxpelli/followers",
    "following_url": "https://api.github.com/users/voxpelli/following{/other_user}",
    "gists_url": "https://api.github.com/users/voxpelli/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/voxpelli/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/voxpelli/subscriptions",
    "organizations_url": "https://api.github.com/users/voxpelli/orgs",
    "repos_url": "https://api.github.com/users/voxpelli/repos",
    "events_url": "https://api.github.com/users/voxpelli/events{/privacy}",
    "received_events_url": "https://api.github.com/users/voxpelli/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "voxpelli",
    "id": 34457,
    "node_id": "MDQ6VXNlcjM0NDU3",
    "avatar_url": "https://avatars1.githubusercontent.com/u/34457?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/voxpelli",
    "html_url": "https://github.com/voxpelli",
    "followers_url": "https://api.github.com/users/voxpelli/followers",
    "following_url": "https://api.github.com/users/voxpelli/following{/other_user}",
    "gists_url": "https://api.github.com/users/voxpelli/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/voxpelli/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/voxpelli/subscriptions",
    "organizations_url": "https://api.github.com/users/voxpelli/orgs",
    "repos_url": "https://api.github.com/users/voxpelli/repos",
    "events_url": "https://api.github.com/users/voxpelli/events{/privacy}",
    "received_events_url": "https://api.github.com/users/voxpelli/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "723cd49bcb65750c26e00b9c28f217e11cf38f84",
      "url": "https://api.github.com/repos/voxpelli/webpage-webmentions/commits/723cd49bcb65750c26e00b9c28f217e11cf38f84",
      "html_url": "https://github.com/voxpelli/webpage-webmentions/commit/723cd49bcb65750c26e00b9c28f217e11cf38f84"
    }
  ],
  "stats": {
    "total": 558,
    "additions": 307,
    "deletions": 251
  },
  "files": [
    {
      "sha": "3dc099d8d063b8648a1d49cac87f2fe73d6eafb1",
      "filename": "test/functional/api.spec.js",
      "status": "modified",
      "additions": 7,
      "deletions": 251,
      "changes": 258,
      "blob_url": "https://github.com/voxpelli/webpage-webmentions/blob/a8f97bdb048e97fbf1bfab69040720f42be7a91a/test/functional/api.spec.js",
      "raw_url": "https://github.com/voxpelli/webpage-webmentions/raw/a8f97bdb048e97fbf1bfab69040720f42be7a91a/test/functional/api.spec.js",
      "contents_url": "https://api.github.com/repos/voxpelli/webpage-webmentions/contents/test/functional/api.spec.js?ref=a8f97bdb048e97fbf1bfab69040720f42be7a91a",
      "patch": "@@ -44,7 +44,7 @@ const isSinonStub = (value) => !!(value && value.restore && value.restore.sinon)\n  */\n const promisedWait = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));\n \n-describe('WebMention API', function () {\n+describe('parseSourcePage', function () {\n   this.timeout(15000);\n \n   let app;\n@@ -88,15 +88,6 @@ describe('WebMention API', function () {\n     return notificationPromise;\n   };\n \n-  /**\n-   * @param {number} [limit]\n-   * @returns {() => Promise<void>}\n-   */\n-  const waitForNotification = (limit) => {\n-    const notificationPromise = asyncNotification(limit);\n-    return () => notificationPromise;\n-  };\n-\n   before(async () => {\n     await dbUtils.clearDb();\n     await dbUtils.setupSchema();\n@@ -128,7 +119,7 @@ describe('WebMention API', function () {\n     }\n   });\n \n-  describe('parseSourcePage', () => {\n+  describe('basic', () => {\n     it('should handle the templates alright', async () => {\n       const mentionTargets = require('../template-mentions.json');\n       const templateMocks = [];\n@@ -472,7 +463,9 @@ describe('WebMention API', function () {\n     });\n \n     it('should properly handle pings of site that returns 404:s');\n+  });\n \n+  describe('salmention', () => {\n     it('should fetch comments found on mentions', async () => {\n       const templateMock = nock('http://example.com')\n         .get('/')\n@@ -746,7 +739,9 @@ describe('WebMention API', function () {\n         { count: '1' }\n       ]);\n     });\n+  });\n \n+  describe('error handling', () => {\n     it('should reject malformed source URL:s', async () =>\n       request(app)\n         .post('/api/webmention')\n@@ -797,246 +792,7 @@ describe('WebMention API', function () {\n     );\n   });\n \n-  describe('fetch mentions', () => {\n-    beforeEach(() => dbUtils.setupSampleMentions());\n-\n-    const matchMentions = (done, count, err, res) => {\n-      if (err) {\n-        return done(err);\n-      }\n-\n-      res.body.should.be.an('array').of.length(count);\n-\n-      res.body.should.have.nested.property('[0].name', null);\n-      res.body.should.have.nested.property('[0].url').that.match(/^https?:\\/\\/[^/]+\\//);\n-      res.body.should.have.nested.property('[0].author.name').that.is.a('string');\n-\n-      res.body.should.have.nested.property('[0].author.photo')\n-        .that.is.a('string')\n-        .that.match(/^https?:\\/\\/[^/]+\\//);\n-\n-      res.body.should.have.nested.property('[0].author.url')\n-        .that.is.a('string')\n-        .that.match(/^https?:\\/\\/[^/]+\\//);\n-\n-      res.body.should.have.nested.property('[0].published')\n-        .that.is.a('number')\n-        .that.is.closeTo(Date.now(), 31 * 24 * 60 * 60 * 1000);\n-\n-      res.body.should.have.nested.property('[0].targets')\n-        .that.is.an('array')\n-        .of.length.above(0);\n-\n-      res.body.should.have.nested.property('[0].type')\n-        .that.is.a('string')\n-        .that.match(/^(like|repost|reply|mention)$/);\n-\n-      res.body.should.have.nested.property('[0].interactions')\n-        .that.is.an('array');\n-\n-      done();\n-    };\n-\n-    it('should return all matching mentions in an expected format', (done) => {\n-      request(app)\n-        .get('/api/mentions')\n-        .query({ url: 'http://example.org/foo' })\n-        .expect(200)\n-        .end((err, res) => matchMentions(done, 4, err, res));\n-    });\n-\n-    it('should return example mentions in an expected format', (done) => {\n-      request(app)\n-        .get('/api/mentions')\n-        .query({ example: 1 })\n-        .expect(200)\n-        .end((err, res) => matchMentions(done, 14, err, res));\n-    });\n-\n-    // Test the resolveDerivedData() method and use\n-    it.skip('should derive interaction target status correctly');\n-\n-    it('should allow matching based on hostname', (done) => {\n-      request(app)\n-        .get('/api/mentions')\n-        .query({ site: 'example.org' })\n-        .expect(200)\n-        .end((err, res) => {\n-          if (err) {\n-            return done(err);\n-          }\n-\n-          res.body.should.be.an('array').of.length(10);\n-          res.body.should.have.nested.property('[0].author.name');\n-\n-          done();\n-        });\n-    });\n-\n-    it('should ignore www. in hostname', (done) => {\n-      request(app)\n-        .get('/api/mentions')\n-        .query({ site: 'www.example.org' })\n-        .expect(200)\n-        .end((err, res) => {\n-          if (err) {\n-            return done(err);\n-          }\n-\n-          res.body.should.be.an('array').of.length(10);\n-          res.body.should.have.nested.property('[0].author.name');\n-\n-          done();\n-        });\n-    });\n-\n-    it('should allow matching based on path', () => {\n-      return [\n-        () => new Promise((resolve, reject) => {\n-          request(app)\n-            .get('/api/mentions')\n-            .query({ path: 'http://example.org/path' })\n-            .expect(200)\n-            .end((err, res) => {\n-              if (err) {\n-                return reject(err);\n-              }\n-\n-              res.body.should.be.an('array').of.length(9);\n-              res.body.should.have.nested.property('[0].author.name');\n-\n-              resolve();\n-            });\n-        }),\n-        () => new Promise((resolve, reject) => {\n-          request(app)\n-            .get('/api/mentions')\n-            .query({ path: 'http://example.org/foo' })\n-            .expect(200)\n-            .end((err, res) => {\n-              if (err) {\n-                return reject(err);\n-              }\n-\n-              res.body.should.be.an('array').of.length(4);\n-              res.body.should.have.nested.property('[0].author.name');\n-\n-              resolve();\n-            });\n-        }),\n-        () => new Promise((resolve, reject) => {\n-          // Test that the escaping works\n-          request(app)\n-            .get('/api/mentions')\n-            .query({ path: ['http://example.org/%h', 'http://example.org/p_th'] })\n-            .expect(200)\n-            .end((err, res) => {\n-              if (err) {\n-                return reject(err);\n-              }\n-\n-              res.body.should.be.an('array').of.length(0);\n-\n-              resolve();\n-            });\n-        })\n-      ].reduce((result, next) => result.then(next), Promise.resolve());\n-    });\n-\n-    it('should ignore handle multiple matches', (done) => {\n-      request(app)\n-        .get('/api/mentions')\n-        .query({\n-          url: [\n-            'http://example.org/path/2',\n-            'http://example.org/path/4'\n-          ],\n-          path: 'http://example.org/foo'\n-        })\n-        .expect(200)\n-        .end((err, res) => {\n-          if (err) {\n-            return done(err);\n-          }\n-\n-          res.body.should.be.an('array').of.length(6);\n-          res.body.should.have.nested.property('[0].author.name');\n-\n-          done();\n-        });\n-    });\n-\n-    it('should sort the result', () => {\n-      return new Promise((resolve, reject) => {\n-        request(app)\n-          .get('/api/mentions')\n-          .query({ path: 'http://example.org/path' })\n-          .expect(200)\n-          .end((err, res) => {\n-            if (err) {\n-              return reject(err);\n-            }\n-\n-            res.body.should.be.an('array').and.satisfy(\n-              entries =>\n-                entries.reduce((previousValue, currentValue) => {\n-                  previousValue = previousValue.published || previousValue;\n-                  if (previousValue === false || previousValue >= currentValue.published) {\n-                    return false;\n-                  }\n-                  return currentValue.published;\n-                }) !== false,\n-              'Should sort by publish date, starting with the oldest one'\n-            );\n-\n-            resolve();\n-          });\n-      });\n-    });\n-\n-    it('should sort the result reversed when requested to', () => {\n-      return new Promise((resolve, reject) => {\n-        request(app)\n-          .get('/api/mentions')\n-          .query({ path: 'http://example.org/path', sort: 'desc' })\n-          .expect(200)\n-          .end((err, res) => {\n-            if (err) {\n-              return reject(err);\n-            }\n-\n-            res.body.should.be.an('array').and.satisfy(\n-              entries =>\n-                entries.reduce((previousValue, currentValue) => {\n-                  previousValue = previousValue.published || previousValue;\n-                  if (previousValue !== undefined && (previousValue === false || previousValue <= currentValue.published)) {\n-                    return false;\n-                  }\n-                  return currentValue.published;\n-                }) !== false,\n-              'Should sort by publish date, starting with the newest one'\n-            );\n-\n-            resolve();\n-          });\n-      });\n-    });\n-\n-    it('should return in HTML when requested', (done) => {\n-      request(app)\n-        .get('/api/mentions')\n-        .query({ site: 'example.org', format: 'html' })\n-        .expect(200)\n-        .end((err, res) => {\n-          if (err) {\n-            return done(err);\n-          }\n-\n-          done();\n-        });\n-    });\n-  });\n-\n+  // TODO: Add in its own file\n   describe('live updates', () => {\n     it.skip('should return data in an expected format');\n "
    },
    {
      "sha": "b0fa0419b4943eda3507c2e2a6164f8b1456fc56",
      "filename": "test/functional/fetch.spec.js",
      "status": "added",
      "additions": 300,
      "deletions": 0,
      "changes": 300,
      "blob_url": "https://github.com/voxpelli/webpage-webmentions/blob/a8f97bdb048e97fbf1bfab69040720f42be7a91a/test/functional/fetch.spec.js",
      "raw_url": "https://github.com/voxpelli/webpage-webmentions/raw/a8f97bdb048e97fbf1bfab69040720f42be7a91a/test/functional/fetch.spec.js",
      "contents_url": "https://api.github.com/repos/voxpelli/webpage-webmentions/contents/test/functional/fetch.spec.js?ref=a8f97bdb048e97fbf1bfab69040720f42be7a91a",
      "patch": "@@ -0,0 +1,300 @@\n+// @ts-check\n+/// <reference types=\"node\" />\n+/// <reference types=\"mocha\" />\n+/// <reference types=\"chai\" />\n+/// <reference types=\"sinon\" />\n+/// <reference types=\"supertest\" />\n+\n+'use strict';\n+\n+const chai = require('chai');\n+const chaiAsPromised = require('chai-as-promised');\n+const request = require('supertest');\n+const nock = require('nock');\n+const sinon = require('sinon');\n+\n+const dbUtils = require('../db-utils');\n+\n+chai.use(chaiAsPromised);\n+chai.should();\n+\n+/**\n+ * @param {number} timeout\n+ * @returns {Promise<void>}\n+ */\n+const promisedWait = (timeout) => new Promise(resolve => setTimeout(resolve, timeout));\n+\n+describe('Fetch mentions', function () {\n+  this.timeout(15000);\n+\n+  let app;\n+\n+  before(async () => {\n+    await dbUtils.clearDb();\n+    await dbUtils.setupSchema();\n+\n+    const main = require('../../lib/main');\n+\n+    app = main.app;\n+\n+    await promisedWait(1000);\n+  });\n+\n+  beforeEach(async () => {\n+    nock.cleanAll();\n+    nock.disableNetConnect();\n+    nock.enableNetConnect('127.0.0.1');\n+\n+    await dbUtils.clearDb();\n+    await dbUtils.setupSchema();\n+    await dbUtils.setupSampleData();\n+  });\n+\n+  afterEach(() => {\n+    sinon.verifyAndRestore();\n+\n+    if (!nock.isDone()) {\n+      throw new Error('pending mocks: ' + nock.pendingMocks());\n+    }\n+  });\n+\n+  describe('main', () => {\n+    beforeEach(() => dbUtils.setupSampleMentions());\n+\n+    const matchMentions = (done, count, err, res) => {\n+      if (err) {\n+        return done(err);\n+      }\n+\n+      res.body.should.be.an('array').of.length(count);\n+\n+      res.body.should.have.nested.property('[0].name', null);\n+      res.body.should.have.nested.property('[0].url').that.match(/^https?:\\/\\/[^/]+\\//);\n+      res.body.should.have.nested.property('[0].author.name').that.is.a('string');\n+\n+      res.body.should.have.nested.property('[0].author.photo')\n+        .that.is.a('string')\n+        .that.match(/^https?:\\/\\/[^/]+\\//);\n+\n+      res.body.should.have.nested.property('[0].author.url')\n+        .that.is.a('string')\n+        .that.match(/^https?:\\/\\/[^/]+\\//);\n+\n+      res.body.should.have.nested.property('[0].published')\n+        .that.is.a('number')\n+        .that.is.closeTo(Date.now(), 31 * 24 * 60 * 60 * 1000);\n+\n+      res.body.should.have.nested.property('[0].targets')\n+        .that.is.an('array')\n+        .of.length.above(0);\n+\n+      res.body.should.have.nested.property('[0].type')\n+        .that.is.a('string')\n+        .that.match(/^(like|repost|reply|mention)$/);\n+\n+      res.body.should.have.nested.property('[0].interactions')\n+        .that.is.an('array');\n+\n+      done();\n+    };\n+\n+    it('should return all matching mentions in an expected format', (done) => {\n+      request(app)\n+        .get('/api/mentions')\n+        .query({ url: 'http://example.org/foo' })\n+        .expect(200)\n+        .end((err, res) => matchMentions(done, 4, err, res));\n+    });\n+\n+    it('should return example mentions in an expected format', (done) => {\n+      request(app)\n+        .get('/api/mentions')\n+        .query({ example: 1 })\n+        .expect(200)\n+        .end((err, res) => matchMentions(done, 14, err, res));\n+    });\n+\n+    // Test the resolveDerivedData() method and use\n+    it.skip('should derive interaction target status correctly');\n+\n+    it('should allow matching based on hostname', (done) => {\n+      request(app)\n+        .get('/api/mentions')\n+        .query({ site: 'example.org' })\n+        .expect(200)\n+        .end((err, res) => {\n+          if (err) {\n+            return done(err);\n+          }\n+\n+          res.body.should.be.an('array').of.length(10);\n+          res.body.should.have.nested.property('[0].author.name');\n+\n+          done();\n+        });\n+    });\n+\n+    it('should ignore www. in hostname', (done) => {\n+      request(app)\n+        .get('/api/mentions')\n+        .query({ site: 'www.example.org' })\n+        .expect(200)\n+        .end((err, res) => {\n+          if (err) {\n+            return done(err);\n+          }\n+\n+          res.body.should.be.an('array').of.length(10);\n+          res.body.should.have.nested.property('[0].author.name');\n+\n+          done();\n+        });\n+    });\n+\n+    it('should allow matching based on path', () => {\n+      return [\n+        () => new Promise((resolve, reject) => {\n+          request(app)\n+            .get('/api/mentions')\n+            .query({ path: 'http://example.org/path' })\n+            .expect(200)\n+            .end((err, res) => {\n+              if (err) {\n+                return reject(err);\n+              }\n+\n+              res.body.should.be.an('array').of.length(9);\n+              res.body.should.have.nested.property('[0].author.name');\n+\n+              resolve();\n+            });\n+        }),\n+        () => new Promise((resolve, reject) => {\n+          request(app)\n+            .get('/api/mentions')\n+            .query({ path: 'http://example.org/foo' })\n+            .expect(200)\n+            .end((err, res) => {\n+              if (err) {\n+                return reject(err);\n+              }\n+\n+              res.body.should.be.an('array').of.length(4);\n+              res.body.should.have.nested.property('[0].author.name');\n+\n+              resolve();\n+            });\n+        }),\n+        () => new Promise((resolve, reject) => {\n+          // Test that the escaping works\n+          request(app)\n+            .get('/api/mentions')\n+            .query({ path: ['http://example.org/%h', 'http://example.org/p_th'] })\n+            .expect(200)\n+            .end((err, res) => {\n+              if (err) {\n+                return reject(err);\n+              }\n+\n+              res.body.should.be.an('array').of.length(0);\n+\n+              resolve();\n+            });\n+        })\n+      ].reduce((result, next) => result.then(next), Promise.resolve());\n+    });\n+\n+    it('should ignore handle multiple matches', (done) => {\n+      request(app)\n+        .get('/api/mentions')\n+        .query({\n+          url: [\n+            'http://example.org/path/2',\n+            'http://example.org/path/4'\n+          ],\n+          path: 'http://example.org/foo'\n+        })\n+        .expect(200)\n+        .end((err, res) => {\n+          if (err) {\n+            return done(err);\n+          }\n+\n+          res.body.should.be.an('array').of.length(6);\n+          res.body.should.have.nested.property('[0].author.name');\n+\n+          done();\n+        });\n+    });\n+\n+    it('should sort the result', () => {\n+      return new Promise((resolve, reject) => {\n+        request(app)\n+          .get('/api/mentions')\n+          .query({ path: 'http://example.org/path' })\n+          .expect(200)\n+          .end((err, res) => {\n+            if (err) {\n+              return reject(err);\n+            }\n+\n+            res.body.should.be.an('array').and.satisfy(\n+              entries =>\n+                entries.reduce((previousValue, currentValue) => {\n+                  previousValue = previousValue.published || previousValue;\n+                  if (previousValue === false || previousValue >= currentValue.published) {\n+                    return false;\n+                  }\n+                  return currentValue.published;\n+                }) !== false,\n+              'Should sort by publish date, starting with the oldest one'\n+            );\n+\n+            resolve();\n+          });\n+      });\n+    });\n+\n+    it('should sort the result reversed when requested to', () => {\n+      return new Promise((resolve, reject) => {\n+        request(app)\n+          .get('/api/mentions')\n+          .query({ path: 'http://example.org/path', sort: 'desc' })\n+          .expect(200)\n+          .end((err, res) => {\n+            if (err) {\n+              return reject(err);\n+            }\n+\n+            res.body.should.be.an('array').and.satisfy(\n+              entries =>\n+                entries.reduce((previousValue, currentValue) => {\n+                  previousValue = previousValue.published || previousValue;\n+                  if (previousValue !== undefined && (previousValue === false || previousValue <= currentValue.published)) {\n+                    return false;\n+                  }\n+                  return currentValue.published;\n+                }) !== false,\n+              'Should sort by publish date, starting with the newest one'\n+            );\n+\n+            resolve();\n+          });\n+      });\n+    });\n+\n+    it('should return in HTML when requested', (done) => {\n+      request(app)\n+        .get('/api/mentions')\n+        .query({ site: 'example.org', format: 'html' })\n+        .expect(200)\n+        .end((err, res) => {\n+          if (err) {\n+            return done(err);\n+          }\n+\n+          done();\n+        });\n+    });\n+  });\n+});"
    }
  ]
}
