{
  "sha": "2dc63d3a27e6fe46d358aad347adbdf668fa076b",
  "node_id": "MDY6Q29tbWl0NzI0NTQyNDI6MmRjNjNkM2EyN2U2ZmU0NmQzNThhYWQzNDdhZGJkZjY2OGZhMDc2Yg==",
  "commit": {
    "author": {
      "name": "Wyatt Johnson",
      "email": "wyattjoh@gmail.com",
      "date": "2020-03-19T20:57:49Z"
    },
    "committer": {
      "name": "GitHub",
      "email": "noreply@github.com",
      "date": "2020-03-19T20:57:49Z"
    },
    "message": "[CORL-754] SSO Key Management (#2732)\n\n* feat: initial impl\r\n\r\n* feat: clean up redis when keys are deleted\r\n\r\n* fix: remove test timeout value",
    "tree": {
      "sha": "a4fd68a805292910fc74aa21cb6b7add2686c31e",
      "url": "https://api.github.com/repos/coralproject/talk/git/trees/a4fd68a805292910fc74aa21cb6b7add2686c31e"
    },
    "url": "https://api.github.com/repos/coralproject/talk/git/commits/2dc63d3a27e6fe46d358aad347adbdf668fa076b",
    "comment_count": 0,
    "verification": {
      "verified": true,
      "reason": "valid",
      "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJec9zNCRBK7hj4Ov3rIwAAdHIIAEyswDCeYYD+OopjkTbu+sFk\nYwd8DAtNPj2r6U1pu41Yd91fTbihT+QyDk25jNfRIiWKRkiXR6NKX0muTsOTE2D6\n//tBNCymqEuaA9hOltKjjBgW4MQOoRryJpx3cAEINTQf0kVlZS2oGVaaKr9sHLan\n9T6Kej3IVmz9NkISkdN71Vit6ZiQvp5Rb/8s9Mp91jJ3hMeoRFM3o9pHXJ9z7JX4\nhsWRr84/R07dCZONGfWzYGWFDpxV9wkuWiiyjcgZ/C1GjWGePcbHMXJgjITft6iZ\nSw4OYdPQsDoI4sWjYZKKp7pEm0tMrHneTP3h5+YmvsVJSX6+5e0lFjWVurezdxo=\n=I0jw\n-----END PGP SIGNATURE-----\n",
      "payload": "tree a4fd68a805292910fc74aa21cb6b7add2686c31e\nparent 1503b735e50b55d1a95209e500f22ea453d5a49d\nauthor Wyatt Johnson <wyattjoh@gmail.com> 1584651469 +0000\ncommitter GitHub <noreply@github.com> 1584651469 +0000\n\n[CORL-754] SSO Key Management (#2732)\n\n* feat: initial impl\r\n\r\n* feat: clean up redis when keys are deleted\r\n\r\n* fix: remove test timeout value"
    }
  },
  "url": "https://api.github.com/repos/coralproject/talk/commits/2dc63d3a27e6fe46d358aad347adbdf668fa076b",
  "html_url": "https://github.com/coralproject/talk/commit/2dc63d3a27e6fe46d358aad347adbdf668fa076b",
  "comments_url": "https://api.github.com/repos/coralproject/talk/commits/2dc63d3a27e6fe46d358aad347adbdf668fa076b/comments",
  "author": {
    "login": "wyattjoh",
    "id": 633002,
    "node_id": "MDQ6VXNlcjYzMzAwMg==",
    "avatar_url": "https://avatars2.githubusercontent.com/u/633002?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wyattjoh",
    "html_url": "https://github.com/wyattjoh",
    "followers_url": "https://api.github.com/users/wyattjoh/followers",
    "following_url": "https://api.github.com/users/wyattjoh/following{/other_user}",
    "gists_url": "https://api.github.com/users/wyattjoh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wyattjoh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wyattjoh/subscriptions",
    "organizations_url": "https://api.github.com/users/wyattjoh/orgs",
    "repos_url": "https://api.github.com/users/wyattjoh/repos",
    "events_url": "https://api.github.com/users/wyattjoh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wyattjoh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "web-flow",
    "id": 19864447,
    "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
    "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/web-flow",
    "html_url": "https://github.com/web-flow",
    "followers_url": "https://api.github.com/users/web-flow/followers",
    "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
    "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
    "organizations_url": "https://api.github.com/users/web-flow/orgs",
    "repos_url": "https://api.github.com/users/web-flow/repos",
    "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
    "received_events_url": "https://api.github.com/users/web-flow/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1503b735e50b55d1a95209e500f22ea453d5a49d",
      "url": "https://api.github.com/repos/coralproject/talk/commits/1503b735e50b55d1a95209e500f22ea453d5a49d",
      "html_url": "https://github.com/coralproject/talk/commit/1503b735e50b55d1a95209e500f22ea453d5a49d"
    }
  ],
  "stats": {
    "total": 1747,
    "additions": 1083,
    "deletions": 664
  },
  "files": [
    {
      "sha": "9398587430f70326c8cf501dd3bc6a82276f4125",
      "filename": "src/core/client/stream/tabs/Configure/Q&A/AddExpertMutation.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/client/stream/tabs/Configure/Q&A/AddExpertMutation.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/client/stream/tabs/Configure/Q&A/AddExpertMutation.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/client/stream/tabs/Configure/Q&A/AddExpertMutation.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -16,7 +16,7 @@ const AddExpertMutation = createMutation(\n   (environment: Environment, input: MutationInput<AddExpertMutation>) =>\n     commitMutationPromiseNormalized<AddExpertMutation>(environment, {\n       mutation: graphql`\n-        mutation AddExpertMutation($input: AddExpertInput!) {\n+        mutation AddExpertMutation($input: AddStoryExpertInput!) {\n           addStoryExpert(input: $input) {\n             story {\n               id"
    },
    {
      "sha": "9c559e8dd919e262dbf0a0953f1f0e72daca91b5",
      "filename": "src/core/client/stream/tabs/Configure/Q&A/RemoveExpertMutation.ts",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/client/stream/tabs/Configure/Q&A/RemoveExpertMutation.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/client/stream/tabs/Configure/Q&A/RemoveExpertMutation.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/client/stream/tabs/Configure/Q&A/RemoveExpertMutation.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -16,7 +16,7 @@ const RemoveExpertMutation = createMutation(\n   (environment: Environment, input: MutationInput<RemoveExpertMutation>) =>\n     commitMutationPromiseNormalized<RemoveExpertMutation>(environment, {\n       mutation: graphql`\n-        mutation RemoveExpertMutation($input: RemoveExpertInput!) {\n+        mutation RemoveExpertMutation($input: RemoveStoryExpertInput!) {\n           removeStoryExpert(input: $input) {\n             story {\n               id"
    },
    {
      "sha": "111f23d39c9b4e2713868b06051548cc48b8b855",
      "filename": "src/core/server/app/middleware/passport/strategies/verifiers/sso.ts",
      "status": "modified",
      "additions": 29,
      "deletions": 4,
      "changes": 33,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/app/middleware/passport/strategies/verifiers/sso.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/app/middleware/passport/strategies/verifiers/sso.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/app/middleware/passport/strategies/verifiers/sso.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -1,12 +1,17 @@\n+import { Redis } from \"ioredis\";\n import Joi from \"joi\";\n-import { isNil } from \"lodash\";\n+import { isNil, throttle } from \"lodash\";\n import { DateTime } from \"luxon\";\n import { Db } from \"mongodb\";\n \n import { validate } from \"coral-server/app/request/body\";\n import { IntegrationDisabled, TokenInvalidError } from \"coral-server/errors\";\n+import logger from \"coral-server/logger\";\n import { Secret, SSOAuthIntegration } from \"coral-server/models/settings\";\n-import { Tenant } from \"coral-server/models/tenant\";\n+import {\n+  Tenant,\n+  updateLastUsedAtTenantSSOKey,\n+} from \"coral-server/models/tenant\";\n import {\n   retrieveUserWithProfile,\n   SSOProfile,\n@@ -163,6 +168,22 @@ export async function findOrCreateSSOUser(\n   return user;\n }\n \n+const updateLastUsedAtKID = throttle(\n+  async (redis: Redis, tenantID: string, kid: string, now: Date) => {\n+    try {\n+      await updateLastUsedAtTenantSSOKey(redis, tenantID, kid, now);\n+      logger.trace({ tenantID, kid }, \"updated last used tenant sso key\");\n+    } catch (err) {\n+      logger.error(\n+        { err, tenantID, kid },\n+        \"could not update the last used tenant sso key\"\n+      );\n+    }\n+  },\n+  // Only let this update the last used time stamp every minute.\n+  60 * 1000\n+);\n+\n export interface SSOVerifierOptions {\n   mongo: Db;\n   redis: AugmentedRedis;\n@@ -285,9 +306,13 @@ export class SSOVerifier implements Verifier<SSOToken> {\n         continue;\n       }\n \n+      // The verification did not throw an error, which means the verification\n+      // succeeded! Mark the key as used last now and break out. We should do\n+      // this in the nextTick because it's not important to have it recorded at\n+      // the same time.\n+      updateLastUsedAtKID(this.redis, tenant.id, key.kid, now);\n+\n       // TODO: [CORL-754] (wyattjoh) reintroduce when we amend the front-end to display the kid\n-      // // The verification did not throw an error, which means the verification\n-      // // succeeded! Break out now.\n       // if (!kid) {\n       //   logger.warn(\n       //     { tenantID: tenant.id, kid: config.kid },"
    },
    {
      "sha": "0768303068a02007122a5f12a015f59cea9941ed",
      "filename": "src/core/server/graph/loaders/Auth.ts",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/loaders/Auth.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/loaders/Auth.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/loaders/Auth.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -1,9 +1,11 @@\n import DataLoader from \"dataloader\";\n \n import GraphContext from \"coral-server/graph/context\";\n-import { GQLDiscoveredOIDCConfiguration } from \"coral-server/graph/schema/__generated__/types\";\n+import { retrieveLastUsedAtTenantSSOKeys } from \"coral-server/models/tenant\";\n import { discoverOIDCConfiguration } from \"coral-server/services/tenant\";\n \n+import { GQLDiscoveredOIDCConfiguration } from \"coral-server/graph/schema/__generated__/types\";\n+\n export default (ctx: GraphContext) => ({\n   discoverOIDCConfiguration: new DataLoader<\n     string,\n@@ -17,4 +19,7 @@ export default (ctx: GraphContext) => ({\n       cache: !ctx.disableCaching,\n     }\n   ),\n+  retrieveSSOKeyLastUsedAt: new DataLoader((kids: string[]) =>\n+    retrieveLastUsedAtTenantSSOKeys(ctx.redis, ctx.tenant.id, kids)\n+  ),\n });"
    },
    {
      "sha": "cda89b2b100e5e6d1936d4e14ffeab1fa611df29",
      "filename": "src/core/server/graph/mutators/Settings.ts",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/mutators/Settings.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/mutators/Settings.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/mutators/Settings.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -3,13 +3,16 @@ import { Tenant } from \"coral-server/models/tenant\";\n import {\n   createAnnouncement,\n   createWebhookEndpoint,\n+  deactivateSSOKey,\n   deleteAnnouncement,\n+  deleteSSOKey,\n   deleteWebhookEndpoint,\n   disableFeatureFlag,\n   disableWebhookEndpoint,\n   enableFeatureFlag,\n   enableWebhookEndpoint,\n   regenerateSSOKey,\n+  rotateSSOKey,\n   rotateWebhookEndpointSecret,\n   update,\n   updateWebhookEndpoint,\n@@ -18,10 +21,13 @@ import {\n import {\n   GQLCreateAnnouncementInput,\n   GQLCreateWebhookEndpointInput,\n+  GQLDeactivateSSOKeyInput,\n+  GQLDeleteSSOKeyInput,\n   GQLDeleteWebhookEndpointInput,\n   GQLDisableWebhookEndpointInput,\n   GQLEnableWebhookEndpointInput,\n   GQLFEATURE_FLAG,\n+  GQLRotateSSOKeyInput,\n   GQLRotateWebhookEndpointSecretInput,\n   GQLUpdateSettingsInput,\n   GQLUpdateWebhookEndpointInput,\n@@ -43,6 +49,12 @@ export const Settings = ({\n     update(mongo, redis, tenantCache, config, tenant, input.settings),\n   regenerateSSOKey: (): Promise<Tenant | null> =>\n     regenerateSSOKey(mongo, redis, tenantCache, tenant, now),\n+  rotateSSOKey: ({ inactiveIn }: GQLRotateSSOKeyInput) =>\n+    rotateSSOKey(mongo, redis, tenantCache, tenant, inactiveIn, now),\n+  deactivateSSOKey: ({ kid }: GQLDeactivateSSOKeyInput) =>\n+    deactivateSSOKey(mongo, redis, tenantCache, tenant, kid, now),\n+  deleteSSOKey: ({ kid }: GQLDeleteSSOKeyInput) =>\n+    deleteSSOKey(mongo, redis, tenantCache, tenant, kid),\n   enableFeatureFlag: (flag: GQLFEATURE_FLAG) =>\n     enableFeatureFlag(mongo, redis, tenantCache, tenant, flag),\n   disableFeatureFlag: (flag: GQLFEATURE_FLAG) =>"
    },
    {
      "sha": "2a2e67c7c34b1214fc6e6939ed08a8677f58c835",
      "filename": "src/core/server/graph/mutators/Stories.ts",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/mutators/Stories.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/mutators/Stories.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/mutators/Stories.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -19,12 +19,12 @@ import {\n import { scrape } from \"coral-server/services/stories/scraper\";\n \n import {\n-  GQLAddExpertInput,\n+  GQLAddStoryExpertInput,\n   GQLCloseStoryInput,\n   GQLCreateStoryInput,\n   GQLMergeStoriesInput,\n   GQLOpenStoryInput,\n-  GQLRemoveExpertInput,\n+  GQLRemoveStoryExpertInput,\n   GQLRemoveStoryInput,\n   GQLScrapeStoryInput,\n   GQLUpdateStoryInput,\n@@ -78,8 +78,8 @@ export const Stories = (ctx: GraphContext) => ({\n     scrape(ctx.mongo, ctx.config, ctx.tenant.id, input.id),\n   updateStoryMode: async (input: GQLUpdateStoryModeInput) =>\n     updateStoryMode(ctx.mongo, ctx.tenant, input.storyID, input.mode),\n-  addStoryExpert: async (input: GQLAddExpertInput) =>\n+  addStoryExpert: async (input: GQLAddStoryExpertInput) =>\n     addStoryExpert(ctx.mongo, ctx.tenant, input.storyID, input.userID),\n-  removeStoryExpert: async (input: GQLRemoveExpertInput) =>\n+  removeStoryExpert: async (input: GQLRemoveStoryExpertInput) =>\n     removeStoryExpert(ctx.mongo, ctx.tenant, input.storyID, input.userID),\n });"
    },
    {
      "sha": "141a515d496bc3f24bf1abdeb08178a3e3c28066",
      "filename": "src/core/server/graph/resolvers/Mutation.ts",
      "status": "modified",
      "additions": 12,
      "deletions": 2,
      "changes": 14,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/resolvers/Mutation.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/resolvers/Mutation.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/resolvers/Mutation.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -1,7 +1,5 @@\n import { GQLMutationTypeResolver } from \"coral-server/graph/schema/__generated__/types\";\n \n-// TODO: (wyattjoh) add rate limiting to these edges\n-\n export const Mutation: Required<GQLMutationTypeResolver<void>> = {\n   editComment: async (source, { input }, ctx) => ({\n     comment: await ctx.mutators.Comments.edit(input),\n@@ -81,6 +79,18 @@ export const Mutation: Required<GQLMutationTypeResolver<void>> = {\n     settings: await ctx.mutators.Settings.regenerateSSOKey(),\n     clientMutationId: input.clientMutationId,\n   }),\n+  rotateSSOKey: async (source, { input }, ctx) => ({\n+    settings: await ctx.mutators.Settings.rotateSSOKey(input),\n+    clientMutationId: input.clientMutationId,\n+  }),\n+  deactivateSSOKey: async (source, { input }, ctx) => ({\n+    settings: await ctx.mutators.Settings.deactivateSSOKey(input),\n+    clientMutationId: input.clientMutationId,\n+  }),\n+  deleteSSOKey: async (source, { input }, ctx) => ({\n+    settings: await ctx.mutators.Settings.deleteSSOKey(input),\n+    clientMutationId: input.clientMutationId,\n+  }),\n   createStory: async (source, { input }, ctx) => ({\n     story: await ctx.mutators.Stories.create(input),\n     clientMutationId: input.clientMutationId,"
    },
    {
      "sha": "dccbb155adf8de655051129def4490b4c7354911",
      "filename": "src/core/server/graph/resolvers/Secret.ts",
      "status": "added",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/resolvers/Secret.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/resolvers/Secret.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/resolvers/Secret.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -0,0 +1,8 @@\n+import * as settings from \"coral-server/models/settings\";\n+\n+import { GQLSecretTypeResolver } from \"coral-server/graph/schema/__generated__/types\";\n+\n+export const Secret: GQLSecretTypeResolver<settings.Secret> = {\n+  lastUsedAt: async ({ kid }, args, ctx) =>\n+    ctx.loaders.Auth.retrieveSSOKeyLastUsedAt.load(kid),\n+};"
    },
    {
      "sha": "7b78a0a38fe2c3dd52cbbf1f19e35d0edb52b48f",
      "filename": "src/core/server/graph/resolvers/index.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/resolvers/index.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/resolvers/index.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/resolvers/index.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -37,6 +37,7 @@ import { Profile } from \"./Profile\";\n import { Query } from \"./Query\";\n import { RecentCommentHistory } from \"./RecentCommentHistory\";\n import { RejectCommentPayload } from \"./RejectCommentPayload\";\n+import { Secret } from \"./Secret\";\n import { Settings } from \"./Settings\";\n import { SlackConfiguration } from \"./SlackConfiguration\";\n import { SSOAuthIntegration } from \"./SSOAuthIntegration\";\n@@ -89,6 +90,7 @@ const Resolvers: GQLResolver = {\n   RecentCommentHistory,\n   RejectCommentPayload,\n   SSOAuthIntegration,\n+  Secret,\n   Story,\n   StorySettings,\n   Subscription,"
    },
    {
      "sha": "cf4aeb9bc8bea062cab24126501dc8f016bc090e",
      "filename": "src/core/server/graph/schema/schema.graphql",
      "status": "modified",
      "additions": 289,
      "deletions": 101,
      "changes": 390,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/schema/schema.graphql",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/graph/schema/schema.graphql",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/graph/schema/schema.graphql?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -65,6 +65,13 @@ rate enforces a rate limit on requests made by the user.\n \"\"\"\n directive @rate(max: Int = 1, seconds: Int!, key: String) on FIELD_DEFINITION\n \n+\"\"\"\n+deprecated indicates that a field should not be used in the future.\n+\"\"\"\n+directive @deprecated(\n+  reason: String = \"No longer supported\"\n+) on FIELD_DEFINITION | ENUM_VALUE\n+\n ################################################################################\n ## Custom Scalar Types\n ################################################################################\n@@ -483,6 +490,40 @@ type LocalAuthIntegration {\n ## SSOAuthIntegration\n ##########################\n \n+type Secret {\n+  \"\"\"\n+  kid is the identifier for the key used when verifying tokens issued by the\n+  provider.\n+  \"\"\"\n+  kid: String!\n+\n+  \"\"\"\n+  secret is the actual underlying secret used to verify the tokens with.\n+  \"\"\"\n+  secret: String!\n+\n+  \"\"\"\n+  createdAt is the date that the key was created at.\n+  \"\"\"\n+  createdAt: Time!\n+\n+  \"\"\"\n+  lastUsedAt is the time that the\n+  \"\"\"\n+  lastUsedAt: Time\n+\n+  \"\"\"\n+  rotatedAt is the time that the token was rotated out.\n+  \"\"\"\n+  rotatedAt: Time\n+\n+  \"\"\"\n+  inactiveAt is the date that the token can no longer be used to validate\n+  tokens.\n+  \"\"\"\n+  inactiveAt: Time\n+}\n+\n \"\"\"\n SSOAuthIntegration is an AuthIntegration that provides a secret to the admins\n of a tenant, where they can sign a SSO payload with it to provide to the\n@@ -504,15 +545,24 @@ type SSOAuthIntegration {\n   \"\"\"\n   targetFilter: AuthenticationTargetFilter!\n \n+  \"\"\"\n+  keys are the different SSOKey's used by this Tenant.\n+  \"\"\"\n+  keys: [Secret!]! @auth(roles: [ADMIN])\n+\n   \"\"\"\n   key is the secret that is used to sign tokens.\n   \"\"\"\n-  key: String @auth(roles: [ADMIN])\n+  key: String\n+    @auth(roles: [ADMIN])\n+    @deprecated(reason: \"field is deprecated in favour of `keys`\")\n \n   \"\"\"\n   keyGeneratedAt is the Time that the key was effective from.\n   \"\"\"\n-  keyGeneratedAt: Time @auth(roles: [ADMIN])\n+  keyGeneratedAt: Time\n+    @auth(roles: [ADMIN])\n+    @deprecated(reason: \"field is deprecated in favour of `keys`\")\n }\n \n ##########################\n@@ -1234,21 +1284,6 @@ enum WEBHOOK_EVENT_NAME {\n   STORY_CREATED\n }\n \n-\"\"\"\n-TODO: merge with SSOKey with PR #2732\n-\"\"\"\n-type Secret {\n-  \"\"\"\n-  secret is the actual underlying secret used to verify the tokens with.\n-  \"\"\"\n-  secret: String!\n-\n-  \"\"\"\n-  createdAt is the date that the key was created at.\n-  \"\"\"\n-  createdAt: Time!\n-}\n-\n type WebhookEndpoint {\n   \"\"\"\n   id is the unique identifier for this specific endpoint.\n@@ -1342,6 +1377,28 @@ type Announcement {\n   content: String!\n }\n \n+type Site {\n+  \"\"\"\n+  id is the identifier of the Site.\n+  \"\"\"\n+  id: ID!\n+\n+  \"\"\"\n+  name is the name of the Site.\n+  \"\"\"\n+  name: String!\n+\n+  \"\"\"\n+  allowedOrigins are the allowed origins for embeds.\n+  \"\"\"\n+  allowedOrigins: [String!]!\n+\n+  \"\"\"\n+  createdAt is when the site was created.\n+  \"\"\"\n+  createdAt: Time!\n+}\n+\n \"\"\"\n Settings stores the global settings for a given Tenant.\n \"\"\"\n@@ -5855,6 +5912,64 @@ type EnableFeatureFlagPayload {\n   flags: [FEATURE_FLAG!]!\n }\n \n+#########################\n+## rotateSSOKey\n+#########################\n+\n+input RotateSSOKeyInput {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  inactiveIn is the number of seconds that the current active SSOKey should be\n+  kept active (allow signed tokens signed with this secret) before rejecting\n+  them.\n+  \"\"\"\n+  inactiveIn: Int!\n+}\n+\n+type RotateSSOKeyPayload {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  settings is the Settings that the SSO key was regenerated on.\n+  \"\"\"\n+  settings: Settings\n+}\n+\n+#########################\n+## deactivateSSOKey\n+#########################\n+\n+input DeactivateSSOKeyInput {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  kid is the ID of the SSOKey being deactivated.\n+  \"\"\"\n+  kid: ID!\n+}\n+\n+type DeactivateSSOKeyPayload {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  settings is the Settings that the SSO key was regenerated on.\n+  \"\"\"\n+  settings: Settings\n+}\n+\n #########################\n # disableFeatureFlag\n #########################\n@@ -5884,10 +5999,10 @@ type DisableFeatureFlagPayload {\n }\n \n #########################\n-# Add / Remove Expert\n+# addStoryExpert\n #########################\n \n-input AddExpertInput {\n+input AddStoryExpertInput {\n   \"\"\"\n   clientMutationId is required for Relay support.\n   \"\"\"\n@@ -5904,7 +6019,7 @@ input AddExpertInput {\n   userID: ID!\n }\n \n-type AddExpertPayload {\n+type AddStoryExpertPayload {\n   \"\"\"\n   clientMutationId is required for Relay support.\n   \"\"\"\n@@ -5916,7 +6031,11 @@ type AddExpertPayload {\n   story: Story!\n }\n \n-input RemoveExpertInput {\n+#########################\n+# removeStoryExpert\n+#########################\n+\n+input RemoveStoryExpertInput {\n   \"\"\"\n   clientMutationId is required for Relay support.\n   \"\"\"\n@@ -5933,7 +6052,7 @@ input RemoveExpertInput {\n   userID: ID!\n }\n \n-type RemoveExpertPayload {\n+type RemoveStoryExpertPayload {\n   \"\"\"\n   clientMutationId is required for Relay support.\n   \"\"\"\n@@ -5945,6 +6064,38 @@ type RemoveExpertPayload {\n   story: Story!\n }\n \n+#########################\n+## deleteSSOKey\n+#########################\n+\n+input DeleteSSOKeyInput {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  kid is the ID of the SSOKey being deleted.\n+  \"\"\"\n+  kid: ID!\n+}\n+\n+type DeleteSSOKeyPayload {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  settings is the Settings that the SSO key was regenerated on.\n+  \"\"\"\n+  settings: Settings\n+}\n+\n+#########################\n+## updateStoryMode\n+#########################\n+\n input UpdateStoryModeInput {\n   \"\"\"\n   storyID is the story id to enable Q&A on.\n@@ -5963,15 +6114,110 @@ input UpdateStoryModeInput {\n }\n \n type UpdateStoryModePayload {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n   \"\"\"\n   story is the resultant story that Q&A was enabled on.\n   \"\"\"\n   story: Story!\n+}\n \n+##################\n+## createSite\n+##################\n+\n+input CreateSite {\n+  \"\"\"\n+  name is the name of the Site.\n+  \"\"\"\n+  name: String!\n+\n+  \"\"\"\n+  allowedOrigins are the allowed origins for embeds.\n+  \"\"\"\n+  allowedOrigins: [String!]!\n+}\n+\n+input CreateSiteInput {\n   \"\"\"\n   clientMutationId is required for Relay support.\n   \"\"\"\n   clientMutationId: String!\n+\n+  \"\"\"\n+  site is the input for the Site to create.\n+  \"\"\"\n+  site: CreateSite!\n+}\n+\n+type CreateSitePayload {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  site is the Site that was newly created.\n+  \"\"\"\n+  site: Site!\n+}\n+\n+##################\n+## updateSite\n+##################\n+\n+input UpdateSite {\n+  \"\"\"\n+  name is the name of the Site.\n+  \"\"\"\n+  name: String\n+\n+  \"\"\"\n+  url is the Site URL, seen in email communications.\n+  \"\"\"\n+  url: String\n+\n+  \"\"\"\n+  contactEmail is the contact email for the Site, seen in email communications.\n+  \"\"\"\n+  contactEmail: String\n+\n+  \"\"\"\n+  allowedOrigins are the allowed origins for embeds.\n+  \"\"\"\n+  allowedOrigins: [String!]\n+}\n+\n+input UpdateSiteInput {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  id is the ID of the Site to update.\n+  \"\"\"\n+  id: ID!\n+\n+  \"\"\"\n+  site is the updates for the Site.\n+  \"\"\"\n+  site: UpdateSite!\n+}\n+\n+type UpdateSitePayload {\n+  \"\"\"\n+  clientMutationId is required for Relay support.\n+  \"\"\"\n+  clientMutationId: String!\n+\n+  \"\"\"\n+  site is the newly updated Site.\n+  \"\"\"\n+  site: Site!\n }\n \n ##################\n@@ -6012,6 +6258,25 @@ type Mutation {\n   \"\"\"\n   regenerateSSOKey(input: RegenerateSSOKeyInput!): RegenerateSSOKeyPayload!\n     @auth(roles: [ADMIN])\n+    @deprecated(reason: \"deprecated in favour of `rotateSSOKey`\")\n+\n+  \"\"\"\n+  rotateSSOKey can be used to rotate a given active SSOKey.\n+  \"\"\"\n+  rotateSSOKey(input: RotateSSOKeyInput!): RotateSSOKeyPayload!\n+    @auth(roles: [ADMIN])\n+\n+  \"\"\"\n+  deactivateSSOKey will deactivate a given deactivated SSOKey.\n+  \"\"\"\n+  deactivateSSOKey(input: DeactivateSSOKeyInput!): DeactivateSSOKeyPayload!\n+    @auth(roles: [ADMIN])\n+\n+  \"\"\"\n+  deleteSSOKey will delete a given inactive SSOKey.\n+  \"\"\"\n+  deleteSSOKey(input: DeleteSSOKeyInput!): DeleteSSOKeyPayload!\n+    @auth(roles: [ADMIN])\n \n   \"\"\"\n   createCommentReaction will create a Reaction authored by the current logged in\n@@ -6416,13 +6681,13 @@ type Mutation {\n   \"\"\"\n   addStoryExpert adds an expert to a story.\n   \"\"\"\n-  addStoryExpert(input: AddExpertInput!): AddExpertPayload!\n+  addStoryExpert(input: AddStoryExpertInput!): AddStoryExpertPayload!\n     @auth(roles: [ADMIN, MODERATOR])\n \n   \"\"\"\n   removeStoryExpert removes an expert from a story.\n   \"\"\"\n-  removeStoryExpert(input: RemoveExpertInput!): RemoveExpertPayload!\n+  removeStoryExpert(input: RemoveStoryExpertInput!): RemoveStoryExpertPayload!\n     @auth(roles: [ADMIN, MODERATOR])\n }\n \n@@ -6608,80 +6873,3 @@ type Subscription {\n   commentFeatured(storyID: ID!): CommentFeaturedPayload!\n     @auth(roles: [MODERATOR, ADMIN])\n }\n-\n-type Site {\n-  \"\"\"\n-  id is the identifier of the Site.\n-  \"\"\"\n-  id: ID!\n-\n-  \"\"\"\n-  name is the name of the Site.\n-  \"\"\"\n-  name: String!\n-\n-  \"\"\"\n-  allowedOrigins are the allowed origins for embeds.\n-  \"\"\"\n-  allowedOrigins: [String!]!\n-\n-  \"\"\"\n-  createdAt is when the site was created.\n-  \"\"\"\n-  createdAt: Time!\n-}\n-\n-input CreateSite {\n-  \"\"\"\n-  name is the name of the Site.\n-  \"\"\"\n-  name: String!\n-\n-  \"\"\"\n-  allowedOrigins are the allowed origins for embeds.\n-  \"\"\"\n-  allowedOrigins: [String!]!\n-}\n-\n-input UpdateSite {\n-  \"\"\"\n-  name is the name of the Site.\n-  \"\"\"\n-  name: String\n-\n-  \"\"\"\n-  url is the Site URL, seen in email communications.\n-  \"\"\"\n-  url: String\n-\n-  \"\"\"\n-  contactEmail is the contact email for the Site, seen in email communications.\n-  \"\"\"\n-  contactEmail: String\n-\n-  \"\"\"\n-  allowedOrigins are the allowed origins for embeds.\n-  \"\"\"\n-  allowedOrigins: [String!]\n-}\n-\n-input CreateSiteInput {\n-  clientMutationId: String!\n-  site: CreateSite!\n-}\n-\n-type CreateSitePayload {\n-  clientMutationId: String!\n-  site: Site!\n-}\n-\n-input UpdateSiteInput {\n-  clientMutationId: String!\n-  site: UpdateSite!\n-  id: ID!\n-}\n-\n-type UpdateSitePayload {\n-  clientMutationId: String!\n-  site: Site!\n-}"
    },
    {
      "sha": "7fbaa82560c83681e8a7576bc65691976e38cd69",
      "filename": "src/core/server/models/tenant/tenant.ts",
      "status": "modified",
      "additions": 84,
      "deletions": 2,
      "changes": 86,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/models/tenant/tenant.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/models/tenant/tenant.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/models/tenant/tenant.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -1,3 +1,4 @@\n+import { Redis } from \"ioredis\";\n import { isEmpty } from \"lodash\";\n import { DateTime } from \"luxon\";\n import { Db } from \"mongodb\";\n@@ -10,7 +11,6 @@ import { DeepPartial, Omit, Sub } from \"coral-common/types\";\n import { isBeforeDate } from \"coral-common/utils\";\n import { dotize } from \"coral-common/utils/dotize\";\n import logger from \"coral-server/logger\";\n-import { Secret, Settings } from \"coral-server/models/settings\";\n import { I18n } from \"coral-server/services/i18n\";\n import { tenants as collection } from \"coral-server/services/mongodb/collections\";\n \n@@ -22,6 +22,7 @@ import {\n   GQLWEBHOOK_EVENT_NAME,\n } from \"coral-server/graph/schema/__generated__/types\";\n \n+import { Secret, Settings } from \"../settings\";\n import {\n   generateSecret,\n   getDefaultReactionConfiguration,\n@@ -388,7 +389,7 @@ export async function createTenantSSOKey(mongo: Db, id: string, now: Date) {\n   return result.value || null;\n }\n \n-export async function rotateTenantSSOKey(\n+export async function deactivateTenantSSOKey(\n   mongo: Db,\n   id: string,\n   kid: string,\n@@ -463,6 +464,24 @@ export async function disableTenantFeatureFlag(\n \n   return result.value || null;\n }\n+export async function deleteTenantSSOKey(mongo: Db, id: string, kid: string) {\n+  // Update the tenant.\n+  const result = await collection(mongo).findOneAndUpdate(\n+    { id },\n+    {\n+      $pull: {\n+        \"auth.integrations.sso.keys\": { kid },\n+      },\n+    },\n+    {\n+      // False to return the updated document instead of the original\n+      // document.\n+      returnOriginal: false,\n+    }\n+  );\n+\n+  return result.value || null;\n+}\n \n export interface CreateAnnouncementInput {\n   content: string;\n@@ -767,3 +786,66 @@ export async function deleteTenantWebhookEndpoint(\n \n   return result.value;\n }\n+\n+function lastUsedAtTenantSSOKey(id: string): string {\n+  return `${id}:lastUsedSSOKey`;\n+}\n+\n+/**\n+ * updateLastUsedAtTenantSSOKey will update the time stamp that the SSO key was\n+ * last used at.\n+ *\n+ * @param redis the Redis connection to use to update the timestamp on\n+ * @param id the ID of the Tenant\n+ * @param kid the kid of the token that was used\n+ * @param when the date that the token was last used at\n+ */\n+export async function updateLastUsedAtTenantSSOKey(\n+  redis: Redis,\n+  id: string,\n+  kid: string,\n+  when: Date\n+) {\n+  await redis.hset(lastUsedAtTenantSSOKey(id), kid, when.toISOString());\n+}\n+\n+/**\n+ *\n+ * @param redis the Redis connection to use to remove the last used on.\n+ * @param id the ID of the Tenant\n+ * @param kid the kid of the token that is being deleted\n+ */\n+export async function deleteLastUsedAtTenantSSOKey(\n+  redis: Redis,\n+  id: string,\n+  kid: string\n+) {\n+  await redis.hdel(lastUsedAtTenantSSOKey(id), kid);\n+}\n+\n+/**\n+ * retrieveLastUsedAtTenantSSOKeys will get the dates that the requested sso\n+ * keys were last used on.\n+ *\n+ * @param redis the Redis connection to use to update the timestamp on\n+ * @param id the ID of the Tenant\n+ * @param kids the kids of the tokens that we want to know when they were last used\n+ */\n+export async function retrieveLastUsedAtTenantSSOKeys(\n+  redis: Redis,\n+  id: string,\n+  kids: string[]\n+) {\n+  const results: Array<string | null> = await redis.hmget(\n+    lastUsedAtTenantSSOKey(id),\n+    ...kids\n+  );\n+\n+  return results.map(lastUsedAt => {\n+    if (!lastUsedAt) {\n+      return null;\n+    }\n+\n+    return new Date(lastUsedAt);\n+  });\n+}"
    },
    {
      "sha": "36a1b843c4f75e946382b301e3ece57e3a05475a",
      "filename": "src/core/server/services/tenant/index.ts",
      "status": "modified",
      "additions": 2,
      "deletions": 548,
      "changes": 550,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/services/tenant/index.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/services/tenant/index.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/services/tenant/index.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -1,548 +1,2 @@\n-import { Redis } from \"ioredis\";\n-import { isUndefined, lowerCase, uniqBy } from \"lodash\";\n-import { DateTime } from \"luxon\";\n-import { Db } from \"mongodb\";\n-import { URL } from \"url\";\n-\n-import { discover } from \"coral-server/app/middleware/passport/strategies/oidc/discover\";\n-import { Config } from \"coral-server/config\";\n-import { TenantInstalledAlreadyError } from \"coral-server/errors\";\n-import logger from \"coral-server/logger\";\n-import {\n-  CreateAnnouncementInput,\n-  createTenant,\n-  createTenantAnnouncement,\n-  CreateTenantInput,\n-  createTenantSSOKey,\n-  createTenantWebhookEndpoint,\n-  CreateTenantWebhookEndpointInput,\n-  deleteTenantAnnouncement,\n-  deleteTenantWebhookEndpoint,\n-  disableTenantFeatureFlag,\n-  enableTenantFeatureFlag,\n-  getWebhookEndpoint,\n-  rollTenantWebhookEndpointSecret,\n-  rotateTenantSSOKey,\n-  Tenant,\n-  updateTenant,\n-  updateTenantWebhookEndpoint,\n-  UpdateTenantWebhookEndpointInput,\n-} from \"coral-server/models/tenant\";\n-import { I18n } from \"coral-server/services/i18n\";\n-\n-import {\n-  GQLFEATURE_FLAG,\n-  GQLSettingsInput,\n-  GQLSettingsWordListInput,\n-  GQLWEBHOOK_EVENT_NAME,\n-} from \"coral-server/graph/schema/__generated__/types\";\n-\n-import TenantCache from \"./cache\";\n-\n-export type UpdateTenant = GQLSettingsInput;\n-\n-function cleanWordList(\n-  list: GQLSettingsWordListInput\n-): GQLSettingsWordListInput {\n-  if (list.banned) {\n-    list.banned = uniqBy(list.banned.filter(Boolean), lowerCase) as string[];\n-  }\n-\n-  if (list.suspect) {\n-    list.suspect = uniqBy(list.suspect.filter(Boolean), lowerCase) as string[];\n-  }\n-\n-  return list;\n-}\n-\n-export async function update(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  config: Config,\n-  tenant: Tenant,\n-  input: UpdateTenant\n-): Promise<Tenant | null> {\n-  // If the environment variable for disabling live updates is provided, then\n-  // ensure we don't permit changes to the database model.\n-  if (\n-    config.get(\"disable_live_updates\") &&\n-    input.live &&\n-    !isUndefined(input.live.enabled)\n-  ) {\n-    delete input.live.enabled;\n-  }\n-\n-  // If the word list was specified, we should validate it to ensure there isn't\n-  // any empty spaces.\n-  if (input.wordList) {\n-    input.wordList = cleanWordList(input.wordList);\n-  }\n-\n-  const updatedTenant = await updateTenant(mongo, tenant.id, input);\n-  if (!updatedTenant) {\n-    return null;\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updatedTenant);\n-\n-  return updatedTenant;\n-}\n-\n-/**\n- * isInstalled will return a promise that if true, indicates that a Tenant has\n- * been installed.\n- */\n-export async function isInstalled(cache: TenantCache, domain?: string) {\n-  const count = await cache.count();\n-  if (count === 0) {\n-    return false;\n-  }\n-\n-  if (domain) {\n-    const tenant = await cache.retrieveByDomain(domain);\n-    if (tenant) {\n-      return true;\n-    }\n-\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-export type InstallTenant = CreateTenantInput;\n-\n-export async function install(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  i18n: I18n,\n-  input: InstallTenant,\n-  now = new Date()\n-) {\n-  // Ensure that this Tenant isn't being installed onto a domain that already\n-  // exists.\n-  if (await isInstalled(cache, input.domain)) {\n-    throw new TenantInstalledAlreadyError();\n-  }\n-\n-  logger.info(\"installing tenant\");\n-\n-  // Create the Tenant.\n-  const tenant = await createTenant(mongo, i18n, input, now);\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, tenant);\n-\n-  logger.info({ tenantID: tenant.id }, \"a tenant has been installed\");\n-\n-  return tenant;\n-}\n-\n-/**\n- * canInstall will return a promise that determines if a given install can\n- * proceed.\n- */\n-export async function canInstall(cache: TenantCache) {\n-  return (await cache.count()) === 0;\n-}\n-\n-/**\n- * regenerateSSOKey will regenerate the Single Sign-On key for the specified\n- * Tenant and notify all other Tenant's connected that the Tenant was updated.\n- */\n-export async function regenerateSSOKey(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  now: Date\n-) {\n-  // Deprecate the old Tenant SSO key if it exists.\n-  if (tenant.auth.integrations.sso.keys.length > 0) {\n-    // Get the old keys that are not deprecated.\n-    const keysToDeprecate = tenant.auth.integrations.sso.keys.filter(key => {\n-      return !key.rotatedAt;\n-    });\n-\n-    // Check to see if there are keys to deprecate.\n-    if (keysToDeprecate.length > 0) {\n-      // All the keys will be deprecated a month from now.\n-      // TODO: [CORL-754] (wyattjoh) take input for the deprecation duration later.\n-      const deprecateAt = DateTime.fromJSDate(now)\n-        .plus({ month: 1 })\n-        .toJSDate();\n-\n-      // Deprecate all the keys that are associated on the tenant that haven't\n-      // been done.\n-      for (const key of keysToDeprecate) {\n-        await rotateTenantSSOKey(mongo, tenant.id, key.kid, deprecateAt, now);\n-      }\n-    }\n-  }\n-\n-  // Create the new Tenant.\n-  const updatedTenant = await createTenantSSOKey(mongo, tenant.id, now);\n-  if (!updatedTenant) {\n-    return null;\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updatedTenant);\n-\n-  return updatedTenant;\n-}\n-\n-/**\n- * discoverOIDCConfiguration will discover the OpenID Connect configuration as\n- * is required by any OpenID Connect compatible service:\n- *\n- * https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig\n- *\n- * @param issuerString the issuer that should be used as the discovery root.\n- */\n-export async function discoverOIDCConfiguration(issuerString: string) {\n-  // Parse the issuer.\n-  const issuer = new URL(issuerString);\n-\n-  // Discover the configuration.\n-  return discover(issuer);\n-}\n-\n-interface WebhookEndpointInput {\n-  url: string;\n-  all: boolean;\n-  events: GQLWEBHOOK_EVENT_NAME[];\n-}\n-\n-export function validateWebhookEndpointInput(\n-  config: Config,\n-  input: WebhookEndpointInput\n-) {\n-  // Check to see that this URL is valid and has a https:// scheme if in\n-  // production mode.\n-  const url = new URL(input.url);\n-  if (config.get(\"env\") === \"production\" && url.protocol !== \"https:\") {\n-    throw new Error(`invalid scheme provided in production: ${url.protocol}`);\n-  }\n-\n-  // Ensure that either the \"all\" or \"events\" is provided but not both.\n-  if (input.all && input.events.length > 0) {\n-    throw new Error(\"both all events and specific events were requested\");\n-  }\n-}\n-\n-export async function createWebhookEndpoint(\n-  mongo: Db,\n-  redis: Redis,\n-  config: Config,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  input: CreateTenantWebhookEndpointInput,\n-  now: Date\n-) {\n-  // Validate the input.\n-  validateWebhookEndpointInput(config, input);\n-\n-  // Looks good in create this, send it off to be created.\n-  const result = await createTenantWebhookEndpoint(\n-    mongo,\n-    tenant.id,\n-    input,\n-    now\n-  );\n-  if (!result.tenant) {\n-    throw new Error(\"could not create the tenant endpoint, tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, result.tenant);\n-\n-  return {\n-    endpoint: result.endpoint,\n-    settings: result.tenant,\n-  };\n-}\n-\n-export async function updateWebhookEndpoint(\n-  mongo: Db,\n-  redis: Redis,\n-  config: Config,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  endpointID: string,\n-  input: UpdateTenantWebhookEndpointInput\n-) {\n-  // Find the endpoint.\n-  let endpoint = getWebhookEndpoint(tenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  // Extract the input.\n-  const {\n-    url = endpoint.url,\n-    all = endpoint.all,\n-    events = endpoint.events,\n-  } = input;\n-\n-  // Validate the input.\n-  validateWebhookEndpointInput(config, {\n-    url,\n-    all,\n-    events,\n-  });\n-\n-  const updatedTenant = await updateTenantWebhookEndpoint(\n-    mongo,\n-    tenant.id,\n-    endpointID,\n-    input\n-  );\n-  if (!updatedTenant) {\n-    throw new Error(\"tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updatedTenant);\n-\n-  // Find the updated endpoint.\n-  endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  return endpoint;\n-}\n-\n-export async function enableWebhookEndpoint(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  endpointID: string\n-) {\n-  // Find the endpoint.\n-  let endpoint = getWebhookEndpoint(tenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  // Endpoint is already enabled.\n-  if (endpoint.enabled === true) {\n-    return endpoint;\n-  }\n-\n-  const updatedTenant = await updateTenantWebhookEndpoint(\n-    mongo,\n-    tenant.id,\n-    endpointID,\n-    { enabled: true }\n-  );\n-  if (!updatedTenant) {\n-    throw new Error(\"tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updatedTenant);\n-\n-  // Find the updated endpoint.\n-  endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  return endpoint;\n-}\n-\n-export async function disableWebhookEndpoint(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  endpointID: string\n-) {\n-  // Find the endpoint.\n-  let endpoint = getWebhookEndpoint(tenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  // Endpoint is already disabled.\n-  if (endpoint.enabled === false) {\n-    return endpoint;\n-  }\n-\n-  const updatedTenant = await updateTenantWebhookEndpoint(\n-    mongo,\n-    tenant.id,\n-    endpointID,\n-    { enabled: false }\n-  );\n-  if (!updatedTenant) {\n-    throw new Error(\"tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updatedTenant);\n-\n-  // Find the updated endpoint.\n-  endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  return endpoint;\n-}\n-\n-export async function deleteWebhookEndpoint(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  endpointID: string\n-) {\n-  // Find the endpoint.\n-  const endpoint = getWebhookEndpoint(tenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  const updatedTenant = await deleteTenantWebhookEndpoint(\n-    mongo,\n-    tenant.id,\n-    endpointID\n-  );\n-  if (!updatedTenant) {\n-    throw new Error(\"tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updatedTenant);\n-\n-  return endpoint;\n-}\n-\n-export async function rotateWebhookEndpointSecret(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  endpointID: string,\n-  inactiveIn: number,\n-  now: Date\n-) {\n-  // Compute the inactiveAt dates for the current active secrets.\n-  const inactiveAt = DateTime.fromJSDate(now)\n-    .plus({ seconds: inactiveIn })\n-    .toJSDate();\n-\n-  // Rotate the secrets.\n-  const updatedTenant = await rollTenantWebhookEndpointSecret(\n-    mongo,\n-    tenant.id,\n-    endpointID,\n-    inactiveAt,\n-    now\n-  );\n-  if (!updatedTenant) {\n-    throw new Error(\"tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updatedTenant);\n-\n-  // Find the updated endpoint.\n-  const endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n-  if (!endpoint) {\n-    throw new Error(\"referenced endpoint was not found on tenant\");\n-  }\n-\n-  return endpoint;\n-}\n-\n-export async function enableFeatureFlag(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  flag: GQLFEATURE_FLAG\n-) {\n-  // If the Tenant already has this flag, don't bother adding it again.\n-  if (tenant.featureFlags && tenant.featureFlags.includes(flag)) {\n-    return tenant.featureFlags;\n-  }\n-\n-  // Enable the feature flag.\n-  const updated = await enableTenantFeatureFlag(mongo, tenant.id, flag);\n-  if (!updated || !updated.featureFlags) {\n-    // As we just added the feature flag, we would expect that the Tenant would\n-    // always have the feature flags set to some array.\n-    throw new Error(\"tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updated);\n-\n-  // Return the updated feature flags.\n-  return updated.featureFlags;\n-}\n-\n-export async function disableFeatureFlag(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  flag: GQLFEATURE_FLAG\n-) {\n-  // If the feature flag doesn't exist on the Tenant (or the Tenant has no\n-  // feature flags), don't bother trying to remove it again.\n-  if (!tenant.featureFlags || !tenant.featureFlags.includes(flag)) {\n-    return tenant.featureFlags || [];\n-  }\n-\n-  // Remove the feature flag.\n-  const updated = await disableTenantFeatureFlag(mongo, tenant.id, flag);\n-  if (!updated) {\n-    throw new Error(\"tenant not found\");\n-  }\n-\n-  // Update the tenant cache.\n-  await cache.update(redis, updated);\n-\n-  // Return the updated feature flags (or [] if there was no feature flags to\n-  // begin with).\n-  return updated.featureFlags || [];\n-}\n-\n-export async function createAnnouncement(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant,\n-  input: CreateAnnouncementInput,\n-  now = new Date()\n-) {\n-  const updated = await createTenantAnnouncement(mongo, tenant.id, input);\n-  if (!updated) {\n-    throw new Error(\"tenant not found\");\n-  }\n-  await cache.update(redis, updated);\n-  return updated;\n-}\n-\n-export async function deleteAnnouncement(\n-  mongo: Db,\n-  redis: Redis,\n-  cache: TenantCache,\n-  tenant: Tenant\n-) {\n-  const updated = await deleteTenantAnnouncement(mongo, tenant.id);\n-  if (!updated) {\n-    throw new Error(\"tenant not found\");\n-  }\n-  await cache.update(redis, updated);\n-  return updated;\n-}\n+export * from \"./tenant\";\n+export * from \"./sso\";"
    },
    {
      "sha": "9bc9a25a856640c3f1e1831c47cb18bde94036d6",
      "filename": "src/core/server/services/tenant/sso.ts",
      "status": "added",
      "additions": 133,
      "deletions": 0,
      "changes": 133,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/services/tenant/sso.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/services/tenant/sso.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/services/tenant/sso.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -0,0 +1,133 @@\n+import { Redis } from \"ioredis\";\n+import { DateTime } from \"luxon\";\n+import { Db } from \"mongodb\";\n+\n+import {\n+  createTenantSSOKey,\n+  deactivateTenantSSOKey,\n+  deleteLastUsedAtTenantSSOKey,\n+  deleteTenantSSOKey,\n+  Tenant,\n+} from \"coral-server/models/tenant\";\n+\n+import TenantCache from \"./cache\";\n+\n+/**\n+ * regenerateSSOKey will regenerate the Single Sign-On key for the specified\n+ * Tenant and notify all other Tenant's connected that the Tenant was updated.\n+ */\n+export async function regenerateSSOKey(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  now: Date\n+) {\n+  // Regeneration is the same as rotating but with a specific 30 day window.\n+  return rotateSSOKey(mongo, redis, cache, tenant, 30 * 24 * 60 * 60, now);\n+}\n+\n+export async function rotateSSOKey(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  inactiveIn: number,\n+  now: Date\n+) {\n+  // Deprecate the old Tenant SSO key if it exists.\n+  if (tenant.auth.integrations.sso.keys.length > 0) {\n+    // Get the old keys that are not deprecated.\n+    const keysToDeprecate = tenant.auth.integrations.sso.keys.filter(key => {\n+      return !key.rotatedAt;\n+    });\n+\n+    // Check to see if there are keys to deprecate.\n+    if (keysToDeprecate.length > 0) {\n+      const deprecateAt = DateTime.fromJSDate(now)\n+        .plus({ seconds: inactiveIn })\n+        .toJSDate();\n+\n+      // Deprecate all the keys that are associated on the tenant that haven't\n+      // been done.\n+      for (const key of keysToDeprecate) {\n+        await deactivateTenantSSOKey(\n+          mongo,\n+          tenant.id,\n+          key.kid,\n+          deprecateAt,\n+          now\n+        );\n+      }\n+    }\n+  }\n+\n+  // Create the new SSOKey.\n+  const updatedTenant = await createTenantSSOKey(mongo, tenant.id, now);\n+  if (!updatedTenant) {\n+    return null;\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  return updatedTenant;\n+}\n+\n+export async function deactivateSSOKey(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  kid: string,\n+  now: Date\n+) {\n+  const key = tenant.auth.integrations.sso.keys.find(k => k.kid === kid);\n+  if (!key) {\n+    throw new Error(\"specified kid not found on tenant\");\n+  }\n+\n+  // Deactivate the sso key now.\n+  const updatedTenant = await deactivateTenantSSOKey(\n+    mongo,\n+    tenant.id,\n+    kid,\n+    now,\n+    now\n+  );\n+  if (!updatedTenant) {\n+    return null;\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  return updatedTenant;\n+}\n+\n+export async function deleteSSOKey(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  kid: string\n+) {\n+  const key = tenant.auth.integrations.sso.keys.find(k => k.kid === kid);\n+  if (!key) {\n+    throw new Error(\"specified kid not found on tenant\");\n+  }\n+\n+  // Deactivate the sso key now.\n+  const updatedTenant = await deleteTenantSSOKey(mongo, tenant.id, kid);\n+  if (!updatedTenant) {\n+    return null;\n+  }\n+\n+  // Remove the last used date entry from the Redis hash.\n+  await deleteLastUsedAtTenantSSOKey(redis, tenant.id, kid);\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  return updatedTenant;\n+}"
    },
    {
      "sha": "1d806540a630475b51e90b3a1e6e9b4825487842",
      "filename": "src/core/server/services/tenant/tenant.ts",
      "status": "added",
      "additions": 500,
      "deletions": 0,
      "changes": 500,
      "blob_url": "https://github.com/coralproject/talk/blob/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/services/tenant/tenant.ts",
      "raw_url": "https://github.com/coralproject/talk/raw/2dc63d3a27e6fe46d358aad347adbdf668fa076b/src/core/server/services/tenant/tenant.ts",
      "contents_url": "https://api.github.com/repos/coralproject/talk/contents/src/core/server/services/tenant/tenant.ts?ref=2dc63d3a27e6fe46d358aad347adbdf668fa076b",
      "patch": "@@ -0,0 +1,500 @@\n+import { Redis } from \"ioredis\";\n+import { isUndefined, lowerCase, uniqBy } from \"lodash\";\n+import { DateTime } from \"luxon\";\n+import { Db } from \"mongodb\";\n+import { URL } from \"url\";\n+\n+import { discover } from \"coral-server/app/middleware/passport/strategies/oidc/discover\";\n+import { Config } from \"coral-server/config\";\n+import { TenantInstalledAlreadyError } from \"coral-server/errors\";\n+import logger from \"coral-server/logger\";\n+import {\n+  CreateAnnouncementInput,\n+  createTenant,\n+  createTenantAnnouncement,\n+  CreateTenantInput,\n+  createTenantWebhookEndpoint,\n+  CreateTenantWebhookEndpointInput,\n+  deleteTenantAnnouncement,\n+  deleteTenantWebhookEndpoint,\n+  disableTenantFeatureFlag,\n+  enableTenantFeatureFlag,\n+  getWebhookEndpoint,\n+  rollTenantWebhookEndpointSecret,\n+  Tenant,\n+  updateTenant,\n+  updateTenantWebhookEndpoint,\n+  UpdateTenantWebhookEndpointInput,\n+} from \"coral-server/models/tenant\";\n+import { I18n } from \"coral-server/services/i18n\";\n+\n+import {\n+  GQLFEATURE_FLAG,\n+  GQLSettingsInput,\n+  GQLSettingsWordListInput,\n+  GQLWEBHOOK_EVENT_NAME,\n+} from \"coral-server/graph/schema/__generated__/types\";\n+\n+import TenantCache from \"./cache\";\n+\n+export type UpdateTenant = GQLSettingsInput;\n+\n+function cleanWordList(\n+  list: GQLSettingsWordListInput\n+): GQLSettingsWordListInput {\n+  if (list.banned) {\n+    list.banned = uniqBy(list.banned.filter(Boolean), lowerCase) as string[];\n+  }\n+\n+  if (list.suspect) {\n+    list.suspect = uniqBy(list.suspect.filter(Boolean), lowerCase) as string[];\n+  }\n+\n+  return list;\n+}\n+\n+export async function update(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  config: Config,\n+  tenant: Tenant,\n+  input: UpdateTenant\n+): Promise<Tenant | null> {\n+  // If the environment variable for disabling live updates is provided, then\n+  // ensure we don't permit changes to the database model.\n+  if (\n+    config.get(\"disable_live_updates\") &&\n+    input.live &&\n+    !isUndefined(input.live.enabled)\n+  ) {\n+    delete input.live.enabled;\n+  }\n+\n+  // If the word list was specified, we should validate it to ensure there isn't\n+  // any empty spaces.\n+  if (input.wordList) {\n+    input.wordList = cleanWordList(input.wordList);\n+  }\n+\n+  const updatedTenant = await updateTenant(mongo, tenant.id, input);\n+  if (!updatedTenant) {\n+    return null;\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  return updatedTenant;\n+}\n+\n+/**\n+ * isInstalled will return a promise that if true, indicates that a Tenant has\n+ * been installed.\n+ */\n+export async function isInstalled(cache: TenantCache, domain?: string) {\n+  const count = await cache.count();\n+  if (count === 0) {\n+    return false;\n+  }\n+\n+  if (domain) {\n+    const tenant = await cache.retrieveByDomain(domain);\n+    if (tenant) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+export type InstallTenant = CreateTenantInput;\n+\n+export async function install(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  i18n: I18n,\n+  input: InstallTenant,\n+  now = new Date()\n+) {\n+  // Ensure that this Tenant isn't being installed onto a domain that already\n+  // exists.\n+  if (await isInstalled(cache, input.domain)) {\n+    throw new TenantInstalledAlreadyError();\n+  }\n+\n+  logger.info(\"installing tenant\");\n+\n+  // Create the Tenant.\n+  const tenant = await createTenant(mongo, i18n, input, now);\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, tenant);\n+\n+  logger.info({ tenantID: tenant.id }, \"a tenant has been installed\");\n+\n+  return tenant;\n+}\n+\n+/**\n+ * canInstall will return a promise that determines if a given install can\n+ * proceed.\n+ */\n+export async function canInstall(cache: TenantCache) {\n+  return (await cache.count()) === 0;\n+}\n+\n+/**\n+ * discoverOIDCConfiguration will discover the OpenID Connect configuration as\n+ * is required by any OpenID Connect compatible service:\n+ *\n+ * https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig\n+ *\n+ * @param issuerString the issuer that should be used as the discovery root.\n+ */\n+export async function discoverOIDCConfiguration(issuerString: string) {\n+  // Parse the issuer.\n+  const issuer = new URL(issuerString);\n+\n+  // Discover the configuration.\n+  return discover(issuer);\n+}\n+\n+interface WebhookEndpointInput {\n+  url: string;\n+  all: boolean;\n+  events: GQLWEBHOOK_EVENT_NAME[];\n+}\n+\n+export function validateWebhookEndpointInput(\n+  config: Config,\n+  input: WebhookEndpointInput\n+) {\n+  // Check to see that this URL is valid and has a https:// scheme if in\n+  // production mode.\n+  const url = new URL(input.url);\n+  if (config.get(\"env\") === \"production\" && url.protocol !== \"https:\") {\n+    throw new Error(`invalid scheme provided in production: ${url.protocol}`);\n+  }\n+\n+  // Ensure that either the \"all\" or \"events\" is provided but not both.\n+  if (input.all && input.events.length > 0) {\n+    throw new Error(\"both all events and specific events were requested\");\n+  }\n+}\n+\n+export async function createWebhookEndpoint(\n+  mongo: Db,\n+  redis: Redis,\n+  config: Config,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  input: CreateTenantWebhookEndpointInput,\n+  now: Date\n+) {\n+  // Validate the input.\n+  validateWebhookEndpointInput(config, input);\n+\n+  // Looks good in create this, send it off to be created.\n+  const result = await createTenantWebhookEndpoint(\n+    mongo,\n+    tenant.id,\n+    input,\n+    now\n+  );\n+  if (!result.tenant) {\n+    throw new Error(\"could not create the tenant endpoint, tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, result.tenant);\n+\n+  return {\n+    endpoint: result.endpoint,\n+    settings: result.tenant,\n+  };\n+}\n+\n+export async function updateWebhookEndpoint(\n+  mongo: Db,\n+  redis: Redis,\n+  config: Config,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  endpointID: string,\n+  input: UpdateTenantWebhookEndpointInput\n+) {\n+  // Find the endpoint.\n+  let endpoint = getWebhookEndpoint(tenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  // Extract the input.\n+  const {\n+    url = endpoint.url,\n+    all = endpoint.all,\n+    events = endpoint.events,\n+  } = input;\n+\n+  // Validate the input.\n+  validateWebhookEndpointInput(config, {\n+    url,\n+    all,\n+    events,\n+  });\n+\n+  const updatedTenant = await updateTenantWebhookEndpoint(\n+    mongo,\n+    tenant.id,\n+    endpointID,\n+    input\n+  );\n+  if (!updatedTenant) {\n+    throw new Error(\"tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  // Find the updated endpoint.\n+  endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  return endpoint;\n+}\n+\n+export async function enableWebhookEndpoint(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  endpointID: string\n+) {\n+  // Find the endpoint.\n+  let endpoint = getWebhookEndpoint(tenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  // Endpoint is already enabled.\n+  if (endpoint.enabled === true) {\n+    return endpoint;\n+  }\n+\n+  const updatedTenant = await updateTenantWebhookEndpoint(\n+    mongo,\n+    tenant.id,\n+    endpointID,\n+    { enabled: true }\n+  );\n+  if (!updatedTenant) {\n+    throw new Error(\"tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  // Find the updated endpoint.\n+  endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  return endpoint;\n+}\n+\n+export async function disableWebhookEndpoint(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  endpointID: string\n+) {\n+  // Find the endpoint.\n+  let endpoint = getWebhookEndpoint(tenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  // Endpoint is already disabled.\n+  if (endpoint.enabled === false) {\n+    return endpoint;\n+  }\n+\n+  const updatedTenant = await updateTenantWebhookEndpoint(\n+    mongo,\n+    tenant.id,\n+    endpointID,\n+    { enabled: false }\n+  );\n+  if (!updatedTenant) {\n+    throw new Error(\"tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  // Find the updated endpoint.\n+  endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  return endpoint;\n+}\n+\n+export async function deleteWebhookEndpoint(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  endpointID: string\n+) {\n+  // Find the endpoint.\n+  const endpoint = getWebhookEndpoint(tenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  const updatedTenant = await deleteTenantWebhookEndpoint(\n+    mongo,\n+    tenant.id,\n+    endpointID\n+  );\n+  if (!updatedTenant) {\n+    throw new Error(\"tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  return endpoint;\n+}\n+\n+export async function rotateWebhookEndpointSecret(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  endpointID: string,\n+  inactiveIn: number,\n+  now: Date\n+) {\n+  // Compute the inactiveAt dates for the current active secrets.\n+  const inactiveAt = DateTime.fromJSDate(now)\n+    .plus({ seconds: inactiveIn })\n+    .toJSDate();\n+\n+  // Rotate the secrets.\n+  const updatedTenant = await rollTenantWebhookEndpointSecret(\n+    mongo,\n+    tenant.id,\n+    endpointID,\n+    inactiveAt,\n+    now\n+  );\n+  if (!updatedTenant) {\n+    throw new Error(\"tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updatedTenant);\n+\n+  // Find the updated endpoint.\n+  const endpoint = getWebhookEndpoint(updatedTenant, endpointID);\n+  if (!endpoint) {\n+    throw new Error(\"referenced endpoint was not found on tenant\");\n+  }\n+\n+  return endpoint;\n+}\n+\n+export async function enableFeatureFlag(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  flag: GQLFEATURE_FLAG\n+) {\n+  // If the Tenant already has this flag, don't bother adding it again.\n+  if (tenant.featureFlags && tenant.featureFlags.includes(flag)) {\n+    return tenant.featureFlags;\n+  }\n+\n+  // Enable the feature flag.\n+  const updated = await enableTenantFeatureFlag(mongo, tenant.id, flag);\n+  if (!updated || !updated.featureFlags) {\n+    // As we just added the feature flag, we would expect that the Tenant would\n+    // always have the feature flags set to some array.\n+    throw new Error(\"tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updated);\n+\n+  // Return the updated feature flags.\n+  return updated.featureFlags;\n+}\n+\n+export async function disableFeatureFlag(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  flag: GQLFEATURE_FLAG\n+) {\n+  // If the feature flag doesn't exist on the Tenant (or the Tenant has no\n+  // feature flags), don't bother trying to remove it again.\n+  if (!tenant.featureFlags || !tenant.featureFlags.includes(flag)) {\n+    return tenant.featureFlags || [];\n+  }\n+\n+  // Remove the feature flag.\n+  const updated = await disableTenantFeatureFlag(mongo, tenant.id, flag);\n+  if (!updated) {\n+    throw new Error(\"tenant not found\");\n+  }\n+\n+  // Update the tenant cache.\n+  await cache.update(redis, updated);\n+\n+  // Return the updated feature flags (or [] if there was no feature flags to\n+  // begin with).\n+  return updated.featureFlags || [];\n+}\n+\n+export async function createAnnouncement(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant,\n+  input: CreateAnnouncementInput,\n+  now = new Date()\n+) {\n+  const updated = await createTenantAnnouncement(mongo, tenant.id, input, now);\n+  if (!updated) {\n+    throw new Error(\"tenant not found\");\n+  }\n+  await cache.update(redis, updated);\n+  return updated;\n+}\n+\n+export async function deleteAnnouncement(\n+  mongo: Db,\n+  redis: Redis,\n+  cache: TenantCache,\n+  tenant: Tenant\n+) {\n+  const updated = await deleteTenantAnnouncement(mongo, tenant.id);\n+  if (!updated) {\n+    throw new Error(\"tenant not found\");\n+  }\n+  await cache.update(redis, updated);\n+  return updated;\n+}"
    }
  ]
}
